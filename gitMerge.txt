!@hash[]!@file[]./OpenDataDemo/opendatademo.cpp!@hash[]!@code[]#include "opendatademo.h"
#include "ui_opendatademo.h"

OpenDataDemo::OpenDataDemo(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::OpenDataDemo)
{
    ui->setupUi(this);

}

OpenDataDemo::~OpenDataDemo()
{
    delete ui;
}

void OpenDataDemo::init(){

    topview_scene = new QGraphicsScene(this);
    verticalview_scene = new QGraphicsScene(this);

    initModelMinMax();
    initDataMinMax();

    ui->Topview->setScene(topview_scene);
    topview_scene->setSceneRect(0, 0, scene_w, scene_h);
    topview_scene->setBackgroundBrush(QBrush(QColor(Qt::black)));

    ui->Verticalview->setScene(verticalview_scene);
    verticalview_scene->setSceneRect(0, 0, scene_w, scene_h);
    verticalview_scene->setBackgroundBrush(QBrush(QColor(Qt::black)));
}

void OpenDataDemo::initModelMinMax(){
    this->ModelMinMax.minx = 0;
    this->ModelMinMax.maxx = 0;
    this->ModelMinMax.miny = 0;
    this->ModelMinMax.maxy = 0;
    this->ModelMinMax.minz = 0;
    this->ModelMinMax.maxz = 0;
}
void OpenDataDemo::initDataMinMax(){
    this->DataMinMax.minx = 0;
    this->DataMinMax.maxx = 0;
    this->DataMinMax.miny = 0;
    this->DataMinMax.maxy = 0;
    this->DataMinMax.minz = 0;
    this->DataMinMax.maxz = 0;
}

void OpenDataDemo::on_Input_model_btn_clicked()
{
    QString file_name = QFileDialog::getOpenFileName(this, "OpenDataDemo", "./Rendering/Data", "Text (*.stl) ;; Files (*.*)");
    if(file_name == "") return;
    ui->Input_model->setText(file_name);
    this->ReadSTL(file_name.toStdString());
    /*for(int i = 0; i < this->stl_vertices.size(); i++){
        cout << "x : " << this->stl_vertices[i].x << " y : " << this->stl_vertices[i].y << " z : " << this->stl_vertices[i].z << endl;
    }*/
    this->ModelMinMax.minx = min_element(this->stl_vertices.begin(), this->stl_vertices.end(), compareVertex_x)->x;
    this->ModelMinMax.maxx = max_element(this->stl_vertices.begin(), this->stl_vertices.end(), compareVertex_x)->x;
    this->ModelMinMax.miny = min_element(this->stl_vertices.begin(), this->stl_vertices.end(), compareVertex_y)->y;
    this->ModelMinMax.maxy = max_element(this->stl_vertices.begin(), this->stl_vertices.end(), compareVertex_y)->y;
    this->ModelMinMax.minz = min_element(this->stl_vertices.begin(), this->stl_vertices.end(), compareVertex_z)->z;
    this->ModelMinMax.maxz = max_element(this->stl_vertices.begin(), this->stl_vertices.end(), compareVertex_z)->z;

    //cout << "x : " << this->ModelMinMax.minx << " y : " << this->ModelMinMax.miny << " z : " << this->ModelMinMax.minz << endl;
    //cout << "x : " << this->ModelMinMax.maxx << " y : " << this->ModelMinMax.maxy << " z : " << this->ModelMinMax.maxz << endl;

    drawingCheck();
}

void OpenDataDemo::on_Input_data_btn_clicked()
{
    QString file_name = QFileDialog::getOpenFileName(this, "OpenDataDemo", "./Rendering/Data", "Text (*.txt) ;; Files (*.*)");
    if(file_name == "") return;
    ui->Input_data->setText(file_name);
    this->ReadData(file_name.toStdString());

    createDataSheet();
    initSetting();
}

void OpenDataDemo::createDataSheet(){
    QStringList datasheet_header;
    for(auto s : data_header) datasheet_header.append(QString::fromStdString(s));
    sheet_col = int(data_header.size());
    sheet_row = int(data_total.size());

    ui->Datasheet->setColumnCount(sheet_col);
    ui->Datasheet->setHorizontalHeaderLabels(datasheet_header);
    ui->Datasheet->setRowCount(sheet_row);
    for(int i = 0 ; i < sheet_row ; i++){
        for(int j = 0 ; j < sheet_col ; j++){
            //cout << data_total[i][j] << endl;
            ui->Datasheet->setItem(i, j, new QTableWidgetItem(QString::number(data_total[i][j])));
        }
    }
}

void OpenDataDemo::initSetting(){
    QStringList setting_list;
    setting_list.append("Not Used");
    for(auto s : data_header) setting_list.append(QString::fromStdString(s));

    ui->setting_time->addItems(setting_list);
    ui->setting_x->addItems(setting_list);
    ui->setting_y->addItems(setting_list);
    ui->setting_z->addItems(setting_list);
    ui->setting_color->addItems(setting_list);

    ui->setting_time->setCurrentIndex(1);
    ui->setting_x->setCurrentIndex(2);
    ui->setting_y->setCurrentIndex(3);
    ui->setting_z->setCurrentIndex(4);
    ui->setting_z_option->setCurrentIndex(1);
    ui->setting_color->setCurrentIndex(4);

    //settingCheck();
}

void OpenDataDemo::drawingCheck(){
    if(modelMinMaxCheck() && dataMinMaxCheck()){
        drawingTopView();
        drawingVerticalView();
    }
}

void OpenDataDemo::drawingTopView(){
    topview_scene->clear();
    if(modelMinMaxCheck() && dataMinMaxCheck()){
        double scale;
        double width = abs(this->ModelMinMax.maxx - this->ModelMinMax.minx);
        double height = abs(this->ModelMinMax.maxy - this->ModelMinMax.miny);
        int w_pixel, h_pixel;
        if(width >= height){
            w_pixel = scene_w;
            h_pixel = (height * w_pixel) / width;
            scale = scene_w / width;
        }
        if(width < height){
            h_pixel = scene_h;
            w_pixel = (width * h_pixel) / height;
            scale = scene_h / height;
        }
        topview_scene->addRect((scene_w/2-w_pixel/2), (scene_h/2-h_pixel/2), w_pixel, h_pixel, QPen(QBrush(Qt::gray), 1), QBrush(QColor(255, 255, 255, 100)));
        QPen linepen;
        linepen.setStyle(Qt::DotLine);
        linepen.setColor(Qt::gray);
        linepen.setWidth(2);
        //topview_scene->addLine(100, (100-h_pixel/2), 100, (100+h_pixel/2), linepen); // 세로라인
        topview_scene->addLine(scene_w/2, (scene_h/2-h_pixel/2)+1, scene_w/2, (scene_h/2+h_pixel/2), linepen); // 세로라인
        topview_scene->addLine((scene_w/2-w_pixel/2)+1, scene_h/2, (scene_w/2+w_pixel/2), scene_h/2, linepen); // 가로라인

        double data_width = abs((this->DataMinMax.maxx+1) - this->DataMinMax.minx);
        double data_height = abs((this->DataMinMax.maxy+1) - this->DataMinMax.miny);
        data_x = data_width;
        data_y = data_height;
        int w_p = data_width*scale;
        int h_p = data_height*scale;
        int offx = offset_x*scale;
        int offy = offset_y*scale;
        topview_scene->addRect((scene_w/2-w_p/2)+offx, (scene_h/2-h_p/2)-offy, w_p, h_p, QPen(QBrush(Qt::blue), 1), QBrush(QColor(0, 170, 255, 50)));
        topview_scene->addLine(scene_w/2+offx, (scene_h/2-h_p/2)+1-offy, scene_w/2+offx, (scene_h/2+h_p/2)-offy, QPen(QColor(Qt::blue), 2)); // 세로라인
        topview_scene->addLine((scene_w/2-w_p/2)+1+offx, scene_h/2-offy, (scene_w/2+w_p/2)+offx, scene_h/2-offy, QPen(QColor(Qt::blue), 2)); // 가로라인
    }
}

void OpenDataDemo::drawingVerticalView(){
    verticalview_scene->clear();
    if(modelMinMaxCheck() && dataMinMaxCheck()){
        int width = 150;
        int height = abs(this->ModelMinMax.maxz - this->ModelMinMax.minz) * z_scale;
        verticalview_scene->addRect((scene_w/2-width/2), (scene_h/2-height/2), width, height, QPen(QBrush(Qt::gray), 1), QBrush(QColor(255, 255, 255, 100)));
        QPen linepen;
        linepen.setStyle(Qt::DotLine);
        linepen.setColor(Qt::gray);
        linepen.setWidth(1);
        verticalview_scene->addLine((scene_w/2-width/2)+1, scene_h/2, (scene_w/2+width/2), scene_h/2, linepen); // 가로라인

        int data_width = 100;
        int data_height = 0;
        int offz = offset_z*z_scale*-1;
        if(this->DataMinMax.maxz > 0 && this->DataMinMax.minz < 0){
            data_height = 100;
            verticalview_scene->addRect((scene_w/2-data_width/2), (scene_h/2-data_height/2)+offz, data_width, data_height, QPen(QBrush(Qt::blue), 1), QBrush(QColor(0, 170, 255, 100)));
            verticalview_scene->addLine((scene_w/2-data_width/2)+1, scene_h/2+offz, (scene_w/2+data_width/2), scene_h/2+offz, QPen(QColor(Qt::blue), 1)); // 가로라인
        }else if(this->DataMinMax.maxz > 0 && this->DataMinMax.minz >= 0){
            data_height = 50;
            verticalview_scene->addRect((scene_w/2-data_width/2), (scene_h/2-data_height)+offz, data_width, data_height, QPen(QBrush(Qt::blue), 1), QBrush(QColor(0, 170, 255, 100)));
            //verticalview_scene->addLine((scene_w/2-data_width/2)+1, scene_h/2+offz, (scene_w/2+data_width/2), scene_h/2+offz, QPen(QColor(Qt::blue), 1)); // 가로라인
        }else if(this->DataMinMax.maxz <= 0 && this->DataMinMax.minz < 0){
            data_height = 50;
            verticalview_scene->addRect((scene_w/2-data_width/2), (scene_h/2)+offz, data_width, data_height, QPen(QBrush(Qt::blue), 1), QBrush(QColor(0, 170, 255, 100)));
            //verticalview_scene->addLine((scene_w/2-data_width/2)+1, scene_h/2+offz, (scene_w/2+data_width/2), scene_h/2+offz, QPen(QColor(Qt::blue), 1)); // 가로라인
        }
    }
}

bool OpenDataDemo::modelMinMaxCheck(){
    if(!compareDouble(this->ModelMinMax.minx, this->ModelMinMax.maxx) &&
       !compareDouble(this->ModelMinMax.miny, this->ModelMinMax.maxy) &&
       !compareDouble(this->ModelMinMax.minz, this->ModelMinMax.maxz)){
        return true;
    }else{
        return false;
    }
}

bool OpenDataDemo::dataMinMaxCheck(){
    if(!compareDouble(this->DataMinMax.minx, this->DataMinMax.maxx) &&
       !compareDouble(this->DataMinMax.miny, this->DataMinMax.maxy) &&
       !compareDouble(this->DataMinMax.minz, this->DataMinMax.maxz)){
        return true;
    }else{
        return false;
    }
}

bool OpenDataDemo::compareDouble(double x, double y){
    double absTolerance = (1.0e-8);
    double diff = x - y;
    if(fabs(diff) <= absTolerance) return true;
    else return false;
}

void OpenDataDemo::ReadData(string file){
    data_header.clear();
    data_col.clear();
    data_total.clear();

    ifstream input(file.c_str(), std::ios::binary);

    if(!input) return;

    std::string line;
    getline(input, line);
    data_header = T2D::string_split(line, '\t');
    //cout << "data size" << data_header.size() << endl;

    while (std::getline(input, line))
    {
        data_col.clear();
        vector<string> split = T2D::string_split(line, '\t');
        for(int i = 0 ; i < int(split.size()) ; i++){
            data_col.push_back(atof(split[i].c_str()));
            //cout <<atof(split[i].c_str())<<endl;
        }
        //cout << line << endl;
        data_total.push_back(data_col);
    }
}

void OpenDataDemo::ReadSTL(string file){
    stl_vertices.clear();

    ifstream input(file.c_str(), std::ios::binary);

    if(!input){
        return;
    }

    char header[80] = {0};
    input.read(header, 80);
    bool isBinary = (strncmp(header, "solid", 5) != 0); // 참이면 바이너리

    if(!isBinary){
        std::string line;
        while (std::getline(input, line))
        {
            // line에서 vertex 정보 추출
            if (line.find("vertex") != std::string::npos)
            {
                Vertex_stl v;
                //sscanf(line.c_str(), "vertex %f %f %f", &v.x, &v.y, &v.z);
                vector<string> split = T2D::string_split(line, ' ');
                /*v.x = atof(split[1].c_str());
                v.y = atof(split[2].c_str());
                v.z = atof(split[3].c_str());*/
                v.x = stod(split[1]);
                v.y = stod(split[2]);
                v.z = stod(split[3]);
                //cout << "x : " << v.x << " y : " << v.y << " z : " << v.z << endl;
                stl_vertices.push_back(v);
            }
        }
    }
}

/*void OpenDataDemo::settingCheck(){
    int time = ui->setting_time->currentIndex();
    int x = ui->setting_x->currentIndex();
    int y = ui->setting_y->currentIndex();
    int z = ui->setting_z->currentIndex();
    int color = ui->setting_color->currentIndex();
    for(int i = 0 ; i < sheet_col+1 ; i++){
        ui->setting_time->setItemData(i, QVariant(1), Qt::ItemIsSelectable);
        ui->setting_x->setItemData(i, QVariant(1), Qt::ItemIsSelectable);
        ui->setting_y->setItemData(i, QVariant(1), Qt::ItemIsSelectable);
        ui->setting_z->setItemData(i, QVariant(1), Qt::ItemIsSelectable);
        ui->setting_color->setItemData(i, QVariant(1), Qt::ItemIsSelectable);
    }

    ui->setting_time->setItemData(3, QVariant(0), Qt::ItemIsSelectable);

    ui->setting_time->view()->update();
    ui->setting_time->update();

   if(time > 0){
        cout << "int" << time << endl;
        int i = time;
        ui->setting_x->setItemData(i, QVariant(0), Qt::ItemIsEnabled);
        ui->setting_y->setItemData(i, QVariant(0), Qt::ItemIsEnabled);
        ui->setting_z->setItemData(i, QVariant(0), Qt::ItemIsEnabled);
        ui->setting_color->setItemData(i, QVariant(0), Qt::ItemIsEnabled);
    }
    if(x > 0){
        cout << "int1 " << x << endl;
        int i = x;
        ui->setting_time->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_y->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_z->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_color->setItemData(i, QVariant(0), Qt::UserRole -1);
    }
    if(y > 0){
        cout << "in2t" << y << endl;
        int i = y;
        ui->setting_x->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_time->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_z->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_color->setItemData(i, QVariant(0), Qt::UserRole -1);
    }
    if(z > 0){
        cout << "i1nt" << z << endl;
        int i = z;
        ui->setting_x->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_y->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_time->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_color->setItemData(i, QVariant(0), Qt::UserRole -1);
    }
    if(color > 0){
        cout << "iant" << color << endl;
        int i = color;
        ui->setting_x->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_y->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_z->setItemData(i, QVariant(0), Qt::UserRole -1);
        ui->setting_time->setItemData(i, QVariant(0), Qt::UserRole -1);
    }

}*/

void OpenDataDemo::on_setting_time_currentIndexChanged(int index)
{
    DataTime.clear();
    //settingCheck();
    if(index == 0) return;
    for(int i = 0 ; i < sheet_row ; i++){
        bool bufchk = false;
        string bufitem = ui->Datasheet->item(i, index - 1)->text().toStdString();
        for(int j = 0 ; j < DataTime.size() ; j++){
            if(bufitem == DataTime[j]){
                bufchk = true;
                break;
            }
        }
        if(bufchk == true) continue;

        DataTime.push_back(bufitem);
    }
}

void OpenDataDemo::on_setting_x_currentIndexChanged(int index)
{
    //settingCheck();
    if(index == 0){
        this->DataMinMax.minx = 0;
        this->DataMinMax.maxx = 0;
        return;
    }

    double min = ui->Datasheet->item(0, index - 1)->text().toDouble();
    double max = ui->Datasheet->item(0, index - 1)->text().toDouble();
    for(int i = 0 ; i < sheet_row ; i++){
        if(min > ui->Datasheet->item(i, index - 1)->text().toDouble()) min = ui->Datasheet->item(i, index - 1)->text().toDouble();
        if(max < ui->Datasheet->item(i, index - 1)->text().toDouble()) max = ui->Datasheet->item(i, index - 1)->text().toDouble();
    }
    this->DataMinMax.minx = min;
    this->DataMinMax.maxx = max;

    //cout << " minx : " << DataMinMax.minx << " maxx : " << DataMinMax.maxx << endl;

    drawingCheck();
}

void OpenDataDemo::on_setting_y_currentIndexChanged(int index)
{
    //settingCheck();
    if(index == 0){
        this->DataMinMax.miny = 0;
        this->DataMinMax.maxy = 0;
        return;
    }

    double min = ui->Datasheet->item(0, index - 1)->text().toDouble();
    double max = ui->Datasheet->item(0, index - 1)->text().toDouble();
    for(int i = 0 ; i < sheet_row ; i++){
        if(min > ui->Datasheet->item(i, index - 1)->text().toDouble()) min = ui->Datasheet->item(i, index - 1)->text().toDouble();
        if(max < ui->Datasheet->item(i, index - 1)->text().toDouble()) max = ui->Datasheet->item(i, index - 1)->text().toDouble();
    }
    this->DataMinMax.miny = min;
    this->DataMinMax.maxy = max;

    //cout << " miny : " << DataMinMax.miny << " maxy : " << DataMinMax.maxy << endl;

    drawingCheck();

}

void OpenDataDemo::on_setting_z_currentIndexChanged(int index)
{
    //settingCheck();
    if(index == 0){
        this->DataMinMax.minz = 0;
        this->DataMinMax.maxz = 0;
        ui->setting_z_option->setEnabled(false);
        return;
    }

    double min = ui->Datasheet->item(0, index - 1)->text().toDouble();
    double max = ui->Datasheet->item(0, index - 1)->text().toDouble();
    for(int i = 0 ; i < sheet_row ; i++){
        if(min > ui->Datasheet->item(i, index - 1)->text().toDouble()) min = ui->Datasheet->item(i, index - 1)->text().toDouble();
        if(max < ui->Datasheet->item(i, index - 1)->text().toDouble()) max = ui->Datasheet->item(i, index - 1)->text().toDouble();
    }

    //cout << " min : " << min << " max : " << max << endl;

    double scale;
    if(max > 0){
        scale = max_height/max;
        max = max_height;
        min = min * scale;
    }
    this->DataMinMax.minz = min;
    this->DataMinMax.maxz = max;

    data_z = scale;

    ui->setting_z_option->setEnabled(true);

    //cout << " min : " << DataMinMax.minz << " max : " << DataMinMax.maxz << endl;

    drawingCheck();

}

void OpenDataDemo::on_setting_color_currentIndexChanged(int index)
{
    //settingCheck();
    if(index == 0){
        this->DataMinMax.minz = 0;
        this->DataMinMax.maxz = 0;
        ui->setting_color_option->setValue(0.0);
        ui->setting_color_option->setEnabled(false);
        return;
    }

    double min = ui->Datasheet->item(0, index - 1)->text().toDouble();
    double max = ui->Datasheet->item(0, index - 1)->text().toDouble();
    for(int i = 0 ; i < sheet_row ; i++){
        if(min > ui->Datasheet->item(i, index - 1)->text().toDouble()) min = ui->Datasheet->item(i, index - 1)->text().toDouble();
        if(max < ui->Datasheet->item(i, index - 1)->text().toDouble()) max = ui->Datasheet->item(i, index - 1)->text().toDouble();
    }
    cout << min << endl;
    cout << max << endl;

    color_min = min;
    color_max = max;

    color_min = min;
    color_max = max;

    color_value = (abs(max)-abs(min))/2;
    ui->setting_color_option->setValue(color_value);
    ui->setting_color_option->setEnabled(true);
}

void OpenDataDemo::on_setting_offset_x_editingFinished()
{
    offset_x = ui->setting_offset_x->text().toDouble();
    drawingCheck();
}

void OpenDataDemo::on_setting_offset_y_editingFinished()
{
    offset_y = ui->setting_offset_y->text().toDouble();
    drawingCheck();
}

void OpenDataDemo::on_setting_offset_z_editingFinished()
{
    offset_z = ui->setting_offset_z->text().toDouble();
    //cout << offset_z << endl;
    drawingCheck();
}

void OpenDataDemo::on_OpenDataDemo_open_btn_clicked()
{
    Data_3D.clear();

    double center = ui->setting_color_option->value();
    int color_scale_up = 255/(color_max-center);
    int color_scale_down = 255/(center - color_min);

    for(auto x : DataTime){
        vector<Data_2nd> bufdata;
        for(int i = 0 ; i < sheet_row ; i++){
            if(x == ui->Datasheet->item(i, 0)->text().toStdString()){
                Data_2nd buf;
                buf.r = 0;
                buf.g = 255;
                buf.b = 0;
                buf.a = 255;
                if(ui->setting_color->currentIndex() != 0){
                    if(ui->Datasheet->item(i, ui->setting_color->currentIndex()-1)->text().toDouble() > center){
                       buf.r = (ui->Datasheet->item(i, ui->setting_color->currentIndex()-1)->text().toDouble() - center) * color_scale_up;
                       buf.g = 255 - (ui->Datasheet->item(i, ui->setting_color->currentIndex()-1)->text().toDouble() - center) * color_scale_up;
                    }
                    if(ui->Datasheet->item(i, ui->setting_color->currentIndex()-1)->text().toDouble() < center){
                       buf.b = (center - ui->Datasheet->item(i, ui->setting_color->currentIndex()-1)->text().toDouble()) * color_scale_down;
                       buf.g = 255 - (center - ui->Datasheet->item(i, ui->setting_color->currentIndex()-1)->text().toDouble()) * color_scale_down;
                    }
                }
                offset_x = 0;
                offset_y = 0;
                buf.minx = ui->Datasheet->item(i, ui->setting_x->currentIndex()-1)->text().toDouble(); //- (data_x / 2) + offset_x;
                buf.maxx = buf.minx + 1;
                buf.miny = ui->Datasheet->item(i, ui->setting_y->currentIndex()-1)->text().toDouble(); // - (data_y / 2) + offset_y;
                buf.maxy = buf.miny + 1;
                if(ui->setting_z_option->currentIndex() == 0){
                    buf.minz = offset_z;
                }
                buf.maxz = ui->Datasheet->item(i, ui->setting_z->currentIndex()-1)->text().toDouble() * data_z + offset_z;
                if(ui->setting_z_option->currentIndex() == 1){
                    buf.minz = buf.maxz - 1;
                }
                /*cout << x << " ix : " << buf.minx << " ax : " << buf.maxx << " iy : " << buf.miny << " ay : " << buf.maxy << " iz : " << buf.minz << " az : " << buf.maxz
                     << " r : " << buf.r << " g : " << buf.g << " b : " << buf.b << endl;*/
                bufdata.push_back(buf);
            }
        }
        Data_3D.push_back(bufdata);
    }

    this->close();
}























!@hash[]!@file[]./Rendering/Src/LayoutData.cpp!@hash[]!@code[]#include "LayoutPEXData.h"

#include <iostream>
#include <string>
#include <vector>
#include <limits>
#include <cstdio>
#include <chrono>

#include "rapidcsv.h"

#include <QFile>
#include <QDebug>



using namespace std;

inline double coord_normalize(double in_value, double move, double scale) {
    return 2 * ((in_value - move) * (scale)) - 1.0f;
}



LayoutItem::LayoutItem() : pattern{}, layer_number{}, layer_datatype{}, layer_type{} {
}
LayoutItem::~LayoutItem() {
}

LayoutItem::LayoutItem(const cube_info& pattern_, const int layer_number_, const int layer_datatype_, LAYOUT_LAYER_TYPE layer_type_)
    : pattern(pattern_), layer_number(layer_number_), layer_datatype(layer_datatype_), layer_type(layer_type_) {
}


LayoutDataManager::LayoutDataManager()
    : file_path{}, patterns{}, scale(1.0),
      layout_min_x{}, layout_max_x{}, layout_min_y{}, layout_max_y{}, layout_min_z{}, layout_max_z{} {
}

LayoutDataManager::~LayoutDataManager() {
    this->patterns.clear();
}

void LayoutDataManager::calculateScale() {
    x_diff = this->layout_max_x - this->layout_min_x;
    y_diff = this->layout_max_y - this->layout_min_y;
    z_diff = this->layout_max_z - this->layout_min_z;

    double max_diff = x_diff > y_diff ? x_diff : y_diff;
    max_diff = max_diff > z_diff ? max_diff : z_diff;

    this->scale = 1.0f / max_diff;
}

bool LayoutDataManager::compareByLength(const LDATA10BY10 &a, const LDATA10BY10 &b) {
    //qDebug() << "is working";
    return a.top < b.top;
}

void LayoutDataManager::loadLayoutData(T2D &t2d) {

    std::chrono::system_clock::time_point start, end;
    std::chrono::seconds run_time;

    start = std::chrono::system_clock::now();

   // rapidcsv::Document infile(file_path, rapidcsv::LabelParams(-1, -1));

    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutDataManager / loadLayoutData / rapidcsv::infile [sec] : "
              << run_time.count() << "\n";

    //std::vector<float> bbox = infile.GetRow<float>(0);
    this->layout_min_x = t2d.LayoutMinMax.minx;
    this->layout_min_y = t2d.LayoutMinMax.miny;
    this->layout_max_x = t2d.LayoutMinMax.maxx;
    this->layout_max_y = t2d.LayoutMinMax.maxy;
    this->layout_min_z = t2d.LayoutMinMax.minz;
    this->layout_max_z = t2d.LayoutMinMax.maxz;

    calculateScale();

    t2d_ptr = &t2d;

    //size_t line_count = infile.GetRowCount();
    //cube_info cur_cube;
    //int layer_number, layer_datatype;

    start = std::chrono::system_clock::now();

    /*
    for (size_t i = 1; i < line_count; ++i) { //first line is bbox area
        vector<string> line = infile.GetRow<string>(i);
        //if (line[LAYOUTINFO_IDX_STRUCTURE] != "Poly") continue;
        //if (std::stoi(line[LAYOUTINFO_IDX_NUMPOINTS]) != 4) continue;

        layer_number = std::stoi(line[LAYOUTINFO_IDX_LAYER]);
        layer_datatype = std::stoi(line[LAYOUTINFO_IDX_DATATYPE]);

        cur_cube.minz = std::stof(line[LAYOUTINFO_IDX_ZSTART]);
        cur_cube.maxz = std::stof(line[LAYOUTINFO_IDX_ZEND]);
        if (cur_cube.minz == cur_cube.maxz) continue;

        cur_cube.minx = std::stof(line[LAYOUTINFO_IDX_LEFT]);
        cur_cube.maxx = std::stof(line[LAYOUTINFO_IDX_RIGHT]);
        cur_cube.miny = std::stof(line[LAYOUTINFO_IDX_BOTTOM]);
        cur_cube.maxy = std::stof(line[LAYOUTINFO_IDX_TOP]);

        //cur_cube.minx = coord_normalize(cur_cube.minx, this->layout_min_x, scale);
        //cur_cube.maxx = coord_normalize(cur_cube.maxx, this->layout_min_x, scale);
        //cur_cube.miny = coord_normalize(cur_cube.miny, this->layout_min_y, scale);
        //cur_cube.maxy = coord_normalize(cur_cube.maxy, this->layout_min_y, scale);
        //cur_cube.minz = coord_normalize(cur_cube.minz, this->layout_min_z, scale);
        //cur_cube.maxz = coord_normalize(cur_cube.maxz, this->layout_min_z, scale);

        this->patterns.push_back(LayoutItem(cur_cube, layer_number, layer_datatype, LAYOUT_LAYER_TYPE::LAYOUT_LAYER_TYPE_DEFAULT));

    }*/

    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    start = std::chrono::system_clock::now();
    std::cout << "Run Time / LayoutDataManager / loadLayoutData / pattern push [sec] : "
              << run_time.count() << "\n";

    std::sort(t2d_ptr->LayoutData10by10.begin(), t2d_ptr->LayoutData10by10.end(), compareByLength);


    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    qDebug() << "Run Time / LayoutDataManager / loadLayoutData / pattern sort [sec] : "
              << run_time.count() << "\n";

   // infile.Clear();

    /*
        printf("\n\nLayout Info Data\n\n");
        for (auto& cur_pattern : this->patterns) {
            printf("left/bottom/right/top/z-start/z-end = %.4f/%.4f/%.4f/%.4f/%.4f/%.4f/\n",
                cur_pattern.pattern.minx, cur_pattern.pattern.miny,
                cur_pattern.pattern.maxx, cur_pattern.pattern.maxy,
         cur_pattern.pattern.minz, cur_pattern.pattern.maxz);
        }
        //*/
}

void testLayoutData() {
    //LayoutDataManager layout_data;
    //layout_data.loadLayoutData("Data/layout_input_data.csv");

}

!@hash[]!@file[]./Rendering/Src/LayoutModel.cpp!@hash[]!@code[]
#include <vulkan/vulkan.h>
#include "LayoutModel.h"

#include <iostream>
#include <string>
#include <vector>
#include <chrono>

#include "LayoutPEXData.h"
#include <unordered_set>
#include <QFile>


LayoutModel::LayoutModel(LveDevice& device, MODEL_TYPE model_type, T2D &t2d)
    : LveModel(device, model_type), layout_data{}, t2d_ref(t2d) {
    this->makeRenderingData(t2d);
    this->createBuffers();
}

LayoutModel::~LayoutModel() {
    this->layout_data.clear();
    this->layerby_vertices.clear();
    this->layerby_face.clear();
    this->layerby_edge.clear();
}

void LayoutModel::createFilteredLayout(){
    this->makeFilteredRendringData();
    this->createFilteredBuffers();
    isfilteredon = true;
}

void LayoutModel::clearFormerDatas(){
    layerby_vertices_filtered.clear();
    drawing_order_layerby_filtered.clear();
    layerby_face_filtered.clear();
    layerby_edge_filtered.clear();
    layerbyVertexBuffers_filtered.clear();
    layerbyVertexBuffersMemory_filtered.clear();
    layerbyFaceIndexBuffers_filtered.clear();
    layerbyFaceIndexBuffersMemory_filtered.clear();
    layerbyEdgeIndexBuffers_filtered.clear();
    layerbyEdgeIndexBuffersMemory_filtered.clear();
}

void LayoutModel::makeFilteredRendringData() {
    clearFormerDatas();
    loadData(t2d_ref);
    makeCubeVertices(true);
    makeVertices(true);
    makeIndices(true);
}

void LayoutModel::createFilteredBuffers() {
    for (auto const& [key, val] : layerby_vertices_filtered) {
        std::map<string, VkBuffer>& buffers = this->layerbyVertexBuffers_filtered;
        std::map<string, VkDeviceMemory>& buffersmemory = this->layerbyVertexBuffersMemory_filtered;
        createVertexBuffers(val, buffers[key], buffersmemory[key]);

        std::map<string, VkBuffer>& facebuffers = this->layerbyFaceIndexBuffers_filtered;
        std::map<string, VkDeviceMemory>& facebuffersmemory = this->layerbyFaceIndexBuffersMemory_filtered;
        createIndexBuffers(layerby_face_filtered[key], facebuffers[key], facebuffersmemory[key]);

        std::map<string, VkBuffer>& edgebuffers = this->layerbyEdgeIndexBuffers_filtered;
        std::map<string, VkDeviceMemory>& edgebuffersmemory = this->layerbyEdgeIndexBuffersMemory_filtered;
        createIndexBuffers(layerby_edge_filtered[key], edgebuffers[key], edgebuffersmemory[key]);
    }
}

void LayoutModel::createBuffers() {

    for (auto const& [key, val] : layerby_vertices) {
        std::map<string, VkBuffer>& buffers = this->layerbyVertexBuffers;
        std::map<string, VkDeviceMemory>& buffersmemory = this->layerbyVertexBuffersMemory;
        createVertexBuffers(val, buffers[key], buffersmemory[key]);

        std::map<string, VkBuffer>& facebuffers = this->layerbyFaceIndexBuffers;
        std::map<string, VkDeviceMemory>& facebuffersmemory = this->layerbyFaceIndexBuffersMemory;
        createIndexBuffers(layerby_face[key], facebuffers[key], facebuffersmemory[key]);

        std::map<string, VkBuffer>& edgebuffers = this->layerbyEdgeIndexBuffers;
        std::map<string, VkDeviceMemory>& edgebuffersmemory = this->layerbyEdgeIndexBuffersMemory;
        createIndexBuffers(layerby_edge[key], edgebuffers[key], edgebuffersmemory[key]);
    }
}

void LayoutModel::destroyBuffers() {
    if (this->model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) {
        for (auto const& [key, val] : layerbyFaceIndexBuffers) {
            vkDestroyBuffer(lveDevice.device(), layerbyVertexBuffers[key], nullptr);
            vkFreeMemory(lveDevice.device(), layerbyVertexBuffersMemory[key], nullptr);
            vkDestroyBuffer(lveDevice.device(), val, nullptr);
            vkFreeMemory(lveDevice.device(), layerbyFaceIndexBuffersMemory[key], nullptr);
            vkDestroyBuffer(lveDevice.device(), layerbyEdgeIndexBuffers[key], nullptr);
            vkFreeMemory(lveDevice.device(), layerbyEdgeIndexBuffersMemory[key], nullptr);
        }

        //vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        //vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }
}


void LayoutModel::makeRenderingData(T2D &t2d) {
    std::chrono::system_clock::time_point start, end;
    std::chrono::seconds run_time;

    start = std::chrono::system_clock::now();
    loadData(t2d);
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / loadData [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeCubeVertices(false);
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / makeCubeVertices [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeVertices(false);
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / lmakeVertices [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeIndices(false);
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / makeIndices [sec] : "
              << run_time.count() << "\n";
}


void LayoutModel::loadData(T2D &t2d) {
    this->layout_data.loadLayoutData(t2d);
}

void LayoutModel::makeCubeVertices(bool isfiltered) {
    std::vector<LDATA10BY10> &layout_items = this->layout_data.getPatterns_t2d();
    std::vector<LDATA10BY10>::iterator it = layout_items.begin();
    cube_vertex cur_cube_vertices;
    std::unordered_set<string> checking_set;
    this->cube_vertices = {};
    qDebug() << layout_items.size();
    for (it = layout_items.begin(); it != layout_items.end(); ++it) {
        cur_cube_vertices.layernum = to_string(it->layernum) + "." + to_string(it->datatype);
        qDebug() <<  QString::fromStdString(cur_cube_vertices.layernum);

        isfiltered? using_xy = it->xy_filtered: using_xy = it->xy;
        for(auto row : using_xy){
            for (auto col : row){
                if(col.size() == 0) continue;
                for(auto each_box : col){

                    cur_cube_vertices.vertex[0] = { each_box.minx, each_box.maxy, it->top };
                    cur_cube_vertices.vertex[1] = { each_box.minx, each_box.miny, it->top };
                    cur_cube_vertices.vertex[2] = { each_box.maxx, each_box.miny, it->top };
                    cur_cube_vertices.vertex[3] = { each_box.maxx, each_box.maxy, it->top };

                    cur_cube_vertices.vertex[4] = { each_box.minx, each_box.maxy, it->bot };
                    cur_cube_vertices.vertex[5] = { each_box.minx, each_box.miny, it->bot };
                    cur_cube_vertices.vertex[6] = { each_box.maxx, each_box.miny, it->bot };
                    cur_cube_vertices.vertex[7] = { each_box.maxx, each_box.maxy, it->bot };

                    this->cube_vertices.push_back(cur_cube_vertices);

                    if (isfiltered) {
                        if(checking_set.find(cur_cube_vertices.layernum) == checking_set.end()){
                            checking_set.insert(cur_cube_vertices.layernum);
                            drawing_order_layerby_filtered.push_back(cur_cube_vertices.layernum);
                        }
                    } else {
                        if(checking_set.find(cur_cube_vertices.layernum) == checking_set.end()){
                            checking_set.insert(cur_cube_vertices.layernum);
                            drawing_order_layerby.push_back(cur_cube_vertices.layernum);
                        }
                    }
                }

            }
            if (isfiltered) continue;
            layerList[cur_cube_vertices.layernum].color = glm::vec3 {it->color.r/(float)255,it->color.g/(float)255, it->color.b/(float)255};
            layerList[cur_cube_vertices.layernum].opacity = it->color.a/(float)255;
            layerList[cur_cube_vertices.layernum].visiblity = it->checking;

        }


        //std::cout << cube_vertices.back().layernum << '\n';
    }
}

void LayoutModel::makeVertices(bool isfiltered) {
    //std::vector<LDATA10BY10> &layout_items = this->layout_data.getPatterns_t2d();
    Vertex temp_vertex;


    float up_color = 0.15f;
    float down_color = 0.6f;

    for (const auto& cur_cube : this->cube_vertices) {
        for (int i = 0; i < 8; ++i) {
            temp_vertex.position = { cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };

            if (i < 4) temp_vertex.color = { up_color , up_color , up_color };
            else       temp_vertex.color = { down_color , down_color , down_color };

            isfiltered
                ? layerby_vertices_filtered[cur_cube.layernum].push_back(temp_vertex)
                : layerby_vertices[cur_cube.layernum].push_back(temp_vertex);

        }
    }
}

void LayoutModel::makeIndices(bool isfiltered) {
    makeIndicesForFace(isfiltered);
    makeIndicesForEdge(isfiltered);
}

void LayoutModel::makeIndicesForFace(bool isfiltered) {
    //size_t layer_count = this->layerby_vertices.size();
    uint32_t start_idx = 0;
    std::map<string, std::vector<uint32_t>>& indices = isfiltered? this->layerby_face_filtered : this->layerby_face;

    for (auto const& [key, val] : layerby_vertices) {
        size_t cube_count_by_layer = val.size() / 8;
        for (size_t i = 0; i < cube_count_by_layer; ++i) {
            start_idx = 8 * i;
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 0);//top

            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 3);//right

            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 0);//front

            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 4);//bottom

            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 0);//left

            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 1);//back
        }
    }

    qDebug() << layerby_vertices.size();

}

void LayoutModel::makeIndicesForEdge(bool isfiltered) {
    //size_t layer_count = this->layerby_vertices.size();
    std::map<string, std::vector<uint32_t>>& indices = isfiltered? this->layerby_edge_filtered : this->layerby_edge;
    indices.clear();
    uint32_t start_idx = 0;
    for (auto const& [key, val] : layerby_vertices) {
        size_t cube_count_by_layer = val.size() / 8;
        for (size_t i = 0; i < cube_count_by_layer; ++i) {
            start_idx = 8 * i;
            //top
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 1);
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 3);
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 0);

            //bottom
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 4);

            //right
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 3);

            //left
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 4);
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 1);
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 0);

            //front
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 3);
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 4);
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 0);

            //back
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 1);
        }
    }

}


void LayoutModel::bindDrawVertexIndexBufferForFace_layer(VkCommandBuffer commandBuffer, const string layer) {
    VkBuffer buffers[] = { layerbyVertexBuffers[layer] };
    VkDeviceSize offsets[] = { 0 };

    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
    vkCmdBindIndexBuffer(commandBuffer, layerbyFaceIndexBuffers[layer], 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_face[layer].size()), 1, 0, 0, 0);
}

void LayoutModel::bindDrawIndexBufferForEdge_layer(VkCommandBuffer commandBuffer, const string layer) {
    vkCmdBindIndexBuffer(commandBuffer, layerbyEdgeIndexBuffers[layer], 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_edge[layer].size()), 1, 0, 0, 0);
}

void LayoutModel::bindDrawVertexIndexBufferForFace_layer_filtered(VkCommandBuffer commandBuffer, const string layer) {
    VkBuffer buffers[] = { layerbyVertexBuffers_filtered[layer] };
    VkDeviceSize offsets[] = { 0 };

    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
    vkCmdBindIndexBuffer(commandBuffer, layerbyFaceIndexBuffers_filtered[layer], 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_face_filtered[layer].size()), 1, 0, 0, 0);
}

void LayoutModel::bindDrawIndexBufferForEdge_layer_filtered(VkCommandBuffer commandBuffer, const string layer) {
    vkCmdBindIndexBuffer(commandBuffer, layerbyEdgeIndexBuffers_filtered[layer], 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_edge_filtered[layer].size()), 1, 0, 0, 0);
}


!@hash[]!@file[]./Rendering/Src/PEXCapacitorModel.cpp!@hash[]!@code[]#include "PEXCapacitorModel.h"

#include <iostream>
#include <map>
#include <vector>
#include <math.h>
#include <cstdio>
#include <thread>
#include <mutex>

#include "LayoutPEXData.h"
#include "utils.h"
#include <QString>

using namespace std;

PEXCapacitorModel::PEXCapacitorModel(
    LveDevice& device,
    MODEL_TYPE model_type,
    const QString& data_file,
    T2D* layout_data_)
    : LveModel(device, model_type), pex_data{}, cap_node_name_to_index_map{}, layout_data{ layout_data_ } {

    this->makePatternCapsFromLayoutData();
    this->makeRenderingData(data_file);
    this->createBuffers();
}


PEXCapacitorModel::~PEXCapacitorModel() {
    for (auto& cur_item : this->layer_to_pattern_cap_map) cur_item.second.clear();
    this->layer_to_pattern_cap_map.clear();
    this->pattern_caps.clear();
}

void PEXCapacitorModel::makePatternCapsFromLayoutData() {
    std::vector<LDATA10BY10>& layout_items = this->layout_data->LayoutData10by10;
    std::vector<LDATA10BY10>::iterator it = layout_items.begin();
    pattern_cap pattern_cap_buf;
    if (layout_items.empty()) {
        std::cerr << "Error! empty patten @PEXCapacitorModel::makePatternWCapsFromLayoutData()\n";
    }

    for (it = layout_items.begin(); it != layout_items.end(); ++it) {
        pattern_cap_buf.layer_number = it->layernum;
        pattern_cap_buf.layer_datatype = it->datatype;
        pattern_cap_buf.cap_value = 0;
        //pattern_cap_buf.normalized_cap_value = 0;
        pattern_cap_buf.cap_count = 0;
        pattern_cap_buf.value_rank = 0;
        for (auto row : it->xy) {
            for (auto col : row) {
                if (col.size() == 0) continue;
                for (auto each_box : col) {
                    pattern_cap_buf.pattern.minx = each_box.minx;
                    pattern_cap_buf.pattern.miny = each_box.miny;
                    pattern_cap_buf.pattern.minz = it->bot;
                    pattern_cap_buf.pattern.maxx = each_box.maxx;
                    pattern_cap_buf.pattern.maxy = each_box.maxy;
                    pattern_cap_buf.pattern.maxz = it->top;

                    this->pattern_caps.push_back(pattern_cap_buf);
                }
            }
        }

        this->layers.insert({ it->layernum, it->datatype });
    }
}

void PEXCapacitorModel::makeRenderingData(const QString& file_path) {
    loadData(file_path);
    makeCapNodesFromPEXData();

    attachCapToPattern();
    normalizePatternCap();
    //sortDescendingOrder();
    //printLayerToPatternCapMap("After Normalization Cap");

    makeCubeVertices();
    makeVertices();
    makeIndices();
    makeIndicesFace();

    for (auto& cur_item : this->layer_to_cap_node_map) cur_item.second.clear();
    this->layer_to_cap_node_map.clear();
    this->cap_nodes.clear();
    this->layers.clear();
}

void PEXCapacitorModel::loadData(const QString& file_path) {
    this->pex_data.loadData(file_path);
    //this->pex_data.printPEXData();
}


void PEXCapacitorModel::makeCapNodesFromPEXData() {
    this->cap_node_name_to_index_map.clear();
    std::map<std::string, size_t>::iterator it;
    for (auto& pex_item : this->pex_data.getCapacitors()) {
        //node1
        std::string& node1_name = pex_item.node1.name;
        it = this->cap_node_name_to_index_map.find(node1_name);
        if (it == this->cap_node_name_to_index_map.end()) addNewCapNode(pex_item.node1, pex_item.value);
        else {
            this->cap_nodes[it->second].value += pex_item.value;
            this->cap_nodes[it->second].connected_count++;
        }

        //node2
        std::string& node2_name = pex_item.node2.name;
        it = this->cap_node_name_to_index_map.find(node2_name);
        if (it == this->cap_node_name_to_index_map.end()) addNewCapNode(pex_item.node2, pex_item.value);
        else {
            this->cap_nodes[it->second].value += pex_item.value;
            this->cap_nodes[it->second].connected_count++;
        }
    }//for(auto & pex_item : this->pex_data.getCapacitors())
    this->pex_data.clear();
    this->cap_node_name_to_index_map.clear();
}


void PEXCapacitorModel::addNewCapNode(pex_node& pex_node, double value) {
    cap_node new_cap_node{};
    new_cap_node.name = pex_node.name;
    new_cap_node.layer_number = pex_node.layer_number;
    new_cap_node.layer_datatype = pex_node.layer_datatype;
    new_cap_node.x = pex_node.x;
    new_cap_node.y = pex_node.y;
    new_cap_node.value = value;
    new_cap_node.connected_count = 1;

    this->cap_nodes.push_back(new_cap_node);
    this->cap_node_name_to_index_map.insert(std::pair<std::string, size_t>(new_cap_node.name, this->cap_nodes.size() - 1));
}


void PEXCapacitorModel::attachCapToPattern() {
    makeLayerToCapNodeMap();
    makeLayerToPatternCapMap();

    /*
        //????o???? ??????? ??
        //matchCapWithPattern(this->cap_layer_map, this->pattern_layer_map, 17, 0);
        for (auto& cur_layer : this->layers) {
            string layer = getLayerString(cur_layer.first, cur_layer.second);
            map<string, vector<cap_node*>>::iterator it_layer_to_cap_node_map = this->layer_to_cap_node_map.find(layer);
            map<string, vector<pattern_cap*>>::iterator it_layer_to_pattern_cap_map = this->layer_to_pattern_cap_map.find(layer);
            if (it_layer_to_cap_node_map == this->layer_to_cap_node_map.end()
                || it_layer_to_pattern_cap_map == this->layer_to_pattern_cap_map.end()) continue;

            std::vector<cap_node*>& caps = it_layer_to_cap_node_map->second;
            std::vector<pattern_cap*>& patterns = it_layer_to_pattern_cap_map->second;

            matchCapWithPattern(caps, patterns);
            //matchCapWithPattern(this->layer_to_cap_node_map, this->layer_to_pattern_cap_map, cur_layer.first, cur_layer.second);
        }
        */

    makeLayersQueueForThreadJob();
    for (size_t i = 0; i < this->num_threads; ++i) {

        this->threads.push_back(
            std::thread(&PEXCapacitorModel::matchCapWithPatternThread, this, &this->layers_queue, &this->mutex_layers_queue));
    }

    for (auto& thread : this->threads)
        thread.join();

    /*
        FILE* out_file = NULL;
        fopen_s(&out_file, "pattern_caps_info_thread.txt", "w");
        if (out_file != NULL) {
            printPatternCaps(out_file);
            fclose(out_file);
        }
        else printPatternCaps(stdout);
        */
}

void PEXCapacitorModel::matchCapWithPatternThread(std::queue<std::string>* layers, std::mutex* mutex_) {
    while (1) {
        mutex_->lock();
        if (layers->empty()) {
            mutex_->unlock();
            break;
        }

        string layer = layers->front();
        layers->pop();
        mutex_->unlock();

        map<string, vector<cap_node*>>::iterator it_layer_to_cap_node_map = this->layer_to_cap_node_map.find(layer);
        map<string, vector<pattern_cap*>>::iterator it_layer_to_pattern_cap_map = this->layer_to_pattern_cap_map.find(layer);
        if (it_layer_to_cap_node_map == this->layer_to_cap_node_map.end()
            || it_layer_to_pattern_cap_map == this->layer_to_pattern_cap_map.end()) continue;;

        std::vector<cap_node*>& caps = it_layer_to_cap_node_map->second;
        std::vector<pattern_cap*>& patterns = it_layer_to_pattern_cap_map->second;
        //matchCapWithPattern(caps, patterns);
        for (auto& cap : caps) {
            for (auto& pattern : patterns) {
                if (isPatternIncludeCap(*pattern, *cap)) {
                    pattern->cap_count++;
                    pattern->cap_value += cap->value;
                    break;
                }
            }//for cap : caps
        }//for pattern : patterns

    }//while 1
}


void PEXCapacitorModel::makeLayersQueueForThreadJob() {
    for (auto& cur_layer : this->layers) {
        string layer = getLayerString(cur_layer.first, cur_layer.second);
        this->layers_queue.push(layer);
    }
}

void PEXCapacitorModel::matchCapWithPattern(
    std::vector<cap_node*>& caps,
    std::vector<pattern_cap*>& patterns
) {

    for (auto& cap : caps) {
        for (auto& pattern : patterns) {
            if (isPatternIncludeCap(*pattern, *cap)) {
                pattern->cap_count++;
                pattern->cap_value += cap->value;
                break;
            }
        }//for cap : caps
    }//for pattern : patterns

}

void PEXCapacitorModel::matchCapWithPattern(
    std::map<std::string, std::vector<cap_node*>>& cap_layer_map_,
    std::map<std::string, std::vector<pattern_cap*>>& pattern_layer_map_,
    uint target_layer_number, uint target_layer_datatype) {

    //string layer = std::to_string(target_layer_number) + "." + std::to_string(target_layer_datatype);
    string layer = getLayerString(target_layer_number, target_layer_datatype);
    std::map<std::string, std::vector<cap_node*>>::iterator it_cap_layer_map = cap_layer_map_.find(layer);
    std::map<std::string, std::vector<pattern_cap*>>::iterator it_pattern_layer_map = pattern_layer_map_.find(layer);
    if (it_cap_layer_map == cap_layer_map_.end() || it_pattern_layer_map == pattern_layer_map_.end()) return;

    std::vector<cap_node*>& caps = it_cap_layer_map->second;
    std::vector<pattern_cap*>& patterns = it_pattern_layer_map->second;

    for (auto& cap : caps) {
        for (auto& pattern : patterns) {
            if (isPatternIncludeCap(*pattern, *cap)) {
                pattern->cap_count++;
                pattern->cap_value += cap->value;
                break;
            }
        }//for cap : caps
    }//for pattern : patterns
}

void PEXCapacitorModel::makeLayerToCapNodeMap() {
    this->layer_to_cap_node_map.clear();
    map<string, vector<cap_node*>>::iterator it;
    for (auto& cur_cap : this->cap_nodes) {
        //std::string layer = std::to_string(cur_cap.layer_number) + "." + std::to_string(cur_cap.layer_datatype);
        string layer = getLayerString(cur_cap.layer_number, cur_cap.layer_datatype);
        it = this->layer_to_cap_node_map.find(layer);
        if (it == this->layer_to_cap_node_map.end()) {
            vector<cap_node*>* new_cap_list = new vector<cap_node*>;
            new_cap_list->push_back(&cur_cap);
            this->layer_to_cap_node_map.insert(pair<string, vector<cap_node*>>(layer, *new_cap_list));
        }
        else {
            it->second.push_back(&cur_cap);
        }
    }//for (auto& cur_cap : this->cap_nodes)

    //printLayerToCapNodeMap();
}


void PEXCapacitorModel::makeLayerToPatternCapMap() {
    this->layer_to_pattern_cap_map.clear();
    map<string, vector<pattern_cap*>>::iterator it;
    for (auto& cur_pattern : this->pattern_caps) {
        //string layer = std::to_string(cur_pattern.layer_number) + "." + std::to_string(cur_pattern.layer_datatype);
        string layer = getLayerString(cur_pattern.layer_number, cur_pattern.layer_datatype);
        it = this->layer_to_pattern_cap_map.find(layer);
        if (it == this->layer_to_pattern_cap_map.end()) {
            vector<pattern_cap*>* new_pattern_list = new vector<pattern_cap*>;
            new_pattern_list->push_back(&cur_pattern);
            this->layer_to_pattern_cap_map.insert(pair<string, vector<pattern_cap*>>(layer, *new_pattern_list));
        }
        else {
            it->second.push_back(&cur_pattern);
        }
    }//for (auto& cur_pattern : this->pattern_caps)

    //printLayerToPatternCapMap();
}

void PEXCapacitorModel::sortDescendingOrder() {
    sort(this->pattern_caps.begin(),
         this->pattern_caps.end(),
         PEXCapacitorModel::compare_descending_order);
}


void PEXCapacitorModel::normalizePatternCap() {
    /*
    for (auto& cur_pattern_cap : this->pattern_caps) {
        if (cur_pattern_cap.cap_value > this->max_cap) this->max_cap = cur_pattern_cap.cap_value;
    }

    for (auto& cur_pattern_cap : this->pattern_caps) {
        cur_pattern_cap.normalized_cap_value = 1.0 / (std::log((cur_pattern_cap.cap_value / this->max_cap)) * (-1.0) + 1.0);
    }
    //*/

    this->sortDescendingOrder();
    size_t rank = 0;
    size_t index = 0;
    size_t num_of_pattern_cap = 0;
    double prev_cap_value{DBL_MIN}, cur_cap_value{};
    for(auto& cur_capacitor : this->pattern_caps){
        cur_cap_value = cur_capacitor.cap_value;
        if( cur_cap_value > 0.0) num_of_pattern_cap++;
        if( cur_cap_value != prev_cap_value){
            rank = index;
        }
        cur_capacitor.value_rank = rank;
        index++;
        prev_cap_value = cur_cap_value;
    }
    this->num_of_pattern_cap_not_zero = num_of_pattern_cap;
}


inline std::string PEXCapacitorModel::getLayerString(uint layer_number, uint layer_datatype) {
    return (std::string(std::to_string(layer_number) + "." + std::to_string(layer_datatype)));
}


bool PEXCapacitorModel::isPatternIncludeCap(const pattern_cap& pattern, const cap_node& cap) {
    double epsilon = 0.00001; //10pm
    if (cap.x < pattern.pattern.minx - epsilon) return false;
    if (cap.x > pattern.pattern.maxx + epsilon) return false;
    if (cap.y < pattern.pattern.miny - epsilon) return false;
    if (cap.y > pattern.pattern.maxy + epsilon) return false;
    return true;
}

void PEXCapacitorModel::makeCubeVertices() {
    cube_vertex cur_cube_vertices;
    std::vector<pattern_cap>::iterator it;
    for (it = this->pattern_caps.begin(); it != this->pattern_caps.end(); ++it) {
        cur_cube_vertices.vertex[0] = { it->pattern.minx, it->pattern.maxy, it->pattern.maxz };
        cur_cube_vertices.vertex[1] = { it->pattern.minx, it->pattern.miny, it->pattern.maxz };
        cur_cube_vertices.vertex[2] = { it->pattern.maxx, it->pattern.miny, it->pattern.maxz };
        cur_cube_vertices.vertex[3] = { it->pattern.maxx, it->pattern.maxy, it->pattern.maxz };

        cur_cube_vertices.vertex[4] = { it->pattern.minx, it->pattern.maxy, it->pattern.minz };
        cur_cube_vertices.vertex[5] = { it->pattern.minx, it->pattern.miny, it->pattern.minz };
        cur_cube_vertices.vertex[6] = { it->pattern.maxx, it->pattern.miny, it->pattern.minz };
        cur_cube_vertices.vertex[7] = { it->pattern.maxx, it->pattern.maxy, it->pattern.minz };

        this->cube_vertices.push_back(cur_cube_vertices);
    }
}
  
void PEXCapacitorModel::makeVertices() {
    VertexCapacitor temp_vertex;
    //float cap_color_r{}, cap_color_g{}, cap_color_b{};

    std::vector<pattern_cap>::iterator cur_pattern_cap = this->pattern_caps.begin();

    //double capacitor_value{};
    double total_pattern_count =
            static_cast<double>(this->getNumOfPatternCapNotZero());
    double capacitor_percentile{};

    //float temp_color[3] = { 0.0f, 0.0f, 0.0f };

    glm::vec3 capacitor_color = { 0.0f, 0.0f, 0.0f };
    for (const auto& cur_cube : this->cube_vertices) {
        //capacitor_value = cur_pattern_cap->cap_value;
        if (cur_pattern_cap->cap_value > -0.0001) {
            capacitor_percentile = cur_pattern_cap->value_rank/total_pattern_count;
            capacitor_color = UTILS::getPercentileColour(capacitor_percentile, 0.0, 1.0);
            /*
              std::cout << cur_pattern_cap->cap_value << std::endl;
              std::cout << "normalized_cap_value -----" << cur_pattern_cap->normalized_cap_value << std::endl;
              std::cout << "layer_number -----" << cur_pattern_cap->layer_number << "." << cur_pattern_cap->layer_datatype << std::endl;
              std::cout << "percentile -----" << capacitor_percentile << std::endl;
              std::cout << "r-" << capacitor_color.r << "g-" << capacitor_color.g << "b-" << capacitor_color.b << std::endl;
              */

            for (int i = 0; i < 8; ++i) {
                temp_vertex.position = { cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };
                temp_vertex.color = {capacitor_color,0.2};
                vertices_capacitor.push_back(temp_vertex);
            }
        }
        cur_pattern_cap++;
    }
}

void PEXCapacitorModel::makeIndices() {
    size_t cube_count = this->cube_vertices.size();

    std::vector<uint32_t>& indices = this->indices_edge;
    uint32_t start_idx = 0;
    for (size_t i = 0; i < cube_count; ++i, start_idx += 8) {
        //top
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);

        //bottom
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);

        //right
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);

        //left
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);

        //front
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);

        //back
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);
    }
}

void PEXCapacitorModel::makeIndicesFace() {
    size_t cube_count = this->cube_vertices.size();

    std::vector<uint32_t>& indices = this->indices_face;
    uint32_t start_idx = 0;
    for (unsigned int i = 0; i < cube_count; ++i) {
        start_idx = 8 * i;
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);//top

        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);//right

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);//front

        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);//bottom

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);//left

        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);//back
    }

  }


double PEXCapacitorModel::percentileOfCapacitor(const pattern_cap& in_cap) {
    std::vector<pattern_cap>::const_iterator it;
    int count = 0;
    int count_all = 0;
    double percent;
    for (it = this->pattern_caps.begin(); it != this->pattern_caps.end(); ++it) {
        if (it->cap_value != 0) {
            if (it->cap_value > in_cap.cap_value) {
                count++;
            }
            count_all++;
        }
    }
    percent = (count * 100) / count_all;
    return percent;
};


void PEXCapacitorModel::printCapNodes() {
    printf("***** PEX ITEM LIST\n");
    int i = 1;
    for (auto& pex_item : this->pex_data.getCapacitors()) {
        printf("%dth PEX Item\n", i++);
        pex_item.print();
        printf("\n");
    }

    printf("***** CAP NODE LIST\n");
    i = 1;
    for (auto& cap_node : this->cap_node_name_to_index_map) {
        printf("%dth Cap Node Item\n", i++);
        printf("\nNode Name = %s / Layer# = %d.%d / x,y = %.4f,%.4f / Value = %e / Neibor = %d\n",
            this->cap_nodes[cap_node.second].name.c_str(),
            this->cap_nodes[cap_node.second].layer_number,
            this->cap_nodes[cap_node.second].layer_datatype,
            this->cap_nodes[cap_node.second].x,
            this->cap_nodes[cap_node.second].y,
            this->cap_nodes[cap_node.second].value,
            this->cap_nodes[cap_node.second].connected_count);
        printf("\n");
    }
}

void PEXCapacitorModel::printPatternCaps(FILE* out_stream) {
    fprintf(out_stream, "\n\n###############################################\n");
    fprintf(out_stream, "### PatternCap List\n");
    for (auto& pattern : this->pattern_caps) {
        fprintf(out_stream, "\nLayer = %u.%u, Cap count = %u, Total Caps = %e\n",
            pattern.layer_number, pattern.layer_datatype, pattern.cap_count, pattern.cap_value);
        fprintf(out_stream, "\tLeft ~ Right/Bottom ~ Top = %.6f ~ %.6f / %.6f ~ %.6f\n",
            pattern.pattern.minx, pattern.pattern.maxx, pattern.pattern.miny, pattern.pattern.maxy);
    }
}

void PEXCapacitorModel::printLayerToCapNodeMap(FILE* out_stream) {
    fprintf(out_stream, "\n\n\n####################################################\n");
    fprintf(out_stream, "Cap Layer Map\n");
    for (auto& cur_item : this->layer_to_cap_node_map) {
        fprintf(out_stream, "\nLayer = %s :: name / cap count / cap value \n", cur_item.first.c_str());
        for (auto cur_cap : cur_item.second) {
            fprintf(out_stream, "\t%s / %u / %e / %.6f, %.6f\n",
                cur_cap->name.c_str(), cur_cap->connected_count, cur_cap->value, cur_cap->x, cur_cap->y);
        }
    }
}

void PEXCapacitorModel::printLayerToPatternCapMap(const char* msg) {
    printf("\n\n\n####################################################\n");
    printf("Pattern Layer Map :: %s\n", msg);
    for (auto& cur_item : this->layer_to_pattern_cap_map) {
        printf("\nLayer = %s :: left ~ right / bottom ~ top - cap count, cap value, norm cap value\n", cur_item.first.c_str());
        for (auto cur_pattern : cur_item.second) {
            printf("\t%.6f ~ %.6f / %.6f ~ %.6f - ",
                cur_pattern->pattern.minx, cur_pattern->pattern.maxx, cur_pattern->pattern.miny, cur_pattern->pattern.maxy);
            printf("%u, %e\n", cur_pattern->cap_count, cur_pattern->cap_value);
        }
    }
}

void PEXCapacitorModel::printLayerList() {
    printf("\n\n\n####################################################\n");
    printf("Layer List\n");
    for (auto& cur_layer : this->layers) {
        printf("\t%u.%u\n", cur_layer.first, cur_layer.second);
    }
}




!@hash[]!@file[]./Rendering/Src/PEXData.cpp!@hash[]!@code[]#include "LayoutPEXData.h"
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

#include <limits>
#include <cstdio>
#include <float.h>

#include "rapidcsv.h"

#include <QFile>
#include <QString>
#include <QDebug>
using namespace std;


/// <summary>
/// PEXItem
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXItem::PEXItem() : node1{}, node2{}, name{} {
    this->value = 0.0;
}

PEXItem::PEXItem(const node& node1_, const node& node2_, const double& value_, const string& name_) :
    node1(node1_), node2(node2_), value(value_), name(name_) {
}

PEXItem::~PEXItem() {
}

void PEXItem::print() {
    printf("%s\n", this->name.c_str());
    printf("Node1 name/layer#/x1,y1/Z-s,Z-e = %s / %d.%d / %.5f,%.5f / %.5f,%.5f\n",
        this->node1.name.c_str(), this->node1.layer_number, this->node1.layer_datatype,
        this->node1.x, this->node1.y, this->node1.z_start, this->node1.z_end);
    printf("Node2 name/layer#/x1,y1/Z-s,Z-e = %s / %d.%d / %.5f,%.5f / %.5f,%.5f\n",
        this->node1.name.c_str(), this->node1.layer_number, this->node1.layer_datatype,
        this->node2.x, this->node2.y, this->node2.z_start, this->node2.z_end);
}


/// <summary>
/// PEXResistor
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXResistor::PEXResistor() : PEXItem(), direction(RES_DIRECTION_NONE) {
}
PEXResistor::PEXResistor(const string& name_, const node& node1_, const node& node2_, const double& value_, const PEXResDirection& direction_) :
    PEXItem(node1_, node2_, value_, name_), direction(direction_) {
}

void PEXResistor::print() {
    PEXItem::print();
    printf("Direction = ");
    if (this->direction == RES_DIRECTION_VERTICAL) printf("Vertical\n");
    else printf("Horizontal\n");
    printf("Resistor Value = %10.5f\n\n", this->getValue());
}

PEXResistor::~PEXResistor() {
}

PEXResDirection PEXResistor::checkDirectionFromDescription(const std::string& description) {
    PEXResDirection direction;
    if (description.find("$a") == std::string::npos) {
        direction = RES_DIRECTION_HORIZONTAL;
    }
    else {
        direction = RES_DIRECTION_VERTICAL;
    }
    //printf("#####Description = %s, ", description.c_str());
    //if (direction == RES_DIRECTION_VERTICAL) printf("Vertical\n");
    //else printf("Horizontal\n");

    return direction;
}

/// <summary>
/// PEXCapacitor
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXCapacitor::PEXCapacitor() : PEXItem() {
}
PEXCapacitor::PEXCapacitor(const std::string& name_, const node& node1_, const node& node2_, const double& value_) :
    PEXItem(node1_, node2_, value_, name_) {
}
PEXCapacitor::~PEXCapacitor() {
}

void PEXCapacitor::print() {
    PEXItem::print();
    printf("Capacitor Value = %10.5e\n\n", this->getValue());
}

/// <summary>
/// PEXResistorDataManager
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXResistorDataManager::PEXResistorDataManager() {
    this->resistors = nullptr;
    this->file_path = "";
    this->max_resistor_vertical = std::numeric_limits<double>::min();
    this->min_resistor_vertical = std::numeric_limits<double>::max();
    this->max_resistor_horizontal = std::numeric_limits<double>::min();
    this->min_resistor_horizontal = std::numeric_limits<double>::max();
}

PEXResistorDataManager::~PEXResistorDataManager() {
    printf("\n\n\t~PEXDataManager\n");
    for(size_t i = 0; i < this->resistors_ref.size(); ++i){
        delete this->resistors_ref[i];
    }
    this->resistors->clear();
    this->resistors_ref.clear();
    this->direction_resistors.clear();
}

void PEXResistorDataManager::clear() {
    this->resistors->clear();
}

void PEXResistorDataManager::loadData(const QString file_path) {
    if (!QFile::exists(file_path)) {
        qDebug() << "Error! " << file_path << " is not exist!!\n";
        return;
    }
    qDebug() << "resistor parsing start";


    this->file_path = file_path;
    rapidcsv::Document infile(file_path.toStdString(), rapidcsv::LabelParams(-1, -1));

    string item_name{}, node1_lvl{}, node2_lvl{};
    node node1{}, node2{};
    string description{};
    double value = 0.0;

    size_t line_count = infile.GetRowCount();
    for (size_t i = 1; i < line_count; ++i) {
        vector<string> line = infile.GetRow<string>(i);

        item_name = line[PEXINFO_INDEX::PEXINFO_INDEX_NAME];
        if (item_name[0] != 'R') continue;

        node1.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_NAME];
        node1.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_X]);
        node1.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_Y]);
        node1.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZSTART]);
        node1.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZEND]);
        node1.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_NUMBER]);
        node1.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_DATATYPE]);

        node2.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_NAME];
        node2.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_X]);
        node2.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_Y]);
        node2.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZSTART]);
        node2.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZEND]);
        node2.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_NUMBER]);
        node2.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_DATATYPE]);

        value = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_VALUE]);

        node1_lvl = line[PEXINFO_INDEX_NODE1_LVL];
        node2_lvl = line[PEXINFO_INDEX_NODE2_LVL];


        if (node1_lvl == "RX") {
            node1.x = node2.x;
            node1.y = node2.y;
        }

        description = line[PEXINFO_INDEX::PEXINFO_INDEX_DESCRIPTION];
        PEXResDirection resistor_direction =
                PEXResistor::checkDirectionFromDescription(description);
        if (value > 0.005) {
            updateMinMaxRes(value, resistor_direction); //임의의 코드, 0보다 작은 저항은 무시
            this->resistors_ref.push_back(
                        new PEXResistor(item_name,
                                        node1,
                                        node2,
                                        value,
                                        resistor_direction));
        }
    }

    this->sortDescendingOrder();
    this->resistors = &this->resistors_ref;
}

void PEXResistorDataManager::setDriectionOfResistor(PEXResDirection _direction) {
    this->direction_resistors.clear();
    int net_index = this->getCurrentNetIndex();
    if (net_index > -1) {
        std::vector<PEXResistor*>& net_resistors =
                this->getNodesOfTargetNet(net_index);
        for (auto& cur_res : net_resistors) {
            if (cur_res->getDirection() == _direction) {
                this->direction_resistors.push_back(cur_res);
            }
        }
    }
    else if (this->getCurrentNetIndex() == -1) {
        for (auto& cur_res : this->resistors_ref) {
            if (cur_res->getDirection() == _direction) {
                this->direction_resistors.push_back(cur_res);
            }
        }
    }

    this->resistors = &this->direction_resistors;
}

void PEXResistorDataManager::prepareNetRenderingData(int net_index){
    if(net_index < -1) return;
    if(net_index >= this->getNetsCount()) return;

    this->resistors = &this->nets_list[net_index];
}

void PEXResistorDataManager::prepareAllNetRenderingData(){
    this->resistors = &this->resistors_ref;
}

inline void PEXResistorDataManager::updateMinMaxRes(const double& new_value, const PEXResDirection direction) {
    if (direction == PEXResDirection::RES_DIRECTION_VERTICAL) {
        if (this->min_resistor_vertical > new_value) this->min_resistor_vertical = new_value;
        if (this->max_resistor_vertical < new_value) this->max_resistor_vertical = new_value;
    }
    else {
        if (this->min_resistor_horizontal > new_value) this->min_resistor_horizontal = new_value;
        if (this->max_resistor_horizontal < new_value) this->max_resistor_horizontal = new_value;
    }

}

void PEXResistorDataManager::printData() {
    for (auto& item : *this->resistors) {
        item->print();
    }
    printf("##Resistor Count : %lld, Vertical Res Max = %10.5f, Min = %10.5f, Horizontal Res Max = %10.5f, Min = %10.5f\n",
        this->resistors->size(),
        this->getMaxResistorVerticalValue(), this->getMinResistorVerticalValue(),
        this->getMaxResistorHorizontalValue(), this->getMinResistorHorizontalValue());
}


void PEXResistorDataManager::makeNetsList(){
    this->makeNodeMap();
    PEXResistor* cur_res;
    unsigned int new_nets_index = 0;
    //for(it = resistors_ref.begin(); it != resistors_ref.end(); ++it){
    for(size_t i = 0; i < this->resistors_ref.size(); ++i){
        cur_res = this->resistors_ref[i];
        if( cur_res->checked) continue;

        new_nets_index = this->makeNewNets();        
        addResistorToCurNet(this->nets_list[new_nets_index], cur_res);

        this->node_queue.clear();
        this->node_queue.push_back(cur_res->node1.name);
        this->node_queue.push_back(cur_res->node2.name);
        findAllNodesAtCurNet(this->nets_list[new_nets_index]);
    }//for(it = resistors_ref.begin(); it != resistors_ref.end(); ++it)

    this->nets_count = this->nets_list.size();
}


void PEXResistorDataManager::findAllNodesAtCurNet(
        std::vector<PEXResistor*>& cur_net){
    string cur_node_name = "";
    string node1_name, node2_name;
    std::multimap<std::string, PEXResistor*>::iterator it;
    std::multimap<std::string, PEXResistor*>::iterator lower_bound, upper_bound;
    while(!this->node_queue.empty()){
        cur_node_name = this->node_queue.front();
        this->node_queue.pop_front();

        lower_bound = this->node_map.lower_bound(cur_node_name);
        upper_bound = this->node_map.upper_bound(cur_node_name);
        for(it = lower_bound; it != upper_bound; ++it){
            if(it->second->checked) continue;
            this->addResistorToCurNet(cur_net, it->second);

            node1_name = it->second->node1.name;
            node2_name = it->second->node2.name;
            if(cur_node_name != node1_name)
                this->node_queue.push_back(node1_name);
            if(cur_node_name != node2_name)
                this->node_queue.push_back(node2_name);
        }//for(it = lower_bound; it != upper_bound; ++it)
    }//while(!this->node_queue.empty())
}

void PEXResistorDataManager::addResistorToCurNet(
        std::vector<PEXResistor*>& cur_net,
        PEXResistor* cur_res){
    cur_net.push_back(cur_res);
    cur_res->checked = true;
}

unsigned int PEXResistorDataManager::makeNewNets(){
    unsigned int new_nets_index = this->nets_list.size();
    std::vector<PEXResistor*> new_nets;
    this->nets_list.push_back(new_nets);

    return new_nets_index;
}

void PEXResistorDataManager::makeNodeMap(){
    std::vector<PEXResistor*>::iterator it;
    for(it = resistors_ref.begin(); it != resistors_ref.end(); ++it){
        this->node_map.insert(pair<string, PEXResistor*>(
                                  (*it)->node1.name, *it));
        this->node_map.insert(pair<string, PEXResistor*>(
                                  (*it)->node2.name, *it));
    }
}

void PEXResistorDataManager::sortDescendingOrder(){
    sort(this->resistors_ref.begin(),
         this->resistors_ref.end(),
         PEXItem::compare_descending_order);

    size_t rank = 0;
    size_t index = 0;
    double prev_res_value{DBL_MIN}, cur_res_value{};
    for(auto& cur_resistor : this->resistors_ref){
        cur_res_value = cur_resistor->value;
        if( cur_res_value != prev_res_value){
            rank = index;
        }
        cur_resistor->value_rank = rank;
        index++;
        prev_res_value = cur_res_value;
    }
}

/// <summary>
/// PEXCapacitorDataManager
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXCapacitorDataManager::PEXCapacitorDataManager() {
    this->capasitors = {};
    this->file_path = "";
    this->max_capacitor = std::numeric_limits<double>::min();
    this->min_capacitor = std::numeric_limits<double>::max();
}

PEXCapacitorDataManager::~PEXCapacitorDataManager() {
    this->capasitors.clear();
}

void PEXCapacitorDataManager::clear() {
    this->capasitors.clear();
}

void PEXCapacitorDataManager::loadData(const QString file_path) {
    if (!QFile::exists(file_path)) {
        qDebug() << "Error! " << file_path << " is not exist!!\n";
        return;
    }
    qDebug() << "capacitor parsing start";

    this->file_path = file_path;
    rapidcsv::Document infile(file_path.toStdString(), rapidcsv::LabelParams(-1, -1));

    string item_name{}, node1_lvl{}, node2_lvl{};
    node node1{}, node2{};
    string description{};
    double value = 0.0;

    size_t line_count = infile.GetRowCount();
    for (size_t i = 1; i < line_count; ++i) {
        vector<string> line = infile.GetRow<string>(i);

        item_name = line[PEXINFO_INDEX::PEXINFO_INDEX_NAME];
        if (item_name[0] != 'C') continue;

        node1.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_NAME];
        node1.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_X]);
        node1.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_Y]);
        node1.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZSTART]);
        node1.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZEND]);
        node1.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_NUMBER]);
        node1.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_DATATYPE]);

        node2.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_NAME];
        node2.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_X]);
        node2.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_Y]);
        node2.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZSTART]);
        node2.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZEND]);
        node2.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_NUMBER]);
        node2.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_DATATYPE]);

        value = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_VALUE]);

        node1_lvl = line[PEXINFO_INDEX_NODE1_LVL];
        node2_lvl = line[PEXINFO_INDEX_NODE2_LVL];

        updateMinMaxCap(value);
        this->capasitors.push_back(PEXCapacitor(item_name, node1, node2, value));
    }

}


inline void PEXCapacitorDataManager::updateMinMaxCap(const double& new_value) {
    if (this->min_capacitor > new_value) this->min_capacitor = new_value;
    if (this->max_capacitor < new_value) this->max_capacitor = new_value;
}


void PEXCapacitorDataManager::printData() {

    std::cout << "\n\nPEX Capacitors\n";
    for (auto item : this->capasitors) {
        item.print();
    }
    printf("##Capacitor Count : %lld, Max cap = %10.5e, Min cap = %10.5e\n",
        this->capasitors.size(), this->getMaxCapacitorValue(), this->getMinCapacitorValue());
}


void testPEXData() {
    PEXResistorDataManager resistor_data;
    resistor_data.loadData("Data/MVP_PEX_RC_r1_0130_0208version.csv");
    resistor_data.printData();

    PEXCapacitorDataManager capacitor_data;
    capacitor_data.loadData("Data/MVP_PEX_RC_r1_0130_0208version.csv");
    capacitor_data.printData();
}
!@hash[]!@file[]./Rendering/Src/PEXResistorModel.cpp!@hash[]!@code[]#include "PEXResistorModel.h"

#include <iostream>
#include <string>
#include <vector>
#include <limits>
#include <float.h>

#include "LayoutPEXData.h"
#include "utils.h"

#include <QFile>
#include <QString>
#include <QDebug>

PEXResistorModel::PEXResistorModel(LveDevice& device, MODEL_TYPE model_type, const QString& data_file)
    : LveModel(device, model_type), pex_data{} {
    this->res_cube_thickness = 0.003;
    this->makeRenderingData(data_file);
    //this->createBuffers();
}

PEXResistorModel::~PEXResistorModel() {
    this->pex_data.clear();
}

void PEXResistorModel::makeRenderingData(const QString& file_path) {
    if (!QFile::exists(file_path)) {
        qDebug() << "Error! " << file_path << " is not exist!!\n";
        return;
    }

    loadData(file_path);
    groupResistorOfNode();
    makeCubes();
    makeCubeVertices();

    //std::chrono::system_clock::time_point start, end;
    //std::chrono::nanoseconds run_time;
    //start = std::chrono::system_clock::now();
    makeVertices();
    //end = std::chrono::system_clock::now();
    //run_time = (end - start);
    //qDebug() << "Run Time PEXResistorModel::makeVertices() : " << run_time.count();

    makeIndices();
    makeIndicesForEdge_map();
    this->createBuffers();
}

void PEXResistorModel::makeNetRenderingData(int net_index) {
    if(this->pex_data.getNetsCount() < -1 ) return;
    this->pex_data.setCurrentNetIndex(net_index);
    this->pex_data.prepareNetRenderingData(net_index);

    this->destroyBuffers();
    this->makeCubes();
    this->makeCubeVertices();
    this->makeVertices();
    this->makeIndices();
    this->makeIndicesForEdge_map();
    this->createBuffers();
}

void PEXResistorModel::makeAllNetRenderingData() {
    if(this->pex_data.getNetsCount() < -1 ) return;
    this->pex_data.prepareAllNetRenderingData();

    this->destroyBuffers();
    this->makeCubes();
    this->makeCubeVertices();
    this->makeVertices();
    this->makeIndices();
    this->makeIndicesForEdge_map();
    this->createBuffers();
}

void PEXResistorModel::makeDirectionRenderingData(PEXResDirection _direction) {
    if(this->pex_data.getNetsCount() < -1 ) return;
    this->pex_data.setDriectionOfResistor(_direction);

    this->destroyBuffers();
    this->makeCubes();
    this->makeCubeVertices();
    this->makeVertices();
    this->makeIndices();
    this->makeIndicesForEdge_map();
    this->createBuffers();
}

void PEXResistorModel::loadData(const QString& file_path) {
    this->pex_data.loadData(file_path);
    //this->pex_data.printData();
}

void PEXResistorModel::groupResistorOfNode() {
    //std::chrono::system_clock::time_point start, end;
    //std::chrono::nanoseconds run_time;

    //start = std::chrono::system_clock::now();
    this->pex_data.makeNetsList();
    //end = std::chrono::system_clock::now();
    //run_time = (end - start);

    //qDebug() << "Make Res Nets List Time Compare";
    //qDebug() << "Time : " << run_time.count() << "nsec";
}

void PEXResistorModel::setDirectionOfResistor(PEXResDirection _direction) {
    this->pex_data.setDriectionOfResistor(_direction);
    //this->pex_data.printData();
}


void PEXResistorModel::increaseNumOfResistorGroup() {
    int net_index = this->pex_data.getCurrentNetIndex();
    if(net_index <= -1) net_index = 0;

    net_index = (net_index+1) % this->pex_data.getNetsCount();
    this->pex_data.setCurrentNetIndex(net_index);
    this->makeNetRenderingData(net_index);
}

void PEXResistorModel::setNumOfResistorGroup(QString resgroupnum) {
    this->pex_data.setCurrentNetIndex(resgroupnum.toInt());
}

void PEXResistorModel::decreaseNumOfResistorGroup() {
    int net_index = this->pex_data.getCurrentNetIndex();
    if(net_index <= -1) net_index = 0;
    else if(net_index == 0) net_index = this->pex_data.getNetsCount()-1;
    else net_index = net_index - 1;

    this->pex_data.setCurrentNetIndex(net_index);
    this->makeNetRenderingData(net_index);
}


void PEXResistorModel::makeCubes() {
    std::vector<PEXResistor*>* resistors = this->pex_data.getResistors();
    cube_info cur_cube{};
    for (auto cur_res : *resistors) {
        this->makeCube(*cur_res, cur_cube, cur_res->getDirection());
        this->cube_infos.push_back(cur_cube);
    }
}

void PEXResistorModel::makeCube(const PEXResistor& res, cube_info& cube, PEXResDirection res_direction) {
    if (res_direction == RES_DIRECTION_VERTICAL) {
        cube.minx = res.node1.x - this->res_cube_thickness;
        cube.maxx = res.node1.x + this->res_cube_thickness;
        cube.miny = res.node1.y - this->res_cube_thickness;
        cube.maxy = res.node1.y + this->res_cube_thickness;
        cube.minz = (res.node1.z_end + res.node1.z_start) / 2;
        cube.maxz = (res.node2.z_end + res.node2.z_start) / 2;
    }
    else if (res_direction == RES_DIRECTION_HORIZONTAL) {
        if (res.node1.x == res.node2.x) {//run-length direction : y
            cube.minx = res.node1.x - this->res_cube_thickness;
            cube.maxx = res.node1.x + this->res_cube_thickness;
            cube.miny = res.node1.y < res.node2.y ? res.node1.y : res.node2.y;
            cube.maxy = res.node1.y < res.node2.y ? res.node2.y : res.node1.y;
        }
        else if (res.node1.y == res.node2.y) {//run-length direction : x
            cube.minx = res.node1.x < res.node2.x ? res.node1.x : res.node2.x;
            cube.maxx = res.node1.x < res.node2.x ? res.node2.x : res.node1.x;
            cube.miny = res.node1.y - this->res_cube_thickness;
            cube.maxy = res.node1.y + this->res_cube_thickness;
        }
        else {
            if (abs(res.node1.x - res.node2.x) > abs(res.node1.y - res.node2.y)) {
                cube.minx = res.node1.x < res.node2.x ? res.node1.x : res.node2.x;
                cube.maxx = res.node1.x < res.node2.x ? res.node2.x : res.node1.x;
                cube.miny = res.node1.y - this->res_cube_thickness;
                cube.maxy = res.node1.y + this->res_cube_thickness;
            }
            else {
                cube.minx = res.node1.x - this->res_cube_thickness;
                cube.maxx = res.node1.x + this->res_cube_thickness;
                cube.miny = res.node1.y < res.node2.y ? res.node1.y : res.node2.y;
                cube.maxy = res.node1.y < res.node2.y ? res.node2.y : res.node1.y;
            }
        }


        cube.minz = res.node1.z_end;
        cube.maxz = res.node2.z_start;
        /*

                    double midz = (res.node1.z_start + res.node1.z_end) * 0.5;
                    cube.minz = midz - this->res_cube_thickness;
                    cube.maxz = midz + this->res_cube_thickness;
        */
    }
    else {
        std::cerr << "\nResistor has no direction\n";
    }
}


void PEXResistorModel::makeCubeVertices() {
    std::vector<cube_info>::const_iterator it;
    cube_vertex cur_cube_vertices;

    for (it = this->cube_infos.begin(); it != this->cube_infos.end(); ++it) {
        cur_cube_vertices.vertex[0] = { it->minx, it->maxy, it->maxz };
        cur_cube_vertices.vertex[1] = { it->minx, it->miny, it->maxz };
        cur_cube_vertices.vertex[2] = { it->maxx, it->miny, it->maxz };
        cur_cube_vertices.vertex[3] = { it->maxx, it->maxy, it->maxz };

        cur_cube_vertices.vertex[4] = { it->minx, it->maxy, it->minz };
        cur_cube_vertices.vertex[5] = { it->minx, it->miny, it->minz };
        cur_cube_vertices.vertex[6] = { it->maxx, it->miny, it->minz };
        cur_cube_vertices.vertex[7] = { it->maxx, it->maxy, it->minz };

        this->cube_vertices.push_back(cur_cube_vertices);
    }
}

void PEXResistorModel::makeVertices() {
    VertexResistor temp_vertex;

    std::vector<PEXResistor*>::iterator cur_resistor
            = this->pex_data.getResistors()->begin();

    glm::vec3 resistor_color;
    double total_resistor_count = static_cast<double>(
                this->pex_data.getResistorsRef()->size());
    double resistor_percentile{};

    for (const auto& cur_cube : this->cube_vertices){
        resistor_percentile = (*cur_resistor)->value_rank / total_resistor_count;
        /*
        double resistor_percentile_t = percentileOfResistance(*cur_resistor);
        qDebug() << index << " : "
                 << "Res/Percentile : "
                 << cur_res_value << "/"
                 << resistor_percentile_t << "/"
                 << resistor_percentile;
        */

        resistor_color = UTILS::getPercentileColour(resistor_percentile, 0.0, 1.0);
        for (int i = 0; i < 8; ++i) {
            temp_vertex.position = {
                cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };
            //if (resistor_direction == PEXResDirection::RES_DIRECTION_VERTICAL) {
            //temp_vertex.color = { resistor_percentile / 100, 0.0f, 1-resistor_percentile/100 };
            temp_vertex.color = { resistor_color,0.2 };
            //	}
                //else {
                    //temp_vertex.color = { 0.0f, 0.0f, static_cast<float>(resistor_value / max_res) };
                //}
            //temp_vertex.color_vert_alpha = { 0.2,1.0,1.0 };
            vertices_resistor.push_back(temp_vertex);
        }//for i 0 to 8
        cur_resistor++;
    }//for auto cur_vertices : this->cubes_vertices
}


void PEXResistorModel::makeIndices() {
    size_t cube_count = this->cube_vertices.size();

    uint32_t start_idx = 0;
    std::vector<uint32_t>& indices = this->indices_face;
    for (unsigned int i = 0; i < cube_count; ++i) {
        start_idx = 8 * i;
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);//top

        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);//right

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);//front

        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);//bottom

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);//left

        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);//back
    }
}

void PEXResistorModel::makeIndicesForEdge_map() {
    size_t cube_count = this->cube_vertices.size();

    std::vector<uint32_t>& indices = this->indices_edge;
    uint32_t start_idx = 0;
    for (unsigned int i = 0; i < cube_count; ++i, start_idx += 8) {
        //top
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);

        //bottom
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);

        //right
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);

        //left
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);

        //front
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);

        //back
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);
    }
}


double PEXResistorModel::percentileOfResistance(const PEXResistor& in_res) {
    std::vector<PEXResistor*>::const_iterator it, it_end;

    it = this->pex_data.getResistors()->begin();
    it_end = this->pex_data.getResistors()->end();
    int count = 0;
    double percent;
    double total_data_count = (double)this->pex_data.getResistors()->size();
    for (; it != it_end; ++it) {
        if ((*it)->value > in_res.value) {
            count++;
        }
    }
    percent = (count * 100) / total_data_count;
    return percent;
};





!@hash[]!@file[]./Rendering/Src/dtaorendersystem.cpp!@hash[]!@code[]

#include <QVulkanWindow>
#include <QVulkanInstance>
#include <vulkan/vulkan.h>

#include <QFileDialog>

#include "dtaorendersystem.h"

#include "lve_model.hpp"
#include "LayoutModel.h"
#include "PEXResistorModel.h"
#include "PEXCapacitorModel.h"


DtaoRenderSystem::DtaoRenderSystem(LveWindow *w)
    : lveWindow(w)
{
    this->trans_info = {};
    initCameraView();
    qDebug() << "\n$$$$$ DtaoRenderSystem()";
}

DtaoRenderSystem::~DtaoRenderSystem()
{
    deleteSimpleRenderSystem();
    deleteLveDevice();
}

void DtaoRenderSystem::initCameraView(){
    this->camera.setViewTarget(
                glm::vec3(0.0f,0.0f,1.0f),
                glm::vec3(0.0f, 0.0f, 0.0f),
                glm::vec3(0.0f, 1.0f, 0.0f));
}

void DtaoRenderSystem::beginRenderPass(VkCommandBuffer command_buffer){
    const QSize sz = this->lveWindow->swapChainImageSize();

    VkClearColorValue clearColor = {{ 0, 0, 0, 1 }};
    VkClearDepthStencilValue clearDS = { 1, 0 };
    VkClearValue clearValues[3];
    memset(clearValues, 0, sizeof(clearValues));
    clearValues[0].color = clearValues[2].color = clearColor;
    clearValues[1].depthStencil = clearDS;

    VkRenderPassBeginInfo rpBeginInfo;
    memset(&rpBeginInfo, 0, sizeof(rpBeginInfo));
    rpBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    rpBeginInfo.renderPass = lveWindow->defaultRenderPass();
    rpBeginInfo.framebuffer = lveWindow->currentFramebuffer();
    rpBeginInfo.renderArea.extent.width = sz.width();
    rpBeginInfo.renderArea.extent.height = sz.height();
    rpBeginInfo.clearValueCount = lveWindow->sampleCountFlagBits() > VK_SAMPLE_COUNT_1_BIT ? 3 : 2;
    rpBeginInfo.pClearValues = clearValues;
    m_devFuncs->vkCmdBeginRenderPass(command_buffer, &rpBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

    VkViewport viewport;
    viewport.x = viewport.y = 0;
    viewport.width = sz.width();
    viewport.height = sz.height();
    viewport.minDepth = 0;
    viewport.maxDepth = 1;
    m_devFuncs->vkCmdSetViewport(command_buffer, 0, 1, &viewport);

    VkRect2D scissor;
    scissor.offset.x = scissor.offset.y = 0;
    scissor.extent.width = viewport.width;
    scissor.extent.height = viewport.height;
    m_devFuncs->vkCmdSetScissor(command_buffer, 0, 1, &scissor);
}

void DtaoRenderSystem::goNavi(POS_MONITORING value){
    this->naviInfo = value;
    isNavi = true;
}

void DtaoRenderSystem::translateLayerPosition(){
    if(!isNavi) return ;

    for (auto& gameobject : this->gameObjects) {
        if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
            gameobject.transform.translation = {-naviInfo.x*trans_info.scale, -naviInfo.y*trans_info.scale, 0};

        }
    }
    camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(naviInfo.zoom/cameraController.monitor.zoom,
                                                               naviInfo.zoom/cameraController.monitor.zoom,
                                                               naviInfo.zoom/cameraController.monitor.zoom));

    glm::vec3 right {camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0]};
    camera.viewMatrix = glm::rotate(camera.getView(), (float)glm::radians(naviInfo.tilt-cameraController.monitor.tilt), right);


    camera.viewMatrix = glm::rotate(camera.getView(), (float)glm::radians(naviInfo.rotation-cameraController.monitor.rotation), glm::vec3(0.0f, 0.0f, 1.0f));

    isNavi = false;
}

void DtaoRenderSystem::emitMonitor(){


    glm::vec3 forward {camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2]};
    glm::vec3 up {camera.viewMatrix[0][1], camera.viewMatrix[1][1], camera.viewMatrix[2][1]};
    double tilt = asin(forward.z/(sqrt(forward.x*forward.x +forward.y*forward.y+forward.z*forward.z)))*(180/3.141592653589793238463);
    double rotation;
    //camera.decomposeView(camera.getView());
    //camera.rotation_d = glm::conjugate(camera.rotation_d);
    // yaw / z
    //double siny_cosp = 2 * (camera.rotation_d.w * camera.rotation_d.z + camera.rotation_d.x * camera.rotation_d.y);
    //double cosy_cosp = 1 - 2 * (camera.rotation_d.y * camera.rotation_d.y + camera.rotation_d.z * camera.rotation_d.z);
    if(tilt > 89.5 || tilt < -89.5){
        //rotation = (double)atan2(siny_cosp, cosy_cosp)*(180/3.141592653589793238463);
        rotation = (double)atan2(up.x, up.y)*(180/3.141592653589793238463);
    } else {
        rotation = (double)atan2(-forward.x, -forward.y)*(180/3.141592653589793238463);
    }


    cameraController.monitor.tilt = tilt;
    cameraController.monitor.rotation = rotation;

    if(!gameObjects.empty()){
        cameraController.monitor.x = -(gameObjects[0].transform.translation.x) / trans_info.scale;
        cameraController.monitor.y = -(gameObjects[0].transform.translation.y)/ trans_info.scale;
        cameraController.monitor.z = -gameObjects[0].transform.translation.z/ trans_info.scale;
        cameraController.monitor.zoom = camera.scale_d.x*this->trans_info.scale*camera.std_scale/(2*tan(glm::radians(25.f)));
    }

    if(!toycad_objects.empty() || !stl_objects.empty()){
        cameraController.monitor.x = -(stl_objects[0].transform.translation.x) / trans_info.scale;
        cameraController.monitor.y = -(stl_objects[0].transform.translation.y)/ trans_info.scale;
        cameraController.monitor.z = -stl_objects[0].transform.translation.z/ trans_info.scale;
        this->trans_info_offset_x = -(this->stl_minx) + cameraController.monitor.x;
        this->trans_info_offset_y = -(this->stl_minx) + cameraController.monitor.y;
        this->trans_info_offset_z = cameraController.monitor.z;
        cameraController.monitor.zoom = camera.scale_d.x*this->trans_info.scale*camera.std_scale/(2*tan(glm::radians(25.f)));
    }

    if(this->render_mode != DTAO_RENDER_MODE_TOYCAD){
        QString funcName = "camera_position";
        emit lveWindow->signalInfoText(funcName,cameraController.monitor);
    }
}

void DtaoRenderSystem::startNextFrame(){
    glm::vec3 move_dir{0.0f};
    move_dir = this->cameraController.moveCamera(
                aspect, this->camera, this->getRenderScale(),
                this->gameObjects, lveWindow);

    if(move_dir != glm::vec3{0.0f,0.0f,0.0f}){
        this->moveToyCADObjects(move_dir);
        this->moveSTLObjects(move_dir);
    }

    move_dir = this->cameraController.moveCameraMouse(
                this->camera, this->getRenderScale(),
                this->gameObjects, lveWindow);

    if(move_dir != glm::vec3{0.0f,0.0f,0.0f}){
        this->moveToyCADObjects(move_dir);
        this->moveSTLObjects(move_dir);
    }
    this->cameraController.toggleFilteredData(this->gameObjects);

    this->cameraController.onDemo(aspect, this->camera, this->getRenderScale(), this->gameObjects, lveWindow);
    this->emitMonitor();
    this->translateLayerPosition();


    VkCommandBuffer command_buffer = this->lveWindow->currentCommandBuffer();
    beginRenderPass(command_buffer);

    if(this->render_mode == DTAO_RENDER_MODE_TOYCAD){
        this->simpleRenderSystem->renderToyCADObjects(
                    command_buffer, this->toycad_objects, this->camera);
    }
    else if(this->render_mode == DTAO_RENDER_MODE_STL){
        this->simpleRenderSystem->renderSTLObjects(
                    command_buffer, this->stl_objects, this->camera);
        this->simpleRenderSystem->renderToyCADObjects(
                    command_buffer, this->toycad_objects, this->camera);
    }
    else{
        this->simpleRenderSystem->renderGameObjects(
                    command_buffer, this->gameObjects, this->camera);
    }


    m_devFuncs->vkCmdEndRenderPass(command_buffer);

    lveWindow->frameReady();
    lveWindow->requestUpdate(); // render continuously, throttled by the presentation rate

}

void DtaoRenderSystem::initResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::initResources()";
    createLveDevice();
    createSimpleRenderSystem();
    //if(!this->render_object_created) loadGameObjects();



    VkDevice dev = this->lveWindow->device();
    m_devFuncs = this->lveWindow->vulkanInstance()->deviceFunctions(dev);

    qDebug() << "\tDevice = " << this->lveDevice->device();

}

void DtaoRenderSystem::releaseResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::releaseResources()";

    deleteSimpleRenderSystem();
    deleteLveDevice();
}

void DtaoRenderSystem::initSwapChainResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::initSwapChainResources()";
    const QSize sz = this->lveWindow->swapChainImageSize();
    aspect = sz.width()/(double)sz.height();
    if(camera.isperspective){
        this->camera.setPerspectiveProjection(glm::radians(50.f), aspect, 0.1f, 100.f);
    } else {
        float zero_plane_height = tan(glm::radians(25.f));
        this->camera.setOrthographicProjection(-1 * aspect * zero_plane_height, 1 * aspect * zero_plane_height, -1 * zero_plane_height, 1 * zero_plane_height, 0.1f, 100.f);
    }

    //this->camera.setOrthographicProjection(-1,1,-1,1,0.1f,100.f);
}


void DtaoRenderSystem::releaseSwapChainResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::releaseSwapChainResources()";
}

void DtaoRenderSystem::createLveDevice(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::createLveDevice()";
    this->lveDevice = new LveDevice(this->lveWindow, this->lveWindow->vulkanInstance());
}

void DtaoRenderSystem::deleteLveDevice(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::deleteLveDevice()";
    delete this->lveDevice;
}

void DtaoRenderSystem::createSimpleRenderSystem(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::createSimpleRenderSystem()";
    VkRenderPass renderpass = this->lveWindow->defaultRenderPass();
    this->simpleRenderSystem = new SimpleRenderSystem(*this->lveDevice, renderpass);
}

void DtaoRenderSystem::deleteSimpleRenderSystem(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::deleteSimpleRenderSystem()";
    delete this->simpleRenderSystem;
}
/*
void DtaoRenderSystem::createNewObject(MODEL_TYPE model_type, const std::string & file_path) {
    if( model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) createNewLayoutObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) createNewPEXCapObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) createNewPEXResObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_AXIS) createNewAxisObject(file_path);
}*/

void DtaoRenderSystem::createT2DObject(MODEL_TYPE model_type, T2D &t2d) {
    if( model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) createT2DLayoutObject(t2d);
    //else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) createNewPEXCapObject(file_path);
    //else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) createNewPEXResObject(file_path);
    //else if( model_type == MODEL_TYPE::MODEL_TYPE_AXIS) createNewAxisObject(file_path);
}

void DtaoRenderSystem::getCustomColor(string layernumber, glm::vec3 rgb){
    if(!gameObjects.empty()){
        for (auto& obj : gameObjects){
          if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT){
              obj.model->changeLayerColor(layernumber,rgb);
          }
        }

    } else {
        qDebug() << "there is no layer. get layer first!";
    }

}

void DtaoRenderSystem::getCustomOpacity(string layernumber, float opacity){
    if(!gameObjects.empty()){
        for (auto& obj : gameObjects){
          if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT){
              obj.model->changeLayerOpacity(layernumber,opacity);
          }
        }

    } else {
        qDebug() << "there is no layer. get layer first!";
    }
}

void DtaoRenderSystem::getCustomVisiblity(string layernumber, bool visibility){
    if(!gameObjects.empty()){
        for (auto& obj : gameObjects){
          if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT){
              obj.model->changeLayerVisiblity(layernumber,visibility);
          }
        }

    } else {
        qDebug() << "there is no layer. get layer first!";
    }
}

void DtaoRenderSystem::createT2DLayoutObject(T2D & t2d){
    std::shared_ptr<LayoutModel> model
            = std::make_unique<LayoutModel>(
                *this->lveDevice, MODEL_TYPE_LAYOUT, t2d);
    model->opacity = 0.5f;

    LayoutDataManager* layout_data = model->getLayoutDataManager();
    this->trans_info.trans_x = static_cast<float>( layout_data->getMinX()
                                                   + layout_data->getDiffX()/2
                                                   );
    this->trans_info.trans_y = static_cast<float>( layout_data->getMinY()
                                                   + layout_data->getDiffY()/2
                                                   );
    this->trans_info.trans_z = static_cast<float>( layout_data->getMinZ());
    this->trans_info.scale =  static_cast<float>( layout_data->getScale());

    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x*trans_info.scale, -this->trans_info.trans_y*trans_info.scale, -this->trans_info.trans_z*trans_info.scale};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale
    };
    this->gameObjects.push_back(std::move(new_object));
    this->render_object_created = true;
    this->layout_model = model;
}

void DtaoRenderSystem::createFilteredLayoutObject(){
    std::shared_ptr<LayoutModel> model
            = std::static_pointer_cast<LayoutModel>(gameObjects[0].model);
    model->opacity = 0.5f;

    LayoutDataManager* layout_data = model->getLayoutDataManager();
    this->trans_info.trans_x = static_cast<float>( layout_data->getMinX()
                                                   + layout_data->getDiffX()/2
                                                   );
    this->trans_info.trans_y = static_cast<float>( layout_data->getMinY()
                                                   + layout_data->getDiffY()/2
                                                   );
    this->trans_info.trans_z = static_cast<float>( layout_data->getMinZ());
    this->trans_info.scale =  static_cast<float>( layout_data->getScale());

    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x*trans_info.scale, -this->trans_info.trans_y*trans_info.scale, -this->trans_info.trans_z*trans_info.scale};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale
    };
    this->gameObjects.push_back(std::move(new_object));
    this->render_object_created = true;
    this->layout_model = model;
}

/*
void DtaoRenderSystem::createNewLayoutObject(const std::string & file_path){

    //Layout model
    std::string layout_info_file_path = file_path;
    std::shared_ptr<LayoutModel> model
            = std::make_unique<LayoutModel>(
                *this->lveDevice, MODEL_TYPE_LAYOUT, layout_info_file_path);
    model->opacity = 0.5f;

    LayoutDataManager* layout_data = model->getLayoutDataManager();
    this->trans_info.trans_x = static_cast<float>( layout_data->getMinX());
    this->trans_info.trans_y = static_cast<float>( layout_data->getMinY());
    this->trans_info.trans_z = static_cast<float>( layout_data->getMinZ());
    this->trans_info.scale = static_cast<float>( layout_data->getScale());

    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x, -this->trans_info.trans_y, -this->trans_info.trans_z};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
    this->render_object_created = true;
    this->layout_model = model;
}
*/

void DtaoRenderSystem::createNewPEXResObject( const QString & file_path){
    //PEX Resistor model
    QString res_info_file_path = file_path;
    std::shared_ptr<PEXResistorModel> model
            = std::make_unique<PEXResistorModel>(
                *this->lveDevice, MODEL_TYPE_PEX_RESISTOR, res_info_file_path);

    //Resistor Object
    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x*trans_info.scale, -this->trans_info.trans_y*trans_info.scale, -this->trans_info.trans_z*trans_info.scale};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
    this->res_model = model;
}

void DtaoRenderSystem::createNewPEXCapObject( const QString & file_path,T2D  t2d){
    //PEX Capacitor model
    QString cap_info_file_path = file_path;
    std::shared_ptr<PEXCapacitorModel> model
            = std::make_unique<PEXCapacitorModel>(
                *this->lveDevice, MODEL_TYPE_PEX_CAPACITOR,
                cap_info_file_path, &t2d);

    //Capacitor Object
    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x*trans_info.scale, -this->trans_info.trans_y*trans_info.scale, -this->trans_info.trans_z*trans_info.scale};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
}

void DtaoRenderSystem::createToyCADObjects(const std::string& file_path){

    if(!this->toycad_objects.empty()) this->toycad_objects.clear();

    ToyCADData toycad_data_loader;
    toycad_data_loader.loadToyCADData(file_path);
    std::vector<TOYCAD_DATA>* toycad_data = toycad_data_loader.getCADData();
    TOYCAD_BBOX& toycad_data_bbox = toycad_data_loader.getDataBBox();

    this->trans_info.trans_x = static_cast<float>(toycad_data_bbox.min_x);
    this->trans_info.trans_y = static_cast<float>(toycad_data_bbox.min_y);
    this->trans_info.trans_z = static_cast<float>(toycad_data_bbox.min_z);
    this->trans_info.scale =  static_cast<float>(toycad_data_loader.getScale());

    for(auto & cur_data : *toycad_data){
        std::shared_ptr<ToyCADModel> model
                = std::make_unique<ToyCADModel>(*this->lveDevice, cur_data);

        auto new_object = ToyCADObject::createToyCADObject();
        new_object.model = model;
        new_object.color = glm::vec3{
                cur_data.color_r/255.0f,
                cur_data.color_g/255.0f,
                cur_data.color_b/255.0f};
        new_object.opacity = cur_data.color_a/255.0f;
        new_object.transform.rotation = glm::vec3{
                cur_data.rotation_x,
                cur_data.rotation_y,
                cur_data.rotation_z};
        new_object.visibility = true;
        new_object.transform.translation = glm::vec3{
            (-this->trans_info.trans_x+cur_data.minx)*this->trans_info.scale,
            (-this->trans_info.trans_y+cur_data.miny)*this->trans_info.scale,
            (-this->trans_info.trans_z+cur_data.minz)*this->trans_info.scale};
        new_object.transform.scale = glm::vec3{
                this->trans_info.scale,
                this->trans_info.scale,
                this->trans_info.scale};
        //new_object.scale = 1.0f;

        this->toycad_objects.push_back(std::move(new_object));
    }//for(auto & cur_data : toycad_datas){

    this->render_object_created = true;
    this->render_mode = DTAO_RENDER_MODE_TOYCAD;
}

void DtaoRenderSystem::createSTLObjects(
            std::vector<Vertex_stl>& stl_data,
            MIN_MAX_XYZ& data_bbox,
            std::vector<Data_2nd>& open_data){

    this->stl_minx = data_bbox.minx;
    this->stl_miny = data_bbox.miny;

    if(!this->stl_objects.empty()) this->stl_objects.clear();

    this->calculateTransform(data_bbox);

    cout << this->trans_info_offset_x << " " << this->trans_info_offset_y << " " << this->trans_info_offset_z << endl;

    this->trans_info.trans_x = this->trans_info.trans_x + trans_info_offset_x;
    this->trans_info.trans_y = this->trans_info.trans_y + trans_info_offset_y;
    this->trans_info.trans_z = this->trans_info.trans_z + trans_info_offset_z;

    std::shared_ptr<STLModel> model
            = std::make_unique<STLModel>(*this->lveDevice, stl_data);
    auto new_object = STLObject::createSTLObject();
    new_object.model = model;
    new_object.color = glm::vec3{0.5f,0.5f,0.5f};
    new_object.opacity = 0.5f;
    new_object.transform.rotation = glm::vec3{0.0f,0.0f,0.0f};
    new_object.visibility = true;
    new_object.transform.translation = glm::vec3{
        -this->trans_info.trans_x*this->trans_info.scale,
        -this->trans_info.trans_y*this->trans_info.scale,
        -this->trans_info.trans_z*this->trans_info.scale};
    new_object.transform.scale = glm::vec3{
            this->trans_info.scale,
            this->trans_info.scale,
            this->trans_info.scale};
    //new_object.scale = 1.0f;

    this->stl_objects.push_back(std::move(new_object));

    this->render_object_created = true;
    this->render_mode = DTAO_RENDER_MODE_STL;



    if(!this->toycad_objects.empty()) this->toycad_objects.clear();

    ToyCADData toycad_data_loader;
    toycad_data_loader.loadToyCADData(open_data);
    std::vector<TOYCAD_DATA>* toycad_data = toycad_data_loader.getCADData();

    for(auto & cur_data : *toycad_data){
        std::shared_ptr<ToyCADModel> model
                = std::make_unique<ToyCADModel>(*this->lveDevice, cur_data);

        auto new_object = ToyCADObject::createToyCADObject();
        new_object.model = model;
        new_object.color = glm::vec3{
                cur_data.color_r/255.0f,
                cur_data.color_g/255.0f,
                cur_data.color_b/255.0f};
        new_object.opacity = cur_data.color_a/255.0f;
        new_object.transform.rotation = glm::vec3{
                cur_data.rotation_x,
                cur_data.rotation_y,
                cur_data.rotation_z};
        new_object.visibility = true;
        new_object.transform.translation = glm::vec3{
            (-this->trans_info.trans_x+cur_data.minx)*this->trans_info.scale,
            (-this->trans_info.trans_y+cur_data.miny)*this->trans_info.scale,
            (-this->trans_info.trans_z+cur_data.minz)*this->trans_info.scale};

        new_object.transform.scale = glm::vec3{
                this->trans_info.scale,
                this->trans_info.scale,
                this->trans_info.scale};


        //new_object.scale = 1.0f;

        this->toycad_objects.push_back(std::move(new_object));
    }//for(auto & cur_data : toycad_datas){
}

void DtaoRenderSystem::calculateTransform(MIN_MAX_XYZ& bbox){
    this->calculateTransform(bbox.minx, bbox.miny, bbox.minz,
                             bbox.maxx, bbox.maxy, bbox.maxz);
}

void DtaoRenderSystem::calculateTransform(double min_x, double min_y, double min_z,
                        double max_x, double max_y, double max_z){

    double diff_x = max_x - min_x;
    double diff_y = max_y - min_y;
    double diff_z = max_z - min_z;

    double diff_max = diff_x > diff_y ? diff_x : diff_y;
    diff_max = diff_max > diff_z ? diff_max : diff_z;

    this->trans_info.trans_x = static_cast<float>(min_x);
    this->trans_info.trans_y = static_cast<float>(min_y);
    this->trans_info.trans_z = static_cast<float>(min_z);
    this->trans_info.scale =  static_cast<float>( 1.0f / diff_max);
}

void DtaoRenderSystem::moveToyCADObjects(glm::vec3 move_dir){
    if( this->toycad_objects.empty()) return;

    float obj_scale = 2*this->getRenderScale();
    float zoom = this->cameraController.monitor.zoom;
    float image_height = this->lveWindow->swapChainImageSize().height();

    if (glm::dot(move_dir, move_dir) > std::numeric_limits<float>::epsilon()) {
        vector<ToyCADObject>::iterator it = this->toycad_objects.begin();
        for(;it != this->toycad_objects.end(); ++it){
                it->transform.translation
                        += (move_dir*obj_scale)/(zoom*image_height);
        }
    }//if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon())
}

void DtaoRenderSystem::moveSTLObjects(glm::vec3 move_dir){
    if( this->stl_objects.empty()) return;

    float obj_scale = 2*this->getRenderScale();
    float zoom = this->cameraController.monitor.zoom;
    float image_height = this->lveWindow->swapChainImageSize().height();

    if (glm::dot(move_dir, move_dir) > std::numeric_limits<float>::epsilon()) {
        vector<STLObject>::iterator it = this->stl_objects.begin();
        for(;it != this->stl_objects.end(); ++it){
                it->transform.translation
                        += (move_dir*obj_scale)/(zoom*image_height);
        }
    }//if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon())
}

/*
void DtaoRenderSystem::createNewAxisObject(const std::string & file_path){
    (void)(file_path);
    //Axis model
    std::shared_ptr<LveModel> model
            = std::make_unique<LveModel>(*this->lveDevice, MODEL_TYPE_AXIS);

    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {0.0f, 0.0f, 0.0f};
    new_object.transform.scale = { 1.0f, 1.0f, 1.0f };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
}
*/

/*
void DtaoRenderSystem::loadGameObjects() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::loadGameObjects()";
    return;

    auto cube = LveGameObject::createGameObject();

    //Layout model
    std::string layout_info_file_path = "Rendering/Data/layout_input_data.csv";
    //std::string layout_info_file_path = "Rendering/Data/big_test_espin.csv";
    std::shared_ptr<LayoutModel> layout_model
            = std::make_unique<LayoutModel>(*this->lveDevice, MODEL_TYPE_LAYOUT, layout_info_file_path);
    layout_model->opacity = 0.5f;

    LayoutDataManager* layout_data = layout_model->getLayoutDataManager();
    float trans_x = static_cast<float>(layout_data->getMinX());
    float trans_y = static_cast<float>(layout_data->getMinY());
    float trans_z = static_cast<float>(layout_data->getMinZ());
    float scale = static_cast<float>(layout_data->getScale());

    this->render_scale = scale;

    //Axis model
    std::shared_ptr<LveModel> axis_model
            = std::make_unique<LveModel>(*this->lveDevice, MODEL_TYPE_AXIS);

    //PEX Resistor model
    std::string res_info_file_path = "Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv";
    std::shared_ptr<PEXResistorModel> res_model
            = std::make_unique<PEXResistorModel>(*this->lveDevice, MODEL_TYPE_PEX_RESISTOR, res_info_file_path);

    //PEX Capacitor model
    std::string cap_info_file_path = "Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv";
    std::shared_ptr<PEXCapacitorModel> cap_model
            = std::make_unique<PEXCapacitorModel>(*this->lveDevice, MODEL_TYPE_PEX_CAPACITOR, cap_info_file_path, layout_model->getLayoutDataManager());


    //Resistor Object
    cube = LveGameObject::createGameObject();
    cube.model = res_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Capacitor Object
    cube = LveGameObject::createGameObject();
    cube.model = cap_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Layout Object
    cube = LveGameObject::createGameObject();
    cube.model = layout_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Axis Object
    cube = LveGameObject::createGameObject();
    cube.model = axis_model;
    cube.transform.translation = { 0.0f, 0.0f, 0.0f };
    cube.transform.scale = { 1.0f, 1.0f, 1.0f };
    gameObjects.push_back(std::move(cube));

    this->render_object_created = true;
}
*/
!@hash[]!@file[]./Rendering/Src/keyboard_movement_controller.cpp!@hash[]!@code[]#include "keyboard_movement_controller.hpp"
#include "lve_window.hpp"

#define GLM_ENABLE_EXPERIMENTAL
#include "LayoutModel.h"
// std
#include <limits>
#include <iostream>

#include <glm/gtx/string_cast.hpp>
#include "lve_model.hpp"

void KeyboardMovementController::visibleSetting(std::vector<LveGameObject>& gameObjects, Qt::Key key) {
    MODEL_TYPE target_model_type = MODEL_TYPE::MODEL_TYPE_DEFAULT;
    bool opacity_mode = false;
    (void)opacity_mode;
    double opacity = 0.0;
    (void)opacity;
    if (key == model_visible_set.resistor_key) {
        target_model_type = MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR;
    }

    else if (key == model_visible_set.capacitor_key) {
        target_model_type = MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR;
    }

    for (auto& obj : gameObjects) {
        if (obj.model->getModelType() == target_model_type) {
            obj.model->toggleVisible();
        }
    }

}

void KeyboardMovementController::setAllMoveFlagOff() {
    camera_moving_flag.rotateLeft = false;
    camera_moving_flag.rotateRight = false;
    camera_moving_flag.moveForward = false;
    camera_moving_flag.moveBackward = false;
    camera_moving_flag.rotateForward = false;
    camera_moving_flag.rotateBackward = false;
}

void KeyboardMovementController::setMouseFlagOff() {
    camera_moving_flag.mouseLeft = false;
    camera_moving_flag.mouseRight = false;
    camera_moving_flag.mouseMiddle = false;
}

void KeyboardMovementController::moveKeyPressed(Qt::Key key) {
    //setAllMoveFlagOff();
    if (key == camera_move_key.moveForward) camera_moving_flag.moveForward = true;
    if (key == camera_move_key.moveBackward) camera_moving_flag.moveBackward = true;
    if (key == camera_move_key.rotateRight) camera_moving_flag.rotateRight = true;
    if (key == camera_move_key.rotateLeft) camera_moving_flag.rotateLeft = true;
    if (key == camera_move_key.rotateForward) camera_moving_flag.rotateForward = true;
    if (key == camera_move_key.rotateBackward) camera_moving_flag.rotateBackward = true;
    if (key == camera_move_key.moveUp) camera_moving_flag.moveUp = true;
    if (key == camera_move_key.moveDown) camera_moving_flag.moveDown = true;
    if (key == camera_move_key.moveLeft) camera_moving_flag.moveLeft = true;
    if (key == camera_move_key.moveRight) camera_moving_flag.moveRight = true;
    if (key == camera_move_key.clearLayout) camera_moving_flag.clearLayout = true;
    if (key == camera_move_key.toggleDemension) {
        camera_moving_flag.toggleDemension = true;
        camera_moving_flag.toggleDemensionXY = true;
    }
    if (key == camera_move_key.toggleFiltered) camera_moving_flag.toggleFiltered = true;


}

void KeyboardMovementController::moveKeyReleased(Qt::Key key) {
    //setAllMoveFlagOff();
    if (key == camera_move_key.moveForward) camera_moving_flag.moveForward = false;
    if (key == camera_move_key.moveBackward) camera_moving_flag.moveBackward = false;
    if (key == camera_move_key.rotateRight) camera_moving_flag.rotateRight = false;
    if (key == camera_move_key.rotateLeft) camera_moving_flag.rotateLeft = false;
    if (key == camera_move_key.rotateForward) camera_moving_flag.rotateForward = false;
    if (key == camera_move_key.rotateBackward) camera_moving_flag.rotateBackward = false;
    if (key == camera_move_key.moveUp) camera_moving_flag.moveUp = false;
    if (key == camera_move_key.moveDown) camera_moving_flag.moveDown = false;
    if (key == camera_move_key.moveLeft) camera_moving_flag.moveLeft = false;
    if (key == camera_move_key.moveRight) camera_moving_flag.moveRight = false;
    if (key == camera_move_key.clearLayout) camera_moving_flag.clearLayout = false;

}

void KeyboardMovementController::setMousePosition(QPoint position, int mode) {
    mouse_position.currentPosition = position;
    if (mode == 1) {
        mouse_position.pressPosition = position;
        mouse_position.currentPosition = position;
        xpos_prev = position.x();
        ypos_prev = position.y();
        //translationOnPressed =

    }
    if (mode == 2) {
        mouse_position.releasePosition = position;
        mouse_position.currentPosition = position;
    }

    //qDebug()<< position.y();
}

void KeyboardMovementController::setMouseScroll(QPoint scroll) {
    if (camera_moving_flag.mouseMiddle) {
        mouse_position.scrollClicked = scroll;
    }
    else {
        mouse_position.scroll = scroll;
    }
}

void KeyboardMovementController::moveButtonPressed(Qt::MouseButtons buttons) {
    setMouseFlagOff();
    if (buttons == camera_move_key.mouseLeft) camera_moving_flag.mouseLeft = true;
    if (buttons == camera_move_key.mouseRight) camera_moving_flag.mouseRight = true;
    if (buttons == camera_move_key.mouseMiddle) camera_moving_flag.mouseMiddle = true;


}

void KeyboardMovementController::moveButtonReleased(Qt::MouseButtons buttons) {
    setMouseFlagOff();
    if (buttons == camera_move_key.mouseLeft) camera_moving_flag.mouseLeft = true;
    if (buttons == camera_move_key.mouseRight) camera_moving_flag.mouseRight = true;
    if (buttons == camera_move_key.mouseMiddle) camera_moving_flag.mouseMiddle = true;
}

void KeyboardMovementController::toggleFilteredData(std::vector<LveGameObject>& gameObjects){
    if(!gameObjects.empty()) {
        std::shared_ptr<LayoutModel> model = std::static_pointer_cast<LayoutModel>(gameObjects[0].model);
        if(!model->t2d_ref.m_filter_onoff) model->isfilteredon = false;
        if (camera_moving_flag.toggleFiltered && gameObjects[0].model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT) {
            model->createFilteredLayout();
        };
    }
    camera_moving_flag.toggleFiltered = false;
}

glm::vec3 KeyboardMovementController::moveCamera(
        float dt, LveCamera& camera, float render_scale,
        std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow) {
    float scale = 0.0f;
    float rotate_lr = 0.0f;
    float rotate_ud = 0.0f;
    float rotate_toggle = 0.0f;
    float rotate_toggle_xy = 0.0f;
    float obj_scale = 2*render_scale;
    glm::vec3 moveDir{ 0.f };

    if (camera_moving_flag.moveForward) scale = 1.0f + 0.01f * obj_scale;
    else if (camera_moving_flag.moveBackward) scale = 1.0f - 0.01f * obj_scale;

    if (camera_moving_flag.rotateRight) rotate_lr = -0.1f * obj_scale;
    else if (camera_moving_flag.rotateLeft) rotate_lr = 0.1f * obj_scale;

    if (camera_moving_flag.rotateForward) rotate_ud = -0.1f * obj_scale;
    else if (camera_moving_flag.rotateBackward) rotate_ud = 0.1f * obj_scale;

    if (camera_moving_flag.toggleDemension && !camera.isperspective) {
        camera.setPerspectiveProjection(glm::radians(50.f), dt, 0.1f, 100.f);
        camera_moving_flag.toggleDemension = false;
    }
    else if (camera_moving_flag.toggleDemension)rotate_toggle = 0.1f;

    if (camera_moving_flag.toggleDemensionXY) rotate_toggle_xy = -0.1f;

    if(camera_moving_flag.clearLayout) {
        qDebug() << "delete start";
        gameObjects[0].~LveGameObject();
        gameObjects.erase(gameObjects.begin());
        camera_moving_flag.clearLayout = false;
    }
    right= glm::normalize(glm::vec3{camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0]});
    forward= glm::normalize(glm::vec3{camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2]});
    up= glm::normalize(glm::vec3{camera.viewMatrix[0][1], camera.viewMatrix[1][1], camera.viewMatrix[2][1]});

    glm::vec3 v{ glm::normalize(glm::cross(right,glm::vec3{0,0,1})) };


    if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon() && camera.isperspective) {
        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr), glm::vec3(0.0f, 0.0f, 1.0f));
    }

    if (glm::dot(rotate_ud, rotate_ud) > std::numeric_limits<float>::epsilon() && camera.isperspective) {
        if(glm::rotate(camera.getView(), glm::radians(rotate_ud*0.5f),right)[2][1] >= 0){
            camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_ud), right);
        }
    }

    if (glm::dot(scale, scale) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(scale, scale, scale));
    }

    camera.decomposeView(camera.getView());

    if (camera_moving_flag.moveRight) moveDir += right;
    if (camera_moving_flag.moveLeft)  moveDir -= right;
    if (camera_moving_flag.moveUp)  moveDir -= v;
    if (camera_moving_flag.moveDown)  moveDir += v;



    if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon()) {
        for (auto& gameobject : gameObjects) {
            if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
                gameobject.transform.translation += moveDir/(float)this->monitor.zoom/(float)lvewindow->swapChainImageSize().height()*obj_scale;
            }
        }
    }


    if (glm::dot(rotate_toggle, rotate_toggle) > std::numeric_limits<float>::epsilon()) {

        camera.decomposeView(camera.getView());
        camera.rotation_d = glm::conjugate(camera.rotation_d);

        // yaw / z
        double siny_cosp = 2 * (camera.rotation_d.w * camera.rotation_d.z + camera.rotation_d.x * camera.rotation_d.y);
        double cosy_cosp = 1 - 2 * (camera.rotation_d.y * camera.rotation_d.y + camera.rotation_d.z * camera.rotation_d.z);
        float rotation = (float)atan2(siny_cosp, cosy_cosp);
        float degree = rotation * (180 / 3.141592653589793238463);
        float tilt = asin(forward.z / (sqrt(forward.x * forward.x + forward.y * forward.y + forward.z * forward.z)));
        tilt = tilt * (180 / 3.141592653589793238463);

        if (!camera_moving_flag.toggleDemensionXY && camera_moving_flag.toggleDemension) {
            if (tilt > 89.5) {
                camera.decomposeView(camera.getView());
                camera.setViewTarget(glm::vec3(0.0f, 0.0f, 1.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));
                camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(camera.scale_d.x, camera.scale_d.x, camera.scale_d.x));
                camera_moving_flag.toggleDemension = false;
                float zero_plane_height = tan(glm::radians(25.f));
                camera.setOrthographicProjection(-1 * dt * zero_plane_height, 1 * dt * zero_plane_height, -1 * zero_plane_height, 1 * zero_plane_height, 0.1f, 100.f);

            }
            else {
                rotate_toggle = rotate_toggle * ((90 - tilt) / 2 + 1);
                camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle), right);
            }
        }


        if (camera_moving_flag.toggleDemensionXY) {
            if (up.z < 0) {
                if (180 - abs(degree) < 1) {
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(degree - 90), glm::vec3(0.0f, 0.0f, 1.0f));
                    camera_moving_flag.toggleDemensionXY = false;
                }
                else {
                    rotate_toggle_xy = rotate_toggle_xy * ((180 - abs(degree)) / 2 + 1) * (180 - abs(degree)) / (180 - abs(degree));
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle_xy), glm::vec3(0.0f, 0.0f, 1.0f));
                }
            }
            else {
                if (abs(degree) < 1) {
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(0 - abs(degree)), glm::vec3(0.0f, 0.0f, 1.0f));
                    camera_moving_flag.toggleDemensionXY = false;
                }
                else {
                    rotate_toggle_xy = rotate_toggle_xy * (abs(degree) / 2 + 1) * abs(degree) / abs(degree);
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle_xy), glm::vec3(0.0f, 0.0f, 1.0f));
                }
            }
        }

    }

    return moveDir;
}

glm::vec3 KeyboardMovementController::moveCameraMouse(
        LveCamera& camera, float render_scale,
        std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow) {

    glm::vec3 moveDir{ 0.f };

    if (camera_moving_flag.mouseRight && camera.isperspective)
    {

        float rotate_lr = 0.0f;
        float rotate_ud = 0.0f;

        rotate_lr = mouse_position.currentPosition.x() - xpos_prev;
        rotate_ud = mouse_position.currentPosition.y() - ypos_prev;

        //glm::vec3 direction{ camera.viewMatrix[0][2], camera.viewMatrix[1][2], 0 };

        right={camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0]};

        if (glm::dot(rotate_ud, rotate_ud) > std::numeric_limits<float>::epsilon()) {
            if (glm::rotate(camera.getView(), glm::radians(rotate_ud * 0.1f), right)[2][1] >= 0) {
                camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_ud * 0.1f), right);
            }
        }

        if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
            camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr * 0.1f), glm::vec3(0.0f, 0.0f, 1.0f));
        }

        xpos_prev = mouse_position.currentPosition.x();
        ypos_prev = mouse_position.currentPosition.y();
    }
    else if (camera_moving_flag.mouseLeft )
    {
        float obj_scale = render_scale;

        float movement_lr = mouse_position.currentPosition.x() - xpos_prev;
        float movement_ud = mouse_position.currentPosition.y() - ypos_prev;

        right = glm::normalize(glm::vec3{camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0]});
        forward={ glm::normalize(glm::cross(right,glm::vec3{0,0,1})) };

        moveDir += right * (movement_lr);
        moveDir += forward * (movement_ud);

        if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon()) {
            for (auto& gameobject : gameObjects) {
                if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
                    gameobject.transform.translation +=  moveDir/(float)this->monitor.zoom/(float)lvewindow->swapChainImageSize().height()*obj_scale ;
                    //camera.viewMatrix = glm::translate(camera.getView(), moveSpeed * dt * moveDir);
                }
            }
        }

        xpos_prev = mouse_position.currentPosition.x();
        ypos_prev = mouse_position.currentPosition.y();
    }

    if (mouse_position.scroll.y() != 0) {
        float scale_mouse;// = 1.0f + 0.1f * (mouse_position.scroll.y() / 120);
        if(mouse_position.scroll.y()>0){
            scale_mouse = 1.0f + 0.1f;
        } else {
            scale_mouse = 1.0f - 0.1f;
        }

        camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(scale_mouse, scale_mouse, scale_mouse));
        mouse_position.scroll.setY(0);
    }

    return moveDir;

}

void KeyboardMovementController::setPerspective(LveCamera& camera, float aspect) {
    if (mouse_position.scrollClicked.y() > 0) {
        if (perspectiveNear + 0.01 > 100.f) {
            perspectiveNear = 100.f;

        }
        else {
            perspectiveNear = perspectiveNear + 0.01;
        }
    }
    else if (mouse_position.scrollClicked.y() < 0) {
        if (perspectiveNear - 0.01 < 0.1f) {
            perspectiveNear = 0.1f;

        }
        else { perspectiveNear = perspectiveNear - 0.01; }
    }
    camera.setPerspectiveProjection(glm::radians(50.f), aspect, perspectiveNear, 100.f);
    mouse_position.scrollClicked.setY(0);
}

void KeyboardMovementController::PEXSetting(std::shared_ptr<PEXResistorModel>& _pexResistorModel, Qt::Key key) {
    if (key == model_visible_set.resistor_up_key) {
        _pexResistorModel->increaseNumOfResistorGroup();

        model_visible_set.resistor_up_key_pressed = false;
    }
    else if (key == model_visible_set.resistor_down_key) {
        std::cout << "gogogogogogogog" << std::endl;
        _pexResistorModel->decreaseNumOfResistorGroup();        

        model_visible_set.resistor_down_key_pressed = false;
    }
    else if (key == model_visible_set.resistor_horizontal_key) {
        _pexResistorModel->makeDirectionRenderingData(
                    RES_DIRECTION_HORIZONTAL);

        model_visible_set.resistor_horizontal_key_pressed = false;
    }
    else if (key == model_visible_set.resistor_vertical_key) {
        _pexResistorModel->makeDirectionRenderingData(
                    RES_DIRECTION_VERTICAL);

        model_visible_set.resistor_vertical_key_pressed = false;
    }
}


void KeyboardMovementController::triggerDemo() {
    camera_moving_flag.demoTrigger = true;
};

void KeyboardMovementController::onDemo(
        float dt,
        LveCamera &camera,
        float render_scale,
        std::vector<LveGameObject> &gameObjects,
        LveWindow *lvewindow){
    (void)lvewindow;
    if (camera_moving_flag.demoTrigger){
        float rotate_lr = 0.0f;
        float rotate_ud = 0.0f;
        (void)rotate_ud;
        float rotate_toggle = 0.0f;
        float rotate_toggle_xy = 0.0f;
        (void)rotate_toggle_xy;
        float obj_scale = 2.0f / render_scale;
        demoTime = demoTime + 1;


        //if (camera_moving_flag.moveForward) scale = 1.0f + 0.01f * obj_scale;
        //else if (camera_moving_flag.moveBackward) scale = 1.0f - 0.01f * obj_scale;
        if (!camera_moving_flag.demoInitLayer) {
            gameObjects[0].model->demoVisiblityOff();
            camera_moving_flag.demoInitLayer = true;
        }

        rotate_lr = 1.6f * obj_scale;

        glm::vec3 forward = { camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2] };
        float tilt = asin(forward.z / (sqrt(forward.x * forward.x + forward.y * forward.y + forward.z * forward.z))) * (180 / 3.141592653589793238463);
        camera.decomposeView(camera.getView());
        camera.rotation_d = glm::conjugate(camera.rotation_d);
        // yaw / z
        double siny_cosp = 2 * (camera.rotation_d.w * camera.rotation_d.z + camera.rotation_d.x * camera.rotation_d.y);
        double cosy_cosp = 1 - 2 * (camera.rotation_d.y * camera.rotation_d.y + camera.rotation_d.z * camera.rotation_d.z);
        float rotation = (float)atan2(siny_cosp, cosy_cosp) * (180 / 3.141592653589793238463);

        if (rotation < 0) {
            rotation = rotation + 360;
        }

        if (rotation > 350 && !camera_moving_flag.layerOn) {
            camera_moving_flag.tiltOn = true;

        }

        if (camera_moving_flag.tiltOn) {
            rotate_toggle = -0.1f;
            glm::vec3 right{ camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0] };
            camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle), right);
            if (tilt < 30) {
                camera_moving_flag.tiltOn = false;
                camera_moving_flag.layerOn = true;
            }
        }

        if (camera_moving_flag.layerOn && !camera_moving_flag.wave1) {
            demoCheckPoint = demoTime;
            std::vector<string> on_layer = { "2","7","15" };
            gameObjects[0].model->demoVisiblityOn(on_layer);
            camera_moving_flag.wave1 = true;
        }

        if (demoCheckPoint < demoTime - 50 && !camera_moving_flag.wave2 && camera_moving_flag.wave1) {
            demoCheckPoint = demoTime;
            std::vector<string> on_layer = { "177","16","17" };
            gameObjects[0].model->demoVisiblityOn(on_layer);
            camera_moving_flag.wave2 = true;
        }

        if (demoCheckPoint < demoTime - 50 && !camera_moving_flag.wave3 && camera_moving_flag.wave2) {
            demoCheckPoint = demoTime;
            std::vector<string> on_layer = { "714","19","18","17","16","15","686","685","245","72914","502","247" };
            gameObjects[0].model->demoVisiblityOn(on_layer);
            camera_moving_flag.wave3 = true;
        }

        if (demoCheckPoint < demoTime - 5000 && camera_moving_flag.wave2) {
            camera_moving_flag.demoTrigger = false;
            camera_moving_flag.demoInitLayer = false;
            camera_moving_flag.tiltOn = false;
            camera_moving_flag.layerOn = false;
            camera_moving_flag.wave1 = false;
            camera_moving_flag.wave2 = false;
            camera_moving_flag.wave3 = false;

        }


        if (camera_moving_flag.rotateForward) rotate_ud = -0.1f * obj_scale;
        else if (camera_moving_flag.rotateBackward) rotate_ud = 0.1f * obj_scale;

        if (camera_moving_flag.toggleDemension && !camera.isperspective) {
            camera.setPerspectiveProjection(glm::radians(50.f), dt, 0.1f, 100.f);
            camera_moving_flag.toggleDemension = false;
        }
        else if (camera_moving_flag.toggleDemension)rotate_toggle = 0.1f;

        if (camera_moving_flag.toggleDemensionXY) rotate_toggle_xy = -0.1f;

        if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
            camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr), glm::vec3(0.0f, 0.0f, 1.0f));
        }

    }

}



!@hash[]!@file[]./Rendering/Src/lve_camera.cpp!@hash[]!@code[]#include "lve_camera.hpp"

// std
#include <cassert>
#include <limits>
#include <glm/glm.hpp> //vec3, vec4, ivec4, mat4
#include <glm/gtc/matrix_transform.hpp> //translate, rotate, scale, perspective 
#include <glm/gtc/type_ptr.hpp> //value_ptr


void LveCamera::setOrthographicProjection(
    float left, float right, float top, float bottom, float near, float far) {
  projectionMatrix = glm::ortho(left,right,top,bottom,near,far);
  isperspective = false;
}

void LveCamera::setPerspectiveProjection(float fovy, float aspect, float near, float far) {
    projectionMatrix = glm::perspective(fovy, aspect, near, far);
    isperspective = true;
    //  assert(glm::abs(aspect - std::numeric_limits<float>::epsilon()) > 0.0f);
    //  const float tanHalfFovy = tan(fovy / 2.f);
    //  projectionMatrix = glm::mat4{0.0f};
    //  projectionMatrix[0][0] = 1.f / (aspect * tanHalfFovy);
    //  projectionMatrix[1][1] = 1.f / (tanHalfFovy);
    //  projectionMatrix[2][2] = far / (far - near);
    //  projectionMatrix[2][3] = 1.f;
    //  projectionMatrix[3][2] = -(far * near) / (far - near);
}

void LveCamera::setViewYXZ(glm::vec3 position, glm::vec3 rotation) {
    const float c3 = glm::cos(rotation.z);
    const float s3 = glm::sin(rotation.z);
    const float c2 = glm::cos(rotation.x);
    const float s2 = glm::sin(rotation.x);
    const float c1 = glm::cos(rotation.y);
    const float s1 = glm::sin(rotation.y);
    const glm::vec3 u{ (c1 * c3 + s1 * s2 * s3), (c2 * s3), (c1 * s2 * s3 - c3 * s1) };
    const glm::vec3 v{ (c3 * s1 * s2 - c1 * s3), (c2 * c3), (c1 * c3 * s2 + s1 * s3) };
    const glm::vec3 w{ (c2 * s1), (-s2), (c1 * c2) };
    viewMatrix = glm::mat4{ 1.f };
    viewMatrix[0][0] = u.x;
    viewMatrix[1][0] = u.y;
    viewMatrix[2][0] = u.z;
    viewMatrix[0][1] = v.x;
    viewMatrix[1][1] = v.y;
    viewMatrix[2][1] = v.z;
    viewMatrix[0][2] = w.x;
    viewMatrix[1][2] = w.y;
    viewMatrix[2][2] = w.z;
    viewMatrix[3][0] = -glm::dot(u, position);
    viewMatrix[3][1] = -glm::dot(v, position);
    viewMatrix[3][2] = -glm::dot(w, position);
}

void LveCamera::setViewDirection(glm::vec3 position, glm::vec3 direction, glm::vec3 up) {
  const glm::vec3 w{glm::normalize(direction)};
  const glm::vec3 u{glm::normalize(glm::cross(w, up))};
  const glm::vec3 v{glm::cross(w, u)};

  viewMatrix = glm::mat4{1.f};
  viewMatrix[0][0] = u.x;
  viewMatrix[1][0] = u.y;
  viewMatrix[2][0] = u.z;
  viewMatrix[0][1] = v.x;
  viewMatrix[1][1] = v.y;
  viewMatrix[2][1] = v.z;
  viewMatrix[0][2] = w.x;
  viewMatrix[1][2] = w.y;
  viewMatrix[2][2] = w.z;
  viewMatrix[3][0] = -glm::dot(u, position);
  viewMatrix[3][1] = -glm::dot(v, position);
  viewMatrix[3][2] = -glm::dot(w, position);
}

void LveCamera::setViewTarget(glm::vec3 position, glm::vec3 target, glm::vec3 up) {
    viewMatrix = glm::lookAt(position, target, up);
    //setViewDirection(position, target - position, up);
}

void LveCamera::decomposeView(glm::mat4 viewMat) {
    glm::decompose(viewMat, scale_d, rotation_d, translation_d, skew_d, perspective_d);
    rotation_d = glm::conjugate(rotation_d);
}

!@hash[]!@file[]./Rendering/Src/lve_device.cpp!@hash[]!@code[]
#include <vulkan/vulkan.h>
#include "lve_device.hpp"



// std headers
#include <cstring>
#include <iostream>
#include <set>
#include <unordered_set>


// class member functions
LveDevice::LveDevice(LveWindow* window_, QVulkanInstance* qvk_instance_)
    : window(window_), qvk_instance(qvk_instance_) {
    qDebug() << "\n$$$$$ LveDevice()";
    createInstance();
    //setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createCommandPool();
}


LveDevice::~LveDevice() {
    qDebug() << "\n$$$$$ ~LveDevice()";
    vkDestroyCommandPool(device_, commandPool, nullptr);
}

void LveDevice::createInstance() {
    this->instance = this->qvk_instance->vkInstance();
}

void LveDevice::pickPhysicalDevice() {
    uint32_t deviceCount = 0;
    vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr);
    if (deviceCount == 0) {
        throw std::runtime_error("failed to find GPUs with Vulkan support!");
    }

    std::vector<VkPhysicalDevice> devices(deviceCount);
    vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data());

    for (const auto &device : devices) {
        VkPhysicalDeviceProperties prop_temp;
        vkGetPhysicalDeviceProperties(device, &prop_temp);

        if (isDeviceSuitable(device)) {
            physicalDevice = device;
            break;
        }
    }

    if (physicalDevice == VK_NULL_HANDLE) {
        throw std::runtime_error("failed to find a suitable GPU!");
    }

    vkGetPhysicalDeviceProperties(physicalDevice, &properties);
}

void LveDevice::createLogicalDevice() {

    QueueFamilyIndices indices = findQueueFamilies(physicalDevice);
    device_ = this->window->device();
    vkGetDeviceQueue(device_, indices.graphicsFamily, 0, &graphicsQueue_);
    vkGetDeviceQueue(device_, indices.presentFamily, 0, &presentQueue_);
}

void LveDevice::createCommandPool() {
    QueueFamilyIndices queueFamilyIndices = findPhysicalQueueFamilies();

    VkCommandPoolCreateInfo poolInfo = {};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily;
    poolInfo.flags =
            VK_COMMAND_POOL_CREATE_TRANSIENT_BIT | VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;

    if (vkCreateCommandPool(device_, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
        throw std::runtime_error("failed to create command pool!");
    }
}


void LveDevice::createSurface() {
    this->surface_ = this->qvk_instance->surfaceForWindow(this->window);
}


bool LveDevice::isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    bool extensionsSupported = checkDeviceExtensionSupport(device);

    bool swapChainAdequate = false;
    if (extensionsSupported) {
        SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);
        swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty();
    }

    VkPhysicalDeviceFeatures supportedFeatures;
    vkGetPhysicalDeviceFeatures(device, &supportedFeatures);

    return indices.isComplete() && extensionsSupported && swapChainAdequate &&
            supportedFeatures.samplerAnisotropy;
}



bool LveDevice::checkValidationLayerSupport() {
    uint32_t layerCount;
    vkEnumerateInstanceLayerProperties(&layerCount, nullptr);

    std::vector<VkLayerProperties> availableLayers(layerCount);
    vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data());

    for (const char *layerName : validationLayers) {
        bool layerFound = false;

        for (const auto &layerProperties : availableLayers) {
            if (strcmp(layerName, layerProperties.layerName) == 0) {
                layerFound = true;
                break;
            }
        }

        if (!layerFound) {
            return false;
        }
    }

    return true;
}


std::vector<const char *> LveDevice::getRequiredExtensions() {

    std::vector<const char *> extensions{};

    //auto supported_extensions = QVulkanInstance::supportedExtensions();
    //for(auto & cur_ext : supported_extensions){
    //    extensions.push_back(cur_ext.name.data());
    //}

    extensions.push_back("VK_KHR_surface");
    extensions.push_back("VK_KHR_win32_surface");
    //extensions.push_back(VK_KHR_SURFACE_EXTENSION_NAME);
    if (enableValidationLayers) {
        extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
    }

    return extensions;
}


void LveDevice::hasRequiredInstanceExtensions() {
    uint32_t extensionCount = 0;
    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr);
    std::vector<VkExtensionProperties> extensions(extensionCount);
    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data());


    qDebug() << "available extensions:";
    std::unordered_set<std::string> available;
    for (const auto &extension : extensions) {
        qDebug() << "\t" << extension.extensionName;
        available.insert(extension.extensionName);
    }

    qDebug() << "required extensions:";
    auto requiredExtensions = getRequiredExtensions();
    for (const auto &required : requiredExtensions) {
        qDebug() << "\t" << required;
        if (available.find(required) == available.end()) {
            throw std::runtime_error("Missing required glfw extension");
        }
    }
}


bool LveDevice::checkDeviceExtensionSupport(VkPhysicalDevice device) {
    uint32_t extensionCount;
    vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);

    std::vector<VkExtensionProperties> availableExtensions(extensionCount);
    vkEnumerateDeviceExtensionProperties(
                device,
                nullptr,
                &extensionCount,
                availableExtensions.data());

    std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());

    for (const auto &extension : availableExtensions) {
        requiredExtensions.erase(extension.extensionName);
    }

    return requiredExtensions.empty();
}


QueueFamilyIndices LveDevice::findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;

    uint32_t queueFamilyCount = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);

    std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());

    int i = 0;
    for (const auto &queueFamily : queueFamilies) {
        if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
            indices.graphicsFamily = i;
            indices.graphicsFamilyHasValue = true;
        }
        VkBool32 presentSupport = false;
        vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface_, &presentSupport);
        if (queueFamily.queueCount > 0 && presentSupport) {
            indices.presentFamily = i;
            indices.presentFamilyHasValue = true;
        }
        if (indices.isComplete()) {
            break;
        }

        i++;
    }

    return indices;
}

SwapChainSupportDetails LveDevice::querySwapChainSupport(VkPhysicalDevice device) {
    SwapChainSupportDetails details;
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface_, &details.capabilities);

    uint32_t formatCount;
    vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface_, &formatCount, nullptr);

    if (formatCount != 0) {
        details.formats.resize(formatCount);
        vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface_, &formatCount, details.formats.data());
    }

    uint32_t presentModeCount;
    vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface_, &presentModeCount, nullptr);

    if (presentModeCount != 0) {
        details.presentModes.resize(presentModeCount);
        vkGetPhysicalDeviceSurfacePresentModesKHR(
                    device,
                    surface_,
                    &presentModeCount,
                    details.presentModes.data());
    }
    return details;
}

VkFormat LveDevice::findSupportedFormat(
        const std::vector<VkFormat> &candidates, VkImageTiling tiling, VkFormatFeatureFlags features) {
    for (VkFormat format : candidates) {
        VkFormatProperties props;
        vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &props);

        if (tiling == VK_IMAGE_TILING_LINEAR && (props.linearTilingFeatures & features) == features) {
            return format;
        } else if (
                   tiling == VK_IMAGE_TILING_OPTIMAL && (props.optimalTilingFeatures & features) == features) {
            return format;
        }
    }
    throw std::runtime_error("failed to find supported format!");
}

uint32_t LveDevice::findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {
    VkPhysicalDeviceMemoryProperties memProperties;
    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);
    for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
        if ((typeFilter & (1 << i)) &&
                (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
            return i;
        }
    }

    throw std::runtime_error("failed to find suitable memory type!");
}

void LveDevice::createBuffer(
        VkDeviceSize size,
        VkBufferUsageFlags usage,
        VkMemoryPropertyFlags properties,
        VkBuffer &buffer,
        VkDeviceMemory &bufferMemory) {
    VkBufferCreateInfo bufferInfo{};
    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    bufferInfo.size = size;
    bufferInfo.usage = usage;
    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    if (vkCreateBuffer(device_, &bufferInfo, nullptr, &buffer) != VK_SUCCESS) {
        throw std::runtime_error("failed to create buffer!");
    }

    VkMemoryRequirements memRequirements;
    vkGetBufferMemoryRequirements(device_, buffer, &memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(device_, &allocInfo, nullptr, &bufferMemory) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate vertex buffer memory!");
    }

    vkBindBufferMemory(device_, buffer, bufferMemory, 0);
}

VkCommandBuffer LveDevice::beginSingleTimeCommands() {
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandPool = commandPool;
    allocInfo.commandBufferCount = 1;

    VkCommandBuffer commandBuffer;
    vkAllocateCommandBuffers(device_, &allocInfo, &commandBuffer);

    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

    vkBeginCommandBuffer(commandBuffer, &beginInfo);
    return commandBuffer;
}

void LveDevice::endSingleTimeCommands(VkCommandBuffer commandBuffer) {
    vkEndCommandBuffer(commandBuffer);

    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &commandBuffer;

    vkQueueSubmit(graphicsQueue_, 1, &submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(graphicsQueue_);

    vkFreeCommandBuffers(device_, commandPool, 1, &commandBuffer);
}

void LveDevice::copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkBufferCopy copyRegion{};
    copyRegion.srcOffset = 0;  // Optional
    copyRegion.dstOffset = 0;  // Optional
    copyRegion.size = size;
    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);

    endSingleTimeCommands(commandBuffer);
}

void LveDevice::copyBufferToImage(
        VkBuffer buffer, VkImage image, uint32_t width, uint32_t height, uint32_t layerCount) {
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkBufferImageCopy region{};
    region.bufferOffset = 0;
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;

    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = layerCount;

    region.imageOffset = {0, 0, 0};
    region.imageExtent = {width, height, 1};

    vkCmdCopyBufferToImage(
                commandBuffer,
                buffer,
                image,
                VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                1,
                &region);
    endSingleTimeCommands(commandBuffer);
}

void LveDevice::createImageWithInfo(
        const VkImageCreateInfo &imageInfo,
        VkMemoryPropertyFlags properties,
        VkImage &image,
        VkDeviceMemory &imageMemory) {
    if (vkCreateImage(device_, &imageInfo, nullptr, &image) != VK_SUCCESS) {
        throw std::runtime_error("failed to create image!");
    }

    VkMemoryRequirements memRequirements;
    vkGetImageMemoryRequirements(device_, image, &memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(device_, &allocInfo, nullptr, &imageMemory) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate image memory!");
    }

    if (vkBindImageMemory(device_, image, imageMemory, 0) != VK_SUCCESS) {
        throw std::runtime_error("failed to bind image memory!");
    }
}

!@hash[]!@file[]./Rendering/Src/lve_model.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>

#include "lve_model.hpp"
#include "rapidcsv.h"

// std
#include <cassert>
#include <cstring>

using namespace std;

inline float coord_normalize(float in_value, float move, float scale) {
    //return 2 * (in_value - min_value) / (max_value - min_value) - 1.0f;
    return (2 * (in_value - move) / (scale)-1.0f);
}



LveModel::LveModel(LveDevice& device, MODEL_TYPE type)
    : lveDevice{ device }, model_type(type) {
    if (type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        makeAxisData();
        createBuffers();
    }

    //createBuffers();
}

LveModel::~LveModel() {
    destroyBuffers();

    this->cube_infos.clear();
    this->cube_vertices.clear();
    this->vertices.clear();
    this->indices_face.clear();
    this->indices_edge.clear();

}

void LveModel::createBuffers() {
    if (this->model_type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        createVertexBuffers(vertices, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) {
        createVertexBuffers(vertices_resistor, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_face, this->indexBufferForFace, this->indexBufferMemoryForFace);
        createIndexBuffers(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) {
        createVertexBuffers(vertices_capacitor, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_face, this->indexBufferForFace, this->indexBufferMemoryForFace);
        createIndexBuffers(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
    }
}

void LveModel::destroyBuffers() {
    if (this->model_type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForFace, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForFace, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForFace, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForFace, nullptr);

        vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }
    this->cube_infos.clear();
    this->cube_vertices.clear();
    this->vertices.clear();
    this->vertices_resistor.clear();
    this->indices_face.clear();
    this->indices_edge.clear();

}

template <typename T>
void LveModel::createVertexBuffers(
    const std::vector<T>& vertices,
    VkBuffer& buffer,
    VkDeviceMemory& memory) {
    vertexCount = static_cast<uint32_t>(vertices.size());
    assert(vertexCount >= 3 && "Vertex count must be at least 3");
    VkDeviceSize bufferSize = sizeof(vertices[0]) * vertexCount;

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
        bufferSize,
        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
        stagingBuffer,
        stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, vertices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
        bufferSize,
        VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
        buffer,
        memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}

void LveModel::createIndexBuffers(
    const std::vector<uint32_t>& indices,
    VkBuffer& buffer,
    VkDeviceMemory& memory) {
    assert(!indices.empty() && "Index size can't be zero");
    VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
        bufferSize,
        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
        stagingBuffer,
        stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, indices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
        bufferSize,
        VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
        buffer,
        memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}

void LveModel::drawForFace(VkCommandBuffer commandBuffer) {
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_face.size()), 1, 0, 0, 0);
}

void LveModel::drawForEdge(VkCommandBuffer commandBuffer) {
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_edge.size()), 1, 0, 0, 0);
}

void LveModel::bindVertexBuffer(VkCommandBuffer commandBuffer) {
    VkBuffer buffers[] = { vertexBuffer };
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
}

//void LveModel::bindDrawVertexIndexBufferForFace_layer(VkCommandBuffer commandBuffer, const string layer) {
//    VkBuffer buffers[] = { layerbyVertexBuffers[layer] };
//    VkDeviceSize offsets[] = { 0 };
//    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
//    vkCmdBindIndexBuffer(commandBuffer, layerbyFaceIndexBuffers[layer], 0, VK_INDEX_TYPE_UINT32);
//    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_face[layer].size()), 1, 0, 0, 0);
//}
//
//void LveModel::bindDrawIndexBufferForEdge_layer(VkCommandBuffer commandBuffer, const string layer) {
//    vkCmdBindIndexBuffer(commandBuffer, layerbyEdgeIndexBuffers[layer], 0, VK_INDEX_TYPE_UINT32);
//    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_edge[layer].size()), 1, 0, 0, 0);
//}



void LveModel::bindIndexBufferForFace(VkCommandBuffer commandBuffer) {
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForFace, 0, VK_INDEX_TYPE_UINT32);
}

void LveModel::bindIndexBufferForEdge(VkCommandBuffer commandBuffer) {
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForEdge, 0, VK_INDEX_TYPE_UINT32);
}


std::vector<VkVertexInputBindingDescription> LveModel::Vertex::getBindingDescriptions() {
    std::vector<VkVertexInputBindingDescription> bindingDescriptions(1);
    bindingDescriptions[0].binding = 0;
    bindingDescriptions[0].stride = sizeof(Vertex);
    bindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    return bindingDescriptions;
}

std::vector<VkVertexInputAttributeDescription> LveModel::Vertex::getAttributeDescriptions() {
    std::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);
    attributeDescriptions[0].binding = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset = offsetof(Vertex, position);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(Vertex, color);
    return attributeDescriptions;
}

std::vector<VkVertexInputBindingDescription> LveModel::VertexResistor::getBindingDescriptions() {
    std::vector<VkVertexInputBindingDescription> bindingDescriptions(1);
    bindingDescriptions[0].binding = 0;
    bindingDescriptions[0].stride = sizeof(VertexResistor);
    bindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    return bindingDescriptions;
}

std::vector<VkVertexInputAttributeDescription> LveModel::VertexResistor::getAttributeDescriptions() {
    std::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);
    attributeDescriptions[0].binding = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset = offsetof(VertexResistor, position);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(VertexResistor, color);
    return attributeDescriptions;
}

std::vector<VkVertexInputBindingDescription> LveModel::VertexCapacitor::getBindingDescriptions() {
    std::vector<VkVertexInputBindingDescription> bindingDescriptions(1);
    bindingDescriptions[0].binding = 0;
    bindingDescriptions[0].stride = sizeof(VertexCapacitor);
    bindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    return bindingDescriptions;
}

std::vector<VkVertexInputAttributeDescription> LveModel::VertexCapacitor::getAttributeDescriptions() {
    std::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);
    attributeDescriptions[0].binding = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset = offsetof(VertexCapacitor, position);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(VertexCapacitor, color);
    return attributeDescriptions;
}




void LveModel::makeAxisData(const float axis_length) {
    this->vertices.clear();
    this->vertices = {
        { { -axis_length, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f } },
        { {  axis_length, 0.0f, 0.0f }, { 1.0f, 0.0f, 0.0f } },
        { { 0.0f, -axis_length, 0.0f }, { 1.0f, 1.0f, 1.0f } },
        { { 0.0f,  axis_length, 0.0f }, { 0.0f, 1.0f, 0.0f } },
        { { 0.0f, 0.0f, -axis_length }, { 1.0f, 1.0f, 1.0f } },
        { { 0.0f, 0.0f,  axis_length }, { 0.0f, 0.0f, 1.0f } }
    };

    vector<uint32_t>& indices = this->indices_edge;
    indices.clear();
    indices.push_back(0);
    indices.push_back(1);
    indices.push_back(2);
    indices.push_back(3);
    indices.push_back(4);
    indices.push_back(5);
}

void LveModel::updateOpacity(float amount) {
    this->opacity += amount;
    if (this->opacity > 1.0f) this->opacity = 1.0f;
    if (this->opacity < 0.0f) this->opacity = 0.0f;
}

std::map<string, LveModel::LayerProperty> LveModel::getLayer() {
    return layerList;
}

void LveModel::changeLayerColor(string layernumber, glm::vec3 rgb) {
    if (layerList.count(layernumber) != 0) {
        layerList[layernumber].color = rgb;
    }

}

void LveModel::changeLayerOpacity(string layernumber, float opacity) {
    if (layerList.count(layernumber) != 0) {
        layerList[layernumber].opacity = opacity;
    }

}

void LveModel::changeLayerVisiblity(string layernumber, bool visiblity) {
    //qDebug() << QString::fromStdString(layernumber) ;

    if (layerList.count(layernumber) != 0) {
        layerList[layernumber].visiblity = visiblity;
    }

}

void LveModel::demoVisiblityOff() {
    //for (auto const& [key, val] : layerList) {
    //    layerList[key].visiblity = false;
    //}
    for(auto& data : layerList){
        layerList[data.first].visiblity = false;
    }
    layerList["4"].visiblity = true;

}

void LveModel::demoVisiblityOn(std::vector<string> layernumbers) {
    for (auto layer : layernumbers) {
        layerList[layer].visiblity = true;
    }
}

!@hash[]!@file[]./Rendering/Src/lve_pipeline.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>

#include "lve_pipeline.hpp"
#include "lve_model.hpp"

// std
#include <cassert>
#include <fstream>
#include <iostream>
#include <stdexcept>



LvePipeline::LvePipeline(
        LveDevice& device,
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo,
    const std::vector<VkVertexInputBindingDescription> bindingDescription_,
    const  std::vector<VkVertexInputAttributeDescription> attributeDescription_
)
    : lveDevice{device} {
    createGraphicsPipeline(vertFilepath, fragFilepath, configInfo, bindingDescription_,attributeDescription_);
}

LvePipeline::~LvePipeline() {
    vkDestroyShaderModule(lveDevice.device(), vertShaderModule, nullptr);
    vkDestroyShaderModule(lveDevice.device(), fragShaderModule, nullptr);
    vkDestroyPipeline(lveDevice.device(), graphicsPipeline, nullptr);
}

std::vector<char> LvePipeline::readFile(const std::string& filepath) {
    std::ifstream file{filepath, std::ios::ate | std::ios::binary};

    if (!file.is_open()) {
        throw std::runtime_error("failed to open file: " + filepath);
    }

    size_t fileSize = static_cast<size_t>(file.tellg());
    std::vector<char> buffer(fileSize);

    file.seekg(0);
    file.read(buffer.data(), fileSize);

    file.close();
    return buffer;
}

void LvePipeline::createGraphicsPipeline(
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo,
    const std::vector<VkVertexInputBindingDescription> bindingDescription_,
    const  std::vector<VkVertexInputAttributeDescription> attributeDescription_
    ) {
    assert(
                configInfo.pipelineLayout != VK_NULL_HANDLE &&
            "Cannot create graphics pipeline: no pipelineLayout provided in configInfo");
    assert(
                configInfo.renderPass != VK_NULL_HANDLE &&
            "Cannot create graphics pipeline: no renderPass provided in configInfo");

    auto vertCode = readFile(vertFilepath);
    auto fragCode = readFile(fragFilepath);

    createShaderModule(vertCode, &vertShaderModule);
    createShaderModule(fragCode, &fragShaderModule);

    VkPipelineShaderStageCreateInfo shaderStages[2];
    shaderStages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    shaderStages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
    shaderStages[0].module = vertShaderModule;
    shaderStages[0].pName = "main";
    shaderStages[0].flags = 0;
    shaderStages[0].pNext = nullptr;
    shaderStages[0].pSpecializationInfo = nullptr;
    shaderStages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    shaderStages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    shaderStages[1].module = fragShaderModule;
    shaderStages[1].pName = "main";
    shaderStages[1].flags = 0;
    shaderStages[1].pNext = nullptr;
    shaderStages[1].pSpecializationInfo = nullptr;

    auto bindingDescriptions = bindingDescription_;
    auto attributeDescriptions = attributeDescription_;
    VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.vertexAttributeDescriptionCount =
            static_cast<uint32_t>(attributeDescriptions.size());
    vertexInputInfo.vertexBindingDescriptionCount = static_cast<uint32_t>(bindingDescriptions.size());
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data();
    vertexInputInfo.pVertexBindingDescriptions = bindingDescriptions.data();

    VkGraphicsPipelineCreateInfo pipelineInfo{};
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &configInfo.inputAssemblyInfo;
    pipelineInfo.pViewportState = &configInfo.viewportInfo;
    pipelineInfo.pRasterizationState = &configInfo.rasterizationInfo;
    pipelineInfo.pMultisampleState = &configInfo.multisampleInfo;
    pipelineInfo.pColorBlendState = &configInfo.colorBlendInfo;
    pipelineInfo.pDepthStencilState = &configInfo.depthStencilInfo;
    pipelineInfo.pDynamicState = &configInfo.dynamicStateInfo;

    pipelineInfo.layout = configInfo.pipelineLayout;
    pipelineInfo.renderPass = configInfo.renderPass;
    pipelineInfo.subpass = configInfo.subpass;

    pipelineInfo.basePipelineIndex = -1;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(
                lveDevice.device(),
                VK_NULL_HANDLE,
                1,
                &pipelineInfo,
                nullptr,
                &graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline");
    }
}

void LvePipeline::createShaderModule(const std::vector<char>& code, VkShaderModule* shaderModule) {
    VkShaderModuleCreateInfo createInfo{};
    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    createInfo.codeSize = code.size();
    createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data());

    if (vkCreateShaderModule(lveDevice.device(), &createInfo, nullptr, shaderModule) != VK_SUCCESS) {
        throw std::runtime_error("failed to create shader module");
    }
}

void LvePipeline::bind(VkCommandBuffer commandBuffer) {
    vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
}

void LvePipeline::defaultPipelineConfigInfo(PipelineConfigInfo& configInfo) {
    configInfo.inputAssemblyInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    configInfo.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    configInfo.inputAssemblyInfo.primitiveRestartEnable = VK_FALSE;

    configInfo.viewportInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    configInfo.viewportInfo.viewportCount = 1;
    configInfo.viewportInfo.pViewports = nullptr;
    configInfo.viewportInfo.scissorCount = 1;
    configInfo.viewportInfo.pScissors = nullptr;

    configInfo.rasterizationInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    configInfo.rasterizationInfo.depthClampEnable = VK_FALSE;
    configInfo.rasterizationInfo.rasterizerDiscardEnable = VK_FALSE;
    configInfo.rasterizationInfo.polygonMode = VK_POLYGON_MODE_FILL;
    configInfo.rasterizationInfo.lineWidth = 1.0f;
    configInfo.rasterizationInfo.cullMode = VK_CULL_MODE_NONE;
    configInfo.rasterizationInfo.frontFace = VK_FRONT_FACE_CLOCKWISE;
    configInfo.rasterizationInfo.depthBiasEnable = VK_FALSE;
    configInfo.rasterizationInfo.depthBiasConstantFactor = 0.0f;  // Optional
    configInfo.rasterizationInfo.depthBiasClamp = 0.0f;           // Optional
    configInfo.rasterizationInfo.depthBiasSlopeFactor = 0.0f;     // Optional

    configInfo.multisampleInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    configInfo.multisampleInfo.sampleShadingEnable = VK_FALSE;
    configInfo.multisampleInfo.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
    configInfo.multisampleInfo.minSampleShading = 1.0f;           // Optional
    configInfo.multisampleInfo.pSampleMask = nullptr;             // Optional
    configInfo.multisampleInfo.alphaToCoverageEnable = VK_FALSE;  // Optional
    configInfo.multisampleInfo.alphaToOneEnable = VK_FALSE;       // Optional

    configInfo.colorBlendAttachment.colorWriteMask =
            VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT |
            VK_COLOR_COMPONENT_A_BIT;
    configInfo.colorBlendAttachment.blendEnable = VK_FALSE;
    configInfo.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;   // Optional
    configInfo.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;  // Optional
    configInfo.colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;              // Optional
    configInfo.colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;   // Optional
    configInfo.colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;  // Optional
    configInfo.colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;              // Optional

    configInfo.colorBlendInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    configInfo.colorBlendInfo.logicOpEnable = VK_FALSE;
    configInfo.colorBlendInfo.logicOp = VK_LOGIC_OP_COPY;  // Optional
    configInfo.colorBlendInfo.attachmentCount = 1;
    configInfo.colorBlendInfo.pAttachments = &configInfo.colorBlendAttachment;
    configInfo.colorBlendInfo.blendConstants[0] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[1] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[2] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[3] = 0.0f;  // Optional

    configInfo.depthStencilInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    configInfo.depthStencilInfo.depthTestEnable = VK_TRUE;
    configInfo.depthStencilInfo.depthWriteEnable = VK_TRUE;
    configInfo.depthStencilInfo.depthCompareOp = VK_COMPARE_OP_LESS;
    configInfo.depthStencilInfo.depthBoundsTestEnable = VK_FALSE;
    configInfo.depthStencilInfo.minDepthBounds = 0.0f;  // Optional
    configInfo.depthStencilInfo.maxDepthBounds = 1.0f;  // Optional
    configInfo.depthStencilInfo.stencilTestEnable = VK_FALSE;
    configInfo.depthStencilInfo.front = {};  // Optional
    configInfo.depthStencilInfo.back = {};   // Optional

    configInfo.dynamicStateEnables = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};
    configInfo.dynamicStateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    configInfo.dynamicStateInfo.pDynamicStates = configInfo.dynamicStateEnables.data();
    configInfo.dynamicStateInfo.dynamicStateCount =
            static_cast<uint32_t>(configInfo.dynamicStateEnables.size());
    configInfo.dynamicStateInfo.flags = 0;
}


!@hash[]!@file[]./Rendering/Src/lve_window.cpp!@hash[]!@code[]
#include <QMouseEvent>
#include <QKeyEvent>
#include <QDockWidget>
#include <QGraphicsRectItem>
#include <QGraphicsOpacityEffect>
#include <QFile>
#include <QFileDialog>
#include <QString>

#include "lve_window.hpp"
#include "dtaorendersystem.h"



LveWindow::LveWindow()
{
}

LveWindow::~LveWindow()
{
    //this->destroy();
}

QVulkanWindowRenderer *LveWindow::createRenderer()
{
    qDebug() << "\n$$$$$ LveWindow::createRenderer()";
    this->m_renderer = new DtaoRenderSystem(this);
    return this->m_renderer;
    //return new DtaoRenderSystem(this);

}

void LveWindow::wheelEvent(QWheelEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    //const float amount = e->angleDelta().y() / 8;
    QPoint scroll = e->angleDelta();
    this->m_renderer->cameraController.setMouseScroll(scroll);

    if (keyCtrl == true)
    {
        //      m_rendere->windowZoom(amount);
        QString funcName = "windowZoom";
        //float value = amount;
        //emit signalInfoText(funcName, value);
        //        qDebug()<<funcName << " : " << value;
    }
    else
    {
        //      m_renderer->moveZoom(amount);
        QString funcName = "moveZoom";
        //float value = amount;
        //emit signalInfoText(funcName, value);
        //        qDebug()<<funcName << " : " << value;
    }
}

void LveWindow::mousePressEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    m_mouseButton = e->buttons();
    Qt::MouseButtons cur_button = e->buttons();
    QPoint position = e->pos();
    //m_lastPos = e->pos();
    this->m_renderer->cameraController.moveButtonPressed(cur_button);
    this->m_renderer->cameraController.setMousePosition(position, 1);

}

void LveWindow::emitStatus(float value){
    (void)value;
    QString funcName = "rotateRenderX";
    //emit signalInfoText(funcName, value);
}


void LveWindow::mouseReleaseEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    m_mouseButton = 0;
    QString funcName = "mouseRelease";
    Qt::MouseButtons cur_button = e->buttons();
    QPoint position = e->pos();
    //float value = 0;
    //emit signalInfoText(funcName, cur_button);
    this->m_renderer->cameraController.moveButtonReleased(cur_button);
    this->m_renderer->cameraController.setMousePosition(position ,2);
}

void LveWindow::mouseMoveEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    QPoint position = e->pos();
    this->m_renderer->cameraController.setMousePosition(position, 0);
    if (m_mouseButton == 0)
        return;
}

void LveWindow::keyPressEvent(QKeyEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    Qt::Key cur_key = (Qt::Key)e->key();
    //QString funcName = "rotateRenderX";
    //float value = 10.0f;
    //emit signalInfoText(funcName, value);

    this->m_renderer->cameraController.moveKeyPressed(cur_key);
    this->m_renderer->cameraController.visibleSetting(this->m_renderer->getGameObjects(), cur_key);
    this->m_renderer->cameraController.PEXSetting(this->m_renderer->getResistorModel(), cur_key);

}
void LveWindow::keyReleaseEvent(QKeyEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    Qt::Key cur_key = (Qt::Key)e->key();
    this->m_renderer->cameraController.moveKeyReleased(cur_key);
}

!@hash[]!@file[]./Rendering/Src/simple_render_system.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>
#include "simple_render_system.hpp"
#include "LayoutModel.h"
// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>
#include <glm/gtc/constants.hpp>

// std
#include <array>
#include <cassert>
#include <stdexcept>



struct SimplePushConstantData {
    glm::mat4 transform{ 1.f };
    alignas(16) glm::vec3 color{};
    glm::float32 alpha;
};

SimpleRenderSystem::SimpleRenderSystem(LveDevice& device, VkRenderPass renderPass)
    : lveDevice{ device } {
    createPipelineLayout(this->pipelineLayoutForLayoutFace);
    createPipelineForFace(renderPass);
    createPipelineLayout(this->pipelineLayoutForLayoutEdge);
    createPipelineForEdge(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXResistor);
    createPipelineForPEXResistor(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXResistorEdge);
    createPipelineForPEXResistorEdge(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXCapacitor);
    createPipelineForPEXCapacitor(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXCapacitorEdge);
    createPipelineForPEXCapacitorEdge(renderPass);

    createPipelineLayout(this->pipelineLayoutForToyCADFace);
    createPipelineForToyCADFace(renderPass);
    createPipelineLayout(this->pipelineLayoutForToyCADEdge);
    createPipelineForToyCADEdge(renderPass);

}

SimpleRenderSystem::~SimpleRenderSystem() {
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForLayoutFace, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForLayoutEdge, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForPEXResistor, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForPEXResistorEdge, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForPEXCapacitor, nullptr);

    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForToyCADFace, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForToyCADEdge, nullptr);
}


void SimpleRenderSystem::createPipelineLayout(VkPipelineLayout& pipeline_layout) {
    VkPushConstantRange pushConstantRange{};
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange.offset = 0;
    pushConstantRange.size = sizeof(SimplePushConstantData);

    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 0;
    pipelineLayoutInfo.pSetLayouts = nullptr;
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(lveDevice.device(), &pipelineLayoutInfo, nullptr, &pipeline_layout) !=
        VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }
}

void SimpleRenderSystem::createPipelineForFace(VkRenderPass renderPass) {
    assert(pipelineLayoutForLayoutFace != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForLayoutFace;

    pipelineConfig.colorBlendAttachment.blendEnable = VK_TRUE;
    pipelineConfig.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    pipelineConfig.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;

    this->lvePipelineForLayoutFace = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert.spv",
        "Rendering/shaders/simple_shader.frag.spv",
        pipelineConfig, LveModel::Vertex::getBindingDescriptions(), LveModel::Vertex::getAttributeDescriptions());
}

void SimpleRenderSystem::createPipelineForEdge(VkRenderPass renderPass) {
    assert(pipelineLayoutForLayoutEdge != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForLayoutEdge;

    pipelineConfig.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForLayoutEdge = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert_edge.spv",
        "Rendering/shaders/simple_shader.frag_edge.spv",
        pipelineConfig, LveModel::Vertex::getBindingDescriptions(), LveModel::Vertex::getAttributeDescriptions());
}

void SimpleRenderSystem::createPipelineForPEXResistor(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXResistor != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigResistor{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigResistor);
    pipelineConfigResistor.renderPass = renderPass;
    pipelineConfigResistor.pipelineLayout = pipelineLayoutForPEXResistor;
    pipelineConfigResistor.colorBlendAttachment.blendEnable = VK_TRUE;

    pipelineConfigResistor.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    pipelineConfigResistor.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;

    this->lvePipelineForPEXResistor = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert_pex.spv",
        "Rendering/shaders/simple_shader.frag_pex.spv",
        pipelineConfigResistor, LveModel::VertexResistor::getBindingDescriptions(), LveModel::VertexResistor::getAttributeDescriptions());
}


void SimpleRenderSystem::createPipelineForPEXResistorEdge(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXResistorEdge != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigResistorEdge{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigResistorEdge);
    pipelineConfigResistorEdge.renderPass = renderPass;
    pipelineConfigResistorEdge.pipelineLayout = pipelineLayoutForPEXResistorEdge;

    pipelineConfigResistorEdge.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForPEXResistorEdge = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert_pex.spv",
        "Rendering/shaders/simple_shader.frag_pex.spv",
        pipelineConfigResistorEdge, LveModel::VertexResistor::getBindingDescriptions(), LveModel::VertexResistor::getAttributeDescriptions());
}

void SimpleRenderSystem::createPipelineForPEXCapacitor(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXCapacitor != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigCapacitor{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigCapacitor);
    pipelineConfigCapacitor.renderPass = renderPass;
    pipelineConfigCapacitor.pipelineLayout = pipelineLayoutForPEXCapacitor;
    pipelineConfigCapacitor.colorBlendAttachment.blendEnable = VK_TRUE;

    pipelineConfigCapacitor.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    pipelineConfigCapacitor.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;

    this->lvePipelineForPEXCapacitor = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert_pex.spv",
        "Rendering/shaders/simple_shader.frag_pex.spv",
        pipelineConfigCapacitor, LveModel::VertexCapacitor::getBindingDescriptions(), LveModel::VertexCapacitor::getAttributeDescriptions());
}

void SimpleRenderSystem::createPipelineForPEXCapacitorEdge(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXCapacitorEdge != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigCapacitorEdge{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigCapacitorEdge);
    pipelineConfigCapacitorEdge.renderPass = renderPass;
    pipelineConfigCapacitorEdge.pipelineLayout = pipelineLayoutForPEXCapacitorEdge;

    pipelineConfigCapacitorEdge.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForPEXCapacitorEdge = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert_pex.spv",
        "Rendering/shaders/simple_shader.frag_pex.spv",
        pipelineConfigCapacitorEdge, LveModel::VertexCapacitor::getBindingDescriptions(), LveModel::VertexCapacitor::getAttributeDescriptions());
}


void SimpleRenderSystem::renderGameObjects(
    VkCommandBuffer commandBuffer,
    std::vector<LveGameObject>& gameObjects,
    const LveCamera& camera) {

    auto proj = camera.getProjection();
    proj[1][1] *= -1;
    auto projectionView = proj * camera.getView();

    SimplePushConstantData push{};
    for (auto& obj : gameObjects) {
        push.transform = projectionView * obj.transform.mat4();

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT && obj.model->getVisible()) {
            std::shared_ptr<LayoutModel> model = std::static_pointer_cast<LayoutModel>(obj.model);
            if(!model->isfilteredon){
                std::map<string, LveModel::LayerProperty> layer_info = obj.model->getLayer();
                for (auto ordered_key : obj.model->drawing_order_layerby) {
                    if (layer_info[ordered_key].visiblity) {
                        lvePipelineForLayoutFace->bind(commandBuffer);
                        push.alpha = layer_info[ordered_key].opacity;
                        push.color = layer_info[ordered_key].color;
                        vkCmdPushConstants(
                            commandBuffer, pipelineLayoutForLayoutFace,
                            VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                            sizeof(SimplePushConstantData), &push);
                        model->bindDrawVertexIndexBufferForFace_layer(commandBuffer, ordered_key);
                        lvePipelineForLayoutEdge->bind(commandBuffer);
                        model->bindDrawIndexBufferForEdge_layer(commandBuffer, ordered_key);
                    }
                }
            }
            else {
                std::map<string, LveModel::LayerProperty> layer_info = obj.model->getLayer();
                for (auto ordered_key : model->drawing_order_layerby_filtered) {
                    if (layer_info[ordered_key].visiblity) {
                        lvePipelineForLayoutFace->bind(commandBuffer);
                        push.alpha = layer_info[ordered_key].opacity;
                        push.color = layer_info[ordered_key].color;
                        vkCmdPushConstants(
                            commandBuffer, pipelineLayoutForLayoutFace,
                            VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                            sizeof(SimplePushConstantData), &push);

                        model->bindDrawVertexIndexBufferForFace_layer_filtered(commandBuffer, ordered_key);
                        lvePipelineForLayoutEdge->bind(commandBuffer);
                        model->bindDrawIndexBufferForEdge_layer_filtered(commandBuffer, ordered_key);
                    }
                }
            }


        }

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_AXIS && obj.model->getVisible()) {
            lvePipelineForLayoutEdge->bind(commandBuffer);
            push.color = glm::vec3(1.0f, 1.0f, 1.0f);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForLayoutEdge,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            obj.model->drawForEdge(commandBuffer);
        }

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR && obj.model->getVisible()) {
            //*

            push.alpha = 0.1f;
            push.color = glm::vec3(1.0f, 1.0f, 1.0f);
            lvePipelineForPEXResistor->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForPEXResistor,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForFace(commandBuffer);
            obj.model->drawForFace(commandBuffer);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            lvePipelineForPEXResistorEdge->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForPEXResistorEdge,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);


            obj.model->drawForEdge(commandBuffer);

        }

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR && obj.model->getVisible()) {
            //*
            lvePipelineForPEXCapacitor->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForPEXCapacitor,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForFace(commandBuffer);
            obj.model->drawForFace(commandBuffer);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            lvePipelineForPEXCapacitorEdge->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForPEXCapacitorEdge,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);

            obj.model->drawForEdge(commandBuffer);
            //*/
        }
    }
}

void SimpleRenderSystem::createPipelineForToyCADFace(VkRenderPass renderPass) {
    assert(pipelineLayoutForToyCADFace != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForToyCADFace;

    pipelineConfig.colorBlendAttachment.blendEnable = VK_TRUE;
    pipelineConfig.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    pipelineConfig.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;

    this->lvePipelineForToyCADFace = std::make_unique<LvePipeline>(
                lveDevice,
                "ToyCAD/shaders/toycad.vert.spv",
                "ToyCAD/shaders/toycad.frag.spv",
                pipelineConfig,
                ToyCADModel::ToyCADVertex::getBindingDescriptions(),
                ToyCADModel::ToyCADVertex::getAttributeDescriptions());
}

void SimpleRenderSystem::createPipelineForToyCADEdge(VkRenderPass renderPass) {
    assert(pipelineLayoutForToyCADEdge != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForToyCADEdge;

    pipelineConfig.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForToyCADEdge = std::make_unique<LvePipeline>(
                lveDevice,
                "ToyCAD/shaders/toycad.vert.spv",
                "ToyCAD/shaders/toycad.frag.spv",
                pipelineConfig,
                ToyCADModel::ToyCADVertex::getBindingDescriptions(),
                ToyCADModel::ToyCADVertex::getAttributeDescriptions());
}

void SimpleRenderSystem::renderToyCADObjects(
    VkCommandBuffer commandBuffer,
    std::vector<ToyCADObject>& objects,
    const LveCamera& camera) {

    auto proj = camera.getProjection();
    proj[1][1] *= -1;
    auto projectionView = proj * camera.getView();

    SimplePushConstantData push{};
    for (auto& obj : objects) {
        if(obj.getVisibility()){
            push.transform = projectionView * obj.transform.mat4();
            push.alpha = obj.opacity;
            push.color = obj.color;

            lvePipelineForToyCADFace->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForToyCADFace,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForFace(commandBuffer);
            obj.model->drawForFace(commandBuffer);

            push.color = glm::vec3{obj.color.r*0.8, obj.color.g*0.8, obj.color.b*0.8,};

            lvePipelineForToyCADEdge->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForToyCADEdge,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            obj.model->drawForEdge(commandBuffer);
        }//if(obj.getVisibility())
    }//for (auto& obj : objects)
}//void SimpleRenderSystem::renderToyCADObjects

void SimpleRenderSystem::renderSTLObjects(
        VkCommandBuffer commandBuffer,
        std::vector<STLObject>& objects,
        const LveCamera& camera){

    auto proj = camera.getProjection();
    proj[1][1] *= -1;
    auto projectionView = proj * camera.getView();

    SimplePushConstantData push{};
    for (auto& obj : objects) {
        if(obj.getVisibility()){
            push.transform = projectionView * obj.transform.mat4();
            push.alpha = obj.opacity;
            push.color = obj.color;

            lvePipelineForToyCADFace->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForToyCADFace,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer, obj.model->vertexBufferFace);
            obj.model->draw(commandBuffer, obj.model->vertices_face);


            push.color = glm::vec3{obj.color.r*0.8, obj.color.g*0.8, obj.color.b*0.8,};

            lvePipelineForToyCADEdge->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForToyCADEdge,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer, obj.model->vertexBufferEdge);
            obj.model->draw(commandBuffer, obj.model->vertices_edge);
        }//if(obj.getVisibility())
    }//for (auto& obj : objects)
}//void SimpleRenderSystem::renderSTLObjects
!@hash[]!@file[]./STLModel/Src/stl_model.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>

#include "stl_model.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>
#include <cassert>
#include <cmath>

#include <QFile>

using namespace std;


STLModel::STLModel(LveDevice& device, std::vector<Vertex_stl>& stl_data)
    : lveDevice{device}{
    this->model_type = MODEL_TYPE_STL;
    this->makeRenderingData(stl_data);
    this->createBuffers();
}

STLModel::~STLModel(){
    this->destroyBuffers();
    this->vertices_face.clear();
    this->vertices_edge.clear();
}

void STLModel::makeRenderingData(std::vector<Vertex_stl>& stl_data){
    this->makeVertices(stl_data);
}

void STLModel::makeVertices(std::vector<Vertex_stl>& stl_data){
    STLVertex vertex[3];
    std::vector<Vertex_stl>::iterator it;

    for(it = stl_data.begin(); it != stl_data.end();){
        vertex[0].position = {
            static_cast<float>(it->x),
            static_cast<float>(it->y),
            static_cast<float>(it->z)};
        it++;

        vertex[1].position = {
            static_cast<float>(it->x),
            static_cast<float>(it->y),
            static_cast<float>(it->z)};
        it++;

        vertex[2].position = {
            static_cast<float>(it->x),
            static_cast<float>(it->y),
            static_cast<float>(it->z)};
        it++;

        this->vertices_face.push_back(vertex[0]);
        this->vertices_face.push_back(vertex[1]);
        this->vertices_face.push_back(vertex[2]);

        this->vertices_edge.push_back(vertex[0]);
        this->vertices_edge.push_back(vertex[1]);

        this->vertices_edge.push_back(vertex[1]);
        this->vertices_edge.push_back(vertex[2]);

        this->vertices_edge.push_back(vertex[2]);
        this->vertices_edge.push_back(vertex[0]);
    }
}

void STLModel::createBuffers(){
    createVertexBuffer(this->vertices_face, this->vertexBufferFace, this->vertexBufferMemoryFace);
    createVertexBuffer(this->vertices_edge, this->vertexBufferEdge, this->vertexBufferMemoryEdge);
}

void STLModel::destroyBuffers(){
    vkDestroyBuffer(lveDevice.device(), vertexBufferFace, nullptr);
    vkFreeMemory(lveDevice.device(), vertexBufferMemoryFace, nullptr);
    vkDestroyBuffer(lveDevice.device(), vertexBufferEdge, nullptr);
    vkFreeMemory(lveDevice.device(), vertexBufferMemoryEdge, nullptr);
}

void STLModel::createVertexBuffer(
        const std::vector<STLVertex>& vertices,
        VkBuffer& buffer,
        VkDeviceMemory& memory){
    uint32_t vertexCount = static_cast<uint32_t>(vertices.size());
    assert(vertexCount >= 3 && "Vertex count must be at least 3");

    VkDeviceSize bufferSize = sizeof(vertices[0]) * vertexCount;
    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, vertices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);

}

void STLModel::bindVertexBuffer(VkCommandBuffer commandBuffer, VkBuffer& buffer){
    VkBuffer buffers[] = {buffer};
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
}


void STLModel::draw(VkCommandBuffer commandBuffer,
                           std::vector<STLVertex>& vertices){
    vkCmdDraw(commandBuffer, static_cast<uint32_t>(vertices.size()), 1, 0, 0);
}


std::vector<VkVertexInputBindingDescription> STLModel::STLVertex::getBindingDescriptions() {
    std::vector<VkVertexInputBindingDescription> bindingDescriptions(1);
    bindingDescriptions[0].binding = 0;
    bindingDescriptions[0].stride = sizeof(STLVertex);
    bindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    return bindingDescriptions;
}

std::vector<VkVertexInputAttributeDescription> STLModel::STLVertex::getAttributeDescriptions() {
    std::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);
    attributeDescriptions[0].binding = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset = offsetof(STLVertex, position);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(STLVertex, color);
    return attributeDescriptions;
}
!@hash[]!@file[]./ToyCAD/Src/toycaddata.cpp!@hash[]!@code[]#include "toycaddata.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>

#include <QDebug>
#include <QFile>

using namespace std;

ToyCADData::ToyCADData()
{
    this->scale = 0.0;
}

ToyCADData::~ToyCADData()
{
    this->cad_data.clear();
}

void ToyCADData::loadToyCADData(const std::string& file_path){
    if (!QFile::exists(file_path.c_str())) {
        cerr << "File is not exist @ ToyCADData - " << file_path << endl;
        return;
    }

    ifstream readfile(file_path);

    string line;
    vector<string> tokens;
    string token;
    TOYCAD_DATA cur_data;

    getline(readfile, line); //bbox line
    stringstream ss(line);
    while( getline(ss, token, ',')){
        tokens.push_back(token);
    }
    this->data_bbox.min_x = stof(tokens[TOYCAD_BBOX_IDX_MINX]);
    this->data_bbox.min_y = stof(tokens[TOYCAD_BBOX_IDX_MINY]);
    this->data_bbox.min_z = stof(tokens[TOYCAD_BBOX_IDX_MINZ]);
    this->data_bbox.max_x = stof(tokens[TOYCAD_BBOX_IDX_MAXX]);
    this->data_bbox.max_y = stof(tokens[TOYCAD_BBOX_IDX_MAXY]);
    this->data_bbox.max_z = stof(tokens[TOYCAD_BBOX_IDX_MAXZ]);
    this->calculateScale();

    getline(readfile, line);//column header line
    while(getline(readfile, line)){
        tokens.clear();
        stringstream ss(line);
        while( getline(ss, token, ',')){
            tokens.push_back(token);
        }

        cur_data.type = tokens[TOYCAD_DATA_IDX_TYPE];
        cur_data.layer = tokens[TOYCAD_DATA_IDX_LAYER];
        cur_data.minx = stof(tokens[TOYCAD_DATA_IDX_MINX]);
        cur_data.miny = stof(tokens[TOYCAD_DATA_IDX_MINY]);
        cur_data.maxx = stof(tokens[TOYCAD_DATA_IDX_MAXX]);
        cur_data.maxy = stof(tokens[TOYCAD_DATA_IDX_MAXY]);
        cur_data.minz = stof(tokens[TOYCAD_DATA_IDX_MINZ]);
        cur_data.maxz = stof(tokens[TOYCAD_DATA_IDX_MAXZ]);
        cur_data.color_r = stoi(tokens[TOYCAD_DATA_IDX_COLOR_R]);
        cur_data.color_g = stoi(tokens[TOYCAD_DATA_IDX_COLOR_G]);
        cur_data.color_b = stoi(tokens[TOYCAD_DATA_IDX_COLOR_B]);
        cur_data.color_a = stoi(tokens[TOYCAD_DATA_IDX_COLOR_A]);
        cur_data.slopex = stof(tokens[TOYCAD_DATA_IDX_SLOPEX]);
        cur_data.slopey = stof(tokens[TOYCAD_DATA_IDX_SLOPEY]);
        cur_data.rotation_x = stof(tokens[TOYCAD_DATA_IDX_ROTATEX]);
        cur_data.rotation_y = stof(tokens[TOYCAD_DATA_IDX_ROTATEY]);
        cur_data.rotation_z = stof(tokens[TOYCAD_DATA_IDX_ROTATEZ]);

        this->cad_data.push_back(cur_data);

    }//while(getline(readfile, line)){
    printAllData();
}

void ToyCADData::loadToyCADData(std::vector<Data_2nd>& open_data){
    TOYCAD_DATA cur_data;
    for(auto & in_data : open_data){
        cur_data.type = "rect";
        cur_data.layer = "1.0";
        cur_data.minx = in_data.minx;
        cur_data.miny = in_data.miny;
        cur_data.maxx = in_data.maxx;
        cur_data.maxy = in_data.maxy;
        cur_data.minz = in_data.minz;
        cur_data.maxz = in_data.maxz;
        cur_data.color_r = in_data.r;
        cur_data.color_g = in_data.g;
        cur_data.color_b = in_data.b;
        cur_data.color_a = in_data.a;
        cur_data.slopex = 0.0;
        cur_data.slopey = 0.0;
        cur_data.rotation_x = 0.0;
        cur_data.rotation_y = 0.0;
        cur_data.rotation_z = 0.0;

        this->cad_data.push_back(cur_data);

    }//for(auto & in_data : open_data)
}

void ToyCADData::calculateScale(){
    double diff_x = this->data_bbox.max_x - this->data_bbox.min_x;
    double diff_y = this->data_bbox.max_y - this->data_bbox.min_y;
    double diff_z = this->data_bbox.max_z - this->data_bbox.min_z;

    double diff_max = diff_x > diff_y ? diff_x : diff_y;
    diff_max = diff_max > diff_z ? diff_max : diff_z;

    this->scale = 1.0f / diff_max;
}

void ToyCADData::printAllData(){
    qDebug() << "ToyCADData :: printAllData()";
    for(auto cur : this->cad_data){
        qDebug() << cur.type.c_str() << ", "
                 << cur.layer.c_str() << ", "
                 << cur.minx << ", "
                 << cur.miny << ", "
                 << cur.maxx << ", "
                 << cur.maxy << ", "
                 << cur.minz << ", "
                 << cur.maxz << ", "
                 << cur.color_r << ", "
                 << cur.color_g << ", "
                 << cur.color_b << ", "
                 << cur.slopex << ", "
                 << cur.slopey << ", "
                 << cur.rotation_x << ", "
                 << cur.rotation_y << ", "
                 << cur.rotation_z;
    }
}
!@hash[]!@file[]./ToyCAD/Src/toycadmodel.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>

#include "toycadmodel.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>
#include <cassert>
#include <cmath>

#include <QFile>

using namespace std;

const double PI = 3.141591;
const double RANDIAN_FACTOR = PI / 180.0;

ToyCADModel::ToyCADModel(LveDevice& device, TOYCAD_DATA& toycad_data)
    : lveDevice{device}{
    this->model_type = MODEL_TYPE_TOY_CAD;
    num_points_for_circle = 30;
    this->makeRenderingData(toycad_data);
    this->createBuffers();
}
ToyCADModel::~ToyCADModel(){
    this->destroyBuffers();
    this->vertices.clear();
    this->indices_face.clear();
    this->indices_edge.clear();
}

void ToyCADModel::makeRenderingData(TOYCAD_DATA& toycad_data){
       //this->loadData();
    this->toycad_datatype = getCurDataType(toycad_data.type);
    this->makeVertices(toycad_data);
    this->makeIndices();
}

void ToyCADModel::makeVertices(TOYCAD_DATA& toycad_data){
    if(this->toycad_datatype == TOYCAD_TYPE_RECT)
        makeRectVertices(toycad_data);
    else if(this->toycad_datatype == TOYCAD_TYPE_CIRCLE)
        makeCircleVertices(toycad_data, num_points_of_circle);
    else if(this->toycad_datatype == TOYCAD_TYPE_FAN)
        makeFanVertices(toycad_data);
    else if(this->toycad_datatype == TOYCAD_TYPE_HEXAGON)
        makeHexagonVertices(toycad_data);
    else if(this->toycad_datatype == TOYCAD_TYPE_OCTAGON)
        makeOctagonVertices(toycad_data);
    else if(this->toycad_datatype == TOYCAD_TYPE_TRIANGLE)
        makeTriangleVertices(toycad_data);
    else if(this->toycad_datatype == TOYCAD_TYPE_PENTAGON)
        makePentagonVertices(toycad_data);
    else if(this->toycad_datatype == TOYCAD_TYPE_DIAMOND)
        makeDiamondVertices(toycad_data);
    else{}
}

void ToyCADModel::makeIndices(){
    if(this->toycad_datatype == TOYCAD_TYPE_RECT) makeRectIndices();
    else if(this->toycad_datatype == TOYCAD_TYPE_CIRCLE) makeCircleIndices(this->num_points_for_circle);
    else if(this->toycad_datatype == TOYCAD_TYPE_FAN) makeFanIndices();
    else if(this->toycad_datatype == TOYCAD_TYPE_HEXAGON) makeHexagonIndices();
    else if(this->toycad_datatype == TOYCAD_TYPE_OCTAGON) makeOctagonIndices();
    else if(this->toycad_datatype == TOYCAD_TYPE_TRIANGLE) makeTriangleIndices();
    else if(this->toycad_datatype == TOYCAD_TYPE_PENTAGON) makePentagonIndices();
    else if(this->toycad_datatype == TOYCAD_TYPE_DIAMOND) makeDiamondIndices();
    else{
    }
}

void ToyCADModel::makeRectVertices(TOYCAD_DATA& toycad_data){
    int num_of_vertex = 8;
    ToyCADVertex vertex[num_of_vertex];

    double length_x = (toycad_data.maxx - toycad_data.minx);
    double length_y = (toycad_data.maxy - toycad_data.miny);
    double length_z = (toycad_data.maxz - toycad_data.minz);
    double half_length_x = length_x*0.5;
    double half_length_y = length_y*0.5;
    double height = toycad_data.maxz - toycad_data.minz;
    double delta_x = height*tan(RANDIAN_FACTOR*toycad_data.slopex);
    double delta_y = height*tan(RANDIAN_FACTOR*toycad_data.slopey);
    if( delta_x < -half_length_x) delta_x = -half_length_x;
    if( delta_y < -half_length_y) delta_y = -half_length_y;

    double min_x = 0;
    double max_x = length_x;
    double min_y = 0;
    double max_y = length_y;
    double min_z = 0;
    double max_z = length_z;

    vertex[0].position = {min_x, max_y, max_z};
    vertex[1].position = {max_x, max_y, max_z};
    vertex[2].position = {max_x, min_y, max_z};
    vertex[3].position = {min_x, min_y, max_z};

    vertex[4].position = {min_x - delta_x, max_y + delta_y, min_z};
    vertex[5].position = {max_x + delta_x, max_y + delta_y, min_z};
    vertex[6].position = {max_x + delta_x, min_y - delta_y, min_z};
    vertex[7].position = {min_x - delta_x, min_y - delta_y, min_z};

    for(int i = 0; i < num_of_vertex; ++i)
        this->vertices.push_back(vertex[i]);
}

void ToyCADModel::makeCircleVertices(TOYCAD_DATA& toycad_data, const unsigned int num_of_vertex_){
    //unsigned int num_of_vertex = this->num_points_for_circle;
    unsigned int num_of_vertex = num_of_vertex_;
    ToyCADVertex vertex;

    double length_x = (toycad_data.maxx - toycad_data.minx);
    double length_y = (toycad_data.maxy - toycad_data.miny);
    double length_z = (toycad_data.maxz - toycad_data.minz);
    if( length_x < length_y ) length_y = length_x;
    else length_x = length_y;

    double radius_top = length_x*0.5;
    double height = toycad_data.maxz - toycad_data.minz;
    double delta = height*tan(RANDIAN_FACTOR*toycad_data.slopex);

    if( delta < -radius_top) delta = -radius_top;
    double radius_bottom = radius_top + delta;

    double cen_x = length_x*0.5;
    double cen_y = length_y*0.5;
    double angle = RANDIAN_FACTOR*360.0/(double)num_of_vertex;

    ToyCADVertex vertex_top_center;
    vertex_top_center.position = {cen_x, cen_y, length_z};
    this->vertices.push_back(vertex_top_center);
    for(unsigned int i = 0; i < num_of_vertex; ++i){
        vertex.position = {
            cen_x+radius_top*cos(angle*i),
            cen_y+radius_top*sin(angle*i),
            length_z};
        this->vertices.push_back(vertex);
    }

    ToyCADVertex vertex_bottom_center;
    vertex_bottom_center.position = {cen_x, cen_y, 0};
    this->vertices.push_back(vertex_bottom_center);
    for(unsigned int i = 0; i < num_of_vertex; ++i){
        vertex.position = {
            cen_x+radius_bottom*cos(angle*i),
            cen_y+radius_bottom*sin(angle*i),
            0};
        this->vertices.push_back(vertex);
    }
}

void ToyCADModel::makeFanVertices(TOYCAD_DATA& toycad_data){
    //unsigned int num_of_vertex = this->num_points_for_circle;
    unsigned int num_of_vertex = num_points_of_fan;
    ToyCADVertex vertex;

    double length_x = (toycad_data.maxx - toycad_data.minx);
    double length_y = (toycad_data.maxy - toycad_data.miny);
    double length_z = (toycad_data.maxz - toycad_data.minz);
    if( length_x < length_y ) length_y = length_x;
    else length_x = length_y;

    double radius_top = length_x;
    double height = toycad_data.maxz - toycad_data.minz;
    double delta = height*tan(RANDIAN_FACTOR*toycad_data.slopex);

    if( delta < -radius_top) delta = -radius_top;
    double radius_bottom = radius_top + delta;

    double cen_x = 0;
    double cen_y = 0;
    double angle = RANDIAN_FACTOR*90.0/(double)num_of_vertex;

    ToyCADVertex vertex_top_center;
    vertex_top_center.position = {cen_x, cen_y, length_z};
    this->vertices.push_back(vertex_top_center);
    for(unsigned int i = 0; i < num_of_vertex; ++i){
        vertex.position = {
            cen_x+radius_top*cos(angle*i),
            cen_y+radius_top*sin(angle*i),
            length_z};
        this->vertices.push_back(vertex);
    }

    ToyCADVertex vertex_bottom_center;
    vertex_bottom_center.position = {cen_x, cen_y, 0};
    this->vertices.push_back(vertex_bottom_center);
    for(unsigned int i = 0; i < num_of_vertex; ++i){
        vertex.position = {
            cen_x+radius_bottom*cos(angle*i),
            cen_y+radius_bottom*sin(angle*i),
            0};
        this->vertices.push_back(vertex);
    }
}

void ToyCADModel::makeDiamondVertices(TOYCAD_DATA& toycad_data){
    int num_of_vertex = 8;
    ToyCADVertex vertex[num_of_vertex];

    double length_x = (toycad_data.maxx - toycad_data.minx);
    double length_y = (toycad_data.maxy - toycad_data.miny);
    double length_z = (toycad_data.maxz - toycad_data.minz);
    double half_length_x = length_x*0.5;
    double half_length_y = length_y*0.5;
    double height = toycad_data.maxz - toycad_data.minz;
    double delta_x = height*tan(RANDIAN_FACTOR*toycad_data.slopex);
    double delta_y = height*tan(RANDIAN_FACTOR*toycad_data.slopey);
    if( delta_x < -half_length_x) delta_x = -half_length_x;
    if( delta_y < -half_length_y) delta_y = -half_length_y;

    double min_x = 0;
    double max_x = length_x;
    double min_y = 0;
    double max_y = length_y;
    double min_z = 0;
    double max_z = length_z;
    double half_x = half_length_x;
    double half_y = half_length_y;

    vertex[0].position = {half_x, max_y, max_z};
    vertex[1].position = {max_x, half_y, max_z};
    vertex[2].position = {half_x, min_y, max_z};
    vertex[3].position = {min_x, half_y, max_z};

    vertex[4].position = {half_x, max_y + delta_y, min_z};
    vertex[5].position = {max_x + delta_x, half_y, min_z};
    vertex[6].position = {half_x, min_y - delta_y, min_z};
    vertex[7].position = {min_x - delta_x, half_y, min_z};

    for(int i = 0; i < num_of_vertex; ++i)
        this->vertices.push_back(vertex[i]);
}

void ToyCADModel::makeHexagonVertices(TOYCAD_DATA& toycad_data){
    makeCircleVertices(toycad_data, num_points_of_hexagon);
}
void ToyCADModel::makeOctagonVertices(TOYCAD_DATA& toycad_data){
    makeCircleVertices(toycad_data, num_points_of_octagon);
}

void ToyCADModel::makeTriangleVertices(TOYCAD_DATA& toycad_data){
    makeCircleVertices(toycad_data, num_points_of_triangle);
}

void ToyCADModel::makePentagonVertices(TOYCAD_DATA& toycad_data){
    makeCircleVertices(toycad_data, num_points_of_pentagon);
}




void ToyCADModel::makeRectIndices(){
    //face
    std::vector<uint32_t>& face = this->indices_face;

    face.push_back(0); face.push_back(1); face.push_back(2);
    face.push_back(2); face.push_back(3); face.push_back(0);//top

    face.push_back(3); face.push_back(2); face.push_back(6);
    face.push_back(6); face.push_back(7); face.push_back(3);//front

    face.push_back(0); face.push_back(3); face.push_back(7);
    face.push_back(7); face.push_back(4); face.push_back(0);//left

    face.push_back(1); face.push_back(5); face.push_back(6);
    face.push_back(6); face.push_back(2); face.push_back(1);//right

    face.push_back(0); face.push_back(4); face.push_back(5);
    face.push_back(5); face.push_back(1); face.push_back(0);//back

    face.push_back(4); face.push_back(7); face.push_back(6);
    face.push_back(6); face.push_back(5); face.push_back(4);//bottom

    //edge
    std::vector<uint32_t>& edge = this->indices_edge;
    edge.push_back(0); edge.push_back(1);
    edge.push_back(1); edge.push_back(2);
    edge.push_back(2); edge.push_back(3);
    edge.push_back(3); edge.push_back(0);//top

    edge.push_back(4); edge.push_back(5);
    edge.push_back(5); edge.push_back(6);
    edge.push_back(6); edge.push_back(7);
    edge.push_back(7); edge.push_back(4);//bottom

    edge.push_back(0); edge.push_back(4);
    edge.push_back(1); edge.push_back(5);
    edge.push_back(2); edge.push_back(6);
    edge.push_back(3); edge.push_back(7);//side


}

void ToyCADModel::makeCircleIndices(const unsigned int num_of_vertex_){
    //unsigned int num_of_vertex = this->num_points_for_circle;
    unsigned int num_of_vertex = num_of_vertex_;
    //face
    std::vector<uint32_t>& face = this->indices_face;
    //top circle
    uint32_t cen_idx = 0;
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        face.push_back(cen_idx); face.push_back(i); face.push_back(i+1);
    }
    face.push_back(cen_idx); face.push_back(num_of_vertex); face.push_back(1);

    //bottom circle
    cen_idx = num_of_vertex+1;
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        face.push_back(cen_idx); face.push_back(cen_idx+i); face.push_back(cen_idx+i+1);
    }
    face.push_back(cen_idx); face.push_back(cen_idx+num_of_vertex); face.push_back(cen_idx+1);

    //side
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        face.push_back(i); face.push_back(i+1); face.push_back(i+1+num_of_vertex);
        face.push_back(i+1+num_of_vertex); face.push_back(i+2+num_of_vertex); face.push_back(i+1);
    }
    face.push_back(num_of_vertex); face.push_back(1); face.push_back(num_of_vertex*2+1);
    face.push_back(num_of_vertex*2+1); face.push_back(num_of_vertex+2); face.push_back(1);

    //edge
    std::vector<uint32_t>& edge = this->indices_edge;
    //top
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        edge.push_back(i); edge.push_back(i+1);
    }
    edge.push_back(num_of_vertex); edge.push_back(1);

    //bottom
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        edge.push_back(num_of_vertex+1+i); edge.push_back(num_of_vertex+1+i+1);
    }
    edge.push_back(num_of_vertex*2+1); edge.push_back(num_of_vertex+1+1);
}

void ToyCADModel::makeFanIndices(){
    //unsigned int num_of_vertex = this->num_points_for_circle;
    unsigned int num_of_vertex = num_points_of_fan;
    //face
    std::vector<uint32_t>& face = this->indices_face;
    //top circle
    uint32_t cen_idx = 0;
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        face.push_back(cen_idx); face.push_back(i); face.push_back(i+1);
    }

    //bottom circle
    cen_idx = num_of_vertex+1;
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        face.push_back(cen_idx); face.push_back(cen_idx+i); face.push_back(cen_idx+i+1);
    }


    //side
    unsigned int top_cen_index = 0;
    unsigned int bottom_cen_index = num_of_vertex + 1;
    unsigned int top_last_index = num_of_vertex;
    unsigned int bottom_last_index = 2*num_of_vertex + 1;
    face.push_back(top_cen_index); face.push_back(top_cen_index+1); face.push_back(bottom_cen_index);
    face.push_back(bottom_cen_index); face.push_back(bottom_cen_index+1); face.push_back(top_cen_index+1);

    face.push_back(top_cen_index); face.push_back(top_last_index); face.push_back(bottom_cen_index);
    face.push_back(bottom_cen_index); face.push_back(bottom_last_index); face.push_back(top_last_index);


    for(unsigned int i = 1; i < num_of_vertex; ++i){
        face.push_back(i); face.push_back(i+1); face.push_back(i+1+num_of_vertex);
        face.push_back(i+1+num_of_vertex); face.push_back(i+2+num_of_vertex); face.push_back(i+1);
    }

    //edge
    std::vector<uint32_t>& edge = this->indices_edge;
    //top
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        edge.push_back(i); edge.push_back(i+1);
    }

    //bottom
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        edge.push_back(num_of_vertex+1+i); edge.push_back(num_of_vertex+1+i+1);
    }

}

void ToyCADModel::makeDiamondIndices(){
    makeRectIndices();
}

void ToyCADModel::makeHexagonIndices(){
    makeCircleIndices(num_points_of_hexagon);
}

void ToyCADModel::makeOctagonIndices(){
    makeCircleIndices(num_points_of_octagon);
}

void ToyCADModel::makeTriangleIndices(){
    makeCircleIndices(num_points_of_triangle);
}

void ToyCADModel::makePentagonIndices(){
    makeCircleIndices(num_points_of_pentagon);
}

int ToyCADModel::getCurDataType(std::string& str_type){
    TOYCAD_TYPE_LIST type;
    if(str_type == "rect") type = TOYCAD_TYPE_RECT;
    else if(str_type == "circle") type = TOYCAD_TYPE_CIRCLE;
    else if(str_type == "fan") type = TOYCAD_TYPE_FAN;
    else if(str_type == "hexagon") type = TOYCAD_TYPE_HEXAGON;
    else if(str_type == "octagon") type = TOYCAD_TYPE_OCTAGON;
    else if(str_type == "triangle") type = TOYCAD_TYPE_TRIANGLE;
    else if(str_type == "pentagon") type = TOYCAD_TYPE_PENTAGON;
    else if(str_type == "diamond") type = TOYCAD_TYPE_DIAMOND;
    else type = TOYCAD_TYPE_DEFAULT;

    return type;
}

void ToyCADModel::createBuffers(){
    createVertexBuffer(this->vertices, this->vertexBuffer, this->vertexBufferMemory);
    createIndexBuffer(this->indices_face, this->indexBufferForFace, this->indexBufferMemoryForFace);
    createIndexBuffer(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
}

void ToyCADModel::destroyBuffers(){
    vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
    vkDestroyBuffer(lveDevice.device(), indexBufferForFace, nullptr);
    vkFreeMemory(lveDevice.device(), indexBufferMemoryForFace, nullptr);
    vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
    vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
}

void ToyCADModel::createVertexBuffer(
        const std::vector<ToyCADVertex>& vertices,
        VkBuffer& buffer,
        VkDeviceMemory& memory){
    uint32_t vertexCount = static_cast<uint32_t>(vertices.size());
    assert(vertexCount >= 3 && "Vertex count must be at least 3");

    VkDeviceSize bufferSize = sizeof(vertices[0]) * vertexCount;
    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, vertices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);

}
void ToyCADModel::createIndexBuffer(
        const std::vector<uint32_t>& indices,
        VkBuffer & buffer,
        VkDeviceMemory & memory){
    assert( !indices.empty() && "Index size can't be zero");

    VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();
    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, indices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}

void ToyCADModel::bindVertexBuffer(VkCommandBuffer commandBuffer){
    VkBuffer buffers[] = {vertexBuffer};
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
}

void ToyCADModel::bindIndexBufferForFace(VkCommandBuffer commandBuffer){
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForFace, 0, VK_INDEX_TYPE_UINT32);
}

void ToyCADModel::bindIndexBufferForEdge(VkCommandBuffer commandBuffer){
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForEdge, 0, VK_INDEX_TYPE_UINT32);
}

void ToyCADModel::drawForFace(VkCommandBuffer commandBuffer){
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_face.size()), 1, 0, 0, 0);
}

void ToyCADModel::drawForEdge(VkCommandBuffer commandBuffer){
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_edge.size()), 1, 0, 0, 0);
}

std::vector<VkVertexInputBindingDescription> ToyCADModel::ToyCADVertex::getBindingDescriptions() {
    std::vector<VkVertexInputBindingDescription> bindingDescriptions(1);
    bindingDescriptions[0].binding = 0;
    bindingDescriptions[0].stride = sizeof(ToyCADVertex);
    bindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    return bindingDescriptions;
}

std::vector<VkVertexInputAttributeDescription> ToyCADModel::ToyCADVertex::getAttributeDescriptions() {
    std::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);
    attributeDescriptions[0].binding = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset = offsetof(ToyCADVertex, position);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(ToyCADVertex, color);
    return attributeDescriptions;
}

void ToyCADModel::test(){
    qDebug() << "test ToyCAD model";
}
!@hash[]!@file[]./GUI/dev_dialog.cpp!@hash[]!@code[]#include "dev_dialog.h"
#include "ui_dev_dialog.h"
#include <QDebug>


DevDialog::DevDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::DevDialog)
{
    ui->setupUi(this);
    ui->checkBox_pos->setChecked(true);
}

DevDialog::~DevDialog()
{
    delete ui;
}

void DevDialog::init(FormTop *m){
    this->ft = m;
}

void DevDialog::init_opendatademo(vector<Vertex_stl> stl_vertices, MIN_MAX_XYZ ModelMinMax, vector<vector<Data_2nd>> Data_3D, int size){
    opendatademo.stl_vertices = stl_vertices;
    opendatademo.ModelMinMax = ModelMinMax;
    opendatademo.Data_3D = Data_3D;
    ui->time_slider->setMaximum(size-1);

}

void DevDialog::sendParameter(bool *is_pos_checked_, POS_MONITORING *pos_)
{
    is_pos_checked = is_pos_checked_;
    pos = pos_;
    init_check = true;
}


void DevDialog::changePos()
{
//    QString position;
//    position = "(" + QString::number(pos->x) + "," + QString::number(pos->y) + "," + QString::number(pos->z) + ")";
//    ui->label_pos->setText(position);
}

void DevDialog::on_checkBox_pos_stateChanged(int arg1)
{
    (void)arg1;
    if(init_check)
    {
        if(ui->checkBox_pos->isChecked())
        {
            *is_pos_checked = true;
        }
        else
        {
            *is_pos_checked = false;
        }
    }
}

void DevDialog::on_pushButton_initCamera_clicked()
{
    DtaoRenderSystem* renderer = getRenderer();
    renderer->initCameraView();
}

void DevDialog::on_topview_um_editingFinished()
{
    ft->m_origin_scale = 100/atof(ui->topview_um->text().toStdString().c_str());
    ft->changePos();
}

void DevDialog::on_time_slider_valueChanged(int value)
{
    //cout << value << endl;
    DtaoRenderSystem* renderer = getRenderer();

    renderer->createSTLObjects(opendatademo.getSTLVertices(),
                               opendatademo.getSTLModelMinMax(),
                               opendatademo.getOpenData(value));
}

void DevDialog::on_playbtn_clicked()
{
    if(ui->time_slider->value()+1 == 5){
        ui->time_slider->setValue(0);
    }else{
        ui->time_slider->setValue(ui->time_slider->value()+1);
    }
}

!@hash[]!@file[]./GUI/formhier.cpp!@hash[]!@code[]#include "formhier.h"
#include "ui_formhier.h"
#include "mainwindow.h"
#include "Rendering/Src/LayoutPEXData.h"
#include "Rendering/Src/lve_model.hpp"

FormHier::FormHier(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormHier)
{
    ui->setupUi(this);

}

FormHier::~FormHier()
{
    delete ui;
}

void FormHier::createHierarchyTree(T2D *t2d){

    this->t2d = t2d;
    vector<QTreeWidgetItem*> m_buf_tree_item;
    QTreeWidgetItem* m_top_tree = new QTreeWidgetItem(ui->hierarchy_tree);
    m_buf_tree_item.resize(99);
    m_buf_tree_item[0] = m_top_tree;
    string m_top_cell_name = this->t2d->HierarchyInstance[0].name + " (" + this->t2d->HierarchyInstance[0].num + ") ";
    m_top_tree->setText(0, QString::fromStdString(m_top_cell_name));
    m_top_tree->setText(1, QString::fromStdString(to_string(0)));
    ui->hierarchy_tree->addTopLevelItem(m_top_tree);

    for(unsigned int i = 1 ; i < t2d->HierarchyInstance.size() ; i++){
        int m_level = t2d->HierarchyInstance[i].level;
        string m_cell_name = t2d->HierarchyInstance[i].name + " (" + t2d->HierarchyInstance[i].num + ") ";

        QTreeWidgetItem* m_child_tree = new QTreeWidgetItem();
        m_child_tree->setText(0, QString::fromStdString(m_cell_name));
        m_child_tree->setText(1, QString::fromStdString(to_string(i)));
        m_buf_tree_item[m_level] = m_child_tree;

        m_buf_tree_item[m_level - 1]->addChild(m_child_tree);
    }
}

void FormHier::receivePointPos(POS_MONITORING &pos)
{
    this->pos_ptr = &pos;
}


void FormHier::on_hierarchy_tree_itemDoubleClicked(QTreeWidgetItem *item, int column)
{
    cout << "minx : " << this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.minx;
    cout << " miny : " << this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.miny;
    cout << " maxx : " << this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.maxx;
    cout << " maxy : " << this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.maxy << endl;

    pos_ptr->x = (this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.minx + this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.maxx)/2;
    pos_ptr->y = (this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.miny + this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.maxy)/2;
    emit signalDirectlyInputPos();
}

void FormHier::on_hierarchy_searching_textEdited(const QString &arg1)
{
//    QString m_input_text = ui->hierarchy_searching->text();
//    QList<QTreeWidgetItem*> m_all_list = ui->hierarchy_tree->findItems("", Qt::MatchContains | Qt::MatchRecursive, 0);
//    if(m_input_text != ""){
//        for (QTreeWidgetItem *item : m_all_list) {
//            item->setTextColor(0, Qt::black);
//        }
//        QList<QTreeWidgetItem*> clist = ui->hierarchy_tree->findItems(m_input_text, Qt::MatchContains | Qt::MatchRecursive, 0);
//        ui->hierarchy_tree->clear();
//        for (QTreeWidgetItem *item : clist) {
//            item->setTextColor(0, Qt::red);
//        }
//    }else{
//        for (QTreeWidgetItem *item : m_all_list) {
//            item->setTextColor(0, Qt::black);
//        }
//    }

//    QTreeWidgetItemIterator it(ui->hierarchy_tree);
//    while(*it){
//        if((*it)->text(0).contains(arg1, Qt::CaseInsensitive)){
//            (*it)->setHidden(false);
//        }else{
//            (*it)->setHidden(true);
//        }
//        ++it;
//    }

//    QSortFilterProxyModel* m_tree_model = new QSortFilterProxyModel(this);
//    m_tree_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
//    m_tree_model->setSourceModel(ui->hierarchy_tree->model());
//    ui->hierarchy_tree->setModel(m_tree_model);

//    m_tree_model->setFilterRegExp(QRegExp(arg1, Qt::CaseInsensitive, QRegExp::FixedString));
    QString m_hierarchy_searching_text = arg1;

    if(m_hierarchy_searching_text.contains('*')){
        m_hierarchy_searching_text.replace("*", ".*", Qt::CaseInsensitive);
        QRegExp m_regex(m_hierarchy_searching_text, Qt::CaseInsensitive);
        QTreeWidgetItemIterator it(ui->hierarchy_tree);
        while(*it){
            if(m_regex.exactMatch((*it)->text(0))){
                QTreeWidgetItem* item = *it;
                while(item){
                    item->setExpanded(true);
                    item->setHidden(false);
                    item = item->parent();
                }
            }else{
                (*it)->setHidden(true);
            }
            ++it;
        }
    } else{
        QTreeWidgetItemIterator it(ui->hierarchy_tree);
        while(*it){
            if((*it)->text(0).contains(m_hierarchy_searching_text, Qt::CaseInsensitive)){
                QTreeWidgetItem* item = *it;
                while(item){
                    item->setExpanded(true);
                    item->setHidden(false);
                    item = item->parent();
                }
            }else{
                (*it)->setHidden(true);
            }
            ++it;
        }
    }
}

!@hash[]!@file[]./GUI/forminfo.cpp!@hash[]!@code[]#include "forminfo.h"
#include "ui_forminfo.h"
#include <QDebug>
#include <QPushButton>
#include "cmath"
#include "defineParam.h"
#include <string>
#include <QDoubleValidator>
#include <QIntValidator>


FormInfo::FormInfo(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormInfo)
{
    ui->setupUi(this);    

    //숫자 제약 설정
    QDoubleValidator *validator_pos = new QDoubleValidator(-9999.0,9999.0,4,this);
    QDoubleValidator *validator_tilt = new QDoubleValidator(-90,90,1,this);
    QDoubleValidator *validator_rot = new QDoubleValidator(-360,360,1,this);
    QDoubleValidator *validator_zoom = new QDoubleValidator(0,9999.0,4,this);
    ui->pos_x       ->setValidator(validator_pos);
    ui->pos_y       ->setValidator(validator_pos);
    ui->pos_z       ->setValidator(validator_pos);
    ui->ang_tilt    ->setValidator(validator_tilt);
    ui->ang_rotation->setValidator(validator_rot);
    ui->zoom        ->setValidator(validator_zoom);

    this->setEnabled(false);
    //edit 값 초기화
    setTextPosTotal(&TEMP_POS);
}

FormInfo::~FormInfo()
{
    delete ui;
}

void FormInfo::setTextPosTotal(POS_MONITORING *pos)
{
    if(isFileOpen)
    {
        double rot = pos->rotation;
        if (rot <-180) {
            rot = rot+360;
        }
        rot = round(rot*100)/100;
        QString str_rot = QString::number(rot);
        setTextTrim(ui->pos_x, &pos->x, 4 ,1, "");
        setTextTrim(ui->pos_y, &pos->y, 4, 1, "");
        setTextTrim(ui->pos_z, &pos->z, 4, 1, "");
        setTextTrim(ui->ang_tilt, &pos->tilt, 2, 1, "");
        setTextTrim(ui->ang_rotation, str_rot);
        setTextTrim(ui->zoom, &pos->zoom, 4, 100, "%");
    }
    else
    {
        setTextTrim(ui->pos_x, "");
        setTextTrim(ui->pos_y, "");
        setTextTrim(ui->pos_z, "");
        setTextTrim(ui->ang_tilt, "");
        setTextTrim(ui->ang_rotation, "");
        setTextTrim(ui->zoom, "");
    }
}

void FormInfo::receiveFile(T2D &t2d)
{
    isFileOpen = true;
    rendering_full = &t2d;
    this->setEnabled(true);
}

void FormInfo::receivePointPos(POS_MONITORING &pos)
{
    this->POS = &pos;
    TEMP_POS = pos;         //TEMP_POS 역할 : enter 를 누르기 전까지 값을 갖고 있는 저장소
}

void FormInfo::changePos()
{
    if (isEndedEdit)
    {
        TEMP_POS = *POS;
        setTextPosTotal(POS);
    }
}

void FormInfo::addItemToPosList(POS_SET *position_item)    //POS_STACK 에 position 넣기
{
    POS_STACK.push_back(*position_item);
    item_data_i = POS_STACK.size() - 1 ;
    addItemToListWidget();
}

void FormInfo::addItemToListWidget()
{
    QListWidgetItem *widgetItem = new QListWidgetItem(QString::fromStdString(POS_STACK[item_data_i].name),ui->listWidget);
    widgetItem->setFlags (widgetItem->flags() | Qt::ItemIsEditable);
    widgetItem->setData(Qt::UserRole,item_data_i);
}

void FormInfo::setTextTrim(QLineEdit *text, double *value, int decimals_, int scale_, QString add_text_)
{
    text->setText(QString::number(round(*value*pow(10,decimals_))/(pow(10,decimals_))*scale_)+add_text_);
}

void FormInfo::setTextTrim(QLineEdit *text, QString text_)
{
    text->setText(text_);
}

void FormInfo::makePosListItem()
{
    std::string temp_str = "position";
    pos_number += 1;
    temp_str.append(to_string(pos_number));
    POS_SET TEMP;
    TEMP.name = temp_str;
    TEMP.position = *POS;
    addItemToPosList(&TEMP);
}

QString FormInfo::makePosText()
{
    QString msg;
    if(current_item != -1 && make_status_bar_msg)
    {
        int i = ui->listWidget->currentItem()->data(Qt::UserRole).toInt();
        msg =       QString::fromStdString(POS_STACK[i].name) + " :"
        + " ( " +      QString::number(POS_STACK[i].position.x) + ", "
        +              QString::number(POS_STACK[i].position.y) + ", "
        +              QString::number(POS_STACK[i].position.z) + " )"
        + " tilt : " + QString::number(POS_STACK[i].position.tilt)
        + " rot : "  + QString::number(POS_STACK[i].position.rotation)
        + " zoom : " + QString::number(POS_STACK[i].position.zoom * 100) + "%";
    }
    else{
        msg = "";
    }
    return msg;
}

void FormInfo::sendStatusBarMsg(QString msg)
{
    signalStatusBarMsg(msg);

}

void FormInfo::inputValueToTemp(double *point, double value_)
{
    *point = value_;
}

void FormInfo::convertTextToValue(double *point, const QString &arg1)
{
    double double_arg = arg1.toDouble();
    inputValueToTemp(point, double_arg);
}

void FormInfo::inputPos()       //직접 입력한 값을 POS 구조체에 넣음
{
    if(isFileOpen)
    {
        isEndedEdit = false;
        *POS = TEMP_POS;
        emit signalDirectlyInputPos();
        makePosListItem();
        isEndedEdit = true;
    }
}

//입력이 들어왔을 때
void FormInfo::on_pos_x_textEdited(const QString &arg1)         {convertTextToValue(&TEMP_POS.x,arg1);}
void FormInfo::on_pos_y_textEdited(const QString &arg1)         {convertTextToValue(&TEMP_POS.y,arg1);}
void FormInfo::on_pos_z_textEdited(const QString &arg1)         {convertTextToValue(&TEMP_POS.z,arg1);}
void FormInfo::on_ang_tilt_textEdited(const QString &arg1)      {convertTextToValue(&TEMP_POS.tilt,arg1);}
void FormInfo::on_ang_rotation_textEdited(const QString &arg1)  {convertTextToValue(&TEMP_POS.rotation,arg1);}
void FormInfo::on_zoom_textEdited(const QString &arg1)
{   //zoom 은 100% 일 경우 1 값을 넣어야 하기 때문에 따로 처리
    double double_arg = arg1.toDouble();
    double_arg = double_arg/100;
    inputValueToTemp(&TEMP_POS.zoom,double_arg);
}

//enter 가 눌리거나 focus 를 잃을 때 TEMP_POS 에 있는 값을 출력함
void FormInfo::on_pos_x_editingFinished()       {setTextTrim(ui->pos_x, &TEMP_POS.x, 4, 1, "");}
void FormInfo::on_pos_y_editingFinished()       {setTextTrim(ui->pos_y, &TEMP_POS.y, 4, 1, "");}
void FormInfo::on_pos_z_editingFinished()       {setTextTrim(ui->pos_z, &TEMP_POS.z, 4, 1, "");}
void FormInfo::on_ang_tilt_editingFinished()    {setTextTrim(ui->ang_tilt, &TEMP_POS.tilt, 2, 1, "");}
void FormInfo::on_ang_rotation_editingFinished(){setTextTrim(ui->ang_rotation, &TEMP_POS.rotation, 2, 1, "");}
void FormInfo::on_zoom_editingFinished()        {setTextTrim(ui->zoom, &TEMP_POS.zoom, 4, 100, "%");}

//enter 를 눌렀을 때 TEMP_POS 에 있는 값을 POS 에 넣고 List 를 만듬
void FormInfo::on_pos_x_returnPressed()         {inputPos();}
void FormInfo::on_pos_y_returnPressed()         {inputPos();}
void FormInfo::on_pos_z_returnPressed()         {inputPos();}
void FormInfo::on_ang_tilt_returnPressed()      {inputPos();}
void FormInfo::on_ang_rotation_returnPressed()  {inputPos();}
void FormInfo::on_zoom_returnPressed()          {inputPos();}


void FormInfo::on_listWidget_currentRowChanged(int currentRow)
{
    if(isDeleting == false)
    {
        current_item = currentRow;
        sendStatusBarMsg(makePosText());
    }
}

void FormInfo::on_pushButton_go_clicked()
{
    if(current_item != -1)
    {
        int i = ui->listWidget->currentItem()->data(Qt::UserRole).toInt();
        *POS = POS_STACK[i].position;
        emit signalDirectlyInputPos();
        qDebug() << "GO  : " << ui->listWidget->currentItem()->text() << "data : " << ui->listWidget->currentItem()->data(Qt::UserRole).toInt();
    }
}

void FormInfo::on_pushButton_add_clicked()
{
    inputPos();
}

void FormInfo::on_pushButton_del_clicked()
{
    isDeleting = true;
    if(current_item != -1)
    {
//        qDebug() << "    all item";
//        for (int i = 0; i < ui->listWidget->count(); i++)
//        {
//            qDebug() << "a : " << i << "item name : "<< ui->listWidget->item(i)->text() << "number" << ui->listWidget->item(i)->data(Qt::UserRole).toInt() ;
//        }
        make_status_bar_msg = false;        //삭제 과정에서 msg 보내지 않도록 방지 : segment fault error 발생

        for (auto item : selected_item)
        {
            int i = ui->listWidget->row(item);
            ui->listWidget->takeItem(i);
        }

        make_status_bar_msg = true;         //msg 보내는 것 원복
        isDeleting = false;
        QString msg = "Deleted Items";
        sendStatusBarMsg(msg);                 //msg 출력
    }
}

void FormInfo::on_listWidget_itemChanged(QListWidgetItem *item)
{
    if(isDeleting == false)
    {
        POS_STACK[item->data(Qt::UserRole).toInt()].name = item->text().toStdString();
        sendStatusBarMsg(makePosText());
    }
}


void FormInfo::on_listWidget_itemSelectionChanged()
{
    if(isDeleting == false)
    {
        selected_item = ui->listWidget->selectedItems();
        int sel_item = selected_item.size();

        if(sel_item > 1)
        {
            sendStatusBarMsg("selected " + QString::number(sel_item) + " items");
        }
    }
}


!@hash[]!@file[]./GUI/formlayer.cpp!@hash[]!@code[]#include "formlayer.h"
#include "ui_formlayer.h"
#include "Rendering/Src/dtaorendersystem.h"
#include "Rendering/Src/lve_model.hpp"
#include <string>
#include <QRgba64>



FormLayer::FormLayer(LveWindow *w, QWidget *parent) :
    QDialog(parent), m_window(w),
    ui(new Ui::FormLayer)
{
    ui->setupUi(this);
    MakeLayerInformationTableHeader();
}

FormLayer::~FormLayer()
{
    delete ui;
}

void FormLayer::ReceiveLayerInformation(T2D &t2d)
{
    ui->tableWidget->clearContents();
    t2d_layer_information = &t2d;
    MakeLayerInformationTableHeader();
    MakeLayerInformationTalbe();
}

void FormLayer::MakeLayerInformationTalbe()
{
    // QTableWidget 크기 설정
    ui->tableWidget->setColumnCount(table_default_column);
    ui->tableWidget->setRowCount(t2d_layer_information->LayoutData10by10.size()+1);
    ui->tableWidget->setColumnWidth(5,80);

    // Table 채우기
    for (unsigned int i=1; i <= t2d_layer_information->LayoutData10by10.size() ; i++)
    {
        MakeTableWidgetItemForText(i);
        MakeCheckBox(i);
        MakeColorButton(i);
        MakeSliderForOpacity(i);
    }
    MakeHeaderCheckBoxAndSlider();

    // Table Edit 금지, 다중 선택 금지
    ui->tableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);
    ui->tableWidget->setSelectionMode(QAbstractItemView::SingleSelection);
}

void FormLayer::on_checkboxInTable_stateChanged()
{
    int checkboxrow = -1;
    QCheckBox *checkboxInTable = qobject_cast<QCheckBox*>(sender());
    if (!checkboxInTable)
        return;

    checkboxrow = FindCheckBoxRow(checkboxInTable);

    if (checkboxrow == 0) {
        ChangeAllCheckBoxState(checkboxInTable);
        return;
    }

    // selected checkbox layer name
    QTableWidgetItem *readcheckbox = ui->tableWidget->item(checkboxrow,2);
    QString selectedLayer = readcheckbox->text();
    QString printLayer = "selectedLayer = " + selectedLayer;

    // selected checkbox layer num
    QTableWidgetItem *ReadLayerNumber = ui->tableWidget->item(checkboxrow,3);
    QTableWidgetItem *ReadDataType = ui->tableWidget->item(checkboxrow,4);
    string LayerNumber =ReadLayerNumber->text().toStdString() + "." + ReadDataType->text().toStdString();

    if (checkboxInTable->isChecked()) {
        ChangeCheckBoxStateToOn(checkboxrow, LayerNumber, printLayer);
    } else {
        ChangeCheckBoxStateToOff(checkboxrow, LayerNumber, printLayer);
    }
}

void FormLayer::on_colorbutton_clicked()
{
    QString OldLayerColorRed = "";
    QString OldLayerColorGreen = "";
    QString OldLayerColorBlue = "";
    QString OldLayerColorAlpha = "";
    int OldLayerColorRedNum = 0;
    int OldLayerColorGreenNum = 0;
    int OldLayerColorBlueNum = 0;
    int OldLayerColorAlphaNum = 0;
    //QRgb orc = qRgba(0, 0, 0, 0);
    QRgba64 orc64 = QRgba64::fromRgba64(0,0,0,0);

    QPushButton *ColorCheckButton = qobject_cast<QPushButton*>(sender());

    int colorbuttonRow = ui->tableWidget->currentRow();
    data_row_for_t2d = colorbuttonRow-1;

    GetPushButtonOldColor(ColorCheckButton, &OldLayerColorRedNum,
                          &OldLayerColorGreenNum, &OldLayerColorBlueNum, &OldLayerColorAlphaNum,
                          &orc64);
    EnterPushButtonNewColor(&colorbuttonRow, &orc64);
}

void FormLayer::on_opacityslider_valueChanged(int Opacity)
{
    // ui->tableWidget->currentRow() 로 찾으려고 하면, current row 가 -1 로 나옴
    int sliderrow = -1;
    int sliderrow_for_t2d = -1;
    QString LayerColorname;
    QString LayerColorText;
    QSlider *OpacityInTalbe = qobject_cast<QSlider*>(sender());

    for (int i = 0; i < ui->tableWidget->rowCount(); i++) {
        QWidget *widget = ui->tableWidget->cellWidget(i, 5);
        QSlider *slider = widget->findChild<QSlider*>();

        if (slider == OpacityInTalbe) {
            sliderrow = i;
            sliderrow_for_t2d = sliderrow-1;
            if (sliderrow == 0){
                for (int k=1; k < ui->tableWidget->rowCount(); k++) {
                    QWidget *SliderChangeWidget = ui->tableWidget->cellWidget(k, 5);
                    QSlider *SliderChange = SliderChangeWidget->findChild<QSlider*>();
                    SliderChange->setValue(Opacity);
                    t2d_layer_information->LayoutData10by10[sliderrow_for_t2d].color.a = Opacity;
                    emit outputLayerStatus(empty_for_emit);
                }
            } else {
                QTableWidgetItem *ReadLayer = ui->tableWidget->item(sliderrow,2);
                QString selectedLayer = ReadLayer->text();
                QString printLayer = "selectedLayer = " + selectedLayer;
                printLayer = printLayer + "  Layer  Opacity = " + QString::number(Opacity);
                QString OldColorStyleSheet = ui->tableWidget->cellWidget(sliderrow,1)->styleSheet();
                QStringList splittext = OldColorStyleSheet.split("(");
                QString splitrgbtemp = splittext[1].remove(")");
                QStringList splitrgb = splitrgbtemp.split(",");

                QString OldLayerColorRed = splitrgb[0];
                QString OldLayerColorGreen = splitrgb[1];
                QString OldLayerColorBlue = splitrgb[2];
                QString OldLayerColorAlpha = QString::number(Opacity);

                LayerColorText = "background-color: rgba(" + OldLayerColorRed;
                LayerColorText = LayerColorText + "," + OldLayerColorGreen + "," + OldLayerColorBlue + "," + OldLayerColorAlpha + ")";
                ui->tableWidget->cellWidget(sliderrow,1)->setStyleSheet(LayerColorText);
                t2d_layer_information->LayoutData10by10[sliderrow_for_t2d].color.a = Opacity;
                emit outputLayerStatus(printLayer);

                QTableWidgetItem *ReadLayerNumber = ui->tableWidget->item(sliderrow,3);
                QTableWidgetItem *ReadDataType = ui->tableWidget->item(sliderrow,4);
                string LayerNumber =ReadLayerNumber->text().toStdString() + "." + ReadDataType->text().toStdString();
                DtaoRenderSystem *renderer = this->m_window->getRenderer();
                renderer->getCustomOpacity(LayerNumber,Opacity/(float)255);
            }
            break;
        }
    }
}

void FormLayer::OpacitySliderValueChange(int OpacityValue){
    (void)OpacityValue;
    //qDebug() << "test number ======================================= " << OpacityValue;
    emit outputLayerStatus(empty_for_emit);
}

void FormLayer::MakeLayerInformationTableHeader(){
    QString TalbeHeader[] = {"","Color","Layer\nName","Layer\nNum","Layer\nType","Opacity\n"};
    ui->tableWidget->setColumnCount(6);
    ui->tableWidget->setRowCount(10);
    ui->tableWidget->setColumnWidth(0,20);
    ui->tableWidget->setColumnWidth(1,40);
    ui->tableWidget->setColumnWidth(2,40);
    ui->tableWidget->setColumnWidth(3,40);
    ui->tableWidget->setColumnWidth(4,40);
    ui->tableWidget->setColumnWidth(5,60);

    /// TableWidget Title Format 설정
    QBrush brush(QColor(255, 255, 255, 255));
    brush.setStyle(Qt::SolidPattern);
    QFont font;
    font.setPointSize(8);
    font.setBold(true);
    font.setWeight(55);

    /// TableWidget Title 입력 및 반영
    for (int i=1; i<6; i++){
        QTableWidgetItem *TableHeaderItem = new QTableWidgetItem;
        TableHeaderItem->setText(TalbeHeader[i]);
        TableHeaderItem->setTextAlignment(Qt::AlignCenter);
        TableHeaderItem->setFont(font);
        TableHeaderItem->setForeground(brush);
        ui->tableWidget->setItem(0,i,TableHeaderItem);
        ui->tableWidget->setRowHeight(0,50);
        ui->tableWidget->item(0,i)->setBackground(QBrush(QColor(100,100,100)));
    }
}

void FormLayer::MakeTableWidgetItemForText(int table_row){
    data_row_for_t2d = table_row-1;
    QTableWidgetItem *tableitem_name = new QTableWidgetItem;
    QTableWidgetItem *tableitem_num = new QTableWidgetItem;
    QTableWidgetItem *tableitem_type = new QTableWidgetItem;

    tableitem_name->setText(t2d_layer_information->LayoutData10by10[data_row_for_t2d].layername.c_str());
    tableitem_num->setText(QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].layernum));
    tableitem_type->setText(QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].datatype));

    tableitem_name->setTextAlignment(Qt::AlignCenter);
    tableitem_num->setTextAlignment(Qt::AlignCenter);
    tableitem_type->setTextAlignment(Qt::AlignCenter);

    ui->tableWidget->setItem((table_row),2,tableitem_name);
    ui->tableWidget->setItem((table_row),3,tableitem_num);
    ui->tableWidget->setItem((table_row),4,tableitem_type);
}

void FormLayer::MakeSliderForOpacity(int table_row){
    data_row_for_t2d = table_row-1;
    QSlider *OpacitySlider = new QSlider(Qt::Horizontal);
    QWidget *OpacitySliderWidget = new QWidget();
    OpacitySlider->setRange(0,255);
    OpacitySlider->setValue(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a);
    OpacitySlider->setFocusPolicy(Qt::StrongFocus);
    QHBoxLayout *OpacityLayout = new QHBoxLayout(OpacitySliderWidget);
    OpacityLayout->addWidget(OpacitySlider);
    OpacitySliderWidget->setLayout(OpacityLayout);
    ui->tableWidget->setCellWidget(table_row, 5, OpacitySliderWidget);
    QObject::connect(OpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(on_opacityslider_valueChanged(int)));
}

void FormLayer::MakeCheckBox(int table_row){
    data_row_for_t2d = table_row-1;
    QCheckBox *checkBoxItem = new QCheckBox();
    checkBoxItem->setCheckState(Qt::Unchecked);
    QWidget *checkboxWidget = new QWidget();
    QHBoxLayout *checkboxLayout = new QHBoxLayout(checkboxWidget);
    checkboxLayout->addWidget(checkBoxItem);
    checkboxLayout->setAlignment(Qt::AlignCenter);
    checkboxLayout->setContentsMargins(0,0,0,0);
    checkboxWidget->setLayout(checkboxLayout);
    ui->tableWidget->setCellWidget(table_row,0,checkboxWidget);
    QObject::connect(checkBoxItem, SIGNAL(stateChanged(int)), this, SLOT(on_checkboxInTable_stateChanged()));
}

void FormLayer::MakeColorButton(int table_row){
    QString LayerColorRed;
    QString LayerColorGreen;
    QString LayerColorBlue;
    QString LayerColorAlpha;
    QString LayerColorText;
    data_row_for_t2d = table_row-1;
    // Layer color rgb defalut value
    int DefaultRedColor = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.r;
    int DefaultGreenColor = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.g;
    int DefaultBlueColor = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.b;
    int DefaultAlpha = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a;
    QColor DefaultColor = QColor(DefaultRedColor, DefaultGreenColor, DefaultBlueColor, DefaultAlpha);
    (void)(DefaultColor);

    // Layer color rgb defalut value
    LayerColorRed = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.r);
    LayerColorGreen = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.g);
    LayerColorBlue = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.b);
    LayerColorAlpha = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a);

    LayerColorText = "background-color: rgba(" + LayerColorRed;
    LayerColorText = LayerColorText + "," + LayerColorGreen + "," + LayerColorBlue + "," + LayerColorAlpha + ")";

    // color pushbutton 채우기
    QPushButton *colorbutton = new QPushButton();
    colorbutton->setStyleSheet(LayerColorText);
    ui->tableWidget->setCellWidget(table_row,1,colorbutton);
    QObject::connect(colorbutton, SIGNAL(clicked()), this, SLOT(on_colorbutton_clicked()));
}

void FormLayer::MakeHeaderCheckBoxAndSlider(){
    //tableWidget title 에 checkbox
    QCheckBox *checkBoxItem = new QCheckBox();
    checkBoxItem->setCheckState(Qt::Unchecked);
    QWidget *checkboxWidget = new QWidget();
    QHBoxLayout *checkboxLayout = new QHBoxLayout(checkboxWidget);
    checkboxLayout->addWidget(checkBoxItem);
    checkboxLayout->setAlignment(Qt::AlignCenter);
    checkboxLayout->setContentsMargins(0,0,0,0);
    checkboxWidget->setLayout(checkboxLayout);
    ui->tableWidget->setCellWidget(0,0,checkboxWidget);
    QObject::connect(checkBoxItem, SIGNAL(stateChanged(int)), this, SLOT(on_checkboxInTable_stateChanged()));

    //tableWidget title 에 slider
    QSpacerItem *HeaderVerticalSpacer = new QSpacerItem(0,20,QSizePolicy::Fixed, QSizePolicy::Fixed);
    QSlider *HeaderOpacitySlider = new QSlider();
    HeaderOpacitySlider->setOrientation(Qt::Horizontal);
    HeaderOpacitySlider->setRange(0,255);
    HeaderOpacitySlider->setValue(200);
    QWidget *HeaderSliderWidget = new QWidget();
    QVBoxLayout *HeaderSliderLayout = new QVBoxLayout(HeaderSliderWidget);
    HeaderSliderLayout->addItem(HeaderVerticalSpacer);
    HeaderSliderLayout->addWidget(HeaderOpacitySlider);
    HeaderSliderWidget->setLayout(HeaderSliderLayout);
    ui->tableWidget->setCellWidget(0,5,HeaderSliderWidget);
    QObject::connect(HeaderOpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(on_opacityslider_valueChanged(int)));
}

int FormLayer::FindCheckBoxRow(QCheckBox *checkBoxInCell){
    QCheckBox &temp = *checkBoxInCell;
    for (int i = 0; i < ui->tableWidget->rowCount(); i++) {
        QWidget *widget = ui->tableWidget->cellWidget(i, 0);
        QCheckBox *checkbox = widget->findChild<QCheckBox*>();
        if (checkbox == &temp) {
            checkboxrow = i;
            break;
        }
    }
    return checkboxrow;
}

void FormLayer::ChangeAllCheckBoxState(QCheckBox *checkBoxInCell){
    this->m_layer_all_check = true;
    QString bufcmdtext;
    if (checkBoxInCell->isChecked()) {
        for (int i = 1; i < ui->tableWidget->rowCount(); i++) {
            data_row_for_t2d = i-1;
            QWidget *widget = ui->tableWidget->cellWidget(i, 0);
            QCheckBox *checkbox = widget->findChild<QCheckBox*>();
            checkbox->setCheckState(Qt::Checked);
            t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = true;
        }
        //qDebug() << "All Layer Checkbox Checked.";
        //emit outputLayerStatus(CommentAllCheckedCheckBox);
        bufcmdtext = CommentAllCheckedCheckBox;

    } else {
        for (int i = 1; i < ui->tableWidget->rowCount(); i++) {
            data_row_for_t2d = i-1;
            QWidget *widget = ui->tableWidget->cellWidget(i, 0);
            QCheckBox *checkbox = widget->findChild<QCheckBox*>();
            checkbox->setCheckState(Qt::Unchecked);
            t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = false;
        }
        //qDebug() << "All Layer Checkbox Unchecked.";
        //emit outputLayerStatus(CommentAllUncheckedCheckBox);
        bufcmdtext = CommentAllUncheckedCheckBox;
    }
    this->m_layer_all_check = false;
    emit outputLayerStatus(bufcmdtext);
}

void FormLayer::ChangeCheckBoxStateToOn(int check_box_row, string layer_num, QString print_comment){
    data_row_for_t2d = check_box_row-1;
    DtaoRenderSystem *renderer = this->m_window->getRenderer();
    renderer->getCustomVisiblity(layer_num, true);
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = true;
    print_comment = print_comment + "  Layer  On";
    emit outputLayerStatus(print_comment);
}

void FormLayer::ChangeCheckBoxStateToOff(int check_box_row, string layer_num, QString print_comment){
    data_row_for_t2d = check_box_row-1;
    DtaoRenderSystem *renderer = this->m_window->getRenderer();
    renderer->getCustomVisiblity(layer_num, false);
    print_comment = print_comment + "  Layer  Off";
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = false;
    emit outputLayerStatus(print_comment);
}

void FormLayer::GetPushButtonOldColor(
        QPushButton *old_push_button,
        int *oldred, int *oldgreen, int *oldblue, int *oldalpha, QRgba64 *oldrgba){
    QPushButton &oldcolor = *old_push_button;
    QString OldColorStyleSheet = oldcolor.styleSheet();
    QStringList splittext = OldColorStyleSheet.split("(");
    QString splitrgbtemp = splittext[1].remove(")");
    QStringList splitrgb = splitrgbtemp.split(",");

    QString OldLayerColorRed = splitrgb[0];
    QString OldLayerColorGreen = splitrgb[1];
    QString OldLayerColorBlue = splitrgb[2];
    QString OldLayerColorAlpha = splitrgb[3];

    *oldred = OldLayerColorRed.toInt();
    *oldgreen = OldLayerColorGreen.toInt();
    *oldblue = OldLayerColorBlue.toInt();
    *oldalpha = OldLayerColorAlpha.toInt();
    *oldrgba = QRgba64::fromRgba64(*oldred, *oldgreen, *oldblue, *oldalpha);
}

void FormLayer::EnterPushButtonNewColor(int *selected_color_button_row, QRgba64 *oldrgba){
    QString LayerColorText;
    int NewColorRed{}, NewColorGreen{}, NewColorBlue{}, NewColorAlpha{};
    QColor chc = QColorDialog::getColor(QColor(*oldrgba));
    chc.getRgb(&NewColorRed, &NewColorGreen, &NewColorBlue, &NewColorAlpha);


    LayerColorText = "background-color: rgba(" + QString::number(NewColorRed);
    LayerColorText = LayerColorText + "," + QString::number(NewColorGreen) + "," + QString::number(NewColorBlue) + "," + QString::number(NewColorAlpha) + ")";
    ui->tableWidget->cellWidget(*selected_color_button_row,1)->setStyleSheet(LayerColorText);

    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.r = NewColorRed;
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.g = NewColorGreen;
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.b = NewColorBlue;
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a = NewColorAlpha;



    string LayerNumber = ui->tableWidget->item(*selected_color_button_row,3)->text().toStdString() + "." + ui->tableWidget->item(*selected_color_button_row,4)->text().toStdString();
    DtaoRenderSystem *renderer = this->m_window->getRenderer();
    renderer->getCustomColor(LayerNumber,
                             glm::vec3 {
                                 NewColorRed/(float)255,
                                 NewColorGreen/(float)255,
                                 NewColorBlue/(float)255});

    emit outputLayerStatus(empty_for_emit);

    QWidget *SliderChangeWidget = ui->tableWidget->cellWidget(*selected_color_button_row, 5);
    QSlider *SliderChange = SliderChangeWidget->findChild<QSlider*>();
    SliderChange->setValue(NewColorAlpha);
}
!@hash[]!@file[]./GUI/formmap.cpp!@hash[]!@code[]#include "formmap.h"
#include "ui_formmap.h"
#include <QGraphicsItem>
#include <QGraphicsRectItem>
#include <QVector>
#include <iostream>
#include <QDebug>
#include <QRect>
#include <QKeyEvent>
#include <QGraphicsView>

SuperItem::SuperItem(QGraphicsItem* parent) : QGraphicsItem(parent)
{
//    setFlag(QGraphicsItem::ItemIsMovable);
    setFlag(QGraphicsItem::ItemSendsGeometryChanges);
}

void SuperItem::getScaleValue(double *m_scale_, double *m_from_window_to_box_x_, double *m_from_window_to_box_y_, double *m_min_x_, double *m_min_y_, double *m_zoom_init_)
{
    m_scale = m_scale_;
    m_from_window_to_box_x = m_from_window_to_box_x_;
    m_from_window_to_box_y = m_from_window_to_box_y_;
    m_min_x = m_min_x_;
    m_min_y = m_min_y_;
    m_zoom_init = m_zoom_init_;
}

void SuperItem::slotMove(POS_MONITORING *pos_)
{
    //emit signalInitMove(window_width/2,-window_height/2);
    pos = pos_;
    double delta_x = (pos->x - convertPosX()) * (*m_scale);
    double delta_y = (pos->y - convertPosY()) * (*m_scale);
    double rot = 360 - pos->rotation;

    if (abs(delta_x) >__DBL_EPSILON__ || abs(delta_y) > __DBL_EPSILON__) // 0보다 크면
    {
        moveBy(delta_x, -1 * delta_y);             
    }

    QTransform trans;
    trans.rotate(rot);

    // m_zoom_init = 1um / height;
    // trans.scale = 1 um / height / pos->zoom = 1 um / height / (1 um / now_height) = now_height / height

    trans.scale((*m_zoom_init)/pos->zoom, ((*m_zoom_init)/pos->zoom) * (pos->tilt / 90));
      //zoom 초기가 25%면 ..
    setTransform(trans);
}

void SuperItem::slotMouseReleaseEvent()
{
    pos->x = convertPosX();
    pos->y = convertPosY();
    emit signalDirectlyInputPos();
}

void SuperItem::slotMouseMoveEvent(QPointF event)
{    
    double delta_x = event.x() - this->x();
    double delta_y = event.y() - this->y();

    if (abs(delta_x) >__DBL_EPSILON__ || abs(delta_y) > __DBL_EPSILON__) // 0보다 크면
    {
        moveBy(delta_x, delta_y);
    }
}

void SuperItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{    
    (void)option;
    (void)widget;
    painter->setPen(Qt::red);
    painter->drawRoundedRect(-60,-60,120,120,5,5);
    painter->setPen(Qt::blue);
    painter->drawLine(-60,-60,60,-60);
}

QRectF SuperItem::boundingRect() const{ // 나중에 이해를 위한 도움 요청 필요    
    return QRectF(-61,-61,122,122);
}

QVariant SuperItem::itemChange(GraphicsItemChange change, const QVariant &value)
{
    if(change == ItemPositionChange)
    {
        QPointF newPos = value.toPointF();        
        return QGraphicsItem::itemChange(change, newPos);
    }
    return QGraphicsItem::itemChange(change, value);
}

double SuperItem::convertPosX()
{
    return (this->x() - (*m_from_window_to_box_x))/(*m_scale)+(*m_min_x); // 원점이 (0,0) 이 아닐 경우 skew(m_min_x) 추가
}

double SuperItem::convertPosY()
{
    return -1 * (this->y() - (*m_from_window_to_box_y))/(*m_scale)+(*m_min_y);
}

//CustomScene

CustomScene::CustomScene(QObject *parent) : QGraphicsScene(parent)
{

}

void CustomScene::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    emit signalMouseMoveEvent(event->scenePos());
}

void CustomScene::mouseMoveEvent(QGraphicsSceneMouseEvent *event)
{
    emit signalMouseMoveEvent(event->scenePos());
}

void CustomScene::mouseReleaseEvent(QGraphicsSceneMouseEvent *)
{
    emit signalMouseReleaseEvent();
}

//FormMap

FormMap::FormMap(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormMap)
{
    ui->setupUi(this);        
}

FormMap::~FormMap()
{
    delete ui;
}

void FormMap::receiveFile(T2D &t2d)
{
    qDebug() << "receiveFile" ;
    QGraphicsRectItem *rectItem = new QGraphicsRectItem;
//    QGraphicsScene *scene = new QGraphicsScene(this);
    CustomScene *scene = new CustomScene(this);
    super = new SuperItem();
    super->getScaleValue(&m_scale, &m_from_window_to_box_x, &m_from_window_to_box_y, &m_min_x, &m_min_y, &m_zoom_init);

    m_min_x = t2d.LayoutMinMax.minx;
    m_min_y = t2d.LayoutMinMax.miny;
    double width = t2d.LayoutMinMax.maxx - t2d.LayoutMinMax.minx;
    double height = t2d.LayoutMinMax.maxy - t2d.LayoutMinMax.miny;
    m_zoom_init = 1 / height;
    m_scale = m_gray_box_size/qMax(width,height);    //가장 긴 곳을 120으로 맞춤
    double box_x_zero_point = -1 * m_scale * width /2;
    double box_y_zero_point = -1 * m_scale * height /2;
    m_box_width = m_scale * width;
    m_box_height = m_scale * height;
    m_window_width = ui->graphicsView->size().width();
    m_window_height = ui->graphicsView->size().height();
    m_from_window_to_box_x = m_window_width/2 - m_box_width/2;
    m_from_window_to_box_y = -1 * (m_window_height/2 - m_box_height/2);

    rectItem->setRect(box_x_zero_point,box_y_zero_point,m_box_width,m_box_height);
    rectItem->setBrush(QBrush(QColor(Qt::gray)));    
    rectItem->setPos(m_window_width/2,-m_window_height/2); //좌측 위 (0,0) 에서 부터 중앙으로 이동
    scene->setSceneRect(m_from_window_to_box_x,(m_from_window_to_box_y - m_box_height),m_box_width,m_box_height); //Y 좌표는 위에서 얼만큼 내려오는가 라서
    scene->addItem(rectItem);           //사각형
    scene->addItem(super);    

    QObject::connect(this,&FormMap::signalMove,super,&SuperItem::slotMove);
    QObject::connect(super,&SuperItem::signalDirectlyInputPos,this,&FormMap::slotDirectlyInputPos);
//    QObject::connect(scene,&CustomScene::signalMouseMoveEvent,this,&FormMap::mouseMoveEvent);

    QObject::connect(scene,&CustomScene::signalMouseMoveEvent,super,&SuperItem::slotMouseMoveEvent);
    QObject::connect(scene,&CustomScene::signalMouseReleaseEvent,super,&SuperItem::slotMouseReleaseEvent);



    ui->graphicsView->setScene(scene);

}

void FormMap::receivePointPos(POS_MONITORING &pos)
{
    this->pos = &pos;
}

void FormMap::changePos()
{
    emit signalMove(pos);
}

void FormMap::slotDirectlyInputPos()
{
    emit signalDirectlyInputPos();
}



!@hash[]!@file[]./GUI/formpex.cpp!@hash[]!@code[]#include "formpex.h"
#include "ui_formpex.h"
#include "mainwindow.h"
#include "Rendering/Src/LayoutPEXData.h"
#include "Rendering/Src/lve_model.hpp"
#include "Rendering/Src/dtaorendersystem.h"
#include "Rendering/Src/keyboard_movement_controller.hpp"

FormPEX::FormPEX(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormPEX)
{
    ui->setupUi(this);
}

FormPEX::~FormPEX()
{
    delete ui;
}

void FormPEX::makePEXResList(std::vector<std::vector<PEXResistor*>>* pex_res_nets_list){
    int group_num = 0;
    for (auto& res_group : *pex_res_nets_list){
        int node_num;
        node_num = res_group.size();
        QTreeWidgetItem *ResTopTree = new QTreeWidgetItem(ui->tree_pex);
        makePEXResTreeTop(ResTopTree, group_num++, node_num);

        for (auto& res_unit : res_group){
            makePEXResTreeChild(ResTopTree, *res_unit);
        }
    }
}

void FormPEX::makePEXResTreeTop(QTreeWidgetItem *ResTopTree, int group_num, int node_num){
    QString res_group_text =
            "Group_" + QString::number(group_num) + "_(" + QString::number(node_num) + ")";
    ResTopTree->setText(0,res_group_text);
    ui->tree_pex->addTopLevelItem(ResTopTree);
}

void FormPEX::makePEXResTreeChild(QTreeWidgetItem *ResTopTree, PEXResistor &pexRes){
    QTreeWidgetItem *ResChildTree = new QTreeWidgetItem();
    QString res_name_value =
            QString::fromStdString(pexRes.name)+" ("+QString::number(pexRes.value)+")";
    ResChildTree->setText(0,res_name_value);
    ResTopTree->addChild(ResChildTree);
}

void FormPEX::on_tree_pex_itemClicked(QTreeWidgetItem *item, int column){
    if (item->parent() == nullptr){
        DtaoRenderSystem* renderer = getRenderer();
        QStringList res_group_split_text = item->text(column).split("_");
        QString res_group_num = res_group_split_text[1];
        //erasePEXCapacitorModelGroup();
        drawPEXResistorModelGroup(renderer->getResistorModel(), res_group_num);
        moveToResistorGroup(renderer, res_group_num);
    }
}

void FormPEX::drawPEXResistorModelGroup(
        std::shared_ptr<PEXResistorModel>& pexResistorModel, QString res_group_num){
    pexResistorModel->makeNetRenderingData(res_group_num.toInt());
}

void FormPEX::moveToResistorGroup(DtaoRenderSystem* renderer, QString res_group_num){
    changeNaviFlag(renderer);
    changeXYCoordinate(renderer, res_group_num);
}

void FormPEX::erasePEXCapacitorModelGroup(){
    DtaoRenderSystem* renderer = getRenderer();
    MODEL_TYPE target_model_type = MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR;
    for (auto& obj : renderer->getGameObjects()) {
        if (obj.model->getModelType() == target_model_type) {
            obj.model->visible = false;
        }
    }
}

void FormPEX::on_all_view_clicked()
{
    DtaoRenderSystem* renderer = getRenderer();
    renderer->getResistorModel()->makeAllNetRenderingData();
}

void FormPEX::on_res_search_textEdited(const QString &arg1)
{
    QString res_instance_text = arg1;
    if(res_instance_text.contains('*')){
        findResistorWithAsterisk(res_instance_text);
    } else {
        findResistorWithTyping(res_instance_text);
    }
}

void FormPEX::findResistorWithAsterisk(QString asterisk_text){
    asterisk_text.replace("*", ".*", Qt::CaseInsensitive);
    QRegExp asterisk_text_reg(asterisk_text, Qt::CaseInsensitive);
    QTreeWidgetItemIterator it(ui->tree_pex);
    while(*it){
        if(asterisk_text_reg.exactMatch((*it)->text(0))){
            QTreeWidgetItem* item = *it;
            while(item){
                item->setExpanded(true);
                item->setHidden(false);
                item = item->parent();
            }
        }else{
            (*it)->setHidden(true);
        }
        ++it;
    }
}

void FormPEX::findResistorWithTyping(QString typing_text){
    QTreeWidgetItemIterator it(ui->tree_pex);
    while(*it){
        if((*it)->text(0).contains(typing_text, Qt::CaseInsensitive)){
            QTreeWidgetItem* item = *it;
            while(item){
                item->setExpanded(true);
                item->setHidden(false);
                item = item->parent();
            }
        }else{
            (*it)->setHidden(true);
        }
        ++it;
    }
}

void FormPEX::on_cap_view_button_toggled(bool checked)
{
    //qDebug() << checked;
    DtaoRenderSystem* renderer = getRenderer();
    MODEL_TYPE target_model_type = MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR;
    if(checked == true){
        for (auto& obj : renderer->getGameObjects()) {
            if (obj.model->getModelType() == target_model_type) {
                obj.model->visible = true;
            }
        }
    } else {
        for (auto& obj : renderer->getGameObjects()) {
            if (obj.model->getModelType() == target_model_type) {
                obj.model->visible = false;
            }
        }
    }
}

void FormPEX::changeNaviFlag(DtaoRenderSystem* renderer){
    renderer->isNavi = true;
}

void FormPEX::changeXYCoordinate(DtaoRenderSystem* renderer, QString res_group_num){
    renderer->naviInfo.x = renderer->getResistorModel()->getPexResData()->
            getNodesOfTargetNet(res_group_num.toDouble())[1]->getNode1().x;
    renderer->naviInfo.y = renderer->getResistorModel()->getPexResData()->
            getNodesOfTargetNet(res_group_num.toDouble())[1]->getNode1().y;
    renderer->naviInfo.z = renderer->cameraController.monitor.z;
    renderer->naviInfo.tilt = renderer->cameraController.monitor.tilt;
    renderer->naviInfo.zoom = renderer->cameraController.monitor.zoom;
    renderer->naviInfo.rotation = renderer->cameraController.monitor.rotation;
    renderer->naviInfo.window_zoom = renderer->cameraController.monitor.window_zoom;
}
!@hash[]!@file[]./GUI/formtop.cpp!@hash[]!@code[]#include "formtop.h"
#include "ui_formtop.h"
#include <QGraphicsItem>
#include "Rendering/Src/dtaorendersystem.h"
#include <QScrollBar>
#include <QVector>
#include <QMap>
#include <iostream>
#include <QDebug>

FormTop::FormTop(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormTop)
{
    ui->setupUi(this);
    this->m_scene = new QGraphicsScene(this);

    trans.scale(1,-1);

    formtop_cut_all = formtop_menu.addAction(tr("All"));
    formtop_cut_all->setCheckable(true);
    formtop_cut_all->setChecked(true);

    formtop_cut_rigtht = formtop_menu.addAction(tr("Right"));
    formtop_cut_rigtht->setCheckable(true);

    formtop_cut_left = formtop_menu.addAction(tr("Left"));
    formtop_cut_left->setCheckable(true);

    formtop_cut_top = formtop_menu.addAction(tr("Top"));
    formtop_cut_top->setCheckable(true);

    formtop_cut_bottom = formtop_menu.addAction(tr("Bottom"));
    formtop_cut_bottom->setCheckable(true);

    ui->graphicsView->setScene(m_scene);
    ui->graphicsView->setOptimizationFlags(QGraphicsView::IndirectPainting | QGraphicsView::DontAdjustForAntialiasing | QGraphicsView::DontSavePainterState);
    ui->graphicsView->setViewportUpdateMode(QGraphicsView::MinimalViewportUpdate);
    ui->graphicsView->setRenderHint(QPainter::Antialiasing, false);
}


FormTop::~FormTop()
{
    delete ui;
}

void FormTop::receiveFile(T2D &t2d, int pixel, double um)
{
    drawingClear();
    m_scene->clear();
    rendering_full = &t2d;            
    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        for(int row = 0 ; row < (int)rendering_full->LayoutData10by10[layer].xy.size() ; row++)
        {
            rendering_full->LayoutData10by10[layer].xy_filtered.resize(rendering_full->LayoutData10by10[layer].xy.size());
            for(int col = 0 ; col < (int)rendering_full->LayoutData10by10[layer].xy[row].size() ; col++)
            {
                rendering_full->LayoutData10by10[layer].xy_filtered[row].resize(rendering_full->LayoutData10by10[layer].xy[row].size());
            }
        }
    }

    this->m_origin_scale = pixel/um;
    this->m_scale = this->m_origin_scale;

    m_scene->setBackgroundBrush(QBrush(QColor(Qt::black)));

    this->changepos_init_check = false;

    //drawing();
}

void FormTop::drawing()
{
    //areaFilterRect();
    if(rendering_full->m_filter_onoff == false){
        this->getRowCol();
    }
    if(rendering_full->m_filter_onoff == true){
        areaFilterRect();
    }

    int obj_cnt = 0;

    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        //layer_enviroment 와 비교하여 for skip
        if( rendering_full->LayoutData10by10[layer].checking == 0){continue;}
        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                vector<B_BOX> *buffer;
                if(rendering_full->m_filter_onoff == false){
                    buffer = &rendering_full->LayoutData10by10[layer].xy[row][col];
                }
                if(rendering_full->m_filter_onoff == true){
                    buffer = &rendering_full->LayoutData10by10[layer].xy_filtered[row][col];
                }
                for(int n = 0 ; n < int(buffer->size()); n++)
                {
                    if((*buffer)[n].maxx >= this->view_minx &&
                       (*buffer)[n].minx <= this->view_maxx &&
                       (*buffer)[n].maxy >= this->view_miny &&
                       (*buffer)[n].miny <= this->view_maxy){
                        addItem((*buffer)[n], rendering_full->LayoutData10by10[layer].color, rendering_full->LayoutData10by10[layer].top, trans);
                    }
                }
            }
        }
    }

//    cout << "object num : " << obj_cnt << endl;

    m_scene->setSceneRect(0, 0, this->m_scene_standard, this->m_scene_standard);
//    ui->graphicsView->setScene(m_scene);

    m_scene->addRect(0,0,100,100, QPen(QBrush(Qt::red), 0), QBrush(Qt::NoBrush));
    m_scene->addRect(50,50,50,50, QPen(QBrush(Qt::blue), 0), QBrush(Qt::NoBrush));
    m_scene->addRect(0,0,50,50, QPen(QBrush(Qt::black), 0), QBrush(Qt::NoBrush));

}

void FormTop::addItem(B_BOX bBox, COLOR_RGBA rgba, double top, QTransform trans)
{
    float x = m_scale*(bBox.minx - pos->x) + this->m_scene_standard / 2;
    float y = m_scale*(bBox.miny - pos->y) - this->m_scene_standard / 2;
    float w = m_scale*(bBox.maxx - bBox.minx);
    float h = m_scale*(bBox.maxy - bBox.miny);

    if(!(w < m_standard_pixel || h < m_standard_pixel) && !(rgba.r == 0 && rgba.g == 0 && rgba.b == 0)){

        QGraphicsRectItem *rectItem = new QGraphicsRectItem;
        rectItemList.push_back(rectItem);

        rectItem->setRect(x,y,w,h);
        rectItem->setBrush(QBrush(QColor(rgba.r, rgba.g, rgba.b, rgba.a)));
        rectItem->setPen(Qt::NoPen);
        rectItem->setZValue(top);
        rectItem->setTransform(trans);

        m_scene->addItem(rectItem);

    }
}

void FormTop::filterDrawing()
{
    areaFilterRect();
    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        //layer_enviroment 와 비교하여 for skip
        if( rendering_full->LayoutData10by10[layer].checking == 0){continue;}
        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                for(int n = 0 ; n < (int)(rendering_full->LayoutData10by10[layer].xy_filtered[row][col]).size(); n++)
                {
                    addFilterRectItem(layer,row,col,n,trans);
                }
            }
        }
    }

    m_scene->setSceneRect(0, 0, this->m_scene_standard, this->m_scene_standard);
    ui->graphicsView->setScene(m_scene);

    m_scene->addRect(0,0,100,100, QPen(QBrush(Qt::red), 0), QBrush(Qt::NoBrush));
    m_scene->addRect(50,50,50,50, QPen(QBrush(Qt::blue), 0), QBrush(Qt::NoBrush));
    m_scene->addRect(0,0,50,50, QPen(QBrush(Qt::black), 0), QBrush(Qt::NoBrush));
}

void FormTop::drawingClear()
{
    // 기존에 있는 vector 를 남겨놔야 함 : delete 를 위해
    for(auto cur_item : rectItemList)
    {
        delete cur_item;
    }
    rectItemList.clear();
    m_scene->clear();
}

void FormTop::receivePointPos(POS_MONITORING &pos)
{
    this->pos = &pos;
    temp_pos.x = pos.x;
    temp_pos.y = pos.y;
}

void FormTop::changePos()
{    
    if(this->changepos_init_check == false && pos->zoom > 0.03) //temp_pos.x != pos->x || temp_pos.y != pos->y)
    {
        this->m_scale = this->m_origin_scale * pos->zoom;
        //cout << "jj " << m_scale/0.1 << endl;

        this->view_minx = pos->x - double(ui->graphicsView->width())/m_scale/2;
        this->view_maxx = pos->x + double(ui->graphicsView->width())/m_scale/2;
        this->view_miny = pos->y - double(ui->graphicsView->height())/m_scale/2;
        this->view_maxy = pos->y + double(ui->graphicsView->height())/m_scale/2;

        //cout << " w : " << this->view_maxx - this->view_minx << "um h : " << this->view_maxy - this->view_miny << "um x1 : " << this->view_minx << " y1 : " << this->view_miny << " x1 : " << this->view_maxx << " y1 : " << this->view_maxy << " z : " << pos->zoom << endl;

        drawingClear();
        drawing();
        //qDebug() << rendering_full;
        /*if(rendering_full->m_filter_onoff == false){
            drawing();
        }
        if(rendering_full->m_filter_onoff == true){
            filterDrawing();
        }*/
    } else{
        //this->changepos_init_check = false;
        drawingClear();
    }
}

void FormTop::addRectItem(int layer, int row, int col, int n, QTransform trans)
{

    QGraphicsRectItem *rectItem = new QGraphicsRectItem;
    rectItemList.push_back(rectItem);

    /*float opacity = rendering_full->LayoutData10by10[layer].color.a;
    opacity = opacity/255;*/

    float x = m_scale*(rendering_full->LayoutData10by10[layer].xy[row][col][n].minx - pos->x) + this->m_scene_standard / 2;
    float y = m_scale*(rendering_full->LayoutData10by10[layer].xy[row][col][n].miny - pos->y) - this->m_scene_standard / 2;
    float w = m_scale*(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx - rendering_full->LayoutData10by10[layer].xy[row][col][n].minx);
    float h = m_scale*(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy - rendering_full->LayoutData10by10[layer].xy[row][col][n].miny);
    //cout << " w : " << w << " h : " << h << endl;

    rectItem->setRect(x,y,w,h);
    rectItem->setBrush(QBrush(QColor(rendering_full->LayoutData10by10[layer].color.r,
                                     rendering_full->LayoutData10by10[layer].color.g,
                                     rendering_full->LayoutData10by10[layer].color.b,
                                     rendering_full->LayoutData10by10[layer].color.a)));
    //rectItem->setOpacity(opacity);
    //qDebug()<< " rect    : " << rectItem->rect() << ":: row/col : " << row << "/" << col << " " << n;
    //qDebug()<< " opacity : " << rendering_full->LayoutData10by10[layer].color.a << " : " << opacity;

    //cout << x << ":" << y << " " << w << ":" << h << endl;
    rectItem->setZValue(rendering_full->LayoutData10by10[layer].top);

    rectItem->setTransform(trans);
    m_scene->addItem(rectItem);

    /*QColor formtop_rgba = QColor(rendering_full->LayoutData10by10[layer].color.r,
                                 rendering_full->LayoutData10by10[layer].color.g,
                                 rendering_full->LayoutData10by10[layer].color.b,
                                 rendering_full->LayoutData10by10[layer].color.a);

    m_scene->addRect(x, y, w, h, QPen(QBrush(Qt::NoBrush), 0), QBrush(formtop_rgba));*/
}

void FormTop::addFilterRectItem(int layer, int row, int col, int n, QTransform trans)
{

    QGraphicsRectItem *rectItem = new QGraphicsRectItem;
    rectItemList.push_back(rectItem);

    /*float opacity = rendering_full->LayoutData10by10[layer].color.a;
    opacity = opacity/255;*/

    float x = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].minx - pos->x) + this->m_scene_standard / 2;
    float y = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].miny - pos->y) - this->m_scene_standard / 2;
    float w = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].maxx - rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].minx);
    float h = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].maxy - rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].miny);

    rectItem->setRect(x,y,w,h);
    rectItem->setBrush(QBrush(QColor(rendering_full->LayoutData10by10[layer].color.r,
                                     rendering_full->LayoutData10by10[layer].color.g,
                                     rendering_full->LayoutData10by10[layer].color.b,
                                     rendering_full->LayoutData10by10[layer].color.a)));

    //rectItem->setOpacity(opacity);
    //qDebug()<< " rect    : " << rectItem->rect() << ":: row/col : " << row << "/" << col << " " << n;
    //qDebug()<< " opacity : " << rendering_full->LayoutData10by10[layer].color.a << " : " << opacity;

    rectItem->setZValue(rendering_full->LayoutData10by10[layer].bot);

    rectItem->setTransform(trans);
    m_scene->addItem(rectItem);
}

int FormTop::extPos(double *pos, double *min, double *max)
{
    double area = m_area / m_area_scale; // 0.05 = 50/1000
    int pos_col_row = (*pos-*min)/m_block_size; // 30.0413/10 = 3
    int max_col_row = (*max-*min)/m_block_size;


    //block 으로 자른 경계면 근처에 있을 경우 external 을 추가
    if ((*pos - *min)<area && pos_col_row > 0) // 30.0413 - 3*10 = 0.0413 < 0.05
    {
        return pos_col_row - 1;
    }
    else if ((*max - *pos)<area && pos_col_row < max_col_row) // 39.9811 col 3 : (3+1)*10 - 39.9811 = 0.0189 < 0.05
    {
        return pos_col_row + 1;
    }

    return pos_col_row;
}

void FormTop::filterRenderingData(int layer, int row, int col, int n)
{
    double minx = 0;
    double maxx = 0;
    double miny = 0;
    double maxy = 0;

    if(m_filter_right == true){
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].minx >= pos->x){return;}
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].minx < pos->x && rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx >= pos->x) //area 보다 넘어가면 자름
        {
            maxx = pos->x;
        }
        else
        {
            maxx = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx;
        }
        minx = rendering_full->LayoutData10by10[layer].xy[row][col][n].minx;
        miny = rendering_full->LayoutData10by10[layer].xy[row][col][n].miny;
        maxy = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy;
    }
    if(m_filter_left == true){
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx <= pos->x){return;}
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx > pos->x && rendering_full->LayoutData10by10[layer].xy[row][col][n].minx <= pos->x) //area 보다 넘어가면 자름
        {
            minx = pos->x;
        }
        else
        {
            minx = rendering_full->LayoutData10by10[layer].xy[row][col][n].minx;
        }
        maxx = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx;
        miny = rendering_full->LayoutData10by10[layer].xy[row][col][n].miny;
        maxy = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy;
    }
    if(m_filter_top == true){
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].miny >= pos->y){return;}
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].miny < pos->y && rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy >= pos->y) //area 보다 넘어가면 자름
        {
            maxy = pos->y;
        }
        else
        {
            maxy = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy;
        }
        minx = rendering_full->LayoutData10by10[layer].xy[row][col][n].minx;
        maxx = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx;
        miny = rendering_full->LayoutData10by10[layer].xy[row][col][n].miny;
    }
    if(m_filter_bottom == true){
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy <= pos->y){return;}
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy > pos->y && rendering_full->LayoutData10by10[layer].xy[row][col][n].miny <= pos->y) //area 보다 넘어가면 자름
        {
            miny = pos->y;
        }
        else
        {
            miny = rendering_full->LayoutData10by10[layer].xy[row][col][n].miny;
        }
        minx = rendering_full->LayoutData10by10[layer].xy[row][col][n].minx;
        maxx = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx;
        maxy = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy;
    }


    B_BOX temp;
    temp.minx = minx;
    temp.miny = miny;
    temp.maxx = maxx;
    temp.maxy = maxy;

    rendering_full->LayoutData10by10[layer].xy_filtered[row][col].push_back(temp);
}

void FormTop::areaFilterRect()
{
    //filter BBOX clear
    this->getRowCol();

    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                rendering_full->LayoutData10by10[layer].xy_filtered[row][col].clear();
            }
        }
    }

    /*int pos_col = (pos->x - rendering_full->LayoutMinMax.minx)/m_block_size; //식이 필요한대   23.3841 / 10 = 2.33841 -> int 2
    int ext_col = extPos(&pos->x, &rendering_full->LayoutMinMax.minx, &rendering_full->LayoutMinMax.maxx);
    m_begin_col = qMin(pos_col,ext_col);
    m_end_col = qMax(pos_col,ext_col)+1;

    int pos_row = (pos->y - rendering_full->LayoutMinMax.miny)/m_block_size;
    int ext_row = extPos(&pos->y, &rendering_full->LayoutMinMax.miny,&rendering_full->LayoutMinMax.maxy);
    m_begin_row = qMin(pos_row,ext_row);
    m_end_row = qMax(pos_col,ext_row)+1;*/

    //layer
    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        //layer_enviroment 와 비교하여 for skip

        if( rendering_full->LayoutData10by10[layer].checking == 0){continue;}

        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                for(int n = 0 ; n < (int)(rendering_full->LayoutData10by10[layer].xy[row][col]).size(); n++)
                {                
                    filterRenderingData(layer,row,col,n);
                }
            }
        }
    }

}

void FormTop::getRowCol(){
    /*int pos_col = (pos->x - rendering_full->LayoutMinMax.minx)/m_block_size; //식이 필요한대   23.3841 / 10 = 2.33841 -> int 2
    if(pos_col - 1 >= 0){
        m_begin_col = pos_col - 1;
    }else{
        m_begin_col = 0;
    }

    if(pos_col + 2 <= rendering_full->col){
        m_end_col = pos_col + 2;
    }else{
        m_end_col = rendering_full->col;
    }

    int pos_row = (pos->y - rendering_full->LayoutMinMax.miny)/m_block_size;
    if(pos_row - 1 >= 0){
        m_begin_row = pos_row - 1;
    }else{
        m_begin_row = 0;
    }

    if(pos_row + 2 <= rendering_full->row){
        m_end_row = pos_row + 2;
    }else{
        m_end_row = rendering_full->row;
    }*/

    m_begin_col = (this->view_minx - rendering_full->LayoutMinMax.minx)/m_block_size;
    if(m_begin_col < 0) m_begin_col = 0;
    m_end_col = (this->view_maxx - rendering_full->LayoutMinMax.minx)/m_block_size + 1;
    if(m_end_col > rendering_full->col) m_end_col = rendering_full->col;

    m_begin_row = (this->view_miny - rendering_full->LayoutMinMax.miny)/m_block_size;
    if(m_begin_row < 0) m_begin_row = 0;
    m_end_row = (this->view_maxy - rendering_full->LayoutMinMax.miny)/m_block_size + 1;
    if(m_end_row > rendering_full->row) m_end_row = rendering_full->row;

    //cout << " bc : " << m_begin_col << " ec : " << m_end_col << " br : " << m_begin_row << " er : " << m_end_row << endl;
}

//void FormTop::wheelEvent(QWheelEvent *event){
//    int delta = event->delta();

//    // 스크롤 값에 따라 스케일 값을 변경
//    if (delta > 0) {
//        this->pos->zoom *= 1.01; // 10% 확대
//    } else if (delta < 0) {
//        this->pos->zoom /= 1.01; // 10% 축소
//    }
//    //pos->zoom = m_scale;
//    //cout << m_scale << endl;
//    cout << this->pos->zoom << endl;
//    //emit signalChangePos("test", *this->pos);
//}

//void FormTop::mousePressEvent(QGraphicsSceneMouseEvent *event)
//{
//    if (event->buttons() == Qt::LeftButton)
//    {
//        // 마우스 좌클릭 시작 좌표 저장
//        startPoint = event->scenePos();
//    }
//}

//void FormTop::mouseMoveEvent(QGraphicsSceneMouseEvent *event)
//{
//    if (event->buttons() & Qt::LeftButton) {
//        // 마우스 좌클릭 후 드래그 시 x, y 좌표 변경
//        QPointF delta = event->pos() - startPoint;
//        pos->x += delta.x();
//        pos->y += delta.y();
//        cout << pos->x << "  " << pos->y << endl;
//    }
//}

void FormTop::contextMenuEvent(QContextMenuEvent *event){
    QAction* selectedItem = formtop_menu.exec(event->globalPos());
    if (selectedItem == formtop_cut_all) {
        rendering_full->m_filter_onoff = false;
        m_filter_right = false;
        m_filter_left = false;
        m_filter_top = false;
        m_filter_bottom = false;
        this->changePos();
    }
    if (selectedItem == formtop_cut_rigtht) {
        rendering_full->m_filter_onoff = true;
        m_filter_right = true;
        m_filter_left = false;
        m_filter_top = false;
        m_filter_bottom = false;
        this->changePos();
    }
    if (selectedItem == formtop_cut_left) {
        rendering_full->m_filter_onoff = true;
        m_filter_right = false;
        m_filter_left = true;
        m_filter_top = false;
        m_filter_bottom = false;
        this->changePos();
    }
    if (selectedItem == formtop_cut_top) {
        rendering_full->m_filter_onoff = true;
        m_filter_right = false;
        m_filter_left = false;
        m_filter_top = true;
        m_filter_bottom = false;
        this->changePos();
    }
    if (selectedItem == formtop_cut_bottom) {
        rendering_full->m_filter_onoff = true;
        m_filter_right = false;
        m_filter_left = false;
        m_filter_top = false;
        m_filter_bottom = true;
        this->changePos();
    }
    filterMenuCheck();
}

void FormTop::filterMenuCheck(){
    formtop_cut_all->setChecked(!rendering_full->m_filter_onoff);
    formtop_cut_rigtht->setChecked(m_filter_right);
    formtop_cut_left->setChecked(m_filter_left);
    formtop_cut_top->setChecked(m_filter_top);
    formtop_cut_bottom->setChecked(m_filter_bottom);
}

void FormTop::resizeEvent(QResizeEvent *){
    //cout << "test" << endl;
    this->changePos();
}







!@hash[]!@file[]./GUI/formplaybar.cpp!@hash[]!@code[]#include "formplaybar.h"
#include "ui_formplaybar.h"

FormPlayBar::FormPlayBar(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormPlayBar)
{
    ui->setupUi(this);

    timer = new QTimer(this);

    connect(timer, &QTimer::timeout, this, &FormPlayBar::moveSlider);
}

FormPlayBar::~FormPlayBar()
{
    delete ui;
}

void FormPlayBar::init(vector<Vertex_stl> stl_vertices, MIN_MAX_XYZ ModelMinMax, vector<vector<Data_2nd>> Data_3D, int size, DtaoRenderSystem* render){
    opendatademo.stl_vertices = stl_vertices;
    opendatademo.ModelMinMax = ModelMinMax;
    opendatademo.Data_3D = Data_3D;
    ui->time_slider->setMaximum(size-1);

    this->renderer = render;
}



void FormPlayBar::startButtonClicked()
{
    timer->start(1000);
}

void FormPlayBar::stopButtonClicked()
{
    timer->stop();
}

void FormPlayBar::moveSlider()
{
    if(ui->time_slider->maximum() == ui->time_slider->value()){
        ui->time_slider->setValue(0);
    }else{
        ui->time_slider->setValue(ui->time_slider->value() + 1);
    }
}

void FormPlayBar::on_time_slider_valueChanged(int value)
{
    renderer->createSTLObjects(opendatademo.getSTLVertices(),
                               opendatademo.getSTLModelMinMax(),
                               opendatademo.getOpenData(value));
}

void FormPlayBar::on_play_btn_clicked()
{
    if(play_check == false){
        startButtonClicked();
        ui->play_btn->setText("∥");
        ui->time_slider->setEnabled(false);
        play_check = true;
    }else if(play_check == true){
        stopButtonClicked();
        ui->play_btn->setText("▶");
        ui->time_slider->setEnabled(true);
        play_check = false;
    }
}
!@hash[]!@file[]./T2D.cpp!@hash[]!@code[]#include "T2D.h"

using namespace std;

bool T2D::text2data(std::string file_name){
    ifstream readfile(file_name);
    string line;
    vector<string> split;

    getline(readfile, line);
    split = T2D::string_split(line, ' ');
    LayoutMinMax.minx = atof(split[0].c_str());
    LayoutMinMax.miny = atof(split[1].c_str());
    LayoutMinMax.maxx = atof(split[2].c_str());
    LayoutMinMax.maxy = atof(split[3].c_str());
    LayoutMinMax.minz = atof(split[4].c_str());
    LayoutMinMax.maxz = atof(split[5].c_str());
    /*cout << LayoutMinMax.minx << "\t";
    cout << LayoutMinMax.miny << "\t";
    cout << LayoutMinMax.maxx << "\t";
    cout << LayoutMinMax.maxy << "\t";
    cout << LayoutMinMax.minz << "\t";
    cout << LayoutMinMax.maxz << endl;*/
    LayoutData10by10.clear();
    while(getline(readfile, line)){
        if(line == "~!@#$%^&*()_++_)(*&^%$#@!~") break;
        split = T2D::string_split(line, ' ');
        this->row = atoi(split[9].c_str());
        this->col = atoi(split[10].c_str());

        buf_ldata10by10.checking = false;
        buf_ldata10by10.layername = split[0];
        buf_ldata10by10.layernum = atoi(split[1].c_str());
        buf_ldata10by10.datatype = atoi(split[2].c_str());
        buf_ldata10by10.color.r = atoi(split[3].c_str());
        buf_ldata10by10.color.g = atoi(split[4].c_str());
        buf_ldata10by10.color.b = atoi(split[5].c_str());
        buf_ldata10by10.color.a = atoi(split[6].c_str());
        buf_ldata10by10.bot = atof(split[7].c_str());
        buf_ldata10by10.top = atof(split[8].c_str());

        buf_xy10by10.resize(row);
        for(int i = 0 ; i < row ; i++){
            buf_xy10by10[i].resize(col);
        }
        for(int i = 0 ; i < row*col ; i++){
            getline(readfile, line);
            split = T2D::string_split(line, ' ');
            int nr = atoi(split[0].c_str());
            int nc = atoi(split[1].c_str());
            int nsize = atoi(split[2].c_str());

            buf_xy.clear();
            for(int i = 0 ; i < nsize ; i++){
                getline(readfile, line);
                split = T2D::string_split(line, ' ');
                B_BOX buf;
                buf.minx = atof(split[0].c_str());
                buf.miny = atof(split[1].c_str());
                buf.maxx = atof(split[2].c_str());
                buf.maxy = atof(split[3].c_str());
                buf_xy.push_back(buf);
            }
            buf_xy10by10[nr][nc] = buf_xy;
        }
        buf_ldata10by10.xy = buf_xy10by10;
        LayoutData10by10.push_back(buf_ldata10by10);

        string m_key = to_string(buf_ldata10by10.layernum)+"."+to_string(buf_ldata10by10.datatype);
        map_LayoutData10by10_.insert({m_key, buf_ldata10by10});
    }
    HierarchyInstance.clear();
    while(getline(readfile, line)){
        split = T2D::string_split(line, ' ');
        Instance buf_instance;
        buf_instance.level = atoi(split[0].c_str());
        buf_instance.name = split[1];
        buf_instance.num = split[2];
        buf_instance.box.minx = atof(split[3].c_str());
        buf_instance.box.miny = atof(split[4].c_str());
        buf_instance.box.maxx = atof(split[5].c_str());
        buf_instance.box.maxy = atof(split[6].c_str());
        HierarchyInstance.push_back(buf_instance);
        //cout << buf_instance.name << endl;
    }

    return true;
}

vector<string> T2D::string_split(string input, char delimiter) {
    vector<string> answer;
    stringstream ss(input);
    string temp;

    while(getline(ss, temp, delimiter)) {
        if(temp != ""){
            answer.push_back(temp);
        }
    }

    return answer;
}


!@hash[]!@file[]./filedb.cpp!@hash[]!@code[]#include "filedb.h"
#include <QFile>
#include <QVector>
#include <QTextStream>
#include <QList>
#include <QDebug>

FileDb::FileDb()
{

}

void FileDb::openFile(QString fileNameInfo,QVector<QList<float>> &vecList,
                      float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize)
{    
    QFile file(fileNameInfo);

    if (file.open(QIODevice::ReadOnly) | (QIODevice::Text))
    {
        QTextStream openFile(&file);
        while(!openFile.atEnd())
        {
            auto dataString = openFile.readLine().split(",");
            QList<float> data;
            for (auto &tempdata : dataString)
            {
                 data.append(tempdata.toFloat());
            }
            vecList.push_back(data);
            qDebug()<< "strVector : " << data;

            if(data.size() == 8)
            {
                if(xMinSize > data[2]){xMinSize = data[2];}
                if(yMinSize > data[3]){yMinSize = data[3];}
                if(xMaxSize < data[4]){xMaxSize = data[4];}
                if(yMaxSize < data[5]){yMaxSize = data[5];}
            }
        }
        file.close();
    }
    else
    {        
        return;
    }

    return;

}
!@hash[]!@file[]./gitmerge.cpp!@hash[]!@code[]#include "gitmerge.h"

#include <QFile>
#include <QTextStream>
#include <QDebug>

//git test

GitMerge::GitMerge()
{
    split1 = hash;
    split2 = hash;
    split1.append(file);
    split2.append(code);

    readCodeFiles();
    readTxtFile();
    if(write_code_files)
    {
        makeCodeFiles();
    }
    else
    {
        makeTxtFile();
    }

}

void GitMerge::readTxtFile()
{
    QString fileName = txt_file;
    QFile file(fileName);
    if(!file.open(QFile::ReadOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for reading ";
        based_on_reading_txt = "";
        if(!file.open(QFile::WriteOnly | QFile::Text))
        {
            return;
        }
        QTextStream out(&file);
        out << "";
        file.close();
        return;
    }
    QTextStream in(&file);
    based_on_reading_txt = in.readAll();
    file.close();

}

void GitMerge::readCodeFiles()
{
    QFile file(pro_file);


    if(!file.open(QFile::ReadOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for reading ";
        return;
    }

    QTextStream in(&file);
    in.setCodec("UTF-8");
    QString merge = in.readAll();
    QStringList mergeList = merge.split("\n");
    for (auto &itemMerge : mergeList)
    {

        itemMerge = itemMerge.remove("\\");
        itemMerge = itemMerge.trimmed();

        if (itemMerge.contains(".cpp", Qt::CaseInsensitive) || itemMerge.contains(".h", Qt::CaseInsensitive) || itemMerge.contains(".ui", Qt::CaseInsensitive))
        {
            QFile codeFile(itemMerge.prepend("./"));
            if(!codeFile.open(QFile::ReadOnly | QFile::Text))
            {
                qDebug() << " Could not open the code file for reading " ;
                return;
            }
            QTextStream codeIn(&codeFile);
            codeIn.setCodec("UTF-8");
            QString codeText = codeIn.readAll();
            //codeText = codeText.toUtf8();

            merged_code_files.append(split1);
            merged_code_files.append(itemMerge);
            merged_code_files.append(split2);
            merged_code_files.append(codeText);
            codeFile.close();

        }

    }
    merged_code_files.append(split1);
    merged_code_files.append("./IInterface.pro");
    merged_code_files.append(split2);
    merged_code_files.append(merge);

    file.close();
}

bool GitMerge::compareCodeFile(QString &A, QString &B)
{
    if (A==B)
    {
        return true;
    }
    else
    {
        return false;
    }

}

void GitMerge::makeTxtFile()
{
    QFile file(txt_file);
    if(!file.open(QFile::WriteOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for writing ";
        return;
    }
    QTextStream out(&file);
    out << merged_code_files;
    out.setCodec("UTF-8");
    file.flush();
    file.close();

}

void GitMerge::makeCodeFiles()
{
    QStringList codeList = merged_code_files.split(split1);
    QStringList fileList = based_on_reading_txt.split(split1);
    QStringList codeListDivide;
    QStringList fileListDivide;
    for (int i = 1; i < fileList.size(); i++)
    {
        fileListDivide = fileList[i].split(split2);
        for (int j = 1; j < codeList.size(); j++)
        {
            codeListDivide = codeList[j].split(split2);
            if (codeListDivide[0] == fileListDivide[0])
            {
                if (codeListDivide[1] != fileListDivide[1])
                {
                    QFile file_gitback(codeListDivide[0].append("_back"));
                    if(!file_gitback.open(QFile::WriteOnly | QFile::Text))
                    {
                        qDebug() << " Could not open the file for writing ";
                        return;
                    }
                    QTextStream out_gitback(&file_gitback);
                    out_gitback << codeListDivide[1];
                    out_gitback.setCodec("UTF-8");
                    file_gitback.flush();
                    file_gitback.close();

                    QFile file(fileListDivide[0]);
                    if(!file.open(QFile::WriteOnly | QFile::Text))
                    {
                        qDebug() << " Could not open the file for writing ";
                        return;
                    }
                    QTextStream out(&file);
                    out << fileListDivide[1];
                    out.setCodec("UTF-8");
                    file.flush();
                    file.close();
                }
                break;
            }
            if (j == codeList.size()-1) // 찾아봤는데 기존 파일이 없다.
            {
                QFile file(fileListDivide[0]);
                if(!file.open(QFile::WriteOnly | QFile::Text))
                {
                    qDebug() << " Could not open the file for writing ";
                    return;
                }
                QTextStream out(&file);
                out << fileListDivide[1];
                out.setCodec("UTF-8");
                file.flush();
                file.close();
            }
        }
    }
}
!@hash[]!@file[]./main.cpp!@hash[]!@code[]#include "mainwindow.h"
#include "gitmerge.h"

#include <QApplication>
#include <QVulkanInstance>
#include <QLoggingCategory>
#include <fstream>
#include <string>
#include <iostream>
#include "GUI/formtop.h"

#include "Rendering/Src/lve_window.hpp"
#include "Rendering/Src/simple_render_system.hpp"

Q_LOGGING_CATEGORY(lcVk, "qt.vulkan")

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

///////// git merge
    GitMerge gitMerge;
/// /////

    QLoggingCategory::setFilterRules(QStringLiteral("qt.vulkan=true"));

    QVulkanInstance inst;
    LveWindow *vulkanWindow = new LveWindow;

    //inst.setLayers(QByteArrayList() << "VK_LAYER_LUNARG_standard_validation");


    if (!inst.create())
        qFatal("Failed to create Vulkan instance: %d", inst.errorCode());

    vulkanWindow->setVulkanInstance(&inst);

    MainWindow mainWindow(vulkanWindow);
    QObject::connect(vulkanWindow, &LveWindow::signalInfoText, &mainWindow, &MainWindow::slotInfoText);



    QRect size = mainWindow.geometry();
    mainWindow.shareGeo(size);
    qDebug() << "Main geo : " << mainWindow.geometry();

    mainWindow.show();

    return app.exec();
}





!@hash[]!@file[]./mainwindow.cpp!@hash[]!@code[]#include "mainwindow.h"
#include "ui_mainwindow.h"

#include "Rendering/Src/dtaorendersystem.h"
#include "Rendering/Src/lve_model.hpp"


#include <QMouseEvent>
#include <QKeyEvent>
#include <QDockWidget>
#include <QGraphicsRectItem>
#include <QGraphicsOpacityEffect>
#include <QFile>
#include <QFileDialog>
#include <QString>

#include <fstream>
#include <iostream>
#include <string>
#include <QIODevice>
#include <QTextStream>


MainWindow::MainWindow(LveWindow* w)
    : m_window(w)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QWidget* wrapper = QWidget::createWindowContainer(w);
    ui->graphicsView->setViewport(wrapper);

    dockHier = new QDockWidget(tr("Hierarchy"), this);
    dockHier->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockHier->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockHier->setObjectName("DockWidgetHier");
    addDockWidget(Qt::RightDockWidgetArea, dockHier);
    formHier = new FormHier;
    dockHier->setWidget(formHier);

    dockLayer = new QDockWidget(tr("Layer Information"), this);
    dockLayer->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockLayer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockLayer->setObjectName("DockWidgetLayer");
    addDockWidget(Qt::RightDockWidgetArea, dockLayer);
    formLayer = new FormLayer(this->m_window);
    dockLayer->setWidget(formLayer);

    dockPEX = new QDockWidget(tr("PEX"), this);
    dockPEX->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockPEX->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockPEX->setObjectName("DockWidgetPEX");
    addDockWidget(Qt::RightDockWidgetArea, dockPEX);
    formPEX = new FormPEX;
    dockPEX->setWidget(formPEX);
    dockPEX->hide();

    dockMap = new QDockWidget(tr("Map"), this);
    dockMap->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockMap->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockMap->setObjectName("DockWidgetMap");
    addDockWidget(Qt::LeftDockWidgetArea, dockMap);
    formMap = new FormMap;
    dockMap->setWidget(formMap);

    dockTop = new QDockWidget(tr("Topview"), this);
    dockTop->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockTop->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockTop->setObjectName("DockWidgetTop");
    addDockWidget(Qt::LeftDockWidgetArea, dockTop);
    formTop = new FormTop;
    dockTop->setWidget(formTop);

    dockInfo = new QDockWidget(tr("Info"), this);
    dockInfo->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockInfo->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockInfo->setObjectName("DockWidgetInfo");
    addDockWidget(Qt::LeftDockWidgetArea, dockInfo);
    formInfo = new FormInfo;
    dockInfo->setWidget(formInfo);

    dockPlayBar = new QDockWidget(tr("PlayBar"), this);
    dockPlayBar->setAllowedAreas(Qt::BottomDockWidgetArea);
    dockPlayBar->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockPlayBar->setObjectName("DockWidgetPlayBar");
    addDockWidget(Qt::BottomDockWidgetArea, dockPlayBar);
    formPlayBar = new FormPlayBar;
    dockPlayBar->setWidget(formPlayBar);
    dockPlayBar->hide();

    resizeDocks({ dockInfo, dockTop, dockMap, dockLayer, dockHier }, { 200,200 }, Qt::Horizontal);
    resizeDocks({ dockTop, dockMap }, { 200,200 }, Qt::Vertical);
    resizeDocks({ dockLayer, dockHier }, { 350,300 }, Qt::Vertical);

    // test //
    pos.x = 0;
    pos.y = 0;
    pos.z = 0;
    pos.tilt = 90;
    pos.rotation = 0;
    pos.zoom = 1;
    pos.window_zoom = 1;
    formMap->receivePointPos(pos);
    formTop->receivePointPos(pos);
    formInfo->receivePointPos(pos);
    formHier->receivePointPos(pos);

    /// connect ////////////////////
    QObject::connect(ui->actionOpen_file, SIGNAL(triggered()), this, SLOT(on_actionOpen_file_triggered));
    QObject::connect(ui->actionOpen_PEX, SIGNAL(triggered()), this, SLOT(on_actionOpen_PEX_triggered));
//    QObject::connect(this, SIGNAL(sendSelectFileName(QString)), input_dataS, SLOT(receiveSelectFileName(QString)));
//    QObject::connect(input_dataS, SIGNAL(sendSplitData(int, int, const QVector <QVector <QString>> &)), formHier, SLOT(ReceiveSplitData(int, int, const QVector <QVector <QString>> &)));
//    QObject::connect(input_dataS, SIGNAL(sendSplitData(int, int, const QVector <QVector <QString>> &)), formLayer, SLOT(ReceiveSplitData(int, int, const QVector <QVector <QString>> &)));
    QObject::connect(formLayer, SIGNAL(outputLayerStatus(QString)), this, SLOT(inputLayerStatus(QString)));
    //QObject::connect(formTop, SIGNAL(signalChangePos(QString, POS_MONITORING)), this, SLOT(slotInfoText(QString, POS_MONITORING)));
    QObject::connect(formInfo, SIGNAL(signalDirectlyInputPos()), this, SLOT(slotDirectlyInputPos()));
    QObject::connect(formMap, SIGNAL(signalDirectlyInputPos()), this, SLOT(slotDirectlyInputPos()));
    QObject::connect(formHier, SIGNAL(signalDirectlyInputPos()), this, SLOT(slotDirectlyInputPos()));
    QObject::connect(formInfo, SIGNAL(signalStatusBarMsg(QString)), this, SLOT(slotStatusBarMsg(QString)));
    QObject::connect(dockMap, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_Map_stateChanged(bool)));
    QObject::connect(dockTop, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_TopView_stateChanged(bool)));
    QObject::connect(dockInfo, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_Info_stateChanged(bool)));
    QObject::connect(dockHier, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_Hier_stateChanged(bool)));
    QObject::connect(dockLayer, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_Layer_stateChanged(bool)));
    QObject::connect(dockPEX, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_PEX_stateChanged(bool)));
    // 평가용
    dev_dialog = new DevDialog(this);
    dev_dialog->setRenderWindow(this->m_window);
    devDialog();

}

void MainWindow::shareGeo(QRect size)
{
    QRect windowSize = size;
    qDebug() << "shareGeo : " << windowSize;
}

void MainWindow::devDialog()
{
    dev_dialog->sendParameter(&is_pos_checked, &pos);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::slotInfoText(QString funcName, POS_MONITORING value)
{
    (void)(funcName);
    if (value.x != pos_past.x ||
        value.y != pos_past.y ||
        value.z != pos_past.z ||
        (value.tilt != pos_past.tilt)  ||
        (value.rotation != pos_past.rotation)  ||
        value.zoom != pos_past.zoom)
    {

        pos.x = value.x;
        pos.y = value.y;
        pos.z = value.z;
        pos.tilt = value.tilt;
        pos.rotation = value.rotation;
        pos.zoom = value.zoom;

        sendPositionDataToDocker(); // changePos() refactoring


        pos_past.x = pos.x;
        pos_past.y = pos.y;
        pos_past.z = pos.z;
        pos_past.tilt = pos.tilt;
        pos_past.rotation = pos.rotation;
        pos_past.zoom = pos.zoom;
    }


    //qDebug() << "slotInfoText" << funcName << value.x << " "<< value.y << " "<< value.z << " ";
///// temp //////
//    QString text = funcName + " : " ;
//    for (int i = text.size() ; i < 30 ; i++)
//    {
//        text.append(" ");
//    }

//    statusText.prepend(text);

//    if (statusText.size() > 120)
//        statusText.remove(120,statusText.size()-120);
//    ui->statusbar->showMessage(statusText);

}

void MainWindow::on_actionOpen_file_triggered()
{

    QString file_name = QFileDialog::getOpenFileName(this, "파일 선택", ".", "Files(*.*)");
    //qDebug() << file_name;

    emit sendSelectFileName(file_name);

}

void MainWindow::on_actionOpen_PEX_triggered()
{
    if (this->t2d.LayoutData10by10.empty() == false) {
        QString file_name = QFileDialog::getOpenFileName(
                    this, "OpenDB", "./Rendering/Data", "CSV (*.csv) ;; Files (*.*)");
        if (!file_name.isEmpty()){
            DtaoRenderSystem* renderer = this->m_window->getRenderer();
            renderer->createNewPEXResObject(file_name);
            renderer->createNewPEXCapObject(file_name,this->t2d);
            formPEX->makePEXResList(renderer->getResistorModel()->getPexResData()->getNetsList());
            formPEX->setRenderWindow(this->m_window);
            dockPEX->show();
        } else {
            return;
        }
    }
    else {
        QMessageBox::critical(nullptr, "Error", "Layout Load 후 PEX를 불러올 수 있습니다");
        qDebug() << "Layout Load 후 PEX를 불러올 수 있습니다";
    }
}

void MainWindow::inputLayerStatus(QString text)
{
    if(formLayer->m_layer_all_check == false){
        ui->statusbar->showMessage(text);
        /*formTop->drawingClear();
        formTop->drawing();*/
        sendPositionDataToDocker();
    }
}

void MainWindow::inputPosInformation()
{

    //execute (pos)
}

void MainWindow::on_actionOpen_Layout_triggered()
{
    QString file_name = QFileDialog::getOpenFileName(this, "파일 선택", ".", "Files(*.*)");
    DtaoRenderSystem* renderer = this->m_window->getRenderer();
    (void)renderer;
    //renderer->createNewObject(MODEL_TYPE::MODEL_TYPE_LAYOUT, file_name.toStdString());


}

void MainWindow::on_actionOpen_DB_triggered() {
    std::cout << "callv" << std::endl;
    QString file_name = QFileDialog::getOpenFileName(
                this, "OpenDB", "./Rendering/Data", "Text (*.txt) ;; Files (*.*)");
    if (file_name != "") {
        std::cout << file_name.toStdString() << std::endl;
        this->t2d.text2data(file_name.toStdString());

        //        printf("%-9f %-9f %-9f %-9f %-9f %-9f", t2d.LayoutMinMax.minx, t2d.LayoutMinMax.miny, t2d.LayoutMinMax.maxx, t2d.LayoutMinMax.maxy, t2d.LayoutMinMax.minz, t2d.LayoutMinMax.maxz);
        //        for(int i = 0 ; i < t2d.LayoutData10by10.size() ; i++){
        //            printf("\n%-9s %-9d %-9d %-9d %-9d %-9d %-9d %-9f %-9f ",
        //                   t2d.LayoutData10by10[i].layername.c_str(),
        //                   t2d.LayoutData10by10[i].layernum,
        //                   t2d.LayoutData10by10[i].datatype,
        //                   t2d.LayoutData10by10[i].color.r,
        //                   t2d.LayoutData10by10[i].color.g,
        //                   t2d.LayoutData10by10[i].color.b,
        //                   t2d.LayoutData10by10[i].color.a,
        //                   t2d.LayoutData10by10[i].bot,
        //                   t2d.LayoutData10by10[i].top);
        //            for(int j = 0 ; j < (t2d.LayoutData10by10[i].xy).size() ; j++){
        //                for(int x = 0 ; x < (t2d.LayoutData10by10[i].xy[j]).size() ; x++){
        //                    printf("\n%d %d %d", j, x, (t2d.LayoutData10by10[i].xy[j][x]).size());
        //                    for(int y = 0 ; y < (t2d.LayoutData10by10[i].xy[j][x]).size() ; y++){
        //                        printf("\n%-9f %-9f %-9f %-9f",
        //                               t2d.LayoutData10by10[i].xy[j][x][y].minx,
        //                               t2d.LayoutData10by10[i].xy[j][x][y].miny,
        //                               t2d.LayoutData10by10[i].xy[j][x][y].maxx,
        //                               t2d.LayoutData10by10[i].xy[j][x][y].maxy);
        //                    }
        //                }
        //            }
        //        }
                //to map data
        //        for(int i = 0 ; i < t2d.HierarchyInstance.size() ; i++){
        //            printf("\n%-3d %-19s %-9s %-9f %-9f %-9f %-9f",
        //                                t2d.HierarchyInstance[i].level,
        //                                t2d.HierarchyInstance[i].name.c_str(),
        //                                t2d.HierarchyInstance[i].num.c_str(),
        //                                t2d.HierarchyInstance[i].box.minx,
        //                                t2d.HierarchyInstance[i].box.miny,
        //                                t2d.HierarchyInstance[i].box.maxx,
        //                                t2d.HierarchyInstance[i].box.maxy);
        //        }

        formHier->createHierarchyTree(&t2d);

        pos.x = t2d.LayoutMinMax.minx;
        pos.y = t2d.LayoutMinMax.miny;
        pos.z = 0;
        pos.tilt = 90;
        pos.rotation = 0;
        pos.zoom = 1;
        formInfo->setTextPosTotal(&pos);

        //to top data


        DtaoRenderSystem* renderer = this->m_window->getRenderer();

        renderer->createT2DObject(MODEL_TYPE::MODEL_TYPE_LAYOUT, t2d);
        qDebug() << &t2d;

        //cout << "!!" << renderer->getRenderScale() << endl;
        formInfo->receiveFile(t2d);
        formTop->receiveFile(t2d, 100, 0.1);
        formMap->receiveFile(t2d);
        formLayer->ReceiveLayerInformation(t2d);
        //test



    }
    fflush(stdout);
    cout << "test end" << endl;

}

void MainWindow::slotDirectlyInputPos() //point info 에서 직접 입력한 경우
{
    sendPositionDataToDocker();
    DtaoRenderSystem * renderer = this->m_window->getRenderer();
    renderer->goNavi(pos);
    //요청사항 230324 vulkan 에서도 수정을 여기서 실행
}

void MainWindow::slotStatusBarMsg(QString msg)
{
    ui->statusbar->showMessage(msg);
}



void MainWindow::on_actionDemo_triggered()
{
    qDebug() << "go?";
    DtaoRenderSystem* renderer = this->m_window->getRenderer();
    renderer->cameraController.triggerDemo();
}




void MainWindow::on_actionTop_triggered()
{
    qDebug() << "go?";
    //cocococo
}

void MainWindow::on_docker_Map_triggered()
{
    if (dockMap->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockMap->show();
    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockMap->hide();
    }
}

void MainWindow::on_docker_Map_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_Map->setCheckable(true);
        ui->docker_Map->setChecked(true);
    } else {
        ui->docker_Map->setCheckable(false);
        ui->docker_Map->setChecked(false);
    }
}

void MainWindow::on_docker_TopView_triggered()
{

    if (dockTop->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockTop->show();

    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockTop->hide();
    }
}

void MainWindow::on_docker_TopView_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_TopView->setCheckable(true);
        ui->docker_TopView->setChecked(true);
    } else {
        ui->docker_TopView->setCheckable(false);
        ui->docker_TopView->setChecked(false);
    }
}

void MainWindow::on_docker_Info_triggered()
{
    if (dockInfo->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockInfo->show();

    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockInfo->hide();
    }
}

void MainWindow::on_docker_Info_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_Info->setCheckable(true);
        ui->docker_Info->setChecked(true);
    } else {
        ui->docker_Info->setCheckable(false);
        ui->docker_Info->setChecked(false);
    }
}

void MainWindow::on_docker_Hier_triggered()
{
    if (dockHier->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockHier->show();

    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockHier->hide();
    }
}

void MainWindow::on_docker_Hier_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_Hier->setCheckable(true);
        ui->docker_Hier->setChecked(true);
    } else {
        ui->docker_Hier->setCheckable(false);
        ui->docker_Hier->setChecked(false);
    }
}

void MainWindow::on_docker_Layer_triggered()
{
    if (dockLayer->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockLayer->show();

    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockLayer->hide();
    }
}

void MainWindow::on_docker_Layer_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_Layer->setCheckable(true);
        ui->docker_Layer->setChecked(true);
    } else {
        ui->docker_Layer->setCheckable(false);
        ui->docker_Layer->setChecked(false);
    }
}

void MainWindow::on_docker_PEX_triggered()
{
    if (dockPEX->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockPEX->show();

    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockPEX->hide();
    }
}

void MainWindow::on_docker_PEX_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_PEX->setCheckable(true);
        ui->docker_PEX->setChecked(true);
    } else {
        ui->docker_PEX->setCheckable(false);
        ui->docker_PEX->setChecked(false);
    }
}


void MainWindow::on_toggle_top_triggered()
{
    DtaoRenderSystem* renderer = this->m_window->getRenderer();
    renderer->cameraController.camera_moving_flag.toggleDemension = true;
    renderer->cameraController.camera_moving_flag.toggleDemensionXY = true;
}

void MainWindow::sendPositionDataToDocker()
{
//dev_dialog
    if (is_pos_checked)
    {
        formMap->changePos();
        formTop->changePos();
        formInfo->changePos();
        dev_dialog->changePos();
    }
}

void MainWindow::on_actionDialog_on_off_triggered()
{
    dev_dialog->init(this->formTop);
    dev_dialog->show();
    dev_dialog->raise();
    dev_dialog->activateWindow();
}

void MainWindow::on_actionToyCAD_triggered()
{
    DtaoRenderSystem* renderer = this->m_window->getRenderer();

    QString file_name =
            QFileDialog::getOpenFileName(this, "파일 선택", "./ToyCAD/Data", "Files(*.*)");


    //renderer->createToyCADObjects("ToyCAD/Data/test.csv");
    //renderer->createToyCADObjects("ToyCAD/Data/wafer_.csv");
    renderer->createToyCADObjects(file_name.toStdString());


}

void MainWindow::on_actionOpen_Data_Demo_triggered(){
    cout << "test" << endl;
    OpenDataDemo test;
    test.init();
    test.exec();

    formPlayBar->init(test.stl_vertices, test.ModelMinMax, test.Data_3D, test.DataTime.size(), this->m_window->getRenderer());

    DtaoRenderSystem* renderer = this->m_window->getRenderer();

    dockMap->hide();
    dockTop->hide();
    dockHier->hide();
    dockInfo->hide();
    dockLayer->hide();
    dockPlayBar->show();

    renderer->createSTLObjects(test.getSTLVertices(),
                               test.getSTLModelMinMax(),
                               test.getOpenData(0));
    formInfo->receiveFile(t2d);
}
!@hash[]!@file[]./OpenDataDemo/opendatademo.h!@hash[]!@code[]#ifndef OPENDATADEMO_H
#define OPENDATADEMO_H

#include <QDialog>
#include <QFileDialog>
#include <QGraphicsView>
#include <QGraphicsScene>
#include <QGraphicsItem>
#include <QRect>

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <map>

#include "defineParam.h"
#include "T2D.h"

using namespace std;

struct Data_2nd{
    int r, g, b, a;
    double minx, miny, maxx, maxy, minz, maxz;
};

struct Vertex_stl{
    double x, y, z;
};

namespace Ui {
class OpenDataDemo;
}

class OpenDataDemo : public QDialog
{
    Q_OBJECT

public:
    explicit OpenDataDemo(QWidget *parent = nullptr);
    ~OpenDataDemo();

    void init();

    vector<Vertex_stl> stl_vertices;
    //map<string, vector<Data_2nd>> Data_3D;
    vector<vector<Data_2nd>> Data_3D;
    vector<string> DataTime;

    MIN_MAX_XYZ ModelMinMax;
    MIN_MAX_XYZ DataMinMax;

private slots:
    void on_Input_model_btn_clicked();

    void on_Input_data_btn_clicked();

    void on_setting_time_currentIndexChanged(int index);

    void on_setting_x_currentIndexChanged(int index);

    void on_setting_y_currentIndexChanged(int index);

    void on_setting_z_currentIndexChanged(int index);

    void on_setting_color_currentIndexChanged(int index);

    void on_setting_offset_x_editingFinished();

    void on_setting_offset_y_editingFinished();

    void on_setting_offset_z_editingFinished();

    void on_OpenDataDemo_open_btn_clicked();

private:
    Ui::OpenDataDemo *ui;

    QGraphicsScene *topview_scene;
    QGraphicsScene *verticalview_scene;

    void ReadSTL(string file);

    void ReadData(string file);
    vector<string> data_header;
    vector<double> data_col;
    vector<vector<double>> data_total;
    int sheet_col;
    int sheet_row;
    //vector<string> DataTime;

    void createDataSheet();
    void initSetting();

    //void settingCheck();

    int scene_w = 180;
    int scene_h = 180;

    int max_height = 10;

    double offset_x = 0;
    double offset_y = 0;
    double offset_z = 0;

    double color_value;
    double color_max, color_min;

    double z_scale = 10; //10pixel/1um

    double data_x, data_y;
    double data_z;

    void drawingCheck();
    void drawingTopView();
    void drawingVerticalView();

    bool modelMinMaxCheck();
    bool dataMinMaxCheck();

    void initModelMinMax();
    void initDataMinMax();

    bool compareDouble(double x, double y);
    static bool compareVertex_x(const Vertex_stl& a, const Vertex_stl& b){return a.x < b.x;}
    static bool compareVertex_y(const Vertex_stl& a, const Vertex_stl& b){return a.y < b.y;}
    static bool compareVertex_z(const Vertex_stl& a, const Vertex_stl& b){return a.z < b.z;}

public:
    vector<Vertex_stl>& getSTLVertices(){return this->stl_vertices;}
    MIN_MAX_XYZ& getSTLModelMinMax(){return this->ModelMinMax;}

    vector<Data_2nd>& getOpenData(int time){return this->Data_3D[time];}

};

#endif // OPENDATADEMO_H
!@hash[]!@file[]./Rendering/Src/LayoutModel.h!@hash[]!@code[]#pragma once

#include "lve_model.hpp"
#include "T2D.h"

class LayoutModel : public LveModel
{
public:
    LayoutModel(LveDevice& device, MODEL_TYPE model_type, T2D &t2d);
    ~LayoutModel();

    LayoutModel() = delete;
    LayoutModel(const LayoutModel&) = delete;
    LayoutModel& operator=(const LayoutModel&) = delete;

private:
    LayoutDataManager layout_data;

public:
    virtual void makeRenderingData(T2D &t2d);
    virtual void loadData(T2D &t2d);
    virtual void makeVertices(bool isfiltered);
    virtual void makeIndices(bool isfiltered);
    void makeFilteredRendringData();

    void createFilteredLayout();
    void createFilteredBuffers();
    void clearFormerDatas();

    void createBuffers();
    void destroyBuffers();

    void makeCubeVertices(bool isfiltered);
    void makeIndicesForFace(bool isfiltered);
    void makeIndicesForEdge(bool isfiltered);

    void makeCubeVertices_map();
    void makeIndicesForFace_map();
    void makeIndicesForEdge_map();

    void bindDrawVertexIndexBufferForFace_layer(VkCommandBuffer commandBuffer, const string layer);
    void bindDrawIndexBufferForEdge_layer(VkCommandBuffer commandBuffer, const string layer);
    void bindDrawVertexIndexBufferForFace_layer_filtered(VkCommandBuffer commandBuffer, const string layer);
    void bindDrawIndexBufferForEdge_layer_filtered(VkCommandBuffer commandBuffer, const string layer);


    LayoutDataManager* getLayoutDataManager() {return &this->layout_data;}

public:

    std::map<string, std::vector<Vertex>> layerby_vertices;
    std::map<string, std::vector<Vertex>> layerby_vertices_filtered;
    std::map<string, std::vector<uint32_t>> layerby_face;
    std::map<string, std::vector<uint32_t>> layerby_face_filtered;
    std::map<string, std::vector<uint32_t>> layerby_edge;
    std::map<string, std::vector<uint32_t>> layerby_edge_filtered;
    std::map<string, glm::vec3> init_layerby_color;
    std::vector<std::vector<std::vector<B_BOX>>> using_xy;
    T2D &t2d_ref;
    //std::vector<LDATA10BY10> layout_items;

    std::map<string, VkBuffer> layerbyVertexBuffers_filtered;
    std::map<string, VkDeviceMemory> layerbyVertexBuffersMemory_filtered;
    std::map<string, VkBuffer> layerbyFaceIndexBuffers_filtered;
    std::map<string, VkDeviceMemory> layerbyFaceIndexBuffersMemory_filtered;
    std::map<string, VkBuffer> layerbyEdgeIndexBuffers_filtered;
    std::map<string, VkDeviceMemory> layerbyEdgeIndexBuffersMemory_filtered;
    std::vector<string> drawing_order_layerby_filtered{};



    bool isfilteredon=false;


};



!@hash[]!@file[]./Rendering/Src/LayoutPEXData.h!@hash[]!@code[]#pragma once
#include <iostream>
#include <string>
#include <vector>
#include <deque>
#include "T2D.h"
#include <QString>
#include <defineParam.h>


void testPEXData();
void testLayoutData();

enum LAYOUTINFO_INDEX {
    //LAYOUTINFO_IDX_STRUCTURE = 0,
    //LAYOUTINFO_IDX_CELLNAME = 1,
    LAYOUTINFO_IDX_LAYER = 0,
    LAYOUTINFO_IDX_DATATYPE = 1,
    LAYOUTINFO_IDX_LEFT = 2,
    LAYOUTINFO_IDX_BOTTOM = 3,
    LAYOUTINFO_IDX_RIGHT = 4,
    LAYOUTINFO_IDX_TOP = 5,
    LAYOUTINFO_IDX_ZSTART = 6,
    LAYOUTINFO_IDX_ZEND = 7,
    LAYOUTINFO_IDX_DEFAULT = -1,

};

enum LAYOUT_LAYER_TYPE {
    LAYOUT_LAYER_TYPE_1 = 0,
    LAYOUT_LAYER_TYPE_DEFAULT = 99
};

enum PEXINFO_INDEX {
    PEXINFO_INDEX_NAME = 0,

    PEXINFO_INDEX_NODE1_NAME = 1,
    PEXINFO_INDEX_NODE1_X = 2,
    PEXINFO_INDEX_NODE1_Y = 3,
    PEXINFO_INDEX_NODE1_ZSTART = 4,
    PEXINFO_INDEX_NODE1_ZEND = 5,
    PEXINFO_INDEX_NODE1_LVL = 6,
    PEXINFO_INDEX_NODE1_LAYER_NUMBER = 7,
    PEXINFO_INDEX_NODE1_LAYER_DATATYPE = 8,
    PEXINFO_INDEX_NODE2_NAME = 9,
    PEXINFO_INDEX_NODE2_X = 10,
    PEXINFO_INDEX_NODE2_Y = 11,
    PEXINFO_INDEX_NODE2_ZSTART = 12,
    PEXINFO_INDEX_NODE2_ZEND = 13,
    PEXINFO_INDEX_NODE2_LVL = 14,
    PEXINFO_INDEX_NODE2_LAYER_NUMBER = 15,
    PEXINFO_INDEX_NODE2_LAYER_DATATYPE = 16,

    PEXINFO_INDEX_VALUE = 17,
    PEXINFO_INDEX_DESCRIPTION = 18,
    PEXINFO_INDEX_DEFULT = 999
};

enum PEXResDirection {
    RES_DIRECTION_VERTICAL = 0,
    RES_DIRECTION_HORIZONTAL = 1,
    RES_DIRECTION_NONE = 99
};

struct cube_info {
    double minx;
    double miny;
    double maxx;
    double maxy;
    double minz;
    double maxz;
};

struct coord3d {
    double x;
    double y;
    double z;
};

struct cube_vertex {
    string layernum;
    coord3d vertex[8];
};

struct node {
    double x;
    double y;
    double z_start;
    double z_end;
    unsigned int layer_number;
    unsigned int layer_datatype;
    std::string name;
};
typedef struct node pex_node;

class LayoutItem {
public:
    LayoutItem();
    ~LayoutItem();
    LayoutItem(const cube_info& pattern_, const int layer_number_, const int layer_datatype_, LAYOUT_LAYER_TYPE layer_type_);

public:
    cube_info pattern;
    unsigned int layer_number;
    unsigned int layer_datatype;
    LAYOUT_LAYER_TYPE layer_type;
};


class LayoutDataManager
{
public:
    LayoutDataManager();
    ~LayoutDataManager();

private:
    std::string file_path;
    std::vector<LayoutItem> patterns;
    T2D *t2d_ptr;


    double scale;

    double layout_min_x;
    double layout_max_x;
    double layout_min_y;
    double layout_max_y;
    double layout_min_z;
    double layout_max_z;
    double x_diff;
    double y_diff;
    double z_diff;



public:
    std::vector<LayoutItem> &getPatterns() { return this->patterns; }
    std::vector<LDATA10BY10> &getPatterns_t2d() { return this->t2d_ptr->LayoutData10by10; }

    void loadLayoutData(T2D &t2d);
    void clear() { this->patterns.clear(); };
    void printLayoutData() {};
    static bool compareByLength( const LDATA10BY10 &a, const LDATA10BY10 &b);

    double getMinX() { return this->layout_min_x; }
    double getMaxX() { return this->layout_max_x; }
    double getMinY() { return this->layout_min_y; }
    double getMaxY() { return this->layout_max_y; }
    double getMinZ() { return this->layout_min_z; }
    double getMaxZ() { return this->layout_max_z; }
    double getDiffX() { return this->x_diff; }
    double getDiffY() { return this->y_diff; }
    double getDiffZ() { return this->z_diff; }
    double getScale() { return this->scale; }

private:
    void calculateScale();

};

class PEXItem
{
public:
    PEXItem();
    virtual ~PEXItem();
    PEXItem(const node& node1_, const node& node2_, const double& value_, const std::string& name_);

public:
    node node1;
    node node2;
    double value;
    size_t value_rank;
    std::string name;

public:
    void setNode1(node& node_) { this->node1 = node_; }
    void setNode2(node& node_) { this->node2 = node_; }
    void setValue(double value_) { this->value = value_; }

    node& getNode1() { return this->node1; }
    node& getNode2() { return this->node2; }
    double getValue() { return this->value; }

    bool operator<(const PEXItem& other){
        return (this->value < other.value);
    }

    bool operator>(const PEXItem& other){
        return (this->value > other.value);
    }

    virtual void print();

    static bool compare_descending_order(
            const PEXItem* item_left, const PEXItem* item_right){
        return item_left->value > item_right->value;
    }

    static bool compare_ascending_order(
            const PEXItem* item_left, const PEXItem* item_right){
        return item_left->value < item_right->value;
    }
};


class PEXResistor : public PEXItem
{
public:
    PEXResistor();
    virtual ~PEXResistor();
    PEXResistor(const std::string& name_, const node& node1_, const node& node2_, const double& value_, const PEXResDirection& direction_);

private:
    PEXResDirection direction;

public:
    void setDirection(PEXResDirection direction_) { this->direction = direction_; }
    PEXResDirection getDirection() const { return this->direction; }

    static PEXResDirection checkDirectionFromDescription(const std::string& description);

    void print();

public:
    bool checked{false};
};

class PEXCapacitor : public PEXItem
{
public:
    PEXCapacitor();
    ~PEXCapacitor();
    PEXCapacitor(const std::string& name_, const node& node1_, const node& node2_, const double& value_);

public:
    void print();
};


class PEXResistorDataManager
{
public:
    PEXResistorDataManager();
    ~PEXResistorDataManager();

private:
    QString file_path;

    std::vector<PEXResistor*> resistors_ref;
    std::vector<PEXResistor*>* resistors;
    std::vector<PEXResistor*> direction_resistors;

    std::multimap<std::string, PEXResistor*> node_map;
    std::vector<std::vector<PEXResistor*>> nets_list;
    std::deque<std::string> node_queue;
    int current_net_index{-1};
    int nets_count{-1};
    //std::vector<std::vector<PEXResistor>> resistors_of_node;

    double max_resistor_vertical;
    double min_resistor_vertical;
    double max_resistor_horizontal;
    double min_resistor_horizontal;

public:
    std::vector<PEXResistor*>* getResistors() {
        return this->resistors; }
    std::vector<PEXResistor*>* getResistorsRef() {
        return &this->resistors_ref; }
    //std::vector<std::vector<PEXResistor>>* getResistorsOfNode() {
    //    return &this->resistors_of_node; }
    void sortDescendingOrder();
    void setDriectionOfResistor(PEXResDirection _direction);
    void prepareNetRenderingData(int net_index);
    void prepareAllNetRenderingData();

    void loadData(const QString file_path);
    void clear();
    void printData();

    double getMinResistorVerticalValue() { return this->min_resistor_vertical; }
    double getMaxResistorVerticalValue() { return this->max_resistor_vertical; }
    double getMinResistorHorizontalValue() { return this->min_resistor_horizontal; }
    double getMaxResistorHorizontalValue() { return this->max_resistor_horizontal; }

private:
    void updateMinMaxRes(const double& value, const PEXResDirection direction);


public:
    void makeNetsList();
    std::vector<std::vector<PEXResistor*>>* getNetsList() {
        return &this->nets_list;}
    std::vector<PEXResistor*>& getNodesOfTargetNet(int net_index){
        return this->nets_list[net_index];
    }

    int getCurrentNetIndex(){return this->current_net_index;}
    void setCurrentNetIndex(const int index){this->current_net_index = index;}
    std::vector<PEXResistor*>& getCurrentNet(){
        return this->nets_list[this->current_net_index];}
    int getNetsCount(){return this->nets_count;}

private:
    void makeNodeMap();
    unsigned int makeNewNets();
    void findAllNodesAtCurNet(
            std::vector<PEXResistor*>& cur_net);
    void addResistorToCurNet(
            std::vector<PEXResistor*>& cur_net,
            PEXResistor* cur_res);

};

class PEXCapacitorDataManager
{
public:
    PEXCapacitorDataManager();
    ~PEXCapacitorDataManager();

private:
    QString file_path;

    std::vector<PEXCapacitor> capasitors;

    double max_capacitor;
    double min_capacitor;

public:
    std::vector<PEXCapacitor>& getCapacitors() { return this->capasitors; }
    void loadData(const QString file_path);
    void clear();
    void printData();

    double getMinCapacitorValue() { return this->min_capacitor; }
    double getMaxCapacitorValue() { return this->max_capacitor; }

private:
    void updateMinMaxCap(const double& value);
};

!@hash[]!@file[]./Rendering/Src/PEXCapacitorModel.h!@hash[]!@code[]#pragma once
#include "lve_model.hpp"
#include "LayoutPEXData.h"

#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <limits>
#include <thread>
#include <queue>
#include <mutex>
#include <cstdio>


typedef unsigned int uint;

class PEXCapacitorModel : public LveModel
{
public:
    struct cap_node {
        double x;
        double y;
        uint layer_number;
        uint layer_datatype;
        std::string name;
        double value;
        uint connected_count;
    };

    struct pattern_cap {
        cube_info pattern;
        uint layer_number;
        uint layer_datatype;
        uint cap_count;
        double cap_value;
        //double normalized_cap_value;
        size_t value_rank;
    };

public:
    PEXCapacitorModel(
            LveDevice& device, MODEL_TYPE model_type,
            const QString& data_file = "", T2D * layout_data_ =nullptr);
    ~PEXCapacitorModel();

    PEXCapacitorModel() = delete;
    PEXCapacitorModel(const PEXCapacitorModel&) = delete;
    PEXCapacitorModel& operator=(const PEXCapacitorModel&) = delete;

    static bool compare_descending_order(
            const pattern_cap& item_left, const pattern_cap& item_right){
        return item_left.cap_value > item_right.cap_value;
    }

    static bool compare_ascending_order(
            const pattern_cap& item_left, const pattern_cap& item_right){
        return item_left.cap_value < item_right.cap_value;
    }


private:
    PEXCapacitorDataManager pex_data;
    std::map<std::string, size_t> cap_node_name_to_index_map;
    T2D* layout_data =nullptr;

    std::vector<cap_node> cap_nodes;
    std::map<std::string, std::vector<cap_node*>> layer_to_cap_node_map;

    std::vector<pattern_cap> pattern_caps;
    size_t num_of_pattern_cap_not_zero{0};
    std::map<std::string, std::vector<pattern_cap*>> layer_to_pattern_cap_map;

    std::set<std::pair<uint, uint>> layers;

    double max_cap = std::numeric_limits<double>::min();

    size_t num_threads = { 4 };
    std::vector<std::thread> threads;
    std::queue<std::string> layers_queue;
    std::mutex mutex_layers_queue;

public:
    virtual void makeRenderingData(const QString& file_path = "");
    virtual void loadData(const QString& file_path = "");
    virtual void makeVertices();
    virtual void makeIndices();
    virtual void makeIndicesFace();

    void makeCubeVertices();

private:
    void makeCapNodesFromPEXData();
    void makePatternCapsFromLayoutData();

    void attachCapToPattern();
    void makeLayerToCapNodeMap();
    void makeLayerToPatternCapMap();

    void matchCapWithPatternThread(std::queue<std::string>* layers, std::mutex* mutex_);
    void matchCapWithPattern(std::vector<cap_node*>& caps, std::vector<pattern_cap*>& patterns);
    void matchCapWithPattern(
            std::map<std::string, std::vector<cap_node*>>& cap_layer_map_,
            std::map<std::string, std::vector<pattern_cap*>>& pattern_layer_map_,
            uint target_layer_number, uint target_layer_datatype);
    bool isPatternIncludeCap(const pattern_cap& pattern, const cap_node& cap);

    void setLayoutDataManager(T2D* layout_data_) { this->layout_data = layout_data_; }
    void addNewCapNode(pex_node& new_node, double value);

    std::string getLayerString(uint layer_number, uint layer_datatype);

    void normalizePatternCap();
    void sortDescendingOrder();

    void makeLayersQueueForThreadJob();
    double percentileOfCapacitor(const pattern_cap& in_cap);

    size_t getNumOfPatternCapNotZero(){return this->num_of_pattern_cap_not_zero;}
    size_t getNumOfPatternCap(){return this->pattern_caps.size();}


    void printCapNodes();
    void printPatternCaps(FILE* stream = stdout);
    void printLayerToCapNodeMap(FILE* stream = stdout);
    void printLayerToPatternCapMap(const char* msg = "");
    void printLayerList();
};


!@hash[]!@file[]./Rendering/Src/PEXResistorModel.h!@hash[]!@code[]#pragma once

#include "lve_model.hpp"


class PEXResistorModel : public LveModel
{
public:

    PEXResistorModel(LveDevice& device, MODEL_TYPE model_type, const QString& data_file = "");
    ~PEXResistorModel();

    PEXResistorModel() = delete;
    PEXResistorModel(const PEXResistorModel&) = delete;
    PEXResistorModel& operator=(const PEXResistorModel&) = delete;

private:
    PEXResistorDataManager pex_data;
    double res_cube_thickness;


public:
    virtual void makeRenderingData(const QString& file_path = "");
    virtual void loadData(const QString& file_path = "");
    virtual void groupResistorOfNode();
    virtual void increaseNumOfResistorGroup();
    virtual void setNumOfResistorGroup(QString resgroupnum);
    virtual void decreaseNumOfResistorGroup();
    virtual void setDirectionOfResistor(PEXResDirection _direction);
    virtual void makeVertices();
    virtual void makeIndices();
    virtual void makeIndicesForEdge_map();

    void makeNetRenderingData(int net_index);
    void makeAllNetRenderingData();
    void makeDirectionRenderingData(PEXResDirection _direction);

    double percentileOfResistance(const PEXResistor& in_res);

    void makeCubeVertices();
    void makeCubes();
    void makeCube(const PEXResistor& in_res, cube_info& out_cube, PEXResDirection direction);
    void setResCubeThickness(double value) { this->res_cube_thickness = value; }
    PEXResistorDataManager* getPexResData() { return &this->pex_data; }

private:

};


!@hash[]!@file[]./Rendering/Src/dtaorendersystem.h!@hash[]!@code[]#ifndef DTAORENDERSYSTEM_H
#define DTAORENDERSYSTEM_H

#include <QVulkanWindow>
#include <QVulkanWindowRenderer>
#include <QVulkanDeviceFunctions>
#include <vulkan/vulkan.h>

#include "lve_window.hpp"
#include "lve_device.hpp"
#include "lve_game_object.hpp"
#include "simple_render_system.hpp"
#include "lve_camera.hpp"
#include "keyboard_movement_controller.hpp"
#include "T2D.h"
#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "PEXResistorModel.h"

#include "ToyCAD/Src/toycad_object.h"
#include "STLModel/Src/stl_object.h"


#include <iostream>
#include <vector>

enum DTAO_RENDER_MODE{
    DTAO_RENDER_MODE_EMPTY = 0,
    DTAO_RENDER_MODE_LAYOUT,
    DTAO_RENDER_MODE_PEX_ALL,
    DTAO_RENDER_MODE_PEX_RES,
    DTAO_RENDER_MODE_PEX_CAP,
    DTAO_RENDER_MODE_TOYCAD,
    DTAO_RENDER_MODE_STL,
    DTAO_RENDER_MODE_DEFAULT
};

class LayoutModel;

class DtaoRenderSystem : public QVulkanWindowRenderer
{
public:
    DtaoRenderSystem(LveWindow *w);
    ~DtaoRenderSystem();

    DtaoRenderSystem(const DtaoRenderSystem &) = delete;
    DtaoRenderSystem &operator=(const DtaoRenderSystem &) = delete;


    void initResources() override;
    void initSwapChainResources() override;
    void releaseSwapChainResources() override;
    void releaseResources() override;
    void goNavi(POS_MONITORING value);
    void translateLayerPosition();
    void emitMonitor();

    void startNextFrame() override;

    float getRenderScale() {return this->trans_info.scale;}
    LayoutModel* getLayoutModel();
    bool isRenderModelLoaded(){return this->render_object_created;}
    bool isNavi=false;
    POS_MONITORING naviInfo;
    std::vector<LveGameObject> &getGameObjects(){return this->gameObjects;}


public:
    LveCamera camera{};
    KeyboardMovementController cameraController{};


private:
    QVulkanDeviceFunctions *m_devFuncs = nullptr;

    void loadGameObjects();

    LveWindow* lveWindow = nullptr;
    LveDevice* lveDevice = nullptr;
    SimpleRenderSystem* simpleRenderSystem = nullptr;

    std::vector<LveGameObject> gameObjects{};
    bool render_object_created = {false};


    struct TRANS_INFORMATION{
       float trans_x;
       float trans_y;
       float trans_z;
       float scale;
       float minx;
       float miny;
    };
    TRANS_INFORMATION trans_info;
    std::shared_ptr<LayoutModel> layout_model = {nullptr};
    std::shared_ptr<PEXResistorModel> res_model = {nullptr};

    void calculateTransform(MIN_MAX_XYZ& bbox);
    void calculateTransform(double minx, double miny, double minz,
                            double maxx, double maxy, double maxz);

private:
    float trans_info_offset_x = 0;
    float trans_info_offset_y = 0;
    float trans_info_offset_z = 0;
    float stl_minx = 0;
    float stl_miny = 0;


public:
    void createNewObject(MODEL_TYPE model_type, const std::string & file_path);

    std::shared_ptr<PEXResistorModel> &getResistorModel() { return this->res_model;};
    void createT2DObject(MODEL_TYPE model_type, T2D &t2d);
    void createFilteredLayoutObject();
    void getCustomColor(string layernumber, glm::vec3 rgb);
    void getCustomOpacity(string layernumber, float opacity);
    void getCustomVisiblity(string layernumber, bool visibility);
    void createNewPEXCapObject(const QString & file_path, T2D t2d);
    void createNewPEXResObject(const QString & file_path);

    void initCameraView();


private:
    void createNewLayoutObject(const std::string & file_path);
    void createT2DLayoutObject(T2D & t2d);
    void createNewAxisObject(const QString & file_path);


private:
    void createLveDevice();
    void deleteLveDevice();
    void createSimpleRenderSystem();
    void deleteSimpleRenderSystem();
    void beginRenderPass(VkCommandBuffer command_buffer);
    float aspect;

private:
    std::vector<ToyCADObject> toycad_objects{};
    std::vector<STLObject> stl_objects{};

public:
    int render_mode{DTAO_RENDER_MODE_EMPTY};

    std::vector<ToyCADObject>& getToyCADObjects(){return this->toycad_objects;}
    void createToyCADObjects(const std::string& file_path);
    void moveToyCADObjects(glm::vec3 move_dir);

    std::vector<STLObject>& getSTLObjects(){return this->stl_objects;}
    void createSTLObjects(
            std::vector<Vertex_stl>& stl_data,
            MIN_MAX_XYZ& data_bbox,
            std::vector<Data_2nd>& open_data);
    void moveSTLObjects(glm::vec3 move_dir);

};

#endif // DTAORENDERSYSTEM_H
!@hash[]!@file[]./Rendering/Src/keyboard_movement_controller.hpp!@hash[]!@code[]#pragma once

#include <QKeyEvent>
#include <QMouseEvent>
#include "lve_game_object.hpp"
#include "lve_window.hpp"
#include "lve_camera.hpp"
#include "PEXResistorModel.h"
//#include "defineParam.h"

#include "ToyCAD/Src/toycad_object.h"

class KeyboardMovementController {
public:
    struct ModelVisibleSet {
        int resistor_key = Qt::Key_R;
        int capacitor_key = Qt::Key_C;
        int resistor_up_key = Qt::Key_M;
        int resistor_down_key = Qt::Key_N;
        int resistor_horizontal_key = Qt::Key_Comma;
        int resistor_vertical_key = Qt::Key_Period;
        bool resistor_up_key_pressed = false;
        bool resistor_down_key_pressed = false;
        bool resistor_horizontal_key_pressed = false;
        bool resistor_vertical_key_pressed = false;
    };

    struct CameraMoveKeyMappings {
        int rotateLeft = Qt::Key_A;
        int rotateRight = Qt::Key_D;
        int moveForward = Qt::Key_W;
        int moveBackward = Qt::Key_S;
        int rotateForward = Qt::Key_E;
        int rotateBackward = Qt::Key_Q;
        int moveUp = Qt::Key_Up;
        int moveDown= Qt::Key_Down;
        int moveLeft= Qt::Key_Left;
        int moveRight= Qt::Key_Right;
        int toggleDemension= Qt::Key_T;
        int toggleFiltered= Qt::Key_F;
        int clearLayout= Qt::Key_Delete;
        Qt::MouseButtons mouseLeft = Qt::LeftButton;
        Qt::MouseButtons mouseRight = Qt::RightButton;
        Qt::MouseButtons mouseMiddle = Qt::MiddleButton;
    };

    struct CameraMovingContinousFlags {
        bool rotateLeft = false;
        bool rotateRight = false;
        bool moveForward = false;
        bool moveBackward = false;
        bool rotateForward = false;
        bool rotateBackward = false;
        bool moveUp = false;
        bool moveDown= false;
        bool moveLeft= false;
        bool moveRight= false;
        bool toggleDemension = false;
        bool toggleDemensionXY = false;
        bool toggleFiltered = false;
        bool clearLayout = false;
        bool mouseLeft= false;
        bool mouseRight= false;
        bool mouseMiddle= false;
        bool demoTrigger= false;
        bool demoInitLayer= false;
        bool tiltOn=false;
        bool layerOn=false;
        bool wave1 = false;
        bool wave2 = false;
        bool wave3 = false;
    };

    struct MousePosition {
        QPoint pressPosition;
        QPoint releasePosition;
        QPoint currentPosition;
        QPoint scroll;
        QPoint scrollClicked;
    };

    void visibleSetting(std::vector<LveGameObject>& gameObjects, Qt::Key key);
    ModelVisibleSet model_visible_set;
    void moveCamera(Qt::Key key, float dt, LveCamera& camera, float render_scale);
    CameraMoveKeyMappings camera_move_key;
    MousePosition mouse_position;

    glm::vec3 moveCamera(float dt, LveCamera& camera, float render_scale,
                    std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow);
    glm::vec3 moveCameraMouse(LveCamera& camera, float render_scale,
                         std::vector<LveGameObject>& gameObjects,LveWindow* lvewindow);
    void setPerspective(LveCamera& camera, float aspect);
    void moveKeyPressed(Qt::Key key);
    void moveKeyReleased(Qt::Key key);
    void moveButtonPressed(Qt::MouseButtons buttons);
    void moveButtonReleased(Qt::MouseButtons buttons);
    void setAllMoveFlagOff();
    void setMouseFlagOff();
    void setMousePosition(QPoint position, int mode);
    void setMouseScroll(QPoint position);
    void PEXSetting(std::shared_ptr< PEXResistorModel>& pexResistorModel, Qt::Key key);
    void triggerDemo();
    void toggleFilteredData(std::vector<LveGameObject>& gameObjects);
    //void translateLayerPosition(std::vector<LveGameObject>& gameObjects);
    void onDemo(float dt, LveCamera& camera, float render_scale,std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow);
    CameraMovingContinousFlags camera_moving_flag;
    POS_MONITORING monitor;

    glm::vec3 right;
    glm::vec3 forward;
    glm::vec3 up;


    float moveSpeed{ 0.05f };
    float lookSpeed{ 1.5f };
    int xpos_prev;
    int ypos_prev;
    float perspectiveNear{ 0.1f };
    int demoTime{0};
    int demoCheckPoint{0};


};

!@hash[]!@file[]./Rendering/Src/lve_camera.hpp!@hash[]!@code[]#pragma once

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>
#include <glm/gtx/matrix_decompose.hpp>



class LveCamera {
public:
    void setOrthographicProjection(
            float left, float right, float top, float bottom, float near, float far);
    void setPerspectiveProjection(float fovy, float aspect, float near, float far);

    void setViewDirection(
            glm::vec3 position, glm::vec3 direction, glm::vec3 up = glm::vec3{0.f, -1.f, 0.f});
    void setViewTarget(
            glm::vec3 position, glm::vec3 target, glm::vec3 up = glm::vec3{0.f, -1.f, 0.f});
    void setViewYXZ(glm::vec3 position, glm::vec3 rotation);

    const glm::mat4& getProjection() const { return projectionMatrix; }
    const glm::mat4& getView() const { return viewMatrix; }
    void decomposeView(glm::mat4 viewMat);

public:
    glm::mat4 projectionMatrix{1.f};
    glm::mat4 viewMatrix{1.f};

    glm::vec3 scale_d;
    glm::quat rotation_d;
    glm::vec3 translation_d;
    glm::vec3 skew_d;
    glm::vec4 perspective_d;
    float std_scale = 1.f;
    bool isperspective = true;

};

!@hash[]!@file[]./Rendering/Src/lve_device.hpp!@hash[]!@code[]#pragma once

#include <QVulkanInstance>
#include <vulkan/vulkan.h>

// std lib headers
#include <string>
#include <vector>

#include "lve_window.hpp"


struct SwapChainSupportDetails {
    VkSurfaceCapabilitiesKHR capabilities;
    std::vector<VkSurfaceFormatKHR> formats;
    std::vector<VkPresentModeKHR> presentModes;
};

struct QueueFamilyIndices {
    uint32_t graphicsFamily;
    uint32_t presentFamily;
    bool graphicsFamilyHasValue = false;
    bool presentFamilyHasValue = false;
    bool isComplete() { return graphicsFamilyHasValue && presentFamilyHasValue; }
};

class LveDevice {
public:
#ifdef NDEBUG
    const bool enableValidationLayers = false;
#else
    const bool enableValidationLayers = true;
#endif

    LveDevice(LveWindow* window, QVulkanInstance* qvk_inst);
    ~LveDevice();

    // Not copyable or movable
    LveDevice(const LveDevice &) = delete;
    LveDevice &operator=(const LveDevice &) = delete;
    LveDevice(LveDevice &&) = delete;
    LveDevice &operator=(LveDevice &&) = delete;

    VkCommandPool getVkCommandPool() { return commandPool; }
    VkDevice device() { return device_; }
    VkSurfaceKHR surface() { return surface_; }
    VkQueue graphicsQueue() { return graphicsQueue_; }
    VkQueue presentQueue() { return presentQueue_; }
    VkInstance getInstance() { return this->instance;}

    SwapChainSupportDetails getSwapChainSupport() { return querySwapChainSupport(physicalDevice); }
    uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties);
    QueueFamilyIndices findPhysicalQueueFamilies() { return findQueueFamilies(physicalDevice); }
    VkFormat findSupportedFormat(
            const std::vector<VkFormat> &candidates, VkImageTiling tiling, VkFormatFeatureFlags features);

    // Buffer Helper Functions
    void createBuffer(
            VkDeviceSize size,
            VkBufferUsageFlags usage,
            VkMemoryPropertyFlags properties,
            VkBuffer &buffer,
            VkDeviceMemory &bufferMemory);
    VkCommandBuffer beginSingleTimeCommands();
    void endSingleTimeCommands(VkCommandBuffer commandBuffer);
    void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size);
    void copyBufferToImage(
            VkBuffer buffer, VkImage image, uint32_t width, uint32_t height, uint32_t layerCount);

    void createImageWithInfo(
            const VkImageCreateInfo &imageInfo,
            VkMemoryPropertyFlags properties,
            VkImage &image,
            VkDeviceMemory &imageMemory);

    VkPhysicalDeviceProperties properties;

private:
    void createInstance();
    void setupDebugMessenger();
    void createSurface();
    void pickPhysicalDevice();
    void createLogicalDevice();
    void createCommandPool();

    // helper functions
    bool isDeviceSuitable(VkPhysicalDevice device);
    std::vector<const char *> getRequiredExtensions();
    bool checkValidationLayerSupport();
    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device);
    void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT &createInfo);
    void hasRequiredInstanceExtensions();
    bool checkDeviceExtensionSupport(VkPhysicalDevice device);
    SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device);

    VkInstance instance;
    VkDebugUtilsMessengerEXT debugMessenger;
    VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
    LveWindow * window;
    QVulkanInstance * qvk_instance;
    VkCommandPool commandPool;

    VkDevice device_;
    VkSurfaceKHR surface_;
    VkQueue graphicsQueue_;
    VkQueue presentQueue_;

    const std::vector<const char *> validationLayers = {"VK_LAYER_KHRONOS_validation"};
    const std::vector<const char *> deviceExtensions = {VK_KHR_SWAPCHAIN_EXTENSION_NAME};
};

!@hash[]!@file[]./Rendering/Src/lve_game_object.hpp!@hash[]!@code[]#pragma once

#include "lve_model.hpp"

// libs
#include <glm/gtc/matrix_transform.hpp>
#include <glm/glm.hpp> //vec3, vec4, ivec4, mat4
#include <glm/gtc/type_ptr.hpp> //value_ptr

// std
#include <memory>


struct TransformComponent {
    glm::vec3 translation{};
    glm::vec3 scale{ 1.f, 1.f, 1.f };
    glm::vec3 rotation{};

    // Matrix corrsponds to Translate * Ry * Rx * Rz * Scale
    // Rotations correspond to Tait-bryan angles of Y(1), X(2), Z(3)
    // https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
    glm::mat4 mat4() {
        glm::mat4 glm_mat4 = glm::mat4{ 1 };
        //glm_mat4 = glm::rotate(glm_mat4,  rotation.x, glm::vec3(1.0f, 0.0f, 0.0f));
        //glm_mat4 = glm::rotate(glm_mat4, rotation.y, glm::vec3(0.0f, 1.0f, 0.0f));
        //glm_mat4 = glm::rotate(glm_mat4, rotation.z, glm::vec3(1.0f, 0.0f, 1.0f));
        glm_mat4 = glm::translate(glm_mat4, translation);
        glm_mat4 = glm::scale(glm_mat4, scale);



        return glm_mat4;
    }
};

class LveGameObject {
public:
    using id_t = unsigned int;

    static LveGameObject createGameObject() {
        static id_t currentId = 0;
        std::cout << "\n\n***LveGameObject :: id : " << currentId << "\n\n";
        return LveGameObject{ currentId++ };
    }

    LveGameObject(const LveGameObject&) = delete;
    LveGameObject& operator=(const LveGameObject&) = delete;
    LveGameObject(LveGameObject&&) = default;
    LveGameObject& operator=(LveGameObject&&) = default;

    id_t getId() { return id; }

    void setEdgeLineEnable(bool flag) { this->edge_line_enabled = flag; }
    void setAxisLineEnable(bool flag) { this->axis_line_enabled = flag; }

public:
    std::shared_ptr<LveModel> model{};
    //LveModel* model{};
    glm::vec3 color{};
    TransformComponent transform{};

private:
    LveGameObject(id_t objId) : id{ objId } {}

    id_t id;

private:
    bool edge_line_enabled = { true };
    bool axis_line_enabled = { true };
};

class DTAOObject {
public:
    using id_t = unsigned int;

    static DTAOObject createObject() {
        static id_t currentId = 0;
        std::cout << "\n\n***DTAOObject :: id : " << currentId << "\n\n";
        return DTAOObject{ currentId++ };
    }

    DTAOObject(const DTAOObject&) = delete;
    DTAOObject& operator=(const DTAOObject&) = delete;
    DTAOObject(DTAOObject&&) = default;
    DTAOObject& operator=(DTAOObject&&) = default;

    id_t getId() { return id; }

    void setEdgeLineEnable(bool flag) { this->edge_line_enabled = flag; }
    void setAxisLineEnable(bool flag) { this->axis_line_enabled = flag; }

public:
    std::shared_ptr<LveModel> model{};
    //LveModel* model{};
    glm::vec3 color{};
    TransformComponent transform{};

private:
    DTAOObject(id_t objId) : id{ objId } {}

    id_t id;

private:
    bool edge_line_enabled = { true };
    bool axis_line_enabled = { true };
};
!@hash[]!@file[]./Rendering/Src/lve_model.hpp!@hash[]!@code[]#pragma once

#include "lve_device.hpp"

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>

// std
#include <vector>

#include <string>
#include <iostream>

#include <map>
//#include <ranges>
#include "LayoutPEXData.h"

typedef enum MODEL_TYPE {
    MODEL_TYPE_LAYOUT = 0,
    MODEL_TYPE_AXIS,
    MODEL_TYPE_PEX_RESISTOR,
    MODEL_TYPE_PEX_CAPACITOR,
    MODEL_TYPE_TOY_CAD,
    MODEL_TYPE_STL,
    MODEL_TYPE_DEFAULT
} MODEL_TYPE;




class LveModel {
public:
    struct Vertex {
        glm::vec3 position{};
        glm::vec3 color{};
        glm::vec3 normal{};

        static std::vector<VkVertexInputBindingDescription> getBindingDescriptions();
        static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions();
    };

    struct VertexResistor {
        glm::vec3 position{};
        glm::vec4 color{};
        glm::vec3 normal{};

        static std::vector<VkVertexInputBindingDescription> getBindingDescriptions();
        static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions();
    };

    struct VertexCapacitor {
        glm::vec3 position{};
        glm::vec4 color{};
        glm::vec3 normal{};

        static std::vector<VkVertexInputBindingDescription> getBindingDescriptions();
        static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions();
    };



    struct LayerProperty {
        bool visiblity;
        glm::vec3 color{};
        float opacity;
    };

    LveModel(LveDevice& device, MODEL_TYPE model_type);
    ~LveModel();

    LveModel() = delete;
    LveModel(const LveModel&) = delete;
    LveModel& operator=(const LveModel&) = delete;

    //void bind(VkCommandBuffer commandBuffer);
    void bindVertexBuffer(VkCommandBuffer commandBuffer);
    void bindVertexBuffer_map(VkCommandBuffer commandBuffer);
    void bindIndexBufferForFace(VkCommandBuffer commandBuffer);
    void bindIndexBufferForFace_map(VkCommandBuffer commandBuffer);
    void bindDrawVertexIndexBufferForFace_map(VkCommandBuffer commandBuffer);
    //void bindDrawVertexIndexBufferForFace_layer(VkCommandBuffer commandBuffer, const string layer);
    //void bindDrawIndexBufferForEdge_layer(VkCommandBuffer commandBuffer, const string layer);
    void bindIndexBufferForEdge(VkCommandBuffer commandBuffer);
    void drawForFace(VkCommandBuffer commandBuffer);
    void drawForEdge(VkCommandBuffer commandBuffer);


public:
    void createBuffers();
    void destroyBuffers();
    template <typename T>
    void createVertexBuffers(const std::vector<T>& vertices, VkBuffer& buffer, VkDeviceMemory& memory);
    void createIndexBuffers(const std::vector<uint32_t>& indices, VkBuffer & buffer, VkDeviceMemory & memory);
    LveDevice& lveDevice;
    VkBuffer vertexBuffer{};
    VkDeviceMemory vertexBufferMemory{};
    std::map<string, VkBuffer> layerbyVertexBuffers;
    std::map<string, VkDeviceMemory> layerbyVertexBuffersMemory;
    uint32_t vertexCount{};

    VkBuffer indexBufferForFace{};
    VkDeviceMemory indexBufferMemoryForFace{};
    VkBuffer indexBufferForEdge{};
    VkDeviceMemory indexBufferMemoryForEdge{};

    std::map<string, VkBuffer> layerbyFaceIndexBuffers;
    std::map<string, VkDeviceMemory> layerbyFaceIndexBuffersMemory;
    std::map<string, VkBuffer> layerbyEdgeIndexBuffers;
    std::map<string, VkDeviceMemory> layerbyEdgeIndexBuffersMemory;

    MODEL_TYPE model_type{};

public:
    //std::string layout_info_file;
    std::vector<cube_info> cube_infos{};
    std::vector<cube_vertex> cube_vertices{};

    std::vector<Vertex> vertices{};
    std::vector<VertexCapacitor> vertices_capacitor{};
    std::vector<VertexResistor> vertices_resistor{};
    std::vector<uint32_t> indices_face{};
    std::vector<uint32_t> indices_edge{};
    std::vector<string> drawing_order_layerby{};

    // std::map<string, std::vector<Vertex>> layerby_vertices;
    // std::map<string, std::vector<uint32_t>> layerby_face;
    // std::map<string, std::vector<uint32_t>> layerby_edge;
    std::map<string, LayerProperty> layerList;
    // std::map<string, glm::vec3> init_layerby_color;
    void changeLayerColor(string layernumber, glm::vec3 rgb);
    void changeLayerOpacity(string layernumber, float opacity);
    void changeLayerVisiblity(string layernumber, bool visiblity);
    void demoVisiblityOff();
    void demoVisiblityOn(std::vector<string> layernumbers);
    bool visible{true};
    float opacity{ 1.0f };

public:
    MODEL_TYPE getModelType() { return this->model_type; }

public:
    //void setLayoutInfoFile(const std::string file_path) { this->layout_info_file = file_path; }
    virtual void makeRenderingData(const QString& file_path = "") {(void)file_path;};
    virtual void loadData(const std::string& file_path = "") {(void)file_path;};
    virtual void makeVertices() {};
    virtual void makeIndices() {};

    void makeAxisData(const float axis_length = (2.0f));
    void setVisible(bool flag) { this->visible = flag; }
    bool getVisible() { return this->visible; }
    void toggleVisible() { this->visible = !this->visible; }
    void updateOpacity(float amount);
    float getOpacity() { return this->opacity; }
    std::map<string, LayerProperty> getLayer();

};

!@hash[]!@file[]./Rendering/Src/lve_pipeline.hpp!@hash[]!@code[]#pragma once

#include "lve_device.hpp"

// std
#include <string>
#include <vector>



struct PipelineConfigInfo {
    PipelineConfigInfo() = default;
    PipelineConfigInfo(const PipelineConfigInfo&) = delete;
    PipelineConfigInfo& operator=(const PipelineConfigInfo&) = delete;

    VkPipelineViewportStateCreateInfo viewportInfo;
    VkPipelineInputAssemblyStateCreateInfo inputAssemblyInfo;
    VkPipelineRasterizationStateCreateInfo rasterizationInfo;
    VkPipelineMultisampleStateCreateInfo multisampleInfo;
    VkPipelineColorBlendAttachmentState colorBlendAttachment;
    VkPipelineColorBlendStateCreateInfo colorBlendInfo;
    VkPipelineDepthStencilStateCreateInfo depthStencilInfo;
    std::vector<VkDynamicState> dynamicStateEnables;
    VkPipelineDynamicStateCreateInfo dynamicStateInfo;
    VkPipelineLayout pipelineLayout = nullptr;
    VkRenderPass renderPass = nullptr;
    uint32_t subpass = 0;
};

class LvePipeline {
public:
    LvePipeline(
        LveDevice& device,
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo,
        const std::vector<VkVertexInputBindingDescription> bindingDescription_,
        const  std::vector<VkVertexInputAttributeDescription> attributeDescription_);
    ~LvePipeline();

    LvePipeline(const LvePipeline&) = delete;
    LvePipeline& operator=(const LvePipeline&) = delete;

    void bind(VkCommandBuffer commandBuffer);

    static void defaultPipelineConfigInfo(PipelineConfigInfo& configInfo);

private:
    static std::vector<char> readFile(const std::string& filepath);

    void createGraphicsPipeline(
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo,
        const std::vector<VkVertexInputBindingDescription> bindingDescription_,
        const  std::vector<VkVertexInputAttributeDescription> attributeDescription_);

    void createShaderModule(const std::vector<char>& code, VkShaderModule* shaderModule);

    LveDevice& lveDevice;
    VkPipeline graphicsPipeline;
    VkShaderModule vertShaderModule;
    VkShaderModule fragShaderModule;
};

!@hash[]!@file[]./Rendering/Src/lve_window.hpp!@hash[]!@code[]#ifndef LVEWINDOW_H
#define LVEWINDOW_H
#include <vulkan/vulkan.h>
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/string_cast.hpp>

#include <QVulkanWindow>
#include "defineParam.h"
//#include <QVulkanWindowRenderer>

//#include "dtaorendersystem.h"

class QVulkanWidowRenderer;
class DtaoRenderSystem;

class LveWindow : public QVulkanWindow
{
    Q_OBJECT

public:
    LveWindow();
    ~LveWindow();

    LveWindow(const LveWindow &) = delete;
    LveWindow &operator=(const LveWindow &) = delete;

public:
    QVulkanWindowRenderer *createRenderer() override;
    //QVulkanWindowRenderer * getRenderer(){ return this->m_renderer;}
    //LveCamera* camera;
    void emitStatus(float value);

public:
    DtaoRenderSystem * getRenderer(){return this->m_renderer;}

private:
    DtaoRenderSystem *m_renderer;
    //QVulkanWindowRenderer * m_renderer;

    void wheelEvent(QWheelEvent *) override;
    void mousePressEvent(QMouseEvent *) override;
    void mouseReleaseEvent(QMouseEvent *) override;
    void mouseMoveEvent(QMouseEvent *) override;
    void keyPressEvent(QKeyEvent *) override;
    void keyReleaseEvent(QKeyEvent *) override;

    bool keyCtrl = false;
    bool keyShift = false;
    bool keyAlt = false;

    int m_mouseButton = 0;


    QPoint m_lastPos;

signals:
    void signalInfoText(QString funcName, POS_MONITORING value);
};

#endif // LVEWINDOW_H
!@hash[]!@file[]./Rendering/Src/simple_render_system.hpp!@hash[]!@code[]#pragma once
#include <vulkan/vulkan.h>

#include "lve_camera.hpp"
#include "lve_device.hpp"
#include "lve_game_object.hpp"
#include "lve_pipeline.hpp"

#include "ToyCAD/Src/toycad_object.h"

// std
#include <memory>
#include <vector>

#include "STLModel/Src/stl_object.h"

class SimpleRenderSystem {

public:

    SimpleRenderSystem(LveDevice& device, VkRenderPass renderPass);
    ~SimpleRenderSystem();

    SimpleRenderSystem(const SimpleRenderSystem&) = delete;
    SimpleRenderSystem& operator=(const SimpleRenderSystem&) = delete;

    void renderGameObjects(
            VkCommandBuffer commandBuffer,
            std::vector<LveGameObject>& gameObjects,
            const LveCamera& camera);

    void renderToyCADObjects(
            VkCommandBuffer commandBuffer,
            std::vector<ToyCADObject>& objects,
            const LveCamera& camera);

    void renderSTLObjects(
            VkCommandBuffer commandBuffer,
            std::vector<STLObject>& objects,
            const LveCamera& camera);

private:
    void createPipelineLayout(VkPipelineLayout & pipeline_layout);
    void createPipelineForFace(VkRenderPass renderPass);
    void createPipelineForEdge(VkRenderPass renderPass);
    void createPipelineForPEXResistor(VkRenderPass renderPass);
    void createPipelineForPEXResistorEdge(VkRenderPass renderPass);
    void createPipelineForPEXCapacitorLine(VkRenderPass renderPass);
    void createPipelineForPEXCapacitor(VkRenderPass renderPass);
    void createPipelineForPEXCapacitorEdge(VkRenderPass renderPass);

    void createPipelineForToyCADFace(VkRenderPass renderPass);
    void createPipelineForToyCADEdge(VkRenderPass renderPass);

    LveDevice& lveDevice;

    std::unique_ptr<LvePipeline> lvePipelineForLayoutFace;
    VkPipelineLayout pipelineLayoutForLayoutFace;

    std::unique_ptr<LvePipeline> lvePipelineForLayoutEdge;
    VkPipelineLayout pipelineLayoutForLayoutEdge;

    std::unique_ptr<LvePipeline> lvePipelineForPEXResistor;
    VkPipelineLayout pipelineLayoutForPEXResistor;

    std::unique_ptr<LvePipeline> lvePipelineForPEXResistorEdge;
    VkPipelineLayout pipelineLayoutForPEXResistorEdge;

    std::unique_ptr<LvePipeline> lvePipelineForPEXCapacitorLine;
    VkPipelineLayout pipelineLayoutForPEXCapacitorLine;

    std::unique_ptr<LvePipeline> lvePipelineForPEXCapacitor;
    VkPipelineLayout pipelineLayoutForPEXCapacitor;

    std::unique_ptr<LvePipeline> lvePipelineForPEXCapacitorEdge;
    VkPipelineLayout pipelineLayoutForPEXCapacitorEdge;

    std::unique_ptr<LvePipeline> lvePipelineForToyCADFace;
    VkPipelineLayout pipelineLayoutForToyCADFace;
    std::unique_ptr<LvePipeline> lvePipelineForToyCADEdge;
    VkPipelineLayout pipelineLayoutForToyCADEdge;
};

!@hash[]!@file[]./Rendering/Src/utils.h!@hash[]!@code[]#pragma once
#ifndef UTILS
#define UTILS
#endif

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>

#include <string>
#include <iostream>
#include <cstdio>

namespace UTILS {
    inline bool check_file_exsist(const std::string& file_path) {
        FILE* fp = nullptr;
        if (fopen_s(&fp, file_path.c_str(), "r")) {
            fclose(fp);
            return true;
        }
        else {
            return false;
        }
    }

    glm::vec3 getPercentileColour(double v, double vmin, double vmax)
    {
        glm::vec3 c = { 1.0,1.0,0.0 }; // white
        double dv;

        if (v < vmin)
            v = vmin;
        if (v > vmax)
            v = vmax;
        dv = vmax - vmin;

        if (v < (vmin + 0.05 * dv)) {
            c.r = 1;
            c.g = 0;
        }
        else if (v < (vmin + 0.5 * dv)) {
            c.r = 0.5 + 5 * (vmin + 0.5 * dv - v) / dv / 4.0;
            c.g = 0.5 + 5 * (v - vmin - 0.5 * dv) / dv / 4.0;
        }
        else if (v < (vmin + 0.95 * dv)) {
            c.r = 0.5 + 5 * (vmin + 0.5 * dv - v) / dv / 4.0;
            c.g = 0.5 + 5 * (v - vmin - 0.5 * dv) / dv / 4.0;
        }
        else {
            c.r = 0;
            c.g = 1;
        }


        return(c);
    }
}

!@hash[]!@file[]./STLModel/Src/stl_model.h!@hash[]!@code[]#ifndef STLDMODEL_H
#define STLDMODEL_H



#include <iostream>
#include <vector>
#include <string>

#include "Rendering/Src/lve_device.hpp"
#include "Rendering/Src/lve_model.hpp"

#include "OpenDataDemo/opendatademo.h"



class STLModel
{
public:
    struct STLVertex {
        glm::vec3 position{};
        glm::vec3 color{};

        static std::vector<VkVertexInputBindingDescription> getBindingDescriptions();
        static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions();
    };

public:
    STLModel(LveDevice& device, std::vector<Vertex_stl>& stl_data );
    ~STLModel();

    STLModel() = delete;
    STLModel(const STLModel&) = delete;
    STLModel& operator=(const STLModel&) = delete;


    void bindVertexBuffer(VkCommandBuffer commandBuffer, VkBuffer& buffer);
    void draw(VkCommandBuffer commandBuffer, std::vector<STLVertex>& vertices);


    void createBuffers();
    void destroyBuffers();
    void createVertexBuffer(const std::vector<STLVertex>& vertices,
                            VkBuffer& buffer,
                            VkDeviceMemory& memory);


public:
    void makeRenderingData(std::vector<Vertex_stl>& stl_data);


private:
    void makeVertices(std::vector<Vertex_stl>& stl_data);

public:
    LveDevice& lveDevice;
    VkBuffer vertexBufferFace{};
    VkBuffer vertexBufferEdge{};
    VkDeviceMemory vertexBufferMemoryFace{};
    VkDeviceMemory vertexBufferMemoryEdge{};

    std::vector<STLVertex> vertices_face{};
    std::vector<STLVertex> vertices_edge{};

private:
    MODEL_TYPE model_type{};

public:
    void test();
};

#endif // STLMODEL_H
!@hash[]!@file[]./STLModel/Src/stl_object.h!@hash[]!@code[]#ifndef STL_OBJECT_H
#define STL_OBJECT_H

#include "stl_model.h"

#include <glm/gtc/matrix_transform.hpp>
#include <glm/glm.hpp>


struct STLTransformComponent {
    glm::vec3 translation{};
    glm::vec3 scale{ 1.f, 1.f, 1.f };
    glm::vec3 rotation{};


    glm::mat4 mat4() {
        glm::mat4 glm_mat4 = glm::mat4{ 1 };
        glm_mat4 = glm::translate(glm_mat4, translation);
        glm_mat4 = glm::rotate(glm_mat4,
                               glm::radians(rotation.x),
                               glm::vec3(1.0f, 0.0f, 0.0f));
        glm_mat4 = glm::rotate(glm_mat4,
                               glm::radians(rotation.y),
                               glm::vec3(0.0f, 1.0f, 0.0f));
        glm_mat4 = glm::rotate(glm_mat4,
                               glm::radians(rotation.z),
                               glm::vec3(0.0f, 0.0f, 1.0f));
        glm_mat4 = glm::scale(glm_mat4, scale);


        return glm_mat4;
    }
};

class STLObject {
public:
    static STLObject createSTLObject() {
        static unsigned int currentId = 0;
        return STLObject{ currentId++ };
    }

    STLObject(unsigned int objId) : id{ objId } {}

    STLObject(const STLObject&) = delete;
    STLObject& operator=(const STLObject&) = delete;
    STLObject(STLObject&&) = default;
    STLObject& operator=(STLObject&&) = default;

public:
    std::shared_ptr<STLModel> model{};
    glm::vec3 color{128.0f,128.0f,128.0f};
    float opacity{1.0f};
    bool visibility{true};

    STLTransformComponent transform{};

private:
    unsigned int id;

public:
    unsigned int getId() { return this->id; }
    bool getVisibility(){return this->visibility;}
    void setVisibility(bool visibility){this->visibility = visibility;}
};

#endif // STL_OBJECT_H
!@hash[]!@file[]./ToyCAD/Src/toycad_object.h!@hash[]!@code[]#ifndef TOYCAD_OBJECT_H
#define TOYCAD_OBJECT_H

#include "toycadmodel.h"

#include <glm/gtc/matrix_transform.hpp>
#include <glm/glm.hpp>


struct ToyCADTransformComponent {
    glm::vec3 translation{};
    glm::vec3 scale{ 1.f, 1.f, 1.f };
    glm::vec3 rotation{};


    glm::mat4 mat4() {
        glm::mat4 glm_mat4 = glm::mat4{ 1 };
        //glm_mat4 = glm::rotate(glm_mat4,  rotation.x, glm::vec3(1.0f, 0.0f, 0.0f));
        //glm_mat4 = glm::rotate(glm_mat4, rotation.y, glm::vec3(0.0f, 1.0f, 0.0f));

        glm_mat4 = glm::translate(glm_mat4, translation);
        glm_mat4 = glm::rotate(glm_mat4,
                               glm::radians(rotation.x),
                               glm::vec3(1.0f, 0.0f, 0.0f));
        glm_mat4 = glm::rotate(glm_mat4,
                               glm::radians(rotation.y),
                               glm::vec3(0.0f, 1.0f, 0.0f));
        glm_mat4 = glm::rotate(glm_mat4,
                               glm::radians(rotation.z),
                               glm::vec3(0.0f, 0.0f, 1.0f));
        glm_mat4 = glm::scale(glm_mat4, scale);


        return glm_mat4;
    }
};

class ToyCADObject {
public:
    static ToyCADObject createToyCADObject() {
        static unsigned int currentId = 0;
        return ToyCADObject{ currentId++ };
    }

    ToyCADObject(unsigned int objId) : id{ objId } {}

    ToyCADObject(const ToyCADObject&) = delete;
    ToyCADObject& operator=(const ToyCADObject&) = delete;
    ToyCADObject(ToyCADObject&&) = default;
    ToyCADObject& operator=(ToyCADObject&&) = default;

public:
    std::shared_ptr<ToyCADModel> model{};
    glm::vec3 color{};
    float opacity{1.0f};
    bool visibility{true};

    ToyCADTransformComponent transform{};

private:
    unsigned int id;

public:
    unsigned int getId() { return this->id; }
    bool getVisibility(){return this->visibility;}
    void setVisibility(bool visibility){this->visibility = visibility;}
};




#endif // TOYCAD_OBJECT_H
!@hash[]!@file[]./ToyCAD/Src/toycaddata.h!@hash[]!@code[]#ifndef TOYCADDATA_H
#define TOYCADDATA_H

#include <iostream>
#include <vector>

#include "OpenDataDemo/opendatademo.h"

enum TOYCAD_DATA_INDEX {
    TOYCAD_DATA_IDX_TYPE = 0,
    TOYCAD_DATA_IDX_LAYER,
    TOYCAD_DATA_IDX_MINX,
    TOYCAD_DATA_IDX_MINY,
    TOYCAD_DATA_IDX_MAXX,
    TOYCAD_DATA_IDX_MAXY,
    TOYCAD_DATA_IDX_MINZ,
    TOYCAD_DATA_IDX_MAXZ,
    TOYCAD_DATA_IDX_COLOR_R,
    TOYCAD_DATA_IDX_COLOR_G,
    TOYCAD_DATA_IDX_COLOR_B,
    TOYCAD_DATA_IDX_COLOR_A,
    TOYCAD_DATA_IDX_SLOPEX,
    TOYCAD_DATA_IDX_SLOPEY,
    TOYCAD_DATA_IDX_ROTATEX,
    TOYCAD_DATA_IDX_ROTATEY,
    TOYCAD_DATA_IDX_ROTATEZ,
    TOYCAD_DATA_IDX_DEFAULT
};

enum TOYCAD_BBOX_INDEX {
    TOYCAD_BBOX_IDX_MINX = 0,
    TOYCAD_BBOX_IDX_MAXX,
    TOYCAD_BBOX_IDX_MINY,
    TOYCAD_BBOX_IDX_MAXY,
    TOYCAD_BBOX_IDX_MINZ,
    TOYCAD_BBOX_IDX_MAXZ,
    TOYCAD_BBOX_IDX_DEFAULT
};

enum TOYCAD_TYPE_LIST {
    TOYCAD_TYPE_RECT = 0,
    TOYCAD_TYPE_CIRCLE,
    TOYCAD_TYPE_FAN,
    TOYCAD_TYPE_HEXAGON,
    TOYCAD_TYPE_OCTAGON,
    TOYCAD_TYPE_TRIANGLE,
    TOYCAD_TYPE_PENTAGON,
    TOYCAD_TYPE_DIAMOND,
    TOYCAD_TYPE_DEFAULT = 99
};

struct TOYCAD_DATA {
    std::string type;
    std::string layer;
    double minx;
    double miny;
    double maxx;
    double maxy;
    double minz;
    double maxz;
    double color_r;
    double color_g;
    double color_b;
    double color_a;
    double slopex;
    double slopey;
    double rotation_x;
    double rotation_y;
    double rotation_z;
};

struct TOYCAD_BBOX{
    double min_x;
    double max_x;
    double min_y;
    double max_y;
    double min_z;
    double max_z;
};


class ToyCADData
{
public:
    ToyCADData();
    ~ToyCADData();

public:
    std::vector<TOYCAD_DATA>* getCADData(){ return &this->cad_data;}
    void loadToyCADData(const std::string& file_path);
    void loadToyCADData(std::vector<Data_2nd>& open_data);

    TOYCAD_BBOX& getDataBBox(){ return this->data_bbox;}
    double getScale(){return this->scale;}

private:
    std::vector<TOYCAD_DATA> cad_data;
    TOYCAD_BBOX data_bbox;
    double scale;

private:
    void calculateScale();
    void printAllData();
};

#endif // TOYCADDATA_H
!@hash[]!@file[]./ToyCAD/Src/toycadmodel.h!@hash[]!@code[]#ifndef TOYCADMODEL_H
#define TOYCADMODEL_H



#include <iostream>
#include <vector>
#include <string>

#include "Rendering/Src/lve_device.hpp"
#include "Rendering/Src/lve_model.hpp"
#include "toycaddata.h"


const unsigned int num_points_of_triangle = 3;
const unsigned int num_points_of_pentagon = 5;
const unsigned int num_points_of_hexagon = 6;
const unsigned int num_points_of_octagon = 8;
const unsigned int num_points_of_circle = 30;
const unsigned int num_points_of_fan = 20;


class ToyCADModel
{
public:
    struct ToyCADVertex {
        glm::vec3 position{};
        glm::vec3 color{};

        static std::vector<VkVertexInputBindingDescription> getBindingDescriptions();
        static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions();
    };

public:
    ToyCADModel(LveDevice& device, TOYCAD_DATA& toycad_data);
    ~ToyCADModel();

    ToyCADModel() = delete;
    ToyCADModel(const ToyCADModel&) = delete;
    ToyCADModel& operator=(const ToyCADModel&) = delete;


    void bindVertexBuffer(VkCommandBuffer commandBuffer);
    void bindIndexBufferForFace(VkCommandBuffer commandBuffer);
    void bindIndexBufferForEdge(VkCommandBuffer commandBuffer);
    void drawForFace(VkCommandBuffer commandBuffer);
    void drawForEdge(VkCommandBuffer commandBuffer);

    void createBuffers();
    void destroyBuffers();
    void createVertexBuffer(const std::vector<ToyCADVertex>& vertices, VkBuffer& buffer, VkDeviceMemory& memory);
    void createIndexBuffer(const std::vector<uint32_t>& indices, VkBuffer & buffer, VkDeviceMemory & memory);

public:
    void makeRenderingData(TOYCAD_DATA& toycad_data);
    void setNumPointsForCircle(unsigned int num_){this->num_points_for_circle=num_;}
    MODEL_TYPE getModelType() { return this->model_type; }

private:
    void makeVertices(TOYCAD_DATA& toycad_data);
    void makeIndices();

    void makeRectVertices(TOYCAD_DATA& toycad_data);
    void makeCircleVertices(TOYCAD_DATA& toycad_data, const unsigned int num_of_vertex);
    void makeFanVertices(TOYCAD_DATA& toycad_data);
    void makePentagonVertices(TOYCAD_DATA& toycad_data);
    void makeHexagonVertices(TOYCAD_DATA& toycad_data);
    void makeOctagonVertices(TOYCAD_DATA& toycad_data);
    void makeTriangleVertices(TOYCAD_DATA& toycad_data);
    void makeDiamondVertices(TOYCAD_DATA& toycad_data);

    void makeRectIndices();
    void makeCircleIndices(const unsigned int num_of_vertex);
    void makeFanIndices();
    void makePentagonIndices();
    void makeHexagonIndices();
    void makeOctagonIndices();
    void makeTriangleIndices();
    void makeDiamondIndices();

    //void makeIndicesForEdge();
    int getCurDataType(std::string& str_type);

public:
    LveDevice& lveDevice;
    VkBuffer vertexBuffer{};
    VkDeviceMemory vertexBufferMemory{};
    VkBuffer indexBufferForFace{};
    VkDeviceMemory indexBufferMemoryForFace{};
    VkBuffer indexBufferForEdge{};
    VkDeviceMemory indexBufferMemoryForEdge{};

    std::vector<ToyCADVertex> vertices{};
    std::vector<uint32_t> indices_face{};
    std::vector<uint32_t> indices_edge{};



private:
    unsigned int num_points_for_circle;
    int toycad_datatype;
    MODEL_TYPE model_type{};

public:
    void test();
};

#endif // TOYCADMODEL_H
!@hash[]!@file[]./GUI/dev_dialog.h!@hash[]!@code[]#ifndef DEV_DIALOG_H
#define DEV_DIALOG_H

#include <QDialog>
#include <defineParam.h>
#include <QString>
#include <iostream>
#include <sstream>
#include <string>

#include "Rendering/Src/lve_window.hpp"
#include "Rendering/Src/dtaorendersystem.h"

#include "formtop.h"
#include "OpenDataDemo/opendatademo.h"


namespace Ui {
class DevDialog;
}

class DevDialog : public QDialog
{
    Q_OBJECT

public:
    explicit DevDialog(QWidget *parent = nullptr);
    ~DevDialog();

    void sendParameter(bool *is_pos_checked_, POS_MONITORING *pos_);
    void changePos();

    FormTop *ft;
    OpenDataDemo opendatademo;
    void init(FormTop *m);
    void init_opendatademo(vector<Vertex_stl> stl_vertices, MIN_MAX_XYZ ModelMinMax, vector<vector<Data_2nd>> Data_3D, int size);

private slots:
    void on_checkBox_pos_stateChanged(int arg1);

    void on_pushButton_initCamera_clicked();

    void on_topview_um_editingFinished();

    void on_time_slider_valueChanged(int value);

    void on_playbtn_clicked();

private:
    Ui::DevDialog *ui;
    bool *is_pos_checked;
    bool init_check = false;
    POS_MONITORING *pos;

    LveWindow* m_window = nullptr;

public:
    void setRenderWindow(LveWindow* window_){ this->m_window = window_;}

private:
    DtaoRenderSystem* getRenderer(){ return this->m_window->getRenderer();}

};

#endif // DEV_DIALOG_H
!@hash[]!@file[]./GUI/formhier.h!@hash[]!@code[]#ifndef FORMHIER_H
#define FORMHIER_H

#include <QDialog>
//#include "all_data.h"
//#include "mainwindow.h"

#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QSortFilterProxyModel>
#include <vector>
#include <iostream>

#include "T2D.h"
#include "Rendering/Src/LayoutPEXData.h"
#include "Rendering/Src/PEXResistorModel.h"
#include "defineParam.h"

namespace Ui {
class FormHier;
}

class FormHier : public QDialog, public PEXResistorDataManager
{
    Q_OBJECT

public:
    FormHier(QWidget *parent = nullptr);
    ~FormHier();
    Ui::FormHier *ui;

    T2D *t2d;

    void createHierarchyTree(T2D *t2d);
    void setRenderWindow(LveWindow* window_){ this->m_window = window_;}
    void receivePointPos(POS_MONITORING &pos);

private slots:
    void on_hierarchy_tree_itemDoubleClicked(QTreeWidgetItem *item, int column);
    void on_hierarchy_searching_textEdited(const QString &arg1);
signals:
    void signalDirectlyInputPos();
private:
    LveWindow* m_window = nullptr;
    DtaoRenderSystem* getRenderer(){ return this->m_window->getRenderer();}
    POS_MONITORING *pos_ptr;
};

#endif // FORMHIER_H

/////
!@hash[]!@file[]./GUI/forminfo.h!@hash[]!@code[]#ifndef FORMINFO_H
#define FORMINFO_H

#include <QDialog>
#include <QLineEdit>
#include <QListWidgetItem>
#include <glm/gtx/string_cast.hpp>
#include "T2D.h"
#include "defineParam.h"

namespace Ui {
class FormInfo;
}

class FormInfo : public QDialog
{
    Q_OBJECT

public:
    explicit FormInfo(QWidget *parent = nullptr);
    ~FormInfo();

    void setTextPosTotal(POS_MONITORING *pos);
    void receiveFile(T2D &t2d);
    void receivePointPos(POS_MONITORING &pos);
    void changePos();
    void addItemToPosList(POS_SET *position_item);

private:
    void addItemToListWidget();
    void setTextTrim(QLineEdit *text, double *value, int decimals_, int scale_, QString add_text_);
    void setTextTrim(QLineEdit *text, QString text_);
    void makePosListItem();

    void outputPosList();
    void resetPosList();
    QString makePosText();
    void sendStatusBarMsg(QString msg);
    void inputValueToTemp(double *point, double value_);
    void convertTextToValue(double *point, const QString &str);
    void inputPos();

//    void selectListWidgetItem();

    Ui::FormInfo *ui;
    T2D *rendering_full;
    POS_MONITORING *POS;
    POS_MONITORING TEMP_POS;
    QVector<POS_SET> POS_STACK;
    QList<QListWidgetItem*> selected_item;
    bool isFileOpen = false;
    bool isEndedEdit = true;
    bool make_status_bar_msg = true;
    bool isDeleting = false;
    int current_item = -1;
    int pos_number = 0;
    int item_data_i = 0;

signals:
    void signalDirectlyInputPos();
    void signalStatusBarMsg(QString msg);
private slots:
    void on_pos_x_textEdited(const QString &arg1);
    void on_pos_y_textEdited(const QString &arg1);
    void on_pos_z_textEdited(const QString &arg1);
    void on_ang_tilt_textEdited(const QString &arg1);
    void on_ang_rotation_textEdited(const QString &arg1);
    void on_zoom_textEdited(const QString &arg1);    
    void on_pos_x_editingFinished();
    void on_pos_y_editingFinished();
    void on_pos_z_editingFinished();
    void on_ang_tilt_editingFinished();
    void on_ang_rotation_editingFinished();
    void on_zoom_editingFinished();
    void on_pos_x_returnPressed();
    void on_pos_y_returnPressed();
    void on_pos_z_returnPressed();
    void on_ang_tilt_returnPressed();
    void on_ang_rotation_returnPressed();
    void on_zoom_returnPressed();

    void on_listWidget_currentRowChanged(int currentRow);
    void on_pushButton_go_clicked();
    void on_pushButton_add_clicked();
    void on_pushButton_del_clicked();
    void on_listWidget_itemChanged(QListWidgetItem *item);

    void on_listWidget_itemSelectionChanged();

};

#endif // FORMINFO_H
!@hash[]!@file[]./GUI/formlayer.h!@hash[]!@code[]#ifndef FORMLAYER_H
#define FORMLAYER_H

#include <QDialog>
#include <QColorDialog>
#include <QtWidgets/QCheckBox>
#include <QTableWidget>
#include <QTableWidgetItem>
#include <QCheckBox>
#include <QPushButton>
#include <QtWidgets/QSlider>
#include <QRgba64>
#include <QDebug>
#include "Rendering/Src/lve_window.hpp"
#include "Rendering/Src/dtaorendersystem.h"
#include "T2D.h"


namespace Ui {
class FormLayer;
}

class FormLayer : public QDialog
{
    Q_OBJECT

public:
    explicit FormLayer(LveWindow *w, QWidget *parent = nullptr);
    ~FormLayer();
    void ReceiveLayerInformation(T2D &t2d);
    void MakeLayerInformationTableHeader();
    void MakeLayerInformationTalbe();
    void MakeTableWidgetItemForText(int);
    void MakeSliderForOpacity(int);
    void MakeCheckBox(int);
    void MakeColorButton(int);
    void MakeHeaderCheckBoxAndSlider();
    void ChangeAllCheckBoxState(QCheckBox *);
    void ChangeCheckBoxStateToOn(int, string, QString);
    void ChangeCheckBoxStateToOff(int, string, QString);
    void GetPushButtonOldColor(QPushButton *, int *, int *, int *, int *, QRgba64 *);
    void EnterPushButtonNewColor(int *, QRgba64 *);
    int FindCheckBoxRow(QCheckBox *);

    bool m_layer_all_check = false;

public slots:
    void on_checkboxInTable_stateChanged();
    void on_colorbutton_clicked();
    void on_opacityslider_valueChanged(int);
    void OpacitySliderValueChange(int);

private:
    LveWindow *m_window;
    Ui::FormLayer *ui;
    T2D *t2d_layer_information;
    int data_row_for_t2d = -1;
    int checkboxrow = -1;
    int table_default_column = 6;
    QString empty_for_emit = "";
    QString CommentAllCheckedCheckBox = "All Layer Checked";
    QString CommentAllUncheckedCheckBox = "All Layer Unchecked";


signals:
    void outputLayerStatus(QString printLayer);

};

#endif // FORMLAYER_H
!@hash[]!@file[]./GUI/formmap.h!@hash[]!@code[]#ifndef FORMMAP_H
#define FORMMAP_H
#include <glm/gtx/string_cast.hpp>
#include <QDialog>
#include <QGraphicsRectItem>
#include <QGraphicsScene>
#include <QGraphicsSceneMouseEvent>
#include "defineParam.h"
#include "T2D.h"

namespace Ui {
class FormMap;
}

class SuperItem : public QObject, public QGraphicsItem
{
    Q_OBJECT
public:
    SuperItem(QGraphicsItem* parent = NULL);
    void getScaleValue(double *m_scale_, double *m_from_window_to_box_x_, double *m_from_window_to_box_y_, double *m_min_x_, double *m_min_y_, double *m_zoom_init_);
public slots:
    void slotMove(POS_MONITORING *pos_);
    void slotMouseMoveEvent(QPointF event);
    void slotMouseReleaseEvent();

signals:
    void signalDirectlyInputPos();

protected:
    void paint(QPainter *painter,
               const QStyleOptionGraphicsItem *option,
               QWidget *widget) override;
    QRectF boundingRect() const override;
    QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;


//    virtual void keyPressEvent(QKeyEvent *evnet);

private:
    bool init_check = true;
    double convertPosX();
    double convertPosY();
    double m_pos_past_x = 0;
    double m_pos_past_y = 0;
    double m_view_size = 1;    
    double m_gray_box_size = 120;
    double *m_scale;
    double *m_zoom_init;
    double *m_from_window_to_box_x;
    double *m_from_window_to_box_y;
    double *m_min_x;
    double *m_min_y;
    double m_zero_point_x;
    double m_zero_point_y;
    double temp_x;      // 마우스로 box 움직일 때 좌표 알아보기 위함
    double temp_y;
    POS_MONITORING *pos;
};

class CustomScene : public QGraphicsScene
{
    Q_OBJECT
public:
    explicit CustomScene(QObject *parent = nullptr);
public slots:
    virtual void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
    virtual void mouseMoveEvent(QGraphicsSceneMouseEvent *event) override;
    virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
signals:    
    void signalMouseMoveEvent(QPointF event);
    void signalMouseReleaseEvent();
};

class FormMap : public QDialog
{
    Q_OBJECT

public:
    explicit FormMap(QWidget *parent = nullptr);
    ~FormMap();
    void receiveFile(T2D &t2d);
    void receivePointPos(POS_MONITORING &pos);

public slots:
    void changePos();
    void slotDirectlyInputPos();

signals:
    void signalMove(POS_MONITORING *pos);
    void signalInitMove(double x, double y);
    void signalDirectlyInputPos();

private:
    Ui::FormMap *ui;
    QGraphicsRectItem *rectItem;
    QGraphicsRectItem *rectItem2;
    QRect *rect;    
    double m_min_x;
    double m_min_y;
    double m_scale = 1;
    double m_zoom_init;
    double m_gray_box_size = 120;
    double m_window_width;
    double m_window_height;
    double m_box_width;
    double m_box_height;
    double m_from_window_to_box_x;
    double m_from_window_to_box_y;
    double m_center_x;
    double m_center_y;

    SuperItem *super;

    POS_MONITORING *pos;

    float pointX = 0;
    float pointY = 0;
    float pointZ = 0;
    float infoTilt = 90;
    float infoRot = 0;
    float infoZoom = 1; //Zoom 초기값에 대한 GDS size 를 갖고와 수정 필요

    float initRot = 0;
    float initTilt = 90;
    float initPointX = 0;
    float initPointY = 0;
    float initPointZ = 0;

    float x = 0;
    float y = 0;
};



#endif // FORMMAP_H
!@hash[]!@file[]./GUI/formpex.h!@hash[]!@code[]#ifndef FORMPEX_H
#define FORMPEX_H

#include <QDialog>
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include "T2D.h"
#include "Rendering/Src/LayoutPEXData.h"
#include "Rendering/Src/PEXResistorModel.h"


namespace Ui {
class FormPEX;
}

class FormPEX : public QDialog, public PEXResistorDataManager
{
    Q_OBJECT

public:
    explicit FormPEX(QWidget *parent = nullptr);
    ~FormPEX();
    Ui::FormPEX *ui;
    void makePEXResList(std::vector<std::vector<PEXResistor*>>* pexResModel);
    void makePEXResTreeTop(QTreeWidgetItem *ResTopTree, int group_num, int node_num);
    void makePEXResTreeChild(QTreeWidgetItem *ResTopTree ,PEXResistor& pexRes);
    void drawPEXResistorModelGroup(
            std::shared_ptr<PEXResistorModel>& pexResistorModel,
            QString res_group_num);
    void moveToResistorGroup(DtaoRenderSystem* renderer,QString res_group_num);
    void erasePEXCapacitorModelGroup();
    void setRenderWindow(LveWindow* window_){ this->m_window = window_;}
    void findResistorWithAsterisk(QString asterisk_text);
    void findResistorWithTyping(QString typing_text);
    void changeNaviFlag(DtaoRenderSystem* renderer);
    void changeXYCoordinate(DtaoRenderSystem* renderer, QString res_group_num);

private slots:
    void on_tree_pex_itemClicked(QTreeWidgetItem *item, int column);
    void on_all_view_clicked();
    void on_res_search_textEdited(const QString &arg1);
    void on_cap_view_button_toggled(bool checked);

private:
    LveWindow* m_window = nullptr;
    DtaoRenderSystem* getRenderer(){ return this->m_window->getRenderer();}

};

#endif // FORMPEX_H
!@hash[]!@file[]./GUI/formtop.h!@hash[]!@code[]#ifndef FORMTOP_H
#define FORMTOP_H

#include "T2D.h"
#include "defineParam.h"
#include <QtWidgets/QDialog>
#include <QtWidgets/QGraphicsItem>
#include <QVector>
#include <QtWidgets/QGraphicsRectItem>
#include <QtWidgets/QMenu>
#include <QContextMenuEvent>
#include <QtWidgets/QGraphicsScene>
#include <QtWidgets/QGraphicsSceneEvent>
#include <QtWidgets/QGraphicsSceneMouseEvent>
#include <QtWidgets/QGraphicsView>
#include <list>
#include <tuple>
#include <thread>
#include <mutex>
#include <vector>

namespace Ui {
class FormTop;
}

class FormTop : public QDialog
{
    Q_OBJECT

public:
    explicit FormTop(QWidget *parent = nullptr);
    ~FormTop();

    void receiveFile(T2D &t2d, int pixel, double um);
    void drawing();
    void filterDrawing();
    void drawingClear();
    void receivePointPos(POS_MONITORING &pos);
    void changePos();
//    void receiveFile(QVector<QList<float>> **mapFile);

    double m_origin_scale;

private:
    int m_standard_pixel = 1;

    void addItem(B_BOX bBox, COLOR_RGBA rgba, double top, QTransform trans);

    void addRectItem(int layer, int row, int col, int n, QTransform trans);

    void addFilterRectItem(int layer, int row, int col, int n, QTransform trans);
    int extPos(double *pos, double *min, double *max);
    void filterRenderingData(int layer, int row, int col, int n);
    void areaFilterRect();
    void getRowCol();
    Ui::FormTop *ui;
    T2D *rendering_full;        
    POS_MONITORING *pos;
    POS_MONITORING temp_pos;
    QGraphicsScene *m_scene;
    QVector<QGraphicsRectItem*> rectItemList;
    QVector<QGraphicsLineItem*> lineItemList;
    QTransform trans;
    int m_begin_x = 0, m_begin_y = 0, m_end_x = 1, m_end_y = 1, m_scale = 500;
    float m_min_x = 0, m_min_y =0, m_max_x =0, m_max_y=0;
    bool init_check = true;

    int m_begin_row = 0, m_end_row = 1, m_begin_col = 0, m_end_col = 1;
    int m_block_size = 10; //10um
    double m_area = 50, m_area_scale = 100 ; // 50/1000 = 0.05um(0.001~0.099)
    double m_min_x_size = -0.5, m_max_x_size = 0.5, m_min_y_size = -0.5, m_max_y_size = 0.5;

//    double m_origin_scale;
    bool changepos_init_check = true;
    int m_scene_standard = 100;

    QMenu formtop_menu;
    QAction* formtop_cut_all;
    QAction* formtop_cut_rigtht;
    QAction* formtop_cut_left;
    QAction* formtop_cut_top;
    QAction* formtop_cut_bottom;

    //bool m_filter_onoff = false;
    bool m_filter_right = false;
    bool m_filter_left = false;
    bool m_filter_top = false;
    bool m_filter_bottom = false;

    void filterMenuCheck();

    double view_minx, view_maxx, view_miny, view_maxy;

    QPointF startPoint;

signals:
    void signalChangePos(QString func, POS_MONITORING pos);

protected:
    void contextMenuEvent(QContextMenuEvent* event) override;
//    void wheelEvent(QWheelEvent *event) override;
//    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
//    void mouseMoveEvent(QGraphicsSceneMouseEvent *event) override;
    void resizeEvent(QResizeEvent *) override;

};

#endif // FORMTOP_H
!@hash[]!@file[]./GUI/formplaybar.h!@hash[]!@code[]#ifndef FORMPLAYBAR_H
#define FORMPLAYBAR_H

#include <QDialog>
#include <QTimer>

#include "Rendering/Src/lve_window.hpp"
#include "Rendering/Src/dtaorendersystem.h"

#include "OpenDataDemo/opendatademo.h"

namespace Ui {
class FormPlayBar;
}

class FormPlayBar : public QDialog
{
    Q_OBJECT

public:
    explicit FormPlayBar(QWidget *parent = nullptr);
    ~FormPlayBar();

    void init(vector<Vertex_stl> stl_vertices, MIN_MAX_XYZ ModelMinMax, vector<vector<Data_2nd>> Data_3D, int size, DtaoRenderSystem* render);

private:
    Ui::FormPlayBar *ui;

    DtaoRenderSystem* renderer;
    OpenDataDemo opendatademo;

    LveWindow* m_window = nullptr;

    QTimer *timer;

    bool play_check = false;

private slots:
    void startButtonClicked();
    void stopButtonClicked();
    void moveSlider();

    void on_time_slider_valueChanged(int value);
    void on_play_btn_clicked();
};

#endif // FORMPLAYBAR_H
!@hash[]!@file[]./defineParam.h!@hash[]!@code[]#ifndef DEFINETYPE_H
#define DEFINETYPE_H

#include <iostream>
#include <vector>

using namespace std;

struct POS_MONITORING{
    double x;
    double y;
    double z;
    double tilt;
    double rotation;
    double zoom;
    double window_zoom;
};

struct POS_SET
{
    std::string name;
    POS_MONITORING position;
};

struct B_BOX{
    double minx;
    double miny;
    double maxx;
    double maxy;
};

struct COLOR_RGBA{
    int r;
    int g;
    int b;
    int a;
};

struct LDATA10BY10{
    bool checking;
    std::string layername;
    int layernum;
    int datatype;
    COLOR_RGBA color;
    double bot;
    double top;
    std::vector<std::vector<std::vector<B_BOX>>> xy;
    std::vector<std::vector<std::vector<B_BOX>>> xy_filtered;
};

struct MIN_MAX_XYZ{
    double minx;
    double maxx;
    double miny;
    double maxy;
    double minz;
    double maxz;
};

#endif // DEFINETYPE_H


!@hash[]!@file[]./T2D.h!@hash[]!@code[]#ifndef T2D_H
#define T2D_H

#include "defineParam.h"

#include <iostream>
#include <vector>
#include <sstream>
#include <fstream>
#include <map>
#include <cstring>

using namespace std;

struct Instance{
    int level;
    string name;
    string num;
    B_BOX box;
};


class T2D{
    public:
        bool text2data(std::string file_name);

        std::vector<LDATA10BY10> LayoutData10by10;
        map<string, LDATA10BY10> map_LayoutData10by10_;
        MIN_MAX_XYZ LayoutMinMax;

        LDATA10BY10 buf_ldata10by10;
        vector<vector<vector<B_BOX>>> buf_xy10by10;
        vector<B_BOX> buf_xy;
        static std::vector<std::string> string_split(std::string input, char delimiter);

        vector<Instance> HierarchyInstance;

        int row;
        int col;

        bool m_filter_onoff = false;
};

#endif // T2D_H
!@hash[]!@file[]./filedb.h!@hash[]!@code[]#ifndef FILEDB_H
#define FILEDB_H

#include <QVector>


class FileDb
{
public:
    FileDb();
    void openFile(QString fileNameInfo,QVector<QList<float>> &vecList,
                  float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize);
};

#endif // FILEDB_H
!@hash[]!@file[]./gitmerge.h!@hash[]!@code[]#ifndef GITMERGE_H
#define GITMERGE_H

#include <QString>

class GitMerge
{
public:
    GitMerge();
private:
    void readTxtFile();
    void readCodeFiles();
    bool compareCodeFile(QString &A, QString &B);
    void makeTxtFile();
    void makeCodeFiles();

    bool write_code_files = false;
    QString split1;
    QString split2;
    QString merged_code_files;    //각종 cpp, h 등에서 읽어온 내용
    QString based_on_reading_txt; //gitMerge.txt 에서 읽어온 내용
    QString txt_file = "./gitMerge.txt";
    QString pro_file = "./IInterface.pro";
    QString hash = "!@hash[]";
    QString file = "!@file[]";
    QString code = "!@code[]";
};

#endif // GITMERGE_H
!@hash[]!@file[]./mainwindow.h!@hash[]!@code[]#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include "Rendering/Src/lve_window.hpp"

#include <QMainWindow>
#include <QVulkanWindow>
#include <QDockWidget>
#include <QMessageBox>

#include "GUI/formhier.h"
#include "GUI/formlayer.h"
#include "GUI/formpex.h"
#include "GUI/formtop.h"
#include "GUI/forminfo.h"
#include "GUI/formmap.h"
#include "GUI/formplaybar.h"
#include "filedb.h"
#include <QVector>
#include "defineParam.h"

#include "GUI/dev_dialog.h"

#include "T2D.h"

#include "OpenDataDemo/opendatademo.h"

class LveWindow;

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; class LayerForm; }
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(LveWindow *w);
    ~MainWindow();

    void shareGeo(QRect size);
    void devDialog();

    T2D t2d;

public slots:

    void slotInfoText(QString funcName, POS_MONITORING value);
    void inputLayerStatus(QString text);
    void on_actionOpen_file_triggered();
    void inputPosInformation();

signals:
    void signalInfoText(QString funcName, float value);
    void sendSelectFileName(QString file_name);



private slots:
    void on_actionOpen_Layout_triggered();
    void on_actionOpen_DB_triggered();
    void on_actionOpen_PEX_triggered();
    void slotDirectlyInputPos();
    void slotStatusBarMsg(QString msg);

    void on_actionTop_triggered();
    void on_actionDemo_triggered();
    void on_docker_TopView_triggered();
    void on_docker_TopView_stateChanged(bool);
    void on_docker_Map_triggered();
    void on_docker_Map_stateChanged(bool);
    void on_docker_Info_triggered();
    void on_docker_Info_stateChanged(bool);
    void on_docker_Hier_triggered();
    void on_docker_Hier_stateChanged(bool);
    void on_docker_Layer_triggered();
    void on_docker_Layer_stateChanged(bool);
    void on_docker_PEX_triggered();
    void on_docker_PEX_stateChanged(bool);
    void on_toggle_top_triggered();

    void on_actionDialog_on_off_triggered();

    void on_actionToyCAD_triggered();

    void on_actionOpen_Data_Demo_triggered();

private:
    void sendPositionDataToDocker();
    LveWindow *m_window;
    Ui::MainWindow *ui;
    QString statusText;
    FormHier *formHier;
    FormLayer *formLayer;
    FormPEX *formPEX;
    FormTop *formTop;
    FormInfo *formInfo;
    FormMap *formMap;
    FormPlayBar *formPlayBar;
    QDockWidget *dockHier;
    QDockWidget *dockLayer;
    QDockWidget *dockPEX;
    QDockWidget *dockMap;
    QDockWidget *dockTop;
    QDockWidget *dockInfo;
    QDockWidget *dockPlayBar;
    SuperItem *superItem;
    QRect *windowSize;
    FileDb *fileDb;
    QStringList split_data;
    POS_MONITORING pos;
    POS_MONITORING pos_past;
    QByteArray dock_widget_geometry;
    QByteArray dock_widget_state;

    OpenDataDemo *opendatademo;

//dev_dialog
    DevDialog *dev_dialog;
    bool is_pos_checked = true;

};

#endif // MAINWINDOW_H
!@hash[]!@file[]./OpenDataDemo/opendatademo.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>OpenDataDemo</class>
 <widget class="QDialog" name="OpenDataDemo">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>725</width>
    <height>785</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <widget class="QGroupBox" name="Inupt_frame">
   <property name="geometry">
    <rect>
     <x>5</x>
     <y>20</y>
     <width>500</width>
     <height>65</height>
    </rect>
   </property>
   <property name="layoutDirection">
    <enum>Qt::LeftToRight</enum>
   </property>
   <property name="title">
    <string/>
   </property>
   <property name="alignment">
    <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
   </property>
   <property name="flat">
    <bool>false</bool>
   </property>
   <property name="checkable">
    <bool>false</bool>
   </property>
   <widget class="QLabel" name="Input_model_label">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>5</y>
      <width>35</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Model</string>
    </property>
   </widget>
   <widget class="QLineEdit" name="Input_model">
    <property name="enabled">
     <bool>false</bool>
    </property>
    <property name="geometry">
     <rect>
      <x>55</x>
      <y>5</y>
      <width>410</width>
      <height>25</height>
     </rect>
    </property>
    <property name="frame">
     <bool>true</bool>
    </property>
   </widget>
   <widget class="QPushButton" name="Input_model_btn">
    <property name="geometry">
     <rect>
      <x>470</x>
      <y>5</y>
      <width>25</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>...</string>
    </property>
   </widget>
   <widget class="QPushButton" name="Input_data_btn">
    <property name="geometry">
     <rect>
      <x>470</x>
      <y>35</y>
      <width>25</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>...</string>
    </property>
   </widget>
   <widget class="QLabel" name="Input_data_label">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>35</y>
      <width>35</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Data</string>
    </property>
   </widget>
   <widget class="QLineEdit" name="Input_data">
    <property name="enabled">
     <bool>false</bool>
    </property>
    <property name="geometry">
     <rect>
      <x>55</x>
      <y>35</y>
      <width>410</width>
      <height>25</height>
     </rect>
    </property>
   </widget>
  </widget>
  <widget class="QLabel" name="Input_frame_label">
   <property name="geometry">
    <rect>
     <x>5</x>
     <y>5</y>
     <width>200</width>
     <height>15</height>
    </rect>
   </property>
   <property name="frameShape">
    <enum>QFrame::NoFrame</enum>
   </property>
   <property name="text">
    <string>Input Information</string>
   </property>
   <property name="textFormat">
    <enum>Qt::AutoText</enum>
   </property>
   <property name="scaledContents">
    <bool>false</bool>
   </property>
   <property name="wordWrap">
    <bool>false</bool>
   </property>
  </widget>
  <widget class="QGroupBox" name="Topview_frame">
   <property name="geometry">
    <rect>
     <x>510</x>
     <y>20</y>
     <width>210</width>
     <height>210</height>
    </rect>
   </property>
   <property name="title">
    <string/>
   </property>
   <widget class="QGraphicsView" name="Topview">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>5</y>
      <width>200</width>
      <height>200</height>
     </rect>
    </property>
   </widget>
  </widget>
  <widget class="QLabel" name="Topview_frame_label">
   <property name="geometry">
    <rect>
     <x>510</x>
     <y>5</y>
     <width>100</width>
     <height>15</height>
    </rect>
   </property>
   <property name="text">
    <string>Top View</string>
   </property>
  </widget>
  <widget class="QLabel" name="Verticalview_frame_label">
   <property name="geometry">
    <rect>
     <x>510</x>
     <y>235</y>
     <width>100</width>
     <height>15</height>
    </rect>
   </property>
   <property name="text">
    <string>Vertical View</string>
   </property>
  </widget>
  <widget class="QGroupBox" name="Verticalview_frame">
   <property name="geometry">
    <rect>
     <x>510</x>
     <y>250</y>
     <width>210</width>
     <height>210</height>
    </rect>
   </property>
   <property name="title">
    <string/>
   </property>
   <widget class="QGraphicsView" name="Verticalview">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>5</y>
      <width>200</width>
      <height>200</height>
     </rect>
    </property>
   </widget>
  </widget>
  <widget class="QGroupBox" name="Datasheet_frame">
   <property name="geometry">
    <rect>
     <x>5</x>
     <y>105</y>
     <width>500</width>
     <height>645</height>
    </rect>
   </property>
   <property name="title">
    <string/>
   </property>
   <widget class="QTableWidget" name="Datasheet">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>5</y>
      <width>490</width>
      <height>635</height>
     </rect>
    </property>
    <attribute name="horizontalHeaderDefaultSectionSize">
     <number>60</number>
    </attribute>
   </widget>
  </widget>
  <widget class="QLabel" name="Datasheet_frame_label">
   <property name="geometry">
    <rect>
     <x>5</x>
     <y>90</y>
     <width>100</width>
     <height>15</height>
    </rect>
   </property>
   <property name="text">
    <string>Data Sheet</string>
   </property>
  </widget>
  <widget class="QLabel" name="Setting_frame_label">
   <property name="geometry">
    <rect>
     <x>510</x>
     <y>465</y>
     <width>100</width>
     <height>15</height>
    </rect>
   </property>
   <property name="text">
    <string>Setting</string>
   </property>
  </widget>
  <widget class="QGroupBox" name="Setting_frame">
   <property name="geometry">
    <rect>
     <x>510</x>
     <y>480</y>
     <width>210</width>
     <height>270</height>
    </rect>
   </property>
   <property name="title">
    <string/>
   </property>
   <widget class="QComboBox" name="setting_x">
    <property name="geometry">
     <rect>
      <x>85</x>
      <y>35</y>
      <width>120</width>
      <height>25</height>
     </rect>
    </property>
   </widget>
   <widget class="QLabel" name="setting_x_label">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>35</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>X</string>
    </property>
   </widget>
   <widget class="QLabel" name="setting_y_label">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>65</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Y</string>
    </property>
   </widget>
   <widget class="QComboBox" name="setting_y">
    <property name="geometry">
     <rect>
      <x>85</x>
      <y>65</y>
      <width>120</width>
      <height>25</height>
     </rect>
    </property>
   </widget>
   <widget class="QLabel" name="setting_z_label">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>95</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Z</string>
    </property>
   </widget>
   <widget class="QComboBox" name="setting_z">
    <property name="geometry">
     <rect>
      <x>85</x>
      <y>95</y>
      <width>120</width>
      <height>25</height>
     </rect>
    </property>
   </widget>
   <widget class="QLabel" name="setting_color_label">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>155</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Color</string>
    </property>
   </widget>
   <widget class="QComboBox" name="setting_color">
    <property name="geometry">
     <rect>
      <x>85</x>
      <y>155</y>
      <width>120</width>
      <height>25</height>
     </rect>
    </property>
   </widget>
   <widget class="QLabel" name="setting_z_option_label">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>125</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Z 표현</string>
    </property>
   </widget>
   <widget class="QComboBox" name="setting_z_option">
    <property name="enabled">
     <bool>false</bool>
    </property>
    <property name="geometry">
     <rect>
      <x>85</x>
      <y>125</y>
      <width>120</width>
      <height>25</height>
     </rect>
    </property>
    <item>
     <property name="text">
      <string>Size</string>
     </property>
    </item>
    <item>
     <property name="text">
      <string>Position</string>
     </property>
    </item>
   </widget>
   <widget class="QLabel" name="setting_color_option_label">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>185</y>
      <width>75</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Color 기준값</string>
    </property>
   </widget>
   <widget class="QDoubleSpinBox" name="setting_color_option">
    <property name="enabled">
     <bool>false</bool>
    </property>
    <property name="geometry">
     <rect>
      <x>85</x>
      <y>185</y>
      <width>120</width>
      <height>25</height>
     </rect>
    </property>
    <property name="minimum">
     <double>-9999.000000000000000</double>
    </property>
    <property name="maximum">
     <double>9999.000000000000000</double>
    </property>
   </widget>
   <widget class="QLabel" name="setting_offset_label">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>240</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Offset</string>
    </property>
   </widget>
   <widget class="QLabel" name="setting_offset_x_label">
    <property name="geometry">
     <rect>
      <x>45</x>
      <y>215</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>X</string>
    </property>
    <property name="alignment">
     <set>Qt::AlignCenter</set>
    </property>
   </widget>
   <widget class="QLabel" name="setting_offset_z_label">
    <property name="geometry">
     <rect>
      <x>155</x>
      <y>215</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Z</string>
    </property>
    <property name="alignment">
     <set>Qt::AlignCenter</set>
    </property>
   </widget>
   <widget class="QLabel" name="setting_offset_y_label">
    <property name="geometry">
     <rect>
      <x>100</x>
      <y>215</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Y</string>
    </property>
    <property name="alignment">
     <set>Qt::AlignCenter</set>
    </property>
   </widget>
   <widget class="QLineEdit" name="setting_offset_z">
    <property name="geometry">
     <rect>
      <x>155</x>
      <y>240</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>0</string>
    </property>
    <property name="alignment">
     <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
    </property>
   </widget>
   <widget class="QLineEdit" name="setting_offset_y">
    <property name="geometry">
     <rect>
      <x>100</x>
      <y>240</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>0</string>
    </property>
    <property name="alignment">
     <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
    </property>
   </widget>
   <widget class="QLineEdit" name="setting_offset_x">
    <property name="geometry">
     <rect>
      <x>45</x>
      <y>240</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>0</string>
    </property>
    <property name="alignment">
     <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
    </property>
   </widget>
   <widget class="QLabel" name="setting_time_label">
    <property name="geometry">
     <rect>
      <x>5</x>
      <y>5</y>
      <width>50</width>
      <height>25</height>
     </rect>
    </property>
    <property name="text">
     <string>Time</string>
    </property>
   </widget>
   <widget class="QComboBox" name="setting_time">
    <property name="geometry">
     <rect>
      <x>85</x>
      <y>5</y>
      <width>120</width>
      <height>25</height>
     </rect>
    </property>
   </widget>
  </widget>
  <widget class="QPushButton" name="OpenDataDemo_cancel_btn">
   <property name="geometry">
    <rect>
     <x>515</x>
     <y>755</y>
     <width>100</width>
     <height>25</height>
    </rect>
   </property>
   <property name="text">
    <string>Cancel</string>
   </property>
  </widget>
  <widget class="QPushButton" name="OpenDataDemo_open_btn">
   <property name="geometry">
    <rect>
     <x>620</x>
     <y>755</y>
     <width>100</width>
     <height>25</height>
    </rect>
   </property>
   <property name="text">
    <string>Open</string>
   </property>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./GUI/dev_dialog.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DevDialog</class>
 <widget class="QDialog" name="DevDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>529</width>
    <height>466</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QTabWidget" name="tabWidget">
     <property name="currentIndex">
      <number>2</number>
     </property>
     <widget class="QWidget" name="tab">
      <attribute name="title">
       <string>MainWindow</string>
      </attribute>
      <widget class="QLabel" name="label">
       <property name="geometry">
        <rect>
         <x>-2</x>
         <y>0</y>
         <width>86</width>
         <height>20</height>
        </rect>
       </property>
       <property name="text">
        <string>TopView 100px</string>
       </property>
      </widget>
      <widget class="QLineEdit" name="topview_um">
       <property name="geometry">
        <rect>
         <x>90</x>
         <y>0</y>
         <width>71</width>
         <height>20</height>
        </rect>
       </property>
       <property name="text">
        <string>0.1</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
       </property>
      </widget>
     </widget>
     <widget class="QWidget" name="tab_2">
      <attribute name="title">
       <string>Docker</string>
      </attribute>
      <widget class="QCheckBox" name="checkBox_pos">
       <property name="geometry">
        <rect>
         <x>30</x>
         <y>20</y>
         <width>113</width>
         <height>18</height>
        </rect>
       </property>
       <property name="text">
        <string>Change Pos</string>
       </property>
      </widget>
     </widget>
     <widget class="QWidget" name="tab_5">
      <attribute name="title">
       <string>Data Process</string>
      </attribute>
      <widget class="QSlider" name="time_slider">
       <property name="geometry">
        <rect>
         <x>40</x>
         <y>10</y>
         <width>200</width>
         <height>25</height>
        </rect>
       </property>
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
      </widget>
      <widget class="QPushButton" name="playbtn">
       <property name="geometry">
        <rect>
         <x>10</x>
         <y>10</y>
         <width>25</width>
         <height>25</height>
        </rect>
       </property>
       <property name="text">
        <string>▶</string>
       </property>
      </widget>
     </widget>
     <widget class="QWidget" name="tab_3">
      <attribute name="title">
       <string>3D Modeling</string>
      </attribute>
     </widget>
     <widget class="QWidget" name="tab_4">
      <attribute name="title">
       <string>PEX</string>
      </attribute>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./GUI/formhier.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormHier</class>
 <widget class="QDialog" name="FormHier">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>780</width>
    <height>646</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>320</width>
    <height>100</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QGridLayout" name="gridLayout_2">
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QLineEdit" name="hierarchy_searching">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
         <horstretch>1</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
       </property>
       <property name="placeholderText">
        <string>Searching...</string>
       </property>
       <property name="clearButtonEnabled">
        <bool>false</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QTreeWidget" name="hierarchy_tree">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
         <horstretch>1</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="verticalScrollBarPolicy">
        <enum>Qt::ScrollBarAsNeeded</enum>
       </property>
       <property name="horizontalScrollBarPolicy">
        <enum>Qt::ScrollBarAlwaysOff</enum>
       </property>
       <property name="expandsOnDoubleClick">
        <bool>false</bool>
       </property>
       <attribute name="headerVisible">
        <bool>false</bool>
       </attribute>
       <column>
        <property name="text">
         <string notr="true">1</string>
        </property>
       </column>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./GUI/forminfo.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormInfo</class>
 <widget class="QDialog" name="FormInfo">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>400</height>
   </rect>
  </property>
  <property name="maximumSize">
   <size>
    <width>16777215</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="2">
      <widget class="QLabel" name="label_4">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Z</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="1">
      <widget class="QLabel" name="label_11">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Rotation</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="2">
      <widget class="QLabel" name="label_12">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Zoom</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="1">
      <widget class="QLabel" name="label_2">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Y</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="1">
      <widget class="QLineEdit" name="pos_y">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="maxLength">
        <number>32767</number>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="2">
      <widget class="QLineEdit" name="zoom">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="0">
      <widget class="QLabel" name="label">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>X</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="0">
      <widget class="QLineEdit" name="ang_tilt">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="maxLength">
        <number>32767</number>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="0">
      <widget class="QLabel" name="label_10">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Tilt</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="0">
      <widget class="QLineEdit" name="pos_x">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="inputMask">
        <string/>
       </property>
       <property name="maxLength">
        <number>32767</number>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="1">
      <widget class="QLineEdit" name="ang_rotation">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="maxLength">
        <number>32767</number>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="2">
      <widget class="QLineEdit" name="pos_z">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="maxLength">
        <number>32767</number>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QListWidget" name="listWidget">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="minimumSize">
      <size>
       <width>0</width>
       <height>0</height>
      </size>
     </property>
     <property name="dragDropMode">
      <enum>QAbstractItemView::DragDrop</enum>
     </property>
     <property name="defaultDropAction">
      <enum>Qt::MoveAction</enum>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::ExtendedSelection</enum>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <property name="sizeConstraint">
      <enum>QLayout::SetFixedSize</enum>
     </property>
     <item>
      <widget class="QPushButton" name="pushButton_go">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Minimum">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>24</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="font">
        <font>
         <family>Arial</family>
         <pointsize>8</pointsize>
         <weight>75</weight>
         <bold>true</bold>
        </font>
       </property>
       <property name="text">
        <string>Go</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_add">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Minimum">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>24</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="font">
        <font>
         <family>Arial</family>
         <pointsize>8</pointsize>
         <weight>75</weight>
         <bold>true</bold>
        </font>
       </property>
       <property name="text">
        <string>Add</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_del">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Minimum">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>24</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="font">
        <font>
         <family>Arial</family>
         <pointsize>8</pointsize>
         <weight>75</weight>
         <bold>true</bold>
        </font>
       </property>
       <property name="text">
        <string>Del</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_save">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Minimum">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>24</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="font">
        <font>
         <family>Arial</family>
         <pointsize>8</pointsize>
         <weight>75</weight>
         <bold>true</bold>
        </font>
       </property>
       <property name="text">
        <string>Save</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_load">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Minimum">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>24</width>
         <height>0</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="font">
        <font>
         <family>Arial</family>
         <pointsize>8</pointsize>
         <weight>75</weight>
         <bold>true</bold>
        </font>
       </property>
       <property name="text">
        <string>Load</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>pos_x</tabstop>
  <tabstop>pos_y</tabstop>
  <tabstop>pos_z</tabstop>
  <tabstop>ang_tilt</tabstop>
  <tabstop>ang_rotation</tabstop>
  <tabstop>zoom</tabstop>
 </tabstops>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./GUI/formlayer.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormLayer</class>
 <widget class="QDialog" name="FormLayer">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>320</width>
    <height>400</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>320</width>
    <height>0</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>430</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QTableWidget" name="tableWidget">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="focusPolicy">
        <enum>Qt::ClickFocus</enum>
       </property>
       <property name="tabKeyNavigation">
        <bool>true</bool>
       </property>
       <property name="alternatingRowColors">
        <bool>true</bool>
       </property>
       <property name="textElideMode">
        <enum>Qt::ElideMiddle</enum>
       </property>
       <attribute name="horizontalHeaderVisible">
        <bool>false</bool>
       </attribute>
       <attribute name="verticalHeaderVisible">
        <bool>false</bool>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./GUI/formmap.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormMap</class>
 <widget class="QDialog" name="FormMap">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>200</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>200</width>
    <height>200</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGraphicsView" name="graphicsView">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="minimumSize">
      <size>
       <width>0</width>
       <height>0</height>
      </size>
     </property>
     <property name="verticalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
     <property name="horizontalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./GUI/formpex.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormPEX</class>
 <widget class="QDialog" name="FormPEX">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="1" column="0">
    <layout class="QVBoxLayout" name="verticalLayout_2">
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_3">
       <item>
        <widget class="QPushButton" name="all_view">
         <property name="text">
          <string>All Reistor View</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="cap_view_button">
         <property name="text">
          <string>Cap.</string>
         </property>
         <property name="iconSize">
          <size>
           <width>16</width>
           <height>16</height>
          </size>
         </property>
         <property name="checkable">
          <bool>true</bool>
         </property>
         <property name="checked">
          <bool>true</bool>
         </property>
        </widget>
       </item>
      </layout>
     </item>
     <item>
      <widget class="QLineEdit" name="res_search">
       <property name="placeholderText">
        <string>Searching..</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QTreeWidget" name="tree_pex">
       <attribute name="headerVisible">
        <bool>false</bool>
       </attribute>
       <column>
        <property name="text">
         <string notr="true">1</string>
        </property>
       </column>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./GUI/formtop.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormTop</class>
 <widget class="QDialog" name="FormTop">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>200</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>200</width>
    <height>200</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGraphicsView" name="graphicsView">
     <property name="mouseTracking">
      <bool>true</bool>
     </property>
     <property name="autoFillBackground">
      <bool>true</bool>
     </property>
     <property name="verticalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
     <property name="horizontalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
     <property name="sizeAdjustPolicy">
      <enum>QAbstractScrollArea::AdjustIgnored</enum>
     </property>
     <property name="backgroundBrush">
      <brush brushstyle="NoBrush">
       <color alpha="255">
        <red>0</red>
        <green>0</green>
        <blue>0</blue>
       </color>
      </brush>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./GUI/formplaybar.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormPlayBar</class>
 <widget class="QDialog" name="FormPlayBar">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>641</width>
    <height>43</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>0</width>
    <height>43</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QHBoxLayout" name="horizontalLayout">
   <item>
    <widget class="QPushButton" name="play_btn">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="minimumSize">
      <size>
       <width>25</width>
       <height>25</height>
      </size>
     </property>
     <property name="maximumSize">
      <size>
       <width>25</width>
       <height>25</height>
      </size>
     </property>
     <property name="text">
      <string>▶</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QSlider" name="time_slider">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="minimumSize">
      <size>
       <width>0</width>
       <height>25</height>
      </size>
     </property>
     <property name="maximumSize">
      <size>
       <width>16777215</width>
       <height>25</height>
      </size>
     </property>
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./mainwindow.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1024</width>
    <height>768</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
     <widget class="QGraphicsView" name="graphicsView"/>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>1024</width>
     <height>20</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>File</string>
    </property>
    <addaction name="actionOpen_file"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_Layout"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_DB"/>
    <addaction name="actionOpen_Data_Demo"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_PEX"/>
   </widget>
   <widget class="QMenu" name="menuView">
    <property name="title">
     <string>View</string>
    </property>
    <addaction name="actionLayer_information"/>
   </widget>
   <widget class="QMenu" name="menuCamera">
    <property name="title">
     <string>Camera</string>
    </property>
    <addaction name="actionTop"/>
    <addaction name="actionDemo"/>
   </widget>
   <widget class="QMenu" name="menudevopt">
    <property name="title">
     <string>devopt</string>
    </property>
    <addaction name="actionDialog_on_off"/>
    <addaction name="actionToyCAD"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuView"/>
   <addaction name="menuCamera"/>
   <addaction name="menudevopt"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="toolBar">
   <property name="windowTitle">
    <string>toolBar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="toggle_top"/>
   <addaction name="separator"/>
   <addaction name="docker_Map"/>
   <addaction name="docker_TopView"/>
   <addaction name="docker_Info"/>
   <addaction name="docker_Hier"/>
   <addaction name="docker_Layer"/>
   <addaction name="docker_PEX"/>
  </widget>
  <action name="actionOpen_file">
   <property name="text">
    <string>Open file</string>
   </property>
  </action>
  <action name="actionLayer_information">
   <property name="text">
    <string>Layer information</string>
   </property>
  </action>
  <action name="actionOpen_Layout">
   <property name="text">
    <string>Open Layout</string>
   </property>
  </action>
  <action name="actionOpen_DB">
   <property name="text">
    <string>Open DB</string>
   </property>
  </action>
  <action name="actionTop">
   <property name="text">
    <string>Top</string>
   </property>
  </action>
  <action name="actionDemo">
   <property name="text">
    <string>Demo</string>
   </property>
  </action>
  <action name="docker_Map">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normaloff>ImageFile/Map_Icon_50by50.png</normaloff>ImageFile/Map_Icon_50by50.png</iconset>
   </property>
   <property name="text">
    <string>docker_Map</string>
   </property>
   <property name="toolTip">
    <string>docker_Map</string>
   </property>
  </action>
  <action name="docker_TopView">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Top_View_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_TopView</string>
   </property>
   <property name="toolTip">
    <string>docker_TopView</string>
   </property>
  </action>
  <action name="docker_Info">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Info_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_Info</string>
   </property>
   <property name="toolTip">
    <string>docker_Info</string>
   </property>
  </action>
  <action name="docker_Hier">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Hier_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_Hier</string>
   </property>
   <property name="toolTip">
    <string>docker_Hier</string>
   </property>
  </action>
  <action name="docker_Layer">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Layer_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_Layer</string>
   </property>
   <property name="toolTip">
    <string>docker_Layer</string>
   </property>
  </action>
  <action name="toggle_top">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset>
     <normaloff>ImageFile/Top_toggle_Icon_50by50.png</normaloff>ImageFile/Top_toggle_Icon_50by50.png</iconset>
   </property>
   <property name="text">
    <string>toggle_top</string>
   </property>
   <property name="toolTip">
    <string>toggle_top</string>
   </property>
  </action>
  <action name="docker_PEX">
   <property name="checkable">
    <bool>false</bool>
   </property>
   <property name="checked">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset>
     <normalon>ImageFile/PEX_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_PEX</string>
   </property>
   <property name="toolTip">
    <string>docker_PEX</string>
   </property>
  </action>
  <action name="actionOpen_PEX">
   <property name="text">
    <string>Open PEX</string>
   </property>
  </action>
  <action name="actionDialog_on_off">
   <property name="text">
    <string>Dialog on/off</string>
   </property>
  </action>
  <action name="actionToyCAD">
   <property name="text">
    <string>ToyCAD</string>
   </property>
  </action>
  <action name="actionOpen_Data_Demo">
   <property name="text">
    <string>Open Data Demo</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./IInterface.pro!@hash[]!@code[]QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++17
QMAKE_CXXFLAGS += -std=c++17

# You can make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
    OpenDataDemo/opendatademo.cpp \
    Rendering/Src/LayoutData.cpp \
    Rendering/Src/LayoutModel.cpp \
    Rendering/Src/PEXCapacitorModel.cpp \
    Rendering/Src/PEXData.cpp \
    Rendering/Src/PEXResistorModel.cpp \
    Rendering/Src/dtaorendersystem.cpp \
    Rendering/Src/keyboard_movement_controller.cpp \
    Rendering/Src/lve_camera.cpp \
    Rendering/Src/lve_device.cpp \
    Rendering/Src/lve_model.cpp \
    Rendering/Src/lve_pipeline.cpp \
    Rendering/Src/lve_window.cpp \
    Rendering/Src/simple_render_system.cpp \
    STLModel/Src/stl_model.cpp \
    ToyCAD/Src/toycaddata.cpp \
    ToyCAD/Src/toycadmodel.cpp \
    GUI/dev_dialog.cpp \
    GUI/formhier.cpp \
    GUI/forminfo.cpp \
    GUI/formlayer.cpp \
    GUI/formmap.cpp \
    GUI/formpex.cpp \
    GUI/formtop.cpp \
    GUI/formplaybar.cpp \
    T2D.cpp \
    filedb.cpp \
    gitmerge.cpp \
    main.cpp \
    mainwindow.cpp

HEADERS += \
    OpenDataDemo/opendatademo.h \
    Rendering/Src/LayoutModel.h \
    Rendering/Src/LayoutPEXData.h \
    Rendering/Src/PEXCapacitorModel.h \
    Rendering/Src/PEXResistorModel.h \
    Rendering/Src/dtaorendersystem.h \
    Rendering/Src/keyboard_movement_controller.hpp \
    Rendering/Src/lve_camera.hpp \
    Rendering/Src/lve_device.hpp \
    Rendering/Src/lve_game_object.hpp \
    Rendering/Src/lve_model.hpp \
    Rendering/Src/lve_pipeline.hpp \
    Rendering/Src/lve_window.hpp \
    Rendering/Src/simple_render_system.hpp \
    Rendering/Src/utils.h \
    STLModel/Src/stl_model.h \
    STLModel/Src/stl_object.h \    
    ToyCAD/Src/toycad_object.h \
    ToyCAD/Src/toycaddata.h \
    ToyCAD/Src/toycadmodel.h \
    GUI/dev_dialog.h \
    GUI/formhier.h \
    GUI/forminfo.h \
    GUI/formlayer.h \
    GUI/formmap.h \
    GUI/formpex.h \
    GUI/formtop.h \
    GUI/formplaybar.h \
    defineParam.h \    
    T2D.h \
    filedb.h \    
    gitmerge.h \
    mainwindow.h

FORMS += \
    OpenDataDemo/opendatademo.ui \
    GUI/dev_dialog.ui \
    GUI/formhier.ui \
    GUI/forminfo.ui \
    GUI/formlayer.ui \
    GUI/formmap.ui \
    GUI/formpex.ui \
    GUI/formtop.ui \
    GUI/formplaybar.ui \
    mainwindow.ui

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target


RESOURCES += \
    Resources.qrc

DISTFILES += \
    Rendering/Data/MVP_PEX_RC_r1_0130.csv \
    Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv \
    Rendering/Data/big_test_espin.csv \
    Rendering/Data/layout_input_data.csv \
    Rendering/Data/layout_input_data_old_format.csv \
    Rendering/Data/pex_cap_test.csv \
    Rendering/Data/pex_res_test.csv \
    Rendering/Data/pex_res_test_beol_only.csv \
    Rendering/Data/pex_res_test_simple.csv \
    Rendering/Data/test_espin.csv \
    Rendering/shaders/compile.bat \
    Rendering/shaders/simple_shader.frag \
    Rendering/shaders/simple_shader.frag.spv \
    Rendering/shaders/simple_shader.frag_edge.spv \
    Rendering/shaders/simple_shader.frag_pex.spv \
    Rendering/shaders/simple_shader.vert \
    Rendering/shaders/simple_shader.vert.spv \
    Rendering/shaders/simple_shader.vert_edge.spv \
    Rendering/shaders/simple_shader.vert_pex.spv \
    Rendering/shaders/simple_shader_edge.frag \
    Rendering/shaders/simple_shader_edge.vert \
    Rendering/shaders/simple_shader_pex.frag \
    Rendering/shaders/simple_shader_pex.vert \
    ToyCAD/Data/test.csv \
    ToyCAD/Data/toy_cad_test_data.csv \
    ToyCAD/Data/toy_cad_test_data.xlsx \
    ToyCAD/Data/wafer_.csv \
    ToyCAD/shaders/compile.bat \
    ToyCAD/shaders/toycad.frag \
    ToyCAD/shaders/toycad.frag.spv \
    ToyCAD/shaders/toycad.vert \
    ToyCAD/shaders/toycad.vert.spv



INCLUDEPATH += $$PWD/../../Library/glm-0.9.9.8

unix:!macx|win32: LIBS += -L$$PWD/../../Library/VulkanSDK/1.3.239.0/Lib/ -lvulkan-1

INCLUDEPATH += $$PWD/../../Library/VulkanSDK/1.3.239.0/Lib
DEPENDPATH += $$PWD/../../Library/VulkanSDK/1.3.239.0/Lib

INCLUDEPATH += $$PWD/../../Library/glm-0.9.9.8/glm

#한글 실험

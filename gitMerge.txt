!@hash[]!@file[]./Rendering/Src/LayoutData.cpp!@hash[]!@code[]#include "LayoutPEXData.h"

#include <iostream>
#include <string>
#include <vector>
#include <limits>
#include <cstdio>
#include <chrono>

#include "rapidcsv.h"

#include <QFile>
#include <QDebug>



using namespace std;

inline double coord_normalize(double in_value, double move, double scale) {
    return 2 * ((in_value - move) * (scale)) - 1.0f;
}



LayoutItem::LayoutItem() : pattern{}, layer_number{}, layer_datatype{}, layer_type{} {
}
LayoutItem::~LayoutItem() {
}

LayoutItem::LayoutItem(const cube_info& pattern_, const int layer_number_, const int layer_datatype_, LAYOUT_LAYER_TYPE layer_type_)
    : pattern(pattern_), layer_number(layer_number_), layer_datatype(layer_datatype_), layer_type(layer_type_) {
}


LayoutDataManager::LayoutDataManager()
    : file_path{}, patterns{}, scale(1.0),
      layout_min_x{}, layout_max_x{}, layout_min_y{}, layout_max_y{}, layout_min_z{}, layout_max_z{} {
}

LayoutDataManager::~LayoutDataManager() {
    this->patterns.clear();
}

void LayoutDataManager::calculateScale() {
    x_diff = this->layout_max_x - this->layout_min_x;
    y_diff = this->layout_max_y - this->layout_min_y;
    z_diff = this->layout_max_z - this->layout_min_z;

    double max_diff = x_diff > y_diff ? x_diff : y_diff;
    max_diff = max_diff > z_diff ? max_diff : z_diff;

    this->scale = 1.0f / max_diff;
}

bool LayoutDataManager::compareByLength(const LDATA10BY10 &a, const LDATA10BY10 &b) {
    //qDebug() << "is working";
    return a.top < b.top;
}

void LayoutDataManager::loadLayoutData(T2D &t2d) {
    /*
    if (!QFile::exists(file_path.c_str())) {
        cerr << "File is not exist : " << file_path << endl;
        return;
    }
    */

    std::chrono::system_clock::time_point start, end;
    std::chrono::seconds run_time;

    start = std::chrono::system_clock::now();

   // rapidcsv::Document infile(file_path, rapidcsv::LabelParams(-1, -1));

    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutDataManager / loadLayoutData / rapidcsv::infile [sec] : "
              << run_time.count() << "\n";

    //std::vector<float> bbox = infile.GetRow<float>(0);
    this->layout_min_x = t2d.LayoutMinMax.minx;
    this->layout_min_y = t2d.LayoutMinMax.miny;
    this->layout_max_x = t2d.LayoutMinMax.maxx;
    this->layout_max_y = t2d.LayoutMinMax.maxy;
    this->layout_min_z = t2d.LayoutMinMax.minz;
    this->layout_max_z = t2d.LayoutMinMax.maxz;

    calculateScale();

    t2d_ptr = &t2d;

    //size_t line_count = infile.GetRowCount();
    //cube_info cur_cube;
    //int layer_number, layer_datatype;

    start = std::chrono::system_clock::now();

    /*
    for (size_t i = 1; i < line_count; ++i) { //first line is bbox area
        vector<string> line = infile.GetRow<string>(i);
        //if (line[LAYOUTINFO_IDX_STRUCTURE] != "Poly") continue;
        //if (std::stoi(line[LAYOUTINFO_IDX_NUMPOINTS]) != 4) continue;

        layer_number = std::stoi(line[LAYOUTINFO_IDX_LAYER]);
        layer_datatype = std::stoi(line[LAYOUTINFO_IDX_DATATYPE]);

        cur_cube.minz = std::stof(line[LAYOUTINFO_IDX_ZSTART]);
        cur_cube.maxz = std::stof(line[LAYOUTINFO_IDX_ZEND]);
        if (cur_cube.minz == cur_cube.maxz) continue;

        cur_cube.minx = std::stof(line[LAYOUTINFO_IDX_LEFT]);
        cur_cube.maxx = std::stof(line[LAYOUTINFO_IDX_RIGHT]);
        cur_cube.miny = std::stof(line[LAYOUTINFO_IDX_BOTTOM]);
        cur_cube.maxy = std::stof(line[LAYOUTINFO_IDX_TOP]);

        //cur_cube.minx = coord_normalize(cur_cube.minx, this->layout_min_x, scale);
        //cur_cube.maxx = coord_normalize(cur_cube.maxx, this->layout_min_x, scale);
        //cur_cube.miny = coord_normalize(cur_cube.miny, this->layout_min_y, scale);
        //cur_cube.maxy = coord_normalize(cur_cube.maxy, this->layout_min_y, scale);
        //cur_cube.minz = coord_normalize(cur_cube.minz, this->layout_min_z, scale);
        //cur_cube.maxz = coord_normalize(cur_cube.maxz, this->layout_min_z, scale);

        this->patterns.push_back(LayoutItem(cur_cube, layer_number, layer_datatype, LAYOUT_LAYER_TYPE::LAYOUT_LAYER_TYPE_DEFAULT));

    }*/

    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    start = std::chrono::system_clock::now();
    std::cout << "Run Time / LayoutDataManager / loadLayoutData / pattern push [sec] : "
              << run_time.count() << "\n";

    std::sort(t2d_ptr->LayoutData10by10.begin(), t2d_ptr->LayoutData10by10.end(), compareByLength);


    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    qDebug() << "Run Time / LayoutDataManager / loadLayoutData / pattern sort [sec] : "
              << run_time.count() << "\n";

   // infile.Clear();

    /*
        printf("\n\nLayout Info Data\n\n");
        for (auto& cur_pattern : this->patterns) {
            printf("left/bottom/right/top/z-start/z-end = %.4f/%.4f/%.4f/%.4f/%.4f/%.4f/\n",
                cur_pattern.pattern.minx, cur_pattern.pattern.miny,
                cur_pattern.pattern.maxx, cur_pattern.pattern.maxy,
         cur_pattern.pattern.minz, cur_pattern.pattern.maxz);
        }
        //*/
}

void testLayoutData() {
    //LayoutDataManager layout_data;
    //layout_data.loadLayoutData("Data/layout_input_data.csv");

}

!@hash[]!@file[]./Rendering/Src/LayoutModel.cpp!@hash[]!@code[]#include "LayoutModel.h"

#include <iostream>
#include <string>
#include <vector>
#include <chrono>

#include "LayoutPEXData.h"
#include <unordered_set>
#include <QFile>


LayoutModel::LayoutModel(LveDevice& device, MODEL_TYPE model_type, T2D &t2d)
    : LveModel(device, model_type), layout_data{} {
    this->makeRenderingData(t2d);
    this->createBuffers();
}

LayoutModel::~LayoutModel() {
    this->layout_data.clear();
}

void LayoutModel::makeRenderingData(T2D &t2d) {
    loadData(t2d);
    std::chrono::system_clock::time_point start, end;
    std::chrono::seconds run_time;

    start = std::chrono::system_clock::now();
    //loadData(file_path);
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / loadData [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeCubeVertices();
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / makeCubeVertices [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeVertices();
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / lmakeVertices [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeIndices();
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / makeIndices [sec] : "
              << run_time.count() << "\n";
}

void LayoutModel::loadData(T2D &t2d) {
    this->layout_data.loadLayoutData(t2d);
}

void LayoutModel::makeCubeVertices() {
    std::vector<LDATA10BY10> &layout_items = this->layout_data.getPatterns_t2d();
    std::vector<LDATA10BY10>::iterator it = layout_items.begin();
    cube_vertex cur_cube_vertices;
    std::unordered_set<int> checking_set;


    for (it = layout_items.begin(); it != layout_items.end(); ++it) {
        cur_cube_vertices.layernum = it->layernum;
        for(auto row : it->xy ){
            for (auto col : row){
                if(col.size() == 0) break;
                for(auto each_box : col){
                    cur_cube_vertices.vertex[0] = { each_box.minx, each_box.maxy, it->top };
                    cur_cube_vertices.vertex[1] = { each_box.minx, each_box.miny, it->top };
                    cur_cube_vertices.vertex[2] = { each_box.maxx, each_box.miny, it->top };
                    cur_cube_vertices.vertex[3] = { each_box.maxx, each_box.maxy, it->top };

                    cur_cube_vertices.vertex[4] = { each_box.minx, each_box.maxy, it->bot };
                    cur_cube_vertices.vertex[5] = { each_box.minx, each_box.miny, it->bot };
                    cur_cube_vertices.vertex[6] = { each_box.maxx, each_box.miny, it->bot };
                    cur_cube_vertices.vertex[7] = { each_box.maxx, each_box.maxy, it->bot };

                    this->cube_vertices.push_back(cur_cube_vertices);

                    if(checking_set.find(it->layernum) == checking_set.end()){
                        checking_set.insert(it->layernum);
                        drawing_order_layerby.push_back(it->layernum);
                    }
                }

            }
            layerList[it->layernum].color = glm::vec3 {it->color.r/(float)255,it->color.g/(float)255, it->color.b/(float)255};
            layerList[it->layernum].opacity = it->color.a/(float)255;
            layerList[it->layernum].visiblity = it->checking;

        }


        //std::cout << cube_vertices.back().layernum << '\n';
    }
}

void LayoutModel::makeVertices() {
    std::vector<LDATA10BY10> &layout_items = this->layout_data.getPatterns_t2d();
    std::vector<LDATA10BY10>::iterator it = layout_items.begin();
    Vertex temp_vertex;

    float up_color = 0.15f;
    float down_color = 0.6f;

    for (const auto& cur_cube : this->cube_vertices) {
        for (int i = 0; i < 8; ++i) {
            temp_vertex.position = { cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };

            if (i < 4) temp_vertex.color = { up_color , up_color , up_color };
            else       temp_vertex.color = { down_color , down_color , down_color };


            layerby_vertices[cur_cube.layernum].push_back(temp_vertex);
        }
    }
}

void LayoutModel::makeIndices() {
    //makeIndicesForFace();
    makeIndicesForFace_map();
    //makeIndicesForEdge();
    makeIndicesForEdge_map();
}

void LayoutModel::makeIndicesForFace_map() {
    //size_t layer_count = this->layerby_vertices.size();

    uint32_t start_idx = 0;
    std::map<float, std::vector<uint32_t>>& indices = this->layerby_face;
    for (auto const& [key, val] : layerby_vertices) {
        size_t cube_count_by_layer = val.size() / 8;
        for (size_t i = 0; i < cube_count_by_layer; ++i) {
            start_idx = 8 * i;
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 0);//top

            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 3);//right

            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 0);//front

            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 4);//bottom

            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 0);//left

            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 1);//back
        }
    }

    qDebug() << layerby_vertices.size();

}

void LayoutModel::makeIndicesForEdge_map() {
    //size_t layer_count = this->layerby_vertices.size();

    std::map<float, std::vector<uint32_t>>& indices = this->layerby_edge;
    uint32_t start_idx = 0;
    for (auto const& [key, val] : layerby_vertices) {
        size_t cube_count_by_layer = val.size() / 8;
        for (size_t i = 0; i < cube_count_by_layer; ++i) {
            start_idx = 8 * i;
            //top
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 1);
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 3);
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 0);

            //bottom
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 4);

            //right
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 3);

            //left
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 4);
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 1);
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 0);

            //front
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 3);
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 4);
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 0);

            //back
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 1);
        }
    }

}

void LayoutModel::makeIndicesForFace() {
    size_t cube_count = this->cube_vertices.size();

    uint32_t start_idx = 0;
    std::vector<uint32_t>& indices = this->indices_face;
    for (int i = 0; i < cube_count; ++i) {
        start_idx = 8 * i;
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);//top

        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);//right

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);//front

        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);//bottom

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);//left

        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);//back
    }
}


void LayoutModel::makeIndicesForEdge() {
    size_t cube_count = this->cube_vertices.size();

    std::vector<uint32_t>& indices = this->indices_edge;
    uint32_t start_idx = 0;
    for (int i = 0; i < cube_count; ++i, start_idx += 8) {
        //top
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);

        //bottom
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);

        //right
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);

        //left
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);

        //front
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);

        //back
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);
    }
}


!@hash[]!@file[]./Rendering/Src/PEXCapacitorModel.cpp!@hash[]!@code[]#include "PEXCapacitorModel.h"

#include <iostream>
#include <map>
#include <vector>
#include <math.h>
#include <cstdio>
#include <thread>
#include <mutex>

#include "LayoutPEXData.h"

using namespace std;

PEXCapacitorModel::PEXCapacitorModel(
        LveDevice& device,
        MODEL_TYPE model_type,
        const std::string& data_file,
        LayoutDataManager* layout_data_)
    : LveModel(device, model_type), pex_data{}, cap_node_name_to_index_map{}, layout_data{ layout_data_ } {

    this->makePatternCapsFromLayoutData();
    this->makeRenderingData(data_file);
    this->createBuffers();
}


PEXCapacitorModel::~PEXCapacitorModel() {
    for (auto& cur_item : this->layer_to_pattern_cap_map) cur_item.second.clear();
    this->layer_to_pattern_cap_map.clear();
    this->pattern_caps.clear();
}

void PEXCapacitorModel::makePatternCapsFromLayoutData() {
    std::vector<LayoutItem>& layout_items = this->layout_data->getPatterns();
    if (layout_items.empty()) {
        std::cerr << "Error! empty patten @PEXCapacitorModel::makePatternWCapsFromLayoutData()\n";
    }

    for (auto& layout_item : layout_items) {
        this->pattern_caps.push_back(
                    pattern_cap(layout_item.pattern, layout_item.layer_number, layout_item.layer_datatype, 0.0, 0.0, 0)
                    );

        this->layers.insert({ layout_item.layer_number, layout_item.layer_datatype });
    }
}

void PEXCapacitorModel::makeRenderingData(const std::string& file_path) {
    loadData(file_path);
    makeCapNodesFromPEXData();

    attachCapToPattern();
    normalizePatternCap();
    //printLayerToPatternCapMap("After Normalization Cap");

    makeCubeVertices();
    makeVertices();
    makeIndices();

    for (auto& cur_item : this->layer_to_cap_node_map) cur_item.second.clear();
    this->layer_to_cap_node_map.clear();
    this->cap_nodes.clear();
    this->layers.clear();
}

void PEXCapacitorModel::loadData(const std::string& file_path) {
    this->pex_data.loadData(file_path);
    //this->pex_data.printPEXData();
}


void PEXCapacitorModel::makeCapNodesFromPEXData() {
    this->cap_node_name_to_index_map.clear();
    std::map<std::string, size_t>::iterator it;
    for (auto& pex_item : this->pex_data.getCapacitors()) {
        //node1
        std::string& node1_name = pex_item.node1.name;
        it = this->cap_node_name_to_index_map.find(node1_name);
        if (it == this->cap_node_name_to_index_map.end()) addNewCapNode(pex_item.node1, pex_item.value);
        else {
            this->cap_nodes[it->second].value += pex_item.value;
            this->cap_nodes[it->second].connected_count++;
        }

        //node2
        std::string& node2_name = pex_item.node2.name;
        it = this->cap_node_name_to_index_map.find(node2_name);
        if (it == this->cap_node_name_to_index_map.end()) addNewCapNode(pex_item.node2, pex_item.value);
        else {
            this->cap_nodes[it->second].value += pex_item.value;
            this->cap_nodes[it->second].connected_count++;
        }
    }//for(auto & pex_item : this->pex_data.getCapacitors())
    this->pex_data.clear();
    this->cap_node_name_to_index_map.clear();
}


void PEXCapacitorModel::addNewCapNode(pex_node& pex_node, double value) {
    cap_node new_cap_node{};
    new_cap_node.name = pex_node.name;
    new_cap_node.layer_number = pex_node.layer_number;
    new_cap_node.layer_datatype = pex_node.layer_datatype;
    new_cap_node.x = pex_node.x;
    new_cap_node.y = pex_node.y;
    new_cap_node.value = value;
    new_cap_node.connected_count = 1;

    this->cap_nodes.push_back(new_cap_node);
    this->cap_node_name_to_index_map.insert(std::pair<std::string, size_t>(new_cap_node.name, this->cap_nodes.size() - 1));
}


void PEXCapacitorModel::attachCapToPattern() {
    makeLayerToCapNodeMap();
    makeLayerToPatternCapMap();

    /*
        //º´·ÄÃ³¸®·Î º¯°æÇØ¾ß ÇÔ
        //matchCapWithPattern(this->cap_layer_map, this->pattern_layer_map, 17, 0);
        for (auto& cur_layer : this->layers) {
            string layer = getLayerString(cur_layer.first, cur_layer.second);
            map<string, vector<cap_node*>>::iterator it_layer_to_cap_node_map = this->layer_to_cap_node_map.find(layer);
            map<string, vector<pattern_cap*>>::iterator it_layer_to_pattern_cap_map = this->layer_to_pattern_cap_map.find(layer);
            if (it_layer_to_cap_node_map == this->layer_to_cap_node_map.end()
                || it_layer_to_pattern_cap_map == this->layer_to_pattern_cap_map.end()) continue;

            std::vector<cap_node*>& caps = it_layer_to_cap_node_map->second;
            std::vector<pattern_cap*>& patterns = it_layer_to_pattern_cap_map->second;

            matchCapWithPattern(caps, patterns);
            //matchCapWithPattern(this->layer_to_cap_node_map, this->layer_to_pattern_cap_map, cur_layer.first, cur_layer.second);
        }
        */

    makeLayersQueueForThreadJob();
    for (size_t i = 0; i < this->num_threads; ++i) {

        this->threads.push_back(
                    std::thread(&PEXCapacitorModel::matchCapWithPatternThread, this, &this->layers_queue, &this->mutex_layers_queue));
    }

    for (auto& thread : this->threads)
        thread.join();

    /*
        FILE* out_file = NULL;
        fopen_s(&out_file, "pattern_caps_info_thread.txt", "w");
        if (out_file != NULL) {
            printPatternCaps(out_file);
            fclose(out_file);
        }
        else printPatternCaps(stdout);
        */
}

void PEXCapacitorModel::matchCapWithPatternThread(std::queue<std::string>* layers, std::mutex* mutex_) {
    while (1) {
        mutex_->lock();
        if (layers->empty()) {
            mutex_->unlock();
            break;
        }

        string layer = layers->front();
        layers->pop();
        mutex_->unlock();

        map<string, vector<cap_node*>>::iterator it_layer_to_cap_node_map = this->layer_to_cap_node_map.find(layer);
        map<string, vector<pattern_cap*>>::iterator it_layer_to_pattern_cap_map = this->layer_to_pattern_cap_map.find(layer);
        if (it_layer_to_cap_node_map == this->layer_to_cap_node_map.end()
                || it_layer_to_pattern_cap_map == this->layer_to_pattern_cap_map.end()) continue;;

        std::vector<cap_node*>& caps = it_layer_to_cap_node_map->second;
        std::vector<pattern_cap*>& patterns = it_layer_to_pattern_cap_map->second;
        //matchCapWithPattern(caps, patterns);
        for (auto& cap : caps) {
            for (auto& pattern : patterns) {
                if (isPatternIncludeCap(*pattern, *cap)) {
                    pattern->cap_count++;
                    pattern->cap_value += cap->value;
                    break;
                }
            }//for cap : caps
        }//for pattern : patterns

    }//while 1
}


void PEXCapacitorModel::makeLayersQueueForThreadJob() {
    for (auto& cur_layer : this->layers) {
        string layer = getLayerString(cur_layer.first, cur_layer.second);
        this->layers_queue.push(layer);
    }
}

void PEXCapacitorModel::matchCapWithPattern(
        std::vector<cap_node*>& caps,
        std::vector<pattern_cap*>& patterns
        ) {

    for (auto& cap : caps) {
        for (auto& pattern : patterns) {
            if (isPatternIncludeCap(*pattern, *cap)) {
                pattern->cap_count++;
                pattern->cap_value += cap->value;
                break;
            }
        }//for cap : caps
    }//for pattern : patterns

}

void PEXCapacitorModel::matchCapWithPattern(
        std::map<std::string, std::vector<cap_node*>>& cap_layer_map_,
        std::map<std::string, std::vector<pattern_cap*>>& pattern_layer_map_,
        uint target_layer_number, uint target_layer_datatype) {

    //string layer = std::to_string(target_layer_number) + "." + std::to_string(target_layer_datatype);
    string layer = getLayerString(target_layer_number, target_layer_datatype);
    std::map<std::string, std::vector<cap_node*>>::iterator it_cap_layer_map = cap_layer_map_.find(layer);
    std::map<std::string, std::vector<pattern_cap*>>::iterator it_pattern_layer_map = pattern_layer_map_.find(layer);
    if (it_cap_layer_map == cap_layer_map_.end() || it_pattern_layer_map == pattern_layer_map_.end()) return;

    std::vector<cap_node*>& caps = it_cap_layer_map->second;
    std::vector<pattern_cap*>& patterns = it_pattern_layer_map->second;

    for (auto& cap : caps) {
        for (auto& pattern : patterns) {
            if (isPatternIncludeCap(*pattern, *cap)) {
                pattern->cap_count++;
                pattern->cap_value += cap->value;
                break;
            }
        }//for cap : caps
    }//for pattern : patterns
}

void PEXCapacitorModel::makeLayerToCapNodeMap() {
    this->layer_to_cap_node_map.clear();
    map<string, vector<cap_node*>>::iterator it;
    for (auto& cur_cap : this->cap_nodes) {
        //std::string layer = std::to_string(cur_cap.layer_number) + "." + std::to_string(cur_cap.layer_datatype);
        string layer = getLayerString(cur_cap.layer_number, cur_cap.layer_datatype);
        it = this->layer_to_cap_node_map.find(layer);
        if (it == this->layer_to_cap_node_map.end()) {
            vector<cap_node*>* new_cap_list = new vector<cap_node*>;
            new_cap_list->push_back(&cur_cap);
            this->layer_to_cap_node_map.insert(pair<string, vector<cap_node*>>(layer, *new_cap_list));
        }
        else {
            it->second.push_back(&cur_cap);
        }
    }//for (auto& cur_cap : this->cap_nodes)

    //printLayerToCapNodeMap();
}


void PEXCapacitorModel::makeLayerToPatternCapMap() {
    this->layer_to_pattern_cap_map.clear();
    map<string, vector<pattern_cap*>>::iterator it;
    for (auto& cur_pattern : this->pattern_caps) {
        //string layer = std::to_string(cur_pattern.layer_number) + "." + std::to_string(cur_pattern.layer_datatype);
        string layer = getLayerString(cur_pattern.layer_number, cur_pattern.layer_datatype);
        it = this->layer_to_pattern_cap_map.find(layer);
        if (it == this->layer_to_pattern_cap_map.end()) {
            vector<pattern_cap*>* new_pattern_list = new vector<pattern_cap*>;
            new_pattern_list->push_back(&cur_pattern);
            this->layer_to_pattern_cap_map.insert(pair<string, vector<pattern_cap*>>(layer, *new_pattern_list));
        }
        else {
            it->second.push_back(&cur_pattern);
        }
    }//for (auto& cur_pattern : this->pattern_caps)

    //printLayerToPatternCapMap();
}


void PEXCapacitorModel::normalizePatternCap() {
    for (auto& cur_pattern_cap : this->pattern_caps) {
        if (cur_pattern_cap.cap_value > this->max_cap) this->max_cap = cur_pattern_cap.cap_value;
    }

    for (auto& cur_pattern_cap : this->pattern_caps) {
        cur_pattern_cap.normalized_cap_value = 1.0 / (std::log((cur_pattern_cap.cap_value / this->max_cap)) * (-1.0) + 1.0);
    }
}


inline std::string PEXCapacitorModel::getLayerString(uint layer_number, uint layer_datatype) {
    return (std::string(std::to_string(layer_number) + "." + std::to_string(layer_datatype)));
}


bool PEXCapacitorModel::isPatternIncludeCap(const pattern_cap& pattern, const cap_node& cap) {
    if (cap.x < pattern.pattern.minx) return false;
    if (cap.x > pattern.pattern.maxx) return false;
    if (cap.y < pattern.pattern.miny) return false;
    if (cap.y > pattern.pattern.maxy) return false;
    return true;
}

void PEXCapacitorModel::makeCubeVertices() {
    cube_vertex cur_cube_vertices;
    std::vector<pattern_cap>::iterator it;
    for (it = this->pattern_caps.begin(); it != this->pattern_caps.end(); ++it) {
        cur_cube_vertices.vertex[0] = { it->pattern.minx, it->pattern.maxy, it->pattern.maxz };
        cur_cube_vertices.vertex[1] = { it->pattern.minx, it->pattern.miny, it->pattern.maxz };
        cur_cube_vertices.vertex[2] = { it->pattern.maxx, it->pattern.miny, it->pattern.maxz };
        cur_cube_vertices.vertex[3] = { it->pattern.maxx, it->pattern.maxy, it->pattern.maxz };

        cur_cube_vertices.vertex[4] = { it->pattern.minx, it->pattern.maxy, it->pattern.minz };
        cur_cube_vertices.vertex[5] = { it->pattern.minx, it->pattern.miny, it->pattern.minz };
        cur_cube_vertices.vertex[6] = { it->pattern.maxx, it->pattern.miny, it->pattern.minz };
        cur_cube_vertices.vertex[7] = { it->pattern.maxx, it->pattern.maxy, it->pattern.minz };

        this->cube_vertices.push_back(cur_cube_vertices);
    }
}

void PEXCapacitorModel::makeVertices() {
    Vertex temp_vertex;
    float cap_color_r{}, cap_color_g{}, cap_color_b{};

    std::vector<pattern_cap>::iterator cur_pattern_cap = this->pattern_caps.begin();
    for (const auto& cur_cube : this->cube_vertices) {
        cap_color_r = cur_pattern_cap->normalized_cap_value;
        cap_color_g = 0.0f; // cur_pattern_cap->normalized_cap_value;
        cap_color_b = 0.0f;

        for (int i = 0; i < 8; ++i) {
            temp_vertex.position = { cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };
            temp_vertex.color = { cap_color_r , cap_color_g , cap_color_b };
            vertices.push_back(temp_vertex);
        }
        cur_pattern_cap++;
    }
}


void PEXCapacitorModel::makeIndices() {
    size_t cube_count = this->cube_vertices.size();

    std::vector<uint32_t>& indices = this->indices_edge;
    uint32_t start_idx = 0;
    for (size_t i = 0; i < cube_count; ++i, start_idx += 8) {
        //top
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);

        //bottom
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);

        //right
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);

        //left
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);

        //front
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);

        //back
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);
    }
}


void PEXCapacitorModel::printCapNodes() {
    printf("***** PEX ITEM LIST\n");
    int i = 1;
    for (auto& pex_item : this->pex_data.getCapacitors()) {
        printf("%dth PEX Item\n", i++);
        pex_item.print();
        printf("\n");
    }

    printf("***** CAP NODE LIST\n");
    i = 1;
    for (auto& cap_node : this->cap_node_name_to_index_map) {
        printf("%dth Cap Node Item\n", i++);
        printf("\nNode Name = %s / Layer# = %d.%d / x,y = %.4f,%.4f / Value = %e / Neibor = %d\n",
               this->cap_nodes[cap_node.second].name.c_str(),
                this->cap_nodes[cap_node.second].layer_number,
                this->cap_nodes[cap_node.second].layer_datatype,
                this->cap_nodes[cap_node.second].x,
                this->cap_nodes[cap_node.second].y,
                this->cap_nodes[cap_node.second].value,
                this->cap_nodes[cap_node.second].connected_count);
        printf("\n");
    }
}

void PEXCapacitorModel::printPatternCaps(FILE* out_stream) {
    fprintf(out_stream, "\n\n###############################################\n");
    fprintf(out_stream, "### PatternCap List\n");
    for (auto& pattern : this->pattern_caps) {
        fprintf(out_stream, "\nLayer = %u.%u, Cap count = %u, Total Caps = %e\n",
                pattern.layer_number, pattern.layer_datatype, pattern.cap_count, pattern.cap_value);
        fprintf(out_stream, "\tLeft ~ Right/Bottom ~ Top = %.6f ~ %.6f / %.6f ~ %.6f\n",
                pattern.pattern.minx, pattern.pattern.maxx, pattern.pattern.miny, pattern.pattern.maxy);
    }
}

void PEXCapacitorModel::printLayerToCapNodeMap(FILE* out_stream) {
    fprintf(out_stream, "\n\n\n####################################################\n");
    fprintf(out_stream, "Cap Layer Map\n");
    for (auto& cur_item : this->layer_to_cap_node_map) {
        fprintf(out_stream, "\nLayer = %s :: name / cap count / cap value \n", cur_item.first.c_str());
        for (auto cur_cap : cur_item.second) {
            fprintf(out_stream, "\t%s / %u / %e / %.6f, %.6f\n",
                    cur_cap->name.c_str(), cur_cap->connected_count, cur_cap->value, cur_cap->x, cur_cap->y);
        }
    }
}

void PEXCapacitorModel::printLayerToPatternCapMap(const char* msg) {
    printf("\n\n\n####################################################\n");
    printf("Pattern Layer Map :: %s\n", msg);
    for (auto& cur_item : this->layer_to_pattern_cap_map) {
        printf("\nLayer = %s :: left ~ right / bottom ~ top - cap count, cap value, norm cap value\n", cur_item.first.c_str());
        for (auto cur_pattern : cur_item.second) {
            printf("\t%.6f ~ %.6f / %.6f ~ %.6f - ",
                   cur_pattern->pattern.minx, cur_pattern->pattern.maxx, cur_pattern->pattern.miny, cur_pattern->pattern.maxy);
            printf("%u, %e, %f\n", cur_pattern->cap_count, cur_pattern->cap_value, cur_pattern->normalized_cap_value);
        }
    }
}

void PEXCapacitorModel::printLayerList() {
    printf("\n\n\n####################################################\n");
    printf("Layer List\n");
    for (auto& cur_layer : this->layers) {
        printf("\t%u.%u\n", cur_layer.first, cur_layer.second);
    }
}




!@hash[]!@file[]./Rendering/Src/PEXData.cpp!@hash[]!@code[]#include "LayoutPEXData.h"
#include <iostream>
#include <string>
#include <vector>

#include <limits>
#include <cstdio>

#include "rapidcsv.h"

#include <QFile>

using namespace std;


/// <summary>
/// PEXItem
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXItem::PEXItem() : node1{}, node2{}, name{} {
    this->value = 0.0;
}

PEXItem::PEXItem(const node& node1_, const node& node2_, const double& value_, const string& name_) :
    node1(node1_), node2(node2_), value(value_), name(name_) {
}

PEXItem::~PEXItem() {
}

void PEXItem::print() {
    printf("%s\n", this->name.c_str());
    printf("Node1 name/layer#/x1,y1/Z-s,Z-e = %s / %d.%d / %.5f,%.5f / %.5f,%.5f\n",
           this->node1.name.c_str(), this->node1.layer_number, this->node1.layer_datatype,
           this->node1.x, this->node1.y, this->node1.z_start, this->node1.z_end);
    printf("Node2 name/layer#/x1,y1/Z-s,Z-e = %s / %d.%d / %.5f,%.5f / %.5f,%.5f\n",
           this->node1.name.c_str(), this->node1.layer_number, this->node1.layer_datatype,
           this->node2.x, this->node2.y, this->node2.z_start, this->node2.z_end);
}

/// <summary>
/// PEXResistor
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXResistor::PEXResistor() : PEXItem(), direction(RES_DIRECTION_NONE) {
}
PEXResistor::PEXResistor(const string& name_, const node& node1_, const node& node2_, const double& value_, const PEXResDirection& direction_) :
    PEXItem(node1_, node2_, value_, name_), direction(direction_) {
}

void PEXResistor::print() {
    PEXItem::print();
    printf("Direction = ");
    if (this->direction == RES_DIRECTION_VERTICAL) printf("Vertical\n");
    else printf("Horizontal\n");
    printf("Resistor Value = %10.5f\n\n", this->getValue());
}

PEXResistor::~PEXResistor() {
}

PEXResDirection PEXResistor::checkDirectionFromDescription(const std::string& description) {
    PEXResDirection direction;
    if (description.find("$a") == std::string::npos) {
        direction = RES_DIRECTION_HORIZONTAL;
    }
    else {
        direction = RES_DIRECTION_VERTICAL;
    }
    //printf("#####Description = %s, ", description.c_str());
    //if (direction == RES_DIRECTION_VERTICAL) printf("Vertical\n");
    //else printf("Horizontal\n");

    return direction;
}

/// <summary>
/// PEXCapacitor
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXCapacitor::PEXCapacitor() : PEXItem() {
}
PEXCapacitor::PEXCapacitor(const std::string& name_, const node& node1_, const node& node2_, const double& value_) :
    PEXItem(node1_, node2_, value_, name_) {
}
PEXCapacitor::~PEXCapacitor() {
}

void PEXCapacitor::print() {
    PEXItem::print();
    printf("Capacitor Value = %10.5e\n\n", this->getValue());
}

/// <summary>
/// PEXResistorDataManager
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXResistorDataManager::PEXResistorDataManager() {
    this->resistors = {};
    this->file_path = "";
    this->max_resistor_vertical = std::numeric_limits<double>::min();
    this->min_resistor_vertical = std::numeric_limits<double>::max();
    this->max_resistor_horizontal = std::numeric_limits<double>::min();
    this->min_resistor_horizontal = std::numeric_limits<double>::max();
}

PEXResistorDataManager::~PEXResistorDataManager() {
    printf("\n\n\t~PEXDataManager\n");
    this->resistors.clear();
}

void PEXResistorDataManager::clear() {
    this->resistors.clear();
}

void PEXResistorDataManager::loadData(const std::string file_path) {
    if (!QFile::exists(file_path.c_str())) {
        cerr << "Error! " << file_path << " is not exist!!\n";
        return;
    }

    this->file_path = file_path;
    rapidcsv::Document infile(file_path, rapidcsv::LabelParams(-1, -1));

    string item_name{}, node1_lvl{}, node2_lvl{};
    node node1{}, node2{};
    string description{};
    double value = 0.0;

    size_t line_count = infile.GetRowCount();
    for (size_t i = 1; i < line_count; ++i) {
        vector<string> line = infile.GetRow<string>(i);

        item_name = line[PEXINFO_INDEX::PEXINFO_INDEX_NAME];
        if (item_name[0] != 'R') continue;

        node1.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_NAME];
        node1.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_X]);
        node1.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_Y]);
        node1.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZSTART]);
        node1.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZEND]);
        node1.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_NUMBER]);
        node1.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_DATATYPE]);

        node2.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_NAME];
        node2.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_X]);
        node2.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_Y]);
        node2.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZSTART]);
        node2.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZEND]);
        node2.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_NUMBER]);
        node2.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_DATATYPE]);

        value = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_VALUE]);

        node1_lvl = line[PEXINFO_INDEX_NODE1_LVL];
        node2_lvl = line[PEXINFO_INDEX_NODE2_LVL];


        if (node1_lvl == "RX") {
            node1.x = node2.x;
            node1.y = node2.y;
        }

        description = line[PEXINFO_INDEX::PEXINFO_INDEX_DESCRIPTION];
        PEXResDirection resistor_direction = PEXResistor::checkDirectionFromDescription(description);
        if (value > 0) updateMinMaxRes(value, resistor_direction); //ÓÇÇ ÄÚµå, 0º¸´Ù Ûº úÇ×º ¹«½Ã
        this->resistors.push_back(PEXResistor(item_name, node1, node2, value, resistor_direction));
    }
}

inline void PEXResistorDataManager::updateMinMaxRes(const double& new_value, const PEXResDirection direction) {
    if (direction == PEXResDirection::RES_DIRECTION_VERTICAL) {
        if (this->min_resistor_vertical > new_value) this->min_resistor_vertical = new_value;
        if (this->max_resistor_vertical < new_value) this->max_resistor_vertical = new_value;
    }
    else {
        if (this->min_resistor_horizontal > new_value) this->min_resistor_horizontal = new_value;
        if (this->max_resistor_horizontal < new_value) this->max_resistor_horizontal = new_value;
    }

}

void PEXResistorDataManager::printData() {
    for (auto item : this->resistors) {
        item.print();
    }
    printf("##Resistor Count : %lld, Vertical Res Max = %10.5f, Min = %10.5f, Horizontal Res Max = %10.5f, Min = %10.5f\n",
           this->resistors.size(),
           this->getMaxResistorVerticalValue(), this->getMinResistorVerticalValue(),
           this->getMaxResistorHorizontalValue(), this->getMinResistorHorizontalValue());
}


/// <summary>
/// PEXCapacitorDataManager
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXCapacitorDataManager::PEXCapacitorDataManager() {
    this->capasitors = {};
    this->file_path = "";
    this->max_capacitor = std::numeric_limits<double>::min();
    this->min_capacitor = std::numeric_limits<double>::max();
}

PEXCapacitorDataManager::~PEXCapacitorDataManager() {
    this->capasitors.clear();
}

void PEXCapacitorDataManager::clear() {
    this->capasitors.clear();
}

void PEXCapacitorDataManager::loadData(const std::string file_path) {
    if (!QFile::exists(file_path.c_str())) {
        cerr << "Error! " << file_path << " is not exist!!\n";
        return;
    }

    this->file_path = file_path;
    rapidcsv::Document infile(file_path, rapidcsv::LabelParams(-1, -1));

    string item_name{}, node1_lvl{}, node2_lvl{};
    node node1{}, node2{};
    string description{};
    double value = 0.0;

    size_t line_count = infile.GetRowCount();
    for (size_t i = 1; i < line_count; ++i) {
        vector<string> line = infile.GetRow<string>(i);

        item_name = line[PEXINFO_INDEX::PEXINFO_INDEX_NAME];
        if (item_name[0] != 'C') continue;

        node1.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_NAME];
        node1.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_X]);
        node1.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_Y]);
        node1.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZSTART]);
        node1.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZEND]);
        node1.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_NUMBER]);
        node1.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_DATATYPE]);

        node2.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_NAME];
        node2.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_X]);
        node2.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_Y]);
        node2.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZSTART]);
        node2.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZEND]);
        node2.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_NUMBER]);
        node2.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_DATATYPE]);

        value = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_VALUE]);

        node1_lvl = line[PEXINFO_INDEX_NODE1_LVL];
        node2_lvl = line[PEXINFO_INDEX_NODE2_LVL];

        updateMinMaxCap(value);
        this->capasitors.push_back(PEXCapacitor(item_name, node1, node2, value));
    }
}


inline void PEXCapacitorDataManager::updateMinMaxCap(const double& new_value) {
    if (this->min_capacitor > new_value) this->min_capacitor = new_value;
    if (this->max_capacitor < new_value) this->max_capacitor = new_value;
}


void PEXCapacitorDataManager::printData() {

    std::cout << "\n\nPEX Capacitors\n";
    for (auto item : this->capasitors) {
        item.print();
    }
    printf("##Capacitor Count : %lld, Max cap = %10.5e, Min cap = %10.5e\n",
           this->capasitors.size(), this->getMaxCapacitorValue(), this->getMinCapacitorValue());
}


void testPEXData() {
    PEXResistorDataManager resistor_data;
    resistor_data.loadData("Data/MVP_PEX_RC_r1_0130_0208version.csv");
    resistor_data.printData();

    PEXCapacitorDataManager capacitor_data;
    capacitor_data.loadData("Data/MVP_PEX_RC_r1_0130_0208version.csv");
    capacitor_data.printData();
}
!@hash[]!@file[]./Rendering/Src/PEXResistorModel.cpp!@hash[]!@code[]#include "PEXResistorModel.h"

#include <iostream>
#include <string>
#include <vector>

#include "LayoutPEXData.h"

#include <QFile>


PEXResistorModel::PEXResistorModel(LveDevice& device, MODEL_TYPE model_type, const std::string& data_file)
    : LveModel(device, model_type), pex_data{} {
    this->res_cube_thickness = 0.005;
    this->makeRenderingData(data_file);
    this->createBuffers();
}

PEXResistorModel::~PEXResistorModel() {
    this->pex_data.clear();
}

void PEXResistorModel::makeRenderingData(const std::string& file_path) {
    if (!QFile::exists(file_path.c_str())) {
        std::cerr << "Error! " << file_path << " is not exist!!\n";
        return;
    }

    loadData(file_path);
    makeCubes();
    makeCubeVertices();
    makeVertices();
    makeIndices();

    printf("\nPEX Resistor\n");
    printf("\tresistor count      : %lld\n", this->pex_data.getResistors().size());
    printf("\tcube_info count     : %lld\n", this->cube_infos.size());
    printf("\tcube_vertices count : %lld\n", this->cube_vertices.size());
    printf("\tVertices count      : %lld\n", this->vertices.size());
    printf("\tIndices count       : %lld\n", this->indices_face.size());

}

void PEXResistorModel::loadData(const std::string& file_path) {
    this->pex_data.loadData(file_path);
    //this->pex_data.printData();
}

void PEXResistorModel::makeCubes() {
    std::vector<PEXResistor>& resistors = this->pex_data.getResistors();
    cube_info cur_cube{};
    for (auto cur_res : resistors) {
        this->makeCube(cur_res, cur_cube, cur_res.getDirection());
        this->cube_infos.push_back(cur_cube);
    }
}

void PEXResistorModel::makeCube(const PEXResistor& res, cube_info& cube, PEXResDirection res_direction) {
    if (res_direction == RES_DIRECTION_VERTICAL) {
        cube.minx = res.node1.x - this->res_cube_thickness;
        cube.maxx = res.node1.x + this->res_cube_thickness;
        cube.miny = res.node1.y - this->res_cube_thickness;
        cube.maxy = res.node1.y + this->res_cube_thickness;
        cube.minz = res.node1.z_end;
        cube.maxz = res.node2.z_start;
    }
    else if (res_direction == RES_DIRECTION_HORIZONTAL) {
        if (res.node1.x == res.node2.x) {//run-length direction : y
            cube.minx = res.node1.x - this->res_cube_thickness;
            cube.maxx = res.node1.x + this->res_cube_thickness;
            cube.miny = res.node1.y < res.node2.y ? res.node1.y : res.node2.y;
            cube.maxy = res.node1.y < res.node2.y ? res.node2.y : res.node1.y;
        }
        else if(res.node1.y == res.node2.y ) {//run-length direction : x
            cube.minx = res.node1.x < res.node2.x ? res.node1.x : res.node2.x;
            cube.maxx = res.node1.x < res.node2.x ? res.node2.x : res.node1.x;
            cube.miny = res.node1.y - this->res_cube_thickness;
            cube.maxy = res.node1.y + this->res_cube_thickness;
        }

        double midz = (res.node1.z_start + res.node1.z_end) * 0.5;
        cube.minz = midz - this->res_cube_thickness;
        cube.maxz = midz + this->res_cube_thickness;
    }
    else {
        std::cerr << "\nResistor has no direction\n";
    }
}


void PEXResistorModel::makeCubeVertices() {
    std::vector<cube_info>::const_iterator it;
    cube_vertex cur_cube_vertices;

    for (it = this->cube_infos.begin(); it != this->cube_infos.end(); ++it) {
        cur_cube_vertices.vertex[0] = { it->minx, it->maxy, it->maxz };
        cur_cube_vertices.vertex[1] = { it->minx, it->miny, it->maxz };
        cur_cube_vertices.vertex[2] = { it->maxx, it->miny, it->maxz };
        cur_cube_vertices.vertex[3] = { it->maxx, it->maxy, it->maxz };

        cur_cube_vertices.vertex[4] = { it->minx, it->maxy, it->minz };
        cur_cube_vertices.vertex[5] = { it->minx, it->miny, it->minz };
        cur_cube_vertices.vertex[6] = { it->maxx, it->miny, it->minz };
        cur_cube_vertices.vertex[7] = { it->maxx, it->maxy, it->minz };

        this->cube_vertices.push_back(cur_cube_vertices);
    }
}

void PEXResistorModel::makeVertices() {
    Vertex temp_vertex;

    double max_vertical_res = this->pex_data.getMaxResistorVerticalValue();
    //double min_vertical_res = this->pex_data.getMinResistorVerticalValue();
    double max_horizontal_res = this->pex_data.getMaxResistorHorizontalValue();
    //double min_horizontal_res = this->pex_data.getMinResistorHorizontalValue();
    double max_res = max_vertical_res > max_horizontal_res ? max_vertical_res : max_horizontal_res;

    std::vector<PEXResistor>::iterator cur_resistor = this->pex_data.getResistors().begin();
    double resistor_value{};
    PEXResDirection resistor_direction{};

    for (const auto& cur_cube : this->cube_vertices) {
        resistor_value = cur_resistor->getValue();
        resistor_direction = cur_resistor->getDirection();

        for (int i = 0; i < 8; ++i) {
            temp_vertex.position = {
                cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };
            if (resistor_direction == PEXResDirection::RES_DIRECTION_VERTICAL) {
                temp_vertex.color = { static_cast<float>(resistor_value / max_res), 0.0f, 0.0f };
            }
            else {
                temp_vertex.color = { 0.0f, 0.0f, static_cast<float>(resistor_value / max_res) };
            }
            vertices.push_back(temp_vertex);
        }//for i 0 to 8
        cur_resistor++;
    }//for auto cur_vertices : this->cubes_vertices
}


void PEXResistorModel::makeIndices() {
    size_t cube_count = this->cube_vertices.size();

    uint32_t start_idx = 0;
    std::vector<uint32_t>& indices = this->indices_face;
    for (size_t i = 0; i < cube_count; ++i) {
        start_idx = 8 * i;
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);//top

        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);//right

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);//front

        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);//bottom

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);//left

        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);//back
    }

}




!@hash[]!@file[]./Rendering/Src/dtaorendersystem.cpp!@hash[]!@code[]

#include <QVulkanWindow>
#include <QVulkanInstance>
#include <vulkan/vulkan.h>

#include <QFileDialog>

#include "dtaorendersystem.h"

#include "lve_model.hpp"
#include "LayoutModel.h"
#include "PEXResistorModel.h"
#include "PEXCapacitorModel.h"


DtaoRenderSystem::DtaoRenderSystem(LveWindow *w)
    : lveWindow(w)
{
    this->trans_info = {};
    this->camera.setViewTarget(
                glm::vec3(0.0f,0.0f,1.0f),
                glm::vec3(0.0f, 0.0f, 0.0f),
                glm::vec3(0.0f, 1.0f, 0.0f));
    qDebug() << "\n$$$$$ DtaoRenderSystem()";
}

DtaoRenderSystem::~DtaoRenderSystem()
{
    deleteSimpleRenderSystem();
    deleteLveDevice();
}

void DtaoRenderSystem::beginRenderPass(VkCommandBuffer command_buffer){
    const QSize sz = this->lveWindow->swapChainImageSize();

    VkClearColorValue clearColor = {{ 0, 0, 0, 1 }};
    VkClearDepthStencilValue clearDS = { 1, 0 };
    VkClearValue clearValues[3];
    memset(clearValues, 0, sizeof(clearValues));
    clearValues[0].color = clearValues[2].color = clearColor;
    clearValues[1].depthStencil = clearDS;

    VkRenderPassBeginInfo rpBeginInfo;
    memset(&rpBeginInfo, 0, sizeof(rpBeginInfo));
    rpBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    rpBeginInfo.renderPass = lveWindow->defaultRenderPass();
    rpBeginInfo.framebuffer = lveWindow->currentFramebuffer();
    rpBeginInfo.renderArea.extent.width = sz.width();
    rpBeginInfo.renderArea.extent.height = sz.height();
    rpBeginInfo.clearValueCount = lveWindow->sampleCountFlagBits() > VK_SAMPLE_COUNT_1_BIT ? 3 : 2;
    rpBeginInfo.pClearValues = clearValues;
    m_devFuncs->vkCmdBeginRenderPass(command_buffer, &rpBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

    VkViewport viewport;
    viewport.x = viewport.y = 0;
    viewport.width = sz.width();
    viewport.height = sz.height();
    viewport.minDepth = 0;
    viewport.maxDepth = 1;
    m_devFuncs->vkCmdSetViewport(command_buffer, 0, 1, &viewport);

    VkRect2D scissor;
    scissor.offset.x = scissor.offset.y = 0;
    scissor.extent.width = viewport.width;
    scissor.extent.height = viewport.height;
    m_devFuncs->vkCmdSetScissor(command_buffer, 0, 1, &scissor);
}

void DtaoRenderSystem::startNextFrame(){
    this->cameraController.moveCamera(
                aspect, this->camera, this->getRenderScale(), this->gameObjects, lveWindow);
    this->cameraController.moveCameraMouse(
                this->camera, this->getRenderScale(), this->gameObjects, lveWindow);
    //this->cameraController.setPerspective(this->camera, aspect);


    VkCommandBuffer command_buffer = this->lveWindow->currentCommandBuffer();
    beginRenderPass(command_buffer);

    this->simpleRenderSystem->renderGameObjects(
                command_buffer, this->gameObjects, this->camera);

    m_devFuncs->vkCmdEndRenderPass(command_buffer);

    lveWindow->frameReady();
    lveWindow->requestUpdate(); // render continuously, throttled by the presentation rate

}

void DtaoRenderSystem::initResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::initResources()";
    createLveDevice();
    createSimpleRenderSystem();
    //if(!this->render_object_created) loadGameObjects();



    VkDevice dev = this->lveWindow->device();
    m_devFuncs = this->lveWindow->vulkanInstance()->deviceFunctions(dev);

    qDebug() << "\tDevice = " << this->lveDevice->device();

}

void DtaoRenderSystem::releaseResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::releaseResources()";

    deleteSimpleRenderSystem();
    deleteLveDevice();
}

void DtaoRenderSystem::initSwapChainResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::initSwapChainResources()";
    const QSize sz = this->lveWindow->swapChainImageSize();
    aspect = sz.width()/(double)sz.height();
    this->camera.setPerspectiveProjection(glm::radians(50.f), aspect, 0.1f, 100.f);
    //this->camera.setOrthographicProjection(-1,1,-1,1,0.1f,100.f);
}


void DtaoRenderSystem::releaseSwapChainResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::releaseSwapChainResources()";
}

void DtaoRenderSystem::createLveDevice(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::createLveDevice()";
    this->lveDevice = new LveDevice(this->lveWindow, this->lveWindow->vulkanInstance());
}

void DtaoRenderSystem::deleteLveDevice(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::deleteLveDevice()";
    delete this->lveDevice;
}

void DtaoRenderSystem::createSimpleRenderSystem(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::createSimpleRenderSystem()";
    VkRenderPass renderpass = this->lveWindow->defaultRenderPass();
    this->simpleRenderSystem = new SimpleRenderSystem(*this->lveDevice, renderpass);
}

void DtaoRenderSystem::deleteSimpleRenderSystem(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::deleteSimpleRenderSystem()";
    delete this->simpleRenderSystem;
}
/*
void DtaoRenderSystem::createNewObject(MODEL_TYPE model_type, const std::string & file_path) {
    if( model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) createNewLayoutObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) createNewPEXCapObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) createNewPEXResObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_AXIS) createNewAxisObject(file_path);
}*/

void DtaoRenderSystem::createT2DObject(MODEL_TYPE model_type, T2D t2d) {
    if( model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) createT2DLayoutObject(t2d);
    //else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) createNewPEXCapObject(file_path);
    //else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) createNewPEXResObject(file_path);
    //else if( model_type == MODEL_TYPE::MODEL_TYPE_AXIS) createNewAxisObject(file_path);
}

void DtaoRenderSystem::getCustomColor(float layernumber, glm::vec3 rgb){
    if(!gameObjects.empty()){
        for (auto& obj : gameObjects){
          if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT){
              obj.model->changeLayerColor(layernumber,rgb);
          }
        }

    } else {
        qDebug() << "there is no layer. get layer first!";
    }

}

void DtaoRenderSystem::getCustomOpacity(float layernumber, float opacity){
    if(!gameObjects.empty()){
        for (auto& obj : gameObjects){
          if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT){
              obj.model->changeLayerOpacity(layernumber,opacity);
          }
        }

    } else {
        qDebug() << "there is no layer. get layer first!";
    }
}

void DtaoRenderSystem::getCustomVisiblity(float layernumber, bool visibility){
    if(!gameObjects.empty()){
        for (auto& obj : gameObjects){
          if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT){
              obj.model->changeLayerVisiblity(layernumber,visibility);
          }
        }

    } else {
        qDebug() << "there is no layer. get layer first!";
    }
}

void DtaoRenderSystem::createT2DLayoutObject(T2D & t2d){

    //Layout model
    //std::string layout_info_file_path = file_path;
    std::shared_ptr<LayoutModel> model
            = std::make_unique<LayoutModel>(
                *this->lveDevice, MODEL_TYPE_LAYOUT, t2d);
    model->opacity = 0.5f;

    LayoutDataManager* layout_data = model->getLayoutDataManager();
    this->trans_info.trans_x = static_cast<float>( layout_data->getMinX() + layout_data->getDiffX()/2 );
    this->trans_info.trans_y = static_cast<float>( layout_data->getMinY()+ layout_data->getDiffY()/2);
    this->trans_info.trans_z = static_cast<float>( layout_data->getMinZ());
    this->trans_info.scale = static_cast<float>( layout_data->getScale());

    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x, -this->trans_info.trans_y, -this->trans_info.trans_z};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
    this->render_object_created = true;
    this->layout_model = model;
}

/*
void DtaoRenderSystem::createNewLayoutObject(const std::string & file_path){

    //Layout model
    std::string layout_info_file_path = file_path;
    std::shared_ptr<LayoutModel> model
            = std::make_unique<LayoutModel>(
                *this->lveDevice, MODEL_TYPE_LAYOUT, layout_info_file_path);
    model->opacity = 0.5f;

    LayoutDataManager* layout_data = model->getLayoutDataManager();
    this->trans_info.trans_x = static_cast<float>( layout_data->getMinX());
    this->trans_info.trans_y = static_cast<float>( layout_data->getMinY());
    this->trans_info.trans_z = static_cast<float>( layout_data->getMinZ());
    this->trans_info.scale = static_cast<float>( layout_data->getScale());

    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x, -this->trans_info.trans_y, -this->trans_info.trans_z};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
    this->render_object_created = true;
    this->layout_model = model;
}

void DtaoRenderSystem::createNewPEXResObject( const std::string & file_path){
    //PEX Resistor model
    std::string res_info_file_path = file_path;
    std::shared_ptr<PEXResistorModel> model
            = std::make_unique<PEXResistorModel>(
                *this->lveDevice, MODEL_TYPE_PEX_RESISTOR, res_info_file_path);

    //Resistor Object
    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x, -this->trans_info.trans_y, -this->trans_info.trans_z};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
}

void DtaoRenderSystem::createNewPEXCapObject( const std::string & file_path){
    //PEX Capacitor model
    std::string cap_info_file_path = file_path;
    std::shared_ptr<PEXCapacitorModel> model
            = std::make_unique<PEXCapacitorModel>(
                *this->lveDevice, MODEL_TYPE_PEX_CAPACITOR,
                cap_info_file_path, this->layout_model->getLayoutDataManager());

    //Capacitor Object
    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x, -this->trans_info.trans_y, -this->trans_info.trans_z};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
}

void DtaoRenderSystem::createNewAxisObject(const std::string & file_path){
    (void)(file_path);
    //Axis model
    std::shared_ptr<LveModel> model
            = std::make_unique<LveModel>(*this->lveDevice, MODEL_TYPE_AXIS);

    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {0.0f, 0.0f, 0.0f};
    new_object.transform.scale = { 1.0f, 1.0f, 1.0f };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
}
*/

/*
void DtaoRenderSystem::loadGameObjects() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::loadGameObjects()";
    return;

    auto cube = LveGameObject::createGameObject();

    //Layout model
    std::string layout_info_file_path = "Rendering/Data/layout_input_data.csv";
    //std::string layout_info_file_path = "Rendering/Data/big_test_espin.csv";
    std::shared_ptr<LayoutModel> layout_model
            = std::make_unique<LayoutModel>(*this->lveDevice, MODEL_TYPE_LAYOUT, layout_info_file_path);
    layout_model->opacity = 0.5f;

    LayoutDataManager* layout_data = layout_model->getLayoutDataManager();
    float trans_x = static_cast<float>(layout_data->getMinX());
    float trans_y = static_cast<float>(layout_data->getMinY());
    float trans_z = static_cast<float>(layout_data->getMinZ());
    float scale = static_cast<float>(layout_data->getScale());

    this->render_scale = scale;

    //Axis model
    std::shared_ptr<LveModel> axis_model
            = std::make_unique<LveModel>(*this->lveDevice, MODEL_TYPE_AXIS);

    //PEX Resistor model
    std::string res_info_file_path = "Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv";
    std::shared_ptr<PEXResistorModel> res_model
            = std::make_unique<PEXResistorModel>(*this->lveDevice, MODEL_TYPE_PEX_RESISTOR, res_info_file_path);

    //PEX Capacitor model
    std::string cap_info_file_path = "Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv";
    std::shared_ptr<PEXCapacitorModel> cap_model
            = std::make_unique<PEXCapacitorModel>(*this->lveDevice, MODEL_TYPE_PEX_CAPACITOR, cap_info_file_path, layout_model->getLayoutDataManager());


    //Resistor Object
    cube = LveGameObject::createGameObject();
    cube.model = res_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Capacitor Object
    cube = LveGameObject::createGameObject();
    cube.model = cap_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Layout Object
    cube = LveGameObject::createGameObject();
    cube.model = layout_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Axis Object
    cube = LveGameObject::createGameObject();
    cube.model = axis_model;
    cube.transform.translation = { 0.0f, 0.0f, 0.0f };
    cube.transform.scale = { 1.0f, 1.0f, 1.0f };
    gameObjects.push_back(std::move(cube));

    this->render_object_created = true;
}
*/
!@hash[]!@file[]./Rendering/Src/keyboard_movement_controller.cpp!@hash[]!@code[]#include "keyboard_movement_controller.hpp"
#include "lve_window.hpp"

#define GLM_ENABLE_EXPERIMENTAL

// std
#include <limits>
#include <iostream>

#include <glm/gtx/string_cast.hpp>
#include "lve_model.hpp"

void KeyboardMovementController::setAllMoveFlagOff() {
    camera_moving_flag.rotateLeft = false;
    camera_moving_flag.rotateRight = false;
    camera_moving_flag.moveForward = false;
    camera_moving_flag.moveBackward = false;
    camera_moving_flag.rotateForward = false;
    camera_moving_flag.rotateBackward = false;
}

void KeyboardMovementController::setMouseFlagOff() {
    camera_moving_flag.mouseLeft = false;
    camera_moving_flag.mouseRight = false;
    camera_moving_flag.mouseMiddle = false;
}

void KeyboardMovementController::moveKeyPressed(Qt::Key key) {
    //setAllMoveFlagOff();
    if (key == camera_move_key.moveForward) camera_moving_flag.moveForward = true;
    if (key == camera_move_key.moveBackward) camera_moving_flag.moveBackward = true;
    if (key == camera_move_key.rotateRight) camera_moving_flag.rotateRight = true;
    if (key == camera_move_key.rotateLeft) camera_moving_flag.rotateLeft = true;
    if (key == camera_move_key.rotateForward) camera_moving_flag.rotateForward = true;
    if (key == camera_move_key.rotateBackward) camera_moving_flag.rotateBackward = true;
    if (key == camera_move_key.moveUp) camera_moving_flag.moveUp = true;
    if (key == camera_move_key.moveDown) camera_moving_flag.moveDown = true;
    if (key == camera_move_key.moveLeft) camera_moving_flag.moveLeft = true;
    if (key == camera_move_key.moveRight) camera_moving_flag.moveRight = true;
    if (key == camera_move_key.toggleDemension) {
        camera_moving_flag.toggleDemension = true;
        camera_moving_flag.toggleDemensionXY = true;
    }


}

void KeyboardMovementController::moveKeyReleased(Qt::Key key) {
    //setAllMoveFlagOff();
    if (key == camera_move_key.moveForward) camera_moving_flag.moveForward = false;
    if (key == camera_move_key.moveBackward) camera_moving_flag.moveBackward = false;
    if (key == camera_move_key.rotateRight) camera_moving_flag.rotateRight = false;
    if (key == camera_move_key.rotateLeft) camera_moving_flag.rotateLeft = false;
    if (key == camera_move_key.rotateForward) camera_moving_flag.rotateForward = false;
    if (key == camera_move_key.rotateBackward) camera_moving_flag.rotateBackward = false;
    if (key == camera_move_key.moveUp) camera_moving_flag.moveUp = false;
    if (key == camera_move_key.moveDown) camera_moving_flag.moveDown = false;
    if (key == camera_move_key.moveLeft) camera_moving_flag.moveLeft = false;
    if (key == camera_move_key.moveRight) camera_moving_flag.moveRight = false;

}

void KeyboardMovementController::setMousePosition(QPoint position, int mode) {
    mouse_position.currentPosition = position;
    if (mode == 1) {
        mouse_position.pressPosition = position;
        mouse_position.currentPosition = position;
        xpos_prev = position.x();
        ypos_prev = position.y();
    }
    if (mode == 2) {
        mouse_position.releasePosition = position;
        mouse_position.currentPosition = position;
    }

    //qDebug()<< position.y();
}

void KeyboardMovementController::setMouseScroll(QPoint scroll) {
    if (camera_moving_flag.mouseMiddle){
        mouse_position.scrollClicked = scroll;
    } else {
        mouse_position.scroll = scroll;
    }
}

void KeyboardMovementController::moveButtonPressed(Qt::MouseButtons buttons) {
    setMouseFlagOff();
    if (buttons == camera_move_key.mouseLeft) camera_moving_flag.mouseLeft = true;
    if (buttons == camera_move_key.mouseRight) camera_moving_flag.mouseRight = true;
    if (buttons == camera_move_key.mouseMiddle) camera_moving_flag.mouseMiddle = true;


}

void KeyboardMovementController::moveButtonReleased(Qt::MouseButtons buttons) {
    setMouseFlagOff();
    if (buttons == camera_move_key.mouseLeft) camera_moving_flag.mouseLeft = true;
    if (buttons == camera_move_key.mouseRight) camera_moving_flag.mouseRight = true;
    if (buttons == camera_move_key.mouseMiddle) camera_moving_flag.mouseMiddle = true;
    //qDebug()<<
}

void KeyboardMovementController::moveCamera(
    float dt, LveCamera& camera, float render_scale, std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow) {
    float scale = 0.0f;
    float rotate_lr = 0.0f;
    float rotate_ud = 0.0f;
    float rotate_toggle = 0.0f;
    float rotate_toggle_xy = 0.0f;
    float obj_scale = 2.0f / render_scale;

    if (camera_moving_flag.moveForward) scale = 1.0f + 0.01f * obj_scale;
    else if (camera_moving_flag.moveBackward) scale = 1.0f - 0.01f * obj_scale;

    if (camera_moving_flag.rotateRight) rotate_lr = -0.1f * obj_scale;
    else if (camera_moving_flag.rotateLeft) rotate_lr = 0.1f * obj_scale;

    if (camera_moving_flag.rotateForward ) rotate_ud = -0.1f * obj_scale;
    else if (camera_moving_flag.rotateBackward) rotate_ud = 0.1f * obj_scale;

    if (camera_moving_flag.toggleDemension && !camera.isperspective) {
        camera.setPerspectiveProjection(glm::radians(50.f), dt, 0.1f, 100.f);
        camera_moving_flag.toggleDemension = false;
    }
    else if (camera_moving_flag.toggleDemension)rotate_toggle = 0.1f;

    if (camera_moving_flag.toggleDemensionXY) rotate_toggle_xy = -0.1f;


    glm::vec3 right{camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0]};
    glm::vec3 up{camera.viewMatrix[0][1], camera.viewMatrix[1][1], camera.viewMatrix[2][1]};
    glm::vec3 forward{camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2]};

    const glm::vec3 v{ glm::normalize(glm::cross(right,glm::vec3{0,0,1})) };

    if (glm::dot(rotate_toggle, rotate_toggle) > std::numeric_limits<float>::epsilon()) {

        camera.decomposeView(camera.getView());
        camera.rotation_d = glm::conjugate(camera.rotation_d);

        // yaw / z
        double siny_cosp = 2 * (camera.rotation_d.w * camera.rotation_d.z + camera.rotation_d.x * camera.rotation_d.y);
        double cosy_cosp = 1 - 2 * (camera.rotation_d.y * camera.rotation_d.y + camera.rotation_d.z * camera.rotation_d.z);
        float rotation = (float)atan2(siny_cosp, cosy_cosp);
        float degree = rotation * (180/3.141592653589793238463);
        float tilt = asin(forward.z/(sqrt(forward.x*forward.x +forward.y*forward.y+forward.z*forward.z)));
        tilt = tilt *(180/3.141592653589793238463);

        if(!camera_moving_flag.toggleDemensionXY && camera_moving_flag.toggleDemension){
            if(tilt  > 89.5 ){
                camera.decomposeView(camera.getView());
                camera.setViewTarget(glm::vec3(0.0f,0.0f,1.0f),glm::vec3(0.0f, 0.0f, 0.0f),glm::vec3(0.0f, 1.0f, 0.0f));
                camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(camera.scale_d.x, camera.scale_d.x, camera.scale_d.x));
                qDebug() << camera.rotation_d.z;
                camera_moving_flag.toggleDemension = false;
                camera.setOrthographicProjection(-1*dt*0.47,1*dt*0.47,-1*0.47,1*0.47,0.1f,100.f);
            } else {
                rotate_toggle=rotate_toggle * ((90 - tilt)/2 +1);
                camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle), right);
            }
        }


        if (camera_moving_flag.toggleDemensionXY) {
            if(up.z <0){
                qDebug() << degree;
                if( 180 - abs(degree) < 1 ){
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(degree-90), glm::vec3(0.0f, 0.0f, 1.0f));
                    camera_moving_flag.toggleDemensionXY = false;
                } else {
                    rotate_toggle_xy=rotate_toggle_xy * ((180 - abs(degree))/2 +1) *(180 - abs(degree))/(180 - abs(degree));
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle_xy), glm::vec3(0.0f, 0.0f, 1.0f));
                }
            } else{
                if( abs(degree) < 1 ){
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians( 0 - abs(degree)), glm::vec3(0.0f, 0.0f, 1.0f));
                    camera_moving_flag.toggleDemensionXY = false;
                } else {
                    rotate_toggle_xy=rotate_toggle_xy * (abs(degree)/2 +1) *abs(degree)/abs(degree);
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle_xy), glm::vec3(0.0f, 0.0f, 1.0f));
                }
            }
        }

    }



    if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr), glm::vec3(0.0f, 0.0f, 1.0f));
    }



    if (glm::dot(rotate_ud, rotate_ud) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_ud), right);

    }

    if (glm::dot(scale, scale) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(scale, scale, scale));

    }


    glm::vec3 moveDir{ 0.f };
    camera.decomposeView(camera.getView());

    if (camera_moving_flag.moveRight) moveDir += right;
    if (camera_moving_flag.moveLeft)  moveDir -= right;
    if (camera_moving_flag.moveUp)  moveDir -= v;
    if (camera_moving_flag.moveDown)  moveDir += v;



    if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon()) {
        //camera.decomposeView(camera.getView());
        //std::cout << glm::to_string(camera.rotation_d) << '\n';
        for (auto& gameobject : gameObjects) {
            if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
                gameobject.transform.translation += obj_scale * moveSpeed  * glm::normalize(moveDir);
                //camera.viewMatrix = glm::translate(camera.getView(), moveSpeed * dt * moveDir);
            }
        }

    }
    forward = {camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2]};
    double tilt = asin(forward.z/(sqrt(forward.x*forward.x +forward.y*forward.y+forward.z*forward.z)))*(180/3.141592653589793238463);
    camera.decomposeView(camera.getView());
    camera.rotation_d = glm::conjugate(camera.rotation_d);
    // yaw / z
    double siny_cosp = 2 * (camera.rotation_d.w * camera.rotation_d.z + camera.rotation_d.x * camera.rotation_d.y);
    double cosy_cosp = 1 - 2 * (camera.rotation_d.y * camera.rotation_d.y + camera.rotation_d.z * camera.rotation_d.z);
    double rotation = (double)atan2(siny_cosp, cosy_cosp)*(180/3.141592653589793238463);

    monitor.tilt = tilt;
    monitor.rotation = rotation;
    monitor.zoom = camera.scale_d.x;
    QString funcName = "camera_position";
    emit lvewindow->signalInfoText(funcName,monitor);

}

void KeyboardMovementController::moveCameraMouse(LveCamera& camera, float render_scale, std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow) {
    if (camera_moving_flag.mouseRight)
    {

        float rotate_lr = 0.0f;
        float rotate_ud = 0.0f;

        rotate_lr = mouse_position.currentPosition.x() - xpos_prev;
        rotate_ud = mouse_position.currentPosition.y() - ypos_prev;

        //glm::vec3 direction{ camera.viewMatrix[0][2], camera.viewMatrix[1][2], 0 };
        glm::vec3 right{camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0]};
        glm::vec3 up{camera.viewMatrix[0][1], camera.viewMatrix[1][1], camera.viewMatrix[2][1]};
        glm::vec3 forward{camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2]};


        if (glm::dot(rotate_ud, rotate_ud) > std::numeric_limits<float>::epsilon()) {
            if(glm::rotate(camera.getView(), glm::radians(rotate_ud*0.5f),right)[2][1] >= 0){
                camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_ud*0.5f),right);
            }
        }

        if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
            camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr*0.5f), glm::vec3(0.0f, 0.0f, 1.0f));
        }

        xpos_prev = mouse_position.currentPosition.x();
        ypos_prev = mouse_position.currentPosition.y();
    }
    else if (camera_moving_flag.mouseLeft)
    {
        float camera_scale = sqrt(pow(camera.viewMatrix[0][2], 2) + pow(camera.viewMatrix[1][2], 2) + pow(camera.viewMatrix[2][2], 2));
        float obj_scale = gameObjects.begin()->transform.scale.x;

        float scale = 2.0f / camera_scale / obj_scale;
        glm::vec3 moveDir{ 0.f };
        float movement_lr = mouse_position.currentPosition.x() - xpos_prev;
        float movement_ud = mouse_position.currentPosition.y() - ypos_prev;

        glm::vec3 direction{ camera.viewMatrix[0][2], camera.viewMatrix[1][2], 0 };
        const glm::vec3 u{ glm::normalize(glm::cross(direction, glm::vec3{0,0,1})) };
        const glm::vec3 v{ glm::normalize(glm::cross(u,glm::vec3{0,0,1})) };


        if (camera.viewMatrix[2][2] > 0 && camera.viewMatrix[2][1] > 0) {

            moveDir -= u * (movement_lr);
            moveDir -= v * (movement_ud);
        }
        else if (camera.viewMatrix[2][2] < 0 && camera.viewMatrix[2][1] > 0) {
            moveDir -= u * (movement_lr);
            moveDir += v * (movement_ud);
        }
        else if (camera.viewMatrix[2][2] < 0 && camera.viewMatrix[2][1] < 0) {
            moveDir += u * (movement_lr);
            moveDir -= v * (movement_ud);
        }
        else {
            moveDir += u * (movement_lr);
            moveDir += v * (movement_ud);
        }


        if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon()) {

            //camera.decomposeView(camera.getView());
            //std::cout << glm::to_string(camera.rotation_d) << '\n';
            for (auto& gameobject : gameObjects) {
                if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
                    gameobject.transform.translation += scale * 0.01f * glm::normalize(moveDir);
                    //camera.viewMatrix = glm::translate(camera.getView(), moveSpeed * dt * moveDir);
                }
            }
        }

        xpos_prev = mouse_position.currentPosition.x();
        ypos_prev = mouse_position.currentPosition.y();
    }

    if (mouse_position.scroll.y() != 0) {
        float scale_mouse = 1.0f + 0.1f * (mouse_position.scroll.y() / 120);
        camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(scale_mouse, scale_mouse, scale_mouse));
        mouse_position.scroll.setY(0);
        camera.decomposeView(camera.getView());
        qDebug() << camera.scale_d.x<< camera.scale_d.y<< camera.scale_d.z;
    }

    glm::vec3 forward = {camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2]};
    float tilt = asin(forward.z/(sqrt(forward.x*forward.x +forward.y*forward.y+forward.z*forward.z)))*(180/3.141592653589793238463);
    camera.decomposeView(camera.getView());
    camera.rotation_d = glm::conjugate(camera.rotation_d);
    // yaw / z
    double siny_cosp = 2 * (camera.rotation_d.w * camera.rotation_d.z + camera.rotation_d.x * camera.rotation_d.y);
    double cosy_cosp = 1 - 2 * (camera.rotation_d.y * camera.rotation_d.y + camera.rotation_d.z * camera.rotation_d.z);
    float rotation = (float)atan2(siny_cosp, cosy_cosp)*(180/3.141592653589793238463);

    monitor.tilt = tilt;
    monitor.rotation = rotation;
    monitor.zoom = camera.scale_d.x;
    QString funcName = "camera_position";
    emit lvewindow->signalInfoText(funcName,monitor);
}

void KeyboardMovementController::setPerspective(LveCamera& camera, float aspect){
    if (mouse_position.scrollClicked.y() > 0) {
        if (perspectiveNear + 0.01  > 100.f){
            perspectiveNear = 100.f;

        } else {
            perspectiveNear=perspectiveNear +0.01;
        }
    } else if (mouse_position.scrollClicked.y() < 0) {
        if (perspectiveNear - 0.01  < 0.1f){
            perspectiveNear = 0.1f;

        }else {perspectiveNear=perspectiveNear -0.01;}
        }
        camera.setPerspectiveProjection(glm::radians(50.f), aspect, perspectiveNear, 100.f);
        mouse_position.scrollClicked.setY(0);
}



!@hash[]!@file[]./Rendering/Src/lve_camera.cpp!@hash[]!@code[]#include "lve_camera.hpp"

// std
#include <cassert>
#include <limits>
#include <glm/glm.hpp> //vec3, vec4, ivec4, mat4
#include <glm/gtc/matrix_transform.hpp> //translate, rotate, scale, perspective 
#include <glm/gtc/type_ptr.hpp> //value_ptr


void LveCamera::setOrthographicProjection(
    float left, float right, float top, float bottom, float near, float far) {
  projectionMatrix = glm::ortho(left,right,top,bottom,near,far);
  isperspective = false;
}

void LveCamera::setPerspectiveProjection(float fovy, float aspect, float near, float far) {
    projectionMatrix = glm::perspective(fovy, aspect, near, far);
    isperspective = true;
    //  assert(glm::abs(aspect - std::numeric_limits<float>::epsilon()) > 0.0f);
    //  const float tanHalfFovy = tan(fovy / 2.f);
    //  projectionMatrix = glm::mat4{0.0f};
    //  projectionMatrix[0][0] = 1.f / (aspect * tanHalfFovy);
    //  projectionMatrix[1][1] = 1.f / (tanHalfFovy);
    //  projectionMatrix[2][2] = far / (far - near);
    //  projectionMatrix[2][3] = 1.f;
    //  projectionMatrix[3][2] = -(far * near) / (far - near);
}

void LveCamera::setViewYXZ(glm::vec3 position, glm::vec3 rotation) {
    const float c3 = glm::cos(rotation.z);
    const float s3 = glm::sin(rotation.z);
    const float c2 = glm::cos(rotation.x);
    const float s2 = glm::sin(rotation.x);
    const float c1 = glm::cos(rotation.y);
    const float s1 = glm::sin(rotation.y);
    const glm::vec3 u{ (c1 * c3 + s1 * s2 * s3), (c2 * s3), (c1 * s2 * s3 - c3 * s1) };
    const glm::vec3 v{ (c3 * s1 * s2 - c1 * s3), (c2 * c3), (c1 * c3 * s2 + s1 * s3) };
    const glm::vec3 w{ (c2 * s1), (-s2), (c1 * c2) };
    viewMatrix = glm::mat4{ 1.f };
    viewMatrix[0][0] = u.x;
    viewMatrix[1][0] = u.y;
    viewMatrix[2][0] = u.z;
    viewMatrix[0][1] = v.x;
    viewMatrix[1][1] = v.y;
    viewMatrix[2][1] = v.z;
    viewMatrix[0][2] = w.x;
    viewMatrix[1][2] = w.y;
    viewMatrix[2][2] = w.z;
    viewMatrix[3][0] = -glm::dot(u, position);
    viewMatrix[3][1] = -glm::dot(v, position);
    viewMatrix[3][2] = -glm::dot(w, position);
}

void LveCamera::setViewDirection(glm::vec3 position, glm::vec3 direction, glm::vec3 up) {
  const glm::vec3 w{glm::normalize(direction)};
  const glm::vec3 u{glm::normalize(glm::cross(w, up))};
  const glm::vec3 v{glm::cross(w, u)};

  viewMatrix = glm::mat4{1.f};
  viewMatrix[0][0] = u.x;
  viewMatrix[1][0] = u.y;
  viewMatrix[2][0] = u.z;
  viewMatrix[0][1] = v.x;
  viewMatrix[1][1] = v.y;
  viewMatrix[2][1] = v.z;
  viewMatrix[0][2] = w.x;
  viewMatrix[1][2] = w.y;
  viewMatrix[2][2] = w.z;
  viewMatrix[3][0] = -glm::dot(u, position);
  viewMatrix[3][1] = -glm::dot(v, position);
  viewMatrix[3][2] = -glm::dot(w, position);
}

void LveCamera::setViewTarget(glm::vec3 position, glm::vec3 target, glm::vec3 up) {
    viewMatrix = glm::lookAt(position, target, up);
    //setViewDirection(position, target - position, up);
}

void LveCamera::decomposeView(glm::mat4 viewMat) {
    glm::decompose(viewMat, scale_d, rotation_d, translation_d, skew_d, perspective_d);
    rotation_d = glm::conjugate(rotation_d);
}

!@hash[]!@file[]./Rendering/Src/lve_device.cpp!@hash[]!@code[]
#include <vulkan/vulkan.h>
#include "lve_device.hpp"



// std headers
#include <cstring>
#include <iostream>
#include <set>
#include <unordered_set>


// class member functions
LveDevice::LveDevice(LveWindow* window_, QVulkanInstance* qvk_instance_)
    : window(window_), qvk_instance(qvk_instance_) {
    qDebug() << "\n$$$$$ LveDevice()";
    createInstance();
    //setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createCommandPool();
}


LveDevice::~LveDevice() {
    qDebug() << "\n$$$$$ ~LveDevice()";
    vkDestroyCommandPool(device_, commandPool, nullptr);
}

void LveDevice::createInstance() {
    this->instance = this->qvk_instance->vkInstance();
}

void LveDevice::pickPhysicalDevice() {
    uint32_t deviceCount = 0;
    vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr);
    if (deviceCount == 0) {
        throw std::runtime_error("failed to find GPUs with Vulkan support!");
    }

    std::vector<VkPhysicalDevice> devices(deviceCount);
    vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data());

    for (const auto &device : devices) {
        VkPhysicalDeviceProperties prop_temp;
        vkGetPhysicalDeviceProperties(device, &prop_temp);

        if (isDeviceSuitable(device)) {
            physicalDevice = device;
            break;
        }
    }

    if (physicalDevice == VK_NULL_HANDLE) {
        throw std::runtime_error("failed to find a suitable GPU!");
    }

    vkGetPhysicalDeviceProperties(physicalDevice, &properties);
}

void LveDevice::createLogicalDevice() {

    QueueFamilyIndices indices = findQueueFamilies(physicalDevice);
    device_ = this->window->device();
    vkGetDeviceQueue(device_, indices.graphicsFamily, 0, &graphicsQueue_);
    vkGetDeviceQueue(device_, indices.presentFamily, 0, &presentQueue_);
}

void LveDevice::createCommandPool() {
    QueueFamilyIndices queueFamilyIndices = findPhysicalQueueFamilies();

    VkCommandPoolCreateInfo poolInfo = {};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily;
    poolInfo.flags =
            VK_COMMAND_POOL_CREATE_TRANSIENT_BIT | VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;

    if (vkCreateCommandPool(device_, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
        throw std::runtime_error("failed to create command pool!");
    }
}


void LveDevice::createSurface() {
    this->surface_ = this->qvk_instance->surfaceForWindow(this->window);
}


bool LveDevice::isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    bool extensionsSupported = checkDeviceExtensionSupport(device);

    bool swapChainAdequate = false;
    if (extensionsSupported) {
        SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);
        swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty();
    }

    VkPhysicalDeviceFeatures supportedFeatures;
    vkGetPhysicalDeviceFeatures(device, &supportedFeatures);

    return indices.isComplete() && extensionsSupported && swapChainAdequate &&
            supportedFeatures.samplerAnisotropy;
}



bool LveDevice::checkValidationLayerSupport() {
    uint32_t layerCount;
    vkEnumerateInstanceLayerProperties(&layerCount, nullptr);

    std::vector<VkLayerProperties> availableLayers(layerCount);
    vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data());

    for (const char *layerName : validationLayers) {
        bool layerFound = false;

        for (const auto &layerProperties : availableLayers) {
            if (strcmp(layerName, layerProperties.layerName) == 0) {
                layerFound = true;
                break;
            }
        }

        if (!layerFound) {
            return false;
        }
    }

    return true;
}


std::vector<const char *> LveDevice::getRequiredExtensions() {

    std::vector<const char *> extensions{};

    //auto supported_extensions = QVulkanInstance::supportedExtensions();
    //for(auto & cur_ext : supported_extensions){
    //    extensions.push_back(cur_ext.name.data());
    //}

    extensions.push_back("VK_KHR_surface");
    extensions.push_back("VK_KHR_win32_surface");
    //extensions.push_back(VK_KHR_SURFACE_EXTENSION_NAME);
    if (enableValidationLayers) {
        extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
    }

    return extensions;
}


void LveDevice::hasRequiredInstanceExtensions() {
    uint32_t extensionCount = 0;
    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr);
    std::vector<VkExtensionProperties> extensions(extensionCount);
    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data());


    qDebug() << "available extensions:";
    std::unordered_set<std::string> available;
    for (const auto &extension : extensions) {
        qDebug() << "\t" << extension.extensionName;
        available.insert(extension.extensionName);
    }

    qDebug() << "required extensions:";
    auto requiredExtensions = getRequiredExtensions();
    for (const auto &required : requiredExtensions) {
        qDebug() << "\t" << required;
        if (available.find(required) == available.end()) {
            throw std::runtime_error("Missing required glfw extension");
        }
    }
}


bool LveDevice::checkDeviceExtensionSupport(VkPhysicalDevice device) {
    uint32_t extensionCount;
    vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);

    std::vector<VkExtensionProperties> availableExtensions(extensionCount);
    vkEnumerateDeviceExtensionProperties(
                device,
                nullptr,
                &extensionCount,
                availableExtensions.data());

    std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());

    for (const auto &extension : availableExtensions) {
        requiredExtensions.erase(extension.extensionName);
    }

    return requiredExtensions.empty();
}


QueueFamilyIndices LveDevice::findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;

    uint32_t queueFamilyCount = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);

    std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());

    int i = 0;
    for (const auto &queueFamily : queueFamilies) {
        if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
            indices.graphicsFamily = i;
            indices.graphicsFamilyHasValue = true;
        }
        VkBool32 presentSupport = false;
        vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface_, &presentSupport);
        if (queueFamily.queueCount > 0 && presentSupport) {
            indices.presentFamily = i;
            indices.presentFamilyHasValue = true;
        }
        if (indices.isComplete()) {
            break;
        }

        i++;
    }

    return indices;
}

SwapChainSupportDetails LveDevice::querySwapChainSupport(VkPhysicalDevice device) {
    SwapChainSupportDetails details;
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface_, &details.capabilities);

    uint32_t formatCount;
    vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface_, &formatCount, nullptr);

    if (formatCount != 0) {
        details.formats.resize(formatCount);
        vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface_, &formatCount, details.formats.data());
    }

    uint32_t presentModeCount;
    vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface_, &presentModeCount, nullptr);

    if (presentModeCount != 0) {
        details.presentModes.resize(presentModeCount);
        vkGetPhysicalDeviceSurfacePresentModesKHR(
                    device,
                    surface_,
                    &presentModeCount,
                    details.presentModes.data());
    }
    return details;
}

VkFormat LveDevice::findSupportedFormat(
        const std::vector<VkFormat> &candidates, VkImageTiling tiling, VkFormatFeatureFlags features) {
    for (VkFormat format : candidates) {
        VkFormatProperties props;
        vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &props);

        if (tiling == VK_IMAGE_TILING_LINEAR && (props.linearTilingFeatures & features) == features) {
            return format;
        } else if (
                   tiling == VK_IMAGE_TILING_OPTIMAL && (props.optimalTilingFeatures & features) == features) {
            return format;
        }
    }
    throw std::runtime_error("failed to find supported format!");
}

uint32_t LveDevice::findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {
    VkPhysicalDeviceMemoryProperties memProperties;
    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);
    for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
        if ((typeFilter & (1 << i)) &&
                (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
            return i;
        }
    }

    throw std::runtime_error("failed to find suitable memory type!");
}

void LveDevice::createBuffer(
        VkDeviceSize size,
        VkBufferUsageFlags usage,
        VkMemoryPropertyFlags properties,
        VkBuffer &buffer,
        VkDeviceMemory &bufferMemory) {
    VkBufferCreateInfo bufferInfo{};
    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    bufferInfo.size = size;
    bufferInfo.usage = usage;
    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    if (vkCreateBuffer(device_, &bufferInfo, nullptr, &buffer) != VK_SUCCESS) {
        throw std::runtime_error("failed to create buffer!");
    }

    VkMemoryRequirements memRequirements;
    vkGetBufferMemoryRequirements(device_, buffer, &memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(device_, &allocInfo, nullptr, &bufferMemory) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate vertex buffer memory!");
    }

    vkBindBufferMemory(device_, buffer, bufferMemory, 0);
}

VkCommandBuffer LveDevice::beginSingleTimeCommands() {
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandPool = commandPool;
    allocInfo.commandBufferCount = 1;

    VkCommandBuffer commandBuffer;
    vkAllocateCommandBuffers(device_, &allocInfo, &commandBuffer);

    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

    vkBeginCommandBuffer(commandBuffer, &beginInfo);
    return commandBuffer;
}

void LveDevice::endSingleTimeCommands(VkCommandBuffer commandBuffer) {
    vkEndCommandBuffer(commandBuffer);

    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &commandBuffer;

    vkQueueSubmit(graphicsQueue_, 1, &submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(graphicsQueue_);

    vkFreeCommandBuffers(device_, commandPool, 1, &commandBuffer);
}

void LveDevice::copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkBufferCopy copyRegion{};
    copyRegion.srcOffset = 0;  // Optional
    copyRegion.dstOffset = 0;  // Optional
    copyRegion.size = size;
    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);

    endSingleTimeCommands(commandBuffer);
}

void LveDevice::copyBufferToImage(
        VkBuffer buffer, VkImage image, uint32_t width, uint32_t height, uint32_t layerCount) {
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkBufferImageCopy region{};
    region.bufferOffset = 0;
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;

    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = layerCount;

    region.imageOffset = {0, 0, 0};
    region.imageExtent = {width, height, 1};

    vkCmdCopyBufferToImage(
                commandBuffer,
                buffer,
                image,
                VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                1,
                &region);
    endSingleTimeCommands(commandBuffer);
}

void LveDevice::createImageWithInfo(
        const VkImageCreateInfo &imageInfo,
        VkMemoryPropertyFlags properties,
        VkImage &image,
        VkDeviceMemory &imageMemory) {
    if (vkCreateImage(device_, &imageInfo, nullptr, &image) != VK_SUCCESS) {
        throw std::runtime_error("failed to create image!");
    }

    VkMemoryRequirements memRequirements;
    vkGetImageMemoryRequirements(device_, image, &memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(device_, &allocInfo, nullptr, &imageMemory) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate image memory!");
    }

    if (vkBindImageMemory(device_, image, imageMemory, 0) != VK_SUCCESS) {
        throw std::runtime_error("failed to bind image memory!");
    }
}

!@hash[]!@file[]./Rendering/Src/lve_model.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>

#include "lve_model.hpp"
#include "rapidcsv.h"

// std
#include <cassert>
#include <cstring>

using namespace std;

inline float coord_normalize(float in_value, float move, float scale) {
    //return 2 * (in_value - min_value) / (max_value - min_value) - 1.0f;
    return (2 * (in_value - move) / (scale)-1.0f);
}



LveModel::LveModel(LveDevice& device, MODEL_TYPE type)
    : lveDevice{ device }, model_type(type) {
    if (type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        makeAxisData();
        createBuffers();
    }

    //createBuffers();
}

LveModel::~LveModel() {
    destroyBuffers();

    this->cube_infos.clear();
    this->cube_vertices.clear();
    this->vertices.clear();
    this->layerby_vertices.clear();
    this->indices_face.clear();
    this->layerby_face.clear();
    this->indices_edge.clear();
    this->layerby_edge.clear();
}

void LveModel::createBuffers() {

    if (this->model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) {
        for (auto const& [key, val] : layerby_vertices) {
            std::map<float, VkBuffer>& buffers = this->layerbyVertexBuffers;
            std::map<float, VkDeviceMemory>& buffersmemory = this->layerbyVertexBuffersMemory;
            createVertexBuffers(val, buffers[key], buffersmemory[key]);

            std::map<float, VkBuffer>& facebuffers = this->layerbyFaceIndexBuffers;
            std::map<float, VkDeviceMemory>& facebuffersmemory = this->layerbyFaceIndexBuffersMemory;
            createIndexBuffers(layerby_face[key], facebuffers[key], facebuffersmemory[key]);

            std::map<float, VkBuffer>& edgebuffers = this->layerbyEdgeIndexBuffers;
            std::map<float, VkDeviceMemory>& edgebuffersmemory = this->layerbyEdgeIndexBuffersMemory;
            createIndexBuffers(layerby_edge[key], edgebuffers[key], edgebuffersmemory[key]);
        }
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        createVertexBuffers(vertices, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) {
        createVertexBuffers(vertices, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_face, this->indexBufferForFace, this->indexBufferMemoryForFace);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) {
        createVertexBuffers(vertices, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
    }
}

void LveModel::destroyBuffers() {
    if (this->model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) {
        for (auto const& [key, val] : layerbyFaceIndexBuffers) {
            vkDestroyBuffer(lveDevice.device(), layerbyVertexBuffers[key], nullptr);
            vkFreeMemory(lveDevice.device(), layerbyVertexBuffersMemory[key], nullptr);
            vkDestroyBuffer(lveDevice.device(), val, nullptr);
            vkFreeMemory(lveDevice.device(), layerbyFaceIndexBuffersMemory[key], nullptr);
            vkDestroyBuffer(lveDevice.device(), layerbyEdgeIndexBuffers[key], nullptr);
            vkFreeMemory(lveDevice.device(), layerbyEdgeIndexBuffersMemory[key], nullptr);
        }

        //vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        //vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForFace, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForFace, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }

}
void LveModel::createVertexBuffers(
        const std::vector<Vertex>& vertices,
        VkBuffer& buffer,
        VkDeviceMemory& memory) {
    vertexCount = static_cast<uint32_t>(vertices.size());
    assert(vertexCount >= 3 && "Vertex count must be at least 3");
    VkDeviceSize bufferSize = sizeof(vertices[0]) * vertexCount;

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, vertices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}

void LveModel::createIndexBuffers(
        const std::vector<uint32_t>& indices,
        VkBuffer& buffer,
        VkDeviceMemory& memory) {
    assert( !indices.empty() && "Index size can't be zero");
    VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, indices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}

void LveModel::drawForFace(VkCommandBuffer commandBuffer) {
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_face.size()), 1, 0, 0, 0);
}

void LveModel::drawForEdge(VkCommandBuffer commandBuffer) {
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_edge.size()), 1, 0, 0, 0);
}

void LveModel::bindVertexBuffer(VkCommandBuffer commandBuffer) {
    VkBuffer buffers[] = {vertexBuffer};
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
}

void LveModel::bindDrawVertexIndexBufferForFace_layer(VkCommandBuffer commandBuffer, const float layer) {
    VkBuffer buffers[] = { layerbyVertexBuffers[layer] };
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
    vkCmdBindIndexBuffer(commandBuffer, layerbyFaceIndexBuffers[layer], 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_face[layer].size()), 1, 0, 0, 0);
}

void LveModel::bindDrawIndexBufferForEdge_layer(VkCommandBuffer commandBuffer, const float layer) {
    vkCmdBindIndexBuffer(commandBuffer, layerbyEdgeIndexBuffers[layer], 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_edge[layer].size()), 1, 0, 0, 0);
}



void LveModel::bindIndexBufferForFace(VkCommandBuffer commandBuffer) {
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForFace, 0, VK_INDEX_TYPE_UINT32);
}

void LveModel::bindIndexBufferForEdge(VkCommandBuffer commandBuffer) {
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForEdge, 0, VK_INDEX_TYPE_UINT32);
}


std::vector<VkVertexInputBindingDescription> LveModel::Vertex::getBindingDescriptions() {
    std::vector<VkVertexInputBindingDescription> bindingDescriptions(1);
    bindingDescriptions[0].binding = 0;
    bindingDescriptions[0].stride = sizeof(Vertex);
    bindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    return bindingDescriptions;
}

std::vector<VkVertexInputAttributeDescription> LveModel::Vertex::getAttributeDescriptions() {
    std::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);
    attributeDescriptions[0].binding = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset = offsetof(Vertex, position);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(Vertex, color);
    return attributeDescriptions;
}

void LveModel::makeAxisData(const float axis_length) {
    this->vertices.clear();
    this->vertices = {
        { { -axis_length, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f } },
        { {  axis_length, 0.0f, 0.0f }, { 1.0f, 0.0f, 0.0f } },
        { { 0.0f, -axis_length, 0.0f }, { 1.0f, 1.0f, 1.0f } },
        { { 0.0f,  axis_length, 0.0f }, { 0.0f, 1.0f, 0.0f } },
        { { 0.0f, 0.0f, -axis_length }, { 1.0f, 1.0f, 1.0f } },
        { { 0.0f, 0.0f,  axis_length }, { 0.0f, 0.0f, 1.0f } }
    };

    vector<uint32_t>& indices = this->indices_edge;
    indices.clear();
    indices.push_back(0);
    indices.push_back(1);
    indices.push_back(2);
    indices.push_back(3);
    indices.push_back(4);
    indices.push_back(5);
}

void LveModel::updateOpacity(float amount) {
    this->opacity += amount;
    if (this->opacity > 1.0f) this->opacity = 1.0f;
    if (this->opacity < 0.0f) this->opacity = 0.0f;
}

std::map<float, LveModel::LayerProperty> LveModel::getLayer() {
    //if(layerList.empty()){
    //    vector<glm::vec3> it = { glm::vec3{0.1,0.5,0.8},glm::vec3{0.8,0.4,0.2},glm::vec3{0.5,0.9,0.9} };
    //    int a = 0;
    //    for (auto ordered_key : drawing_order_layerby) {
    //
    //        layerList.insert(pair(ordered_key, LayerProperty{true,it.at(a%3), 0.5}) );
    //        a++;
    //    }
    //}
    return layerList;
}

void LveModel::changeLayerColor(float layernumber, glm::vec3 rgb){
    if(layerList.count(layernumber) != 0 ){
        layerList[layernumber].color = rgb;
    }

}

void LveModel::changeLayerOpacity(float layernumber, float opacity){
    if(layerList.count(layernumber) != 0 ){
        layerList[layernumber].opacity = opacity;
    }

}

void LveModel::changeLayerVisiblity(float layernumber, bool visiblity){
    if(layerList.count(layernumber) != 0 ){
        layerList[layernumber].visiblity = visiblity;
    }

}

!@hash[]!@file[]./Rendering/Src/lve_pipeline.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>

#include "lve_pipeline.hpp"
#include "lve_model.hpp"

// std
#include <cassert>
#include <fstream>
#include <iostream>
#include <stdexcept>



LvePipeline::LvePipeline(
        LveDevice& device,
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo)
    : lveDevice{device} {
    createGraphicsPipeline(vertFilepath, fragFilepath, configInfo);
}

LvePipeline::~LvePipeline() {
    vkDestroyShaderModule(lveDevice.device(), vertShaderModule, nullptr);
    vkDestroyShaderModule(lveDevice.device(), fragShaderModule, nullptr);
    vkDestroyPipeline(lveDevice.device(), graphicsPipeline, nullptr);
}

std::vector<char> LvePipeline::readFile(const std::string& filepath) {
    std::ifstream file{filepath, std::ios::ate | std::ios::binary};

    if (!file.is_open()) {
        throw std::runtime_error("failed to open file: " + filepath);
    }

    size_t fileSize = static_cast<size_t>(file.tellg());
    std::vector<char> buffer(fileSize);

    file.seekg(0);
    file.read(buffer.data(), fileSize);

    file.close();
    return buffer;
}

void LvePipeline::createGraphicsPipeline(
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo) {
    assert(
                configInfo.pipelineLayout != VK_NULL_HANDLE &&
            "Cannot create graphics pipeline: no pipelineLayout provided in configInfo");
    assert(
                configInfo.renderPass != VK_NULL_HANDLE &&
            "Cannot create graphics pipeline: no renderPass provided in configInfo");

    auto vertCode = readFile(vertFilepath);
    auto fragCode = readFile(fragFilepath);

    createShaderModule(vertCode, &vertShaderModule);
    createShaderModule(fragCode, &fragShaderModule);

    VkPipelineShaderStageCreateInfo shaderStages[2];
    shaderStages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    shaderStages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
    shaderStages[0].module = vertShaderModule;
    shaderStages[0].pName = "main";
    shaderStages[0].flags = 0;
    shaderStages[0].pNext = nullptr;
    shaderStages[0].pSpecializationInfo = nullptr;
    shaderStages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    shaderStages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    shaderStages[1].module = fragShaderModule;
    shaderStages[1].pName = "main";
    shaderStages[1].flags = 0;
    shaderStages[1].pNext = nullptr;
    shaderStages[1].pSpecializationInfo = nullptr;

    auto bindingDescriptions = LveModel::Vertex::getBindingDescriptions();
    auto attributeDescriptions = LveModel::Vertex::getAttributeDescriptions();
    VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.vertexAttributeDescriptionCount =
            static_cast<uint32_t>(attributeDescriptions.size());
    vertexInputInfo.vertexBindingDescriptionCount = static_cast<uint32_t>(bindingDescriptions.size());
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data();
    vertexInputInfo.pVertexBindingDescriptions = bindingDescriptions.data();

    VkGraphicsPipelineCreateInfo pipelineInfo{};
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &configInfo.inputAssemblyInfo;
    pipelineInfo.pViewportState = &configInfo.viewportInfo;
    pipelineInfo.pRasterizationState = &configInfo.rasterizationInfo;
    pipelineInfo.pMultisampleState = &configInfo.multisampleInfo;
    pipelineInfo.pColorBlendState = &configInfo.colorBlendInfo;
    pipelineInfo.pDepthStencilState = &configInfo.depthStencilInfo;
    pipelineInfo.pDynamicState = &configInfo.dynamicStateInfo;

    pipelineInfo.layout = configInfo.pipelineLayout;
    pipelineInfo.renderPass = configInfo.renderPass;
    pipelineInfo.subpass = configInfo.subpass;

    pipelineInfo.basePipelineIndex = -1;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(
                lveDevice.device(),
                VK_NULL_HANDLE,
                1,
                &pipelineInfo,
                nullptr,
                &graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline");
    }
}

void LvePipeline::createShaderModule(const std::vector<char>& code, VkShaderModule* shaderModule) {
    VkShaderModuleCreateInfo createInfo{};
    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    createInfo.codeSize = code.size();
    createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data());

    if (vkCreateShaderModule(lveDevice.device(), &createInfo, nullptr, shaderModule) != VK_SUCCESS) {
        throw std::runtime_error("failed to create shader module");
    }
}

void LvePipeline::bind(VkCommandBuffer commandBuffer) {
    vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
}

void LvePipeline::defaultPipelineConfigInfo(PipelineConfigInfo& configInfo) {
    configInfo.inputAssemblyInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    configInfo.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    configInfo.inputAssemblyInfo.primitiveRestartEnable = VK_FALSE;

    configInfo.viewportInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    configInfo.viewportInfo.viewportCount = 1;
    configInfo.viewportInfo.pViewports = nullptr;
    configInfo.viewportInfo.scissorCount = 1;
    configInfo.viewportInfo.pScissors = nullptr;

    configInfo.rasterizationInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    configInfo.rasterizationInfo.depthClampEnable = VK_FALSE;
    configInfo.rasterizationInfo.rasterizerDiscardEnable = VK_FALSE;
    configInfo.rasterizationInfo.polygonMode = VK_POLYGON_MODE_FILL;
    configInfo.rasterizationInfo.lineWidth = 1.0f;
    configInfo.rasterizationInfo.cullMode = VK_CULL_MODE_NONE;
    configInfo.rasterizationInfo.frontFace = VK_FRONT_FACE_CLOCKWISE;
    configInfo.rasterizationInfo.depthBiasEnable = VK_FALSE;
    configInfo.rasterizationInfo.depthBiasConstantFactor = 0.0f;  // Optional
    configInfo.rasterizationInfo.depthBiasClamp = 0.0f;           // Optional
    configInfo.rasterizationInfo.depthBiasSlopeFactor = 0.0f;     // Optional

    configInfo.multisampleInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    configInfo.multisampleInfo.sampleShadingEnable = VK_FALSE;
    configInfo.multisampleInfo.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
    configInfo.multisampleInfo.minSampleShading = 1.0f;           // Optional
    configInfo.multisampleInfo.pSampleMask = nullptr;             // Optional
    configInfo.multisampleInfo.alphaToCoverageEnable = VK_FALSE;  // Optional
    configInfo.multisampleInfo.alphaToOneEnable = VK_FALSE;       // Optional

    configInfo.colorBlendAttachment.colorWriteMask =
            VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT |
            VK_COLOR_COMPONENT_A_BIT;
    configInfo.colorBlendAttachment.blendEnable = VK_FALSE;
    configInfo.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;   // Optional
    configInfo.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;  // Optional
    configInfo.colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;              // Optional
    configInfo.colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;   // Optional
    configInfo.colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;  // Optional
    configInfo.colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;              // Optional

    configInfo.colorBlendInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    configInfo.colorBlendInfo.logicOpEnable = VK_FALSE;
    configInfo.colorBlendInfo.logicOp = VK_LOGIC_OP_COPY;  // Optional
    configInfo.colorBlendInfo.attachmentCount = 1;
    configInfo.colorBlendInfo.pAttachments = &configInfo.colorBlendAttachment;
    configInfo.colorBlendInfo.blendConstants[0] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[1] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[2] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[3] = 0.0f;  // Optional

    configInfo.depthStencilInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    configInfo.depthStencilInfo.depthTestEnable = VK_TRUE;
    configInfo.depthStencilInfo.depthWriteEnable = VK_TRUE;
    configInfo.depthStencilInfo.depthCompareOp = VK_COMPARE_OP_LESS;
    configInfo.depthStencilInfo.depthBoundsTestEnable = VK_FALSE;
    configInfo.depthStencilInfo.minDepthBounds = 0.0f;  // Optional
    configInfo.depthStencilInfo.maxDepthBounds = 1.0f;  // Optional
    configInfo.depthStencilInfo.stencilTestEnable = VK_FALSE;
    configInfo.depthStencilInfo.front = {};  // Optional
    configInfo.depthStencilInfo.back = {};   // Optional

    configInfo.dynamicStateEnables = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};
    configInfo.dynamicStateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    configInfo.dynamicStateInfo.pDynamicStates = configInfo.dynamicStateEnables.data();
    configInfo.dynamicStateInfo.dynamicStateCount =
            static_cast<uint32_t>(configInfo.dynamicStateEnables.size());
    configInfo.dynamicStateInfo.flags = 0;
}


!@hash[]!@file[]./Rendering/Src/lve_window.cpp!@hash[]!@code[]
#include <QMouseEvent>
#include <QKeyEvent>
#include <QDockWidget>
#include <QGraphicsRectItem>
#include <QGraphicsOpacityEffect>
#include <QFile>
#include <QFileDialog>
#include <QString>

#include "lve_window.hpp"
#include "dtaorendersystem.h"



LveWindow::LveWindow()
{
}

LveWindow::~LveWindow()
{
    //this->destroy();
}

QVulkanWindowRenderer *LveWindow::createRenderer()
{
    qDebug() << "\n$$$$$ LveWindow::createRenderer()";
    this->m_renderer = new DtaoRenderSystem(this);
    return this->m_renderer;
    //return new DtaoRenderSystem(this);

}

void LveWindow::wheelEvent(QWheelEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    const float amount = e->angleDelta().y() / 8;
    QPoint scroll = e->angleDelta();
    this->m_renderer->cameraController.setMouseScroll(scroll);

    if (keyCtrl == true)
    {
        //      m_rendere->windowZoom(amount);
        QString funcName = "windowZoom";
        float value = amount;
        //emit signalInfoText(funcName, value);
        //        qDebug()<<funcName << " : " << value;
    }
    else
    {
        //      m_renderer->moveZoom(amount);
        QString funcName = "moveZoom";
        float value = amount;
        //emit signalInfoText(funcName, value);
        //        qDebug()<<funcName << " : " << value;
    }
}

void LveWindow::mousePressEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    m_mouseButton = e->buttons();
    Qt::MouseButtons cur_button = e->buttons();
    QString funcName = "mousePress";
    QPoint position = e->pos();
    //emit signalInfoText(funcName, m_lastPos);
    m_lastPos = e->pos();
    this->m_renderer->cameraController.moveButtonPressed(cur_button);
    this->m_renderer->cameraController.setMousePosition(position, 1);

}

void LveWindow::emitStatus(float value){
    QString funcName = "rotateRenderX";
    //emit signalInfoText(funcName, value);
}


void LveWindow::mouseReleaseEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    m_mouseButton = 0;
    QString funcName = "mouseRelease";
    Qt::MouseButtons cur_button = e->buttons();
    QPoint position = e->pos();
    float value = 0;
    //emit signalInfoText(funcName, cur_button);
    this->m_renderer->cameraController.moveButtonReleased(cur_button);
    this->m_renderer->cameraController.setMousePosition(position, 2);
}

void LveWindow::mouseMoveEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    QPoint position = e->pos();
    this->m_renderer->cameraController.setMousePosition(position, 0);
    if (m_mouseButton == 0)
        return;

    int dx = e->pos().x() - m_lastPos.x();
    int dy = e->pos().y() - m_lastPos.y();

    if (dx)
    {
        if (m_mouseButton == 2)
        {
            //            m_renderer->rotateRenderY(dx / 10.0f);
            QString funcName = "rotateRenderX";
            float value = -dx / 10.0f;
            //emit signalInfoText(funcName, value);
            //qDebug()<< "mouseEvent "<<funcName << " : " << value;
        }
        else if (m_mouseButton == 4)
        {
            //            m_renderer->moveRenderX(dx / 10.0f);
            QString funcName = "moveRenderX";
            //float value = -dx / 10.0f;
            //emit signalInfoText(funcName, value);
            //            qDebug()<<funcName << " : " << value;
        }
    }

    if (dy)
    {
        if (m_mouseButton == 2)
        {
            //            m_renderer->rotateRenderY(dy / 10.0f);
            QString funcName = "rotateRenderY";
            //float value = dy / 10.0f;
            //emit signalInfoText(funcName, value);
            //            qDebug()<<funcName << " : " << value;
        }
        else if (m_mouseButton == 4)
        {
            //            m_renderer->moveRenderY(dy / 10.0f);
            QString funcName = "moveRenderY";
            //float value = dy / 10.0f;
            //emit signalInfoText(funcName, value);
            //            qDebug()<<funcName << " : " << value;
        }
    }
}

void LveWindow::keyPressEvent(QKeyEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    Qt::Key cur_key = (Qt::Key)e->key();
    //QString funcName = "rotateRenderX";
    //float value = 10.0f;
    //emit signalInfoText(funcName, value);

    this->m_renderer->cameraController.moveKeyPressed(cur_key);

}
void LveWindow::keyReleaseEvent(QKeyEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    Qt::Key cur_key = (Qt::Key)e->key();
    this->m_renderer->cameraController.moveKeyReleased(cur_key);
}

!@hash[]!@file[]./Rendering/Src/simple_render_system.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>
#include "simple_render_system.hpp"

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>
#include <glm/gtc/constants.hpp>

// std
#include <array>
#include <cassert>
#include <stdexcept>



struct SimplePushConstantData {
    glm::mat4 transform{ 1.f };
    alignas(16) glm::vec3 color{};
    glm::float32 alpha;
};

SimpleRenderSystem::SimpleRenderSystem(LveDevice& device, VkRenderPass renderPass )
    : lveDevice{ device } {
    createPipelineLayout(this->pipelineLayoutForLayoutFace);
    createPipelineForFace(renderPass);
    createPipelineLayout(this->pipelineLayoutForLayoutEdge);
    createPipelineForEdge(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXResistor);
    createPipelineForPEXResistor(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXCapacitor);
    createPipelineForPEXCapacitor(renderPass);
}

SimpleRenderSystem::~SimpleRenderSystem() {
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForLayoutFace, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForLayoutEdge, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForPEXResistor, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForPEXCapacitor, nullptr);
}


void SimpleRenderSystem::createPipelineLayout(VkPipelineLayout & pipeline_layout) {
    VkPushConstantRange pushConstantRange{};
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange.offset = 0;
    pushConstantRange.size = sizeof(SimplePushConstantData);

    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 0;
    pipelineLayoutInfo.pSetLayouts = nullptr;
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(lveDevice.device(), &pipelineLayoutInfo, nullptr, &pipeline_layout) !=
            VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }
}

void SimpleRenderSystem::createPipelineForFace(VkRenderPass renderPass) {
    assert(pipelineLayoutForLayoutFace != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForLayoutFace;

    pipelineConfig.colorBlendAttachment.blendEnable = VK_TRUE;
    pipelineConfig.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    pipelineConfig.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;

    this->lvePipelineForLayoutFace = std::make_unique<LvePipeline>(
                lveDevice,
                "Rendering/shaders/simple_shader.vert.spv",
                "Rendering/shaders/simple_shader.frag.spv",
                pipelineConfig);
}

void SimpleRenderSystem::createPipelineForEdge(VkRenderPass renderPass) {
    assert(pipelineLayoutForLayoutEdge != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForLayoutEdge;

    pipelineConfig.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForLayoutEdge = std::make_unique<LvePipeline>(
                lveDevice,
                "Rendering/shaders/simple_shader.vert_edge.spv",
                "Rendering/shaders/simple_shader.frag_edge.spv",
                pipelineConfig);
}

void SimpleRenderSystem::createPipelineForPEXResistor(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXResistor != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigResistor{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigResistor);
    pipelineConfigResistor.renderPass = renderPass;
    pipelineConfigResistor.pipelineLayout = pipelineLayoutForPEXResistor;

    this->lvePipelineForPEXResistor = std::make_unique<LvePipeline>(
                lveDevice,
                "Rendering/shaders/simple_shader.vert_pex.spv",
                "Rendering/shaders/simple_shader.frag_pex.spv",
                pipelineConfigResistor);
}

void SimpleRenderSystem::createPipelineForPEXCapacitor(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXCapacitor != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigCapacitor{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigCapacitor);
    pipelineConfigCapacitor.renderPass = renderPass;
    pipelineConfigCapacitor.pipelineLayout = pipelineLayoutForPEXCapacitor;

    pipelineConfigCapacitor.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForPEXCapacitor = std::make_unique<LvePipeline>(
                lveDevice,
                "Rendering/shaders/simple_shader.vert_pex.spv",
                "Rendering/shaders/simple_shader.frag_pex.spv",
                pipelineConfigCapacitor);
}

void SimpleRenderSystem::renderGameObjects(
        VkCommandBuffer commandBuffer,
        std::vector<LveGameObject>& gameObjects,
        const LveCamera& camera) {

    auto proj = camera.getProjection();
    proj[1][1] *= -1;
    auto projectionView = proj * camera.getView();

    SimplePushConstantData push{};
    for (auto& obj : gameObjects) {
        push.transform = projectionView * obj.transform.mat4();

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT && obj.model->getVisible()) {
            std::map<float, LveModel::LayerProperty> layer_info = obj.model->getLayer();

            for (auto ordered_key : obj.model->drawing_order_layerby ) {
                if(layer_info[ordered_key].visiblity){
                    lvePipelineForLayoutFace->bind(commandBuffer);
                    push.alpha = layer_info[ordered_key].opacity;
                    push.color = layer_info[ordered_key].color;
                    vkCmdPushConstants(
                                commandBuffer, pipelineLayoutForLayoutFace,
                                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                                sizeof(SimplePushConstantData), &push);
                    obj.model->bindDrawVertexIndexBufferForFace_layer(commandBuffer, ordered_key);
                    lvePipelineForLayoutEdge->bind(commandBuffer);
                    obj.model->bindDrawIndexBufferForEdge_layer(commandBuffer, ordered_key);
                }
            }

        }

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_AXIS && obj.model->getVisible()) {
            lvePipelineForLayoutEdge->bind(commandBuffer);
            push.color = glm::vec3(1.0f, 1.0f, 1.0f);
            vkCmdPushConstants(
                        commandBuffer, pipelineLayoutForLayoutEdge,
                        VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                        sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            obj.model->drawForEdge(commandBuffer);
        }

        if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR && obj.model->getVisible()) {
            //*
            push.alpha = 1.0f;
            push.color = glm::vec3(1.0f, 1.0f, 1.0f);
            lvePipelineForPEXResistor->bind(commandBuffer);
            vkCmdPushConstants(
                        commandBuffer, pipelineLayoutForPEXResistor,
                        VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                        sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForFace(commandBuffer);
            obj.model->drawForFace(commandBuffer);
            //*/
        }

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR && obj.model->getVisible()) {
            /*
            lvePipelineForPEXCapacitor->bind(commandBuffer);
            vkCmdPushConstants(
                        commandBuffer, pipelineLayoutForPEXCapacitor,
                        VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                        sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            obj.model->drawForEdge(commandBuffer);
            //*/
        }
    }
}


!@hash[]!@file[]./T2D.cpp!@hash[]!@code[]#include "T2D.h"

using namespace std;

bool T2D::text2data(std::string file_name){
    ifstream readfile(file_name);
    string line;
    vector<string> split;

    getline(readfile, line);
    split = T2D::string_split(line, ' ');
    LayoutMinMax.minx = atof(split[0].c_str());
    LayoutMinMax.miny = atof(split[1].c_str());
    LayoutMinMax.maxx = atof(split[2].c_str());
    LayoutMinMax.maxy = atof(split[3].c_str());
    LayoutMinMax.minz = atof(split[4].c_str());
    LayoutMinMax.maxz = atof(split[5].c_str());
    /*cout << LayoutMinMax.minx << "\t";
    cout << LayoutMinMax.miny << "\t";
    cout << LayoutMinMax.maxx << "\t";
    cout << LayoutMinMax.maxy << "\t";
    cout << LayoutMinMax.minz << "\t";
    cout << LayoutMinMax.maxz << endl;*/
    LayoutData10by10.clear();
    while(getline(readfile, line)){
        split = T2D::string_split(line, ' ');
        int row = atoi(split[9].c_str());
        int col = atoi(split[10].c_str());

        buf_ldata10by10.checking = false;
        buf_ldata10by10.layername = split[0];
        buf_ldata10by10.layernum = atoi(split[1].c_str());
        buf_ldata10by10.datatype = atoi(split[2].c_str());
        buf_ldata10by10.color.r = atoi(split[3].c_str());
        buf_ldata10by10.color.g = atoi(split[4].c_str());
        buf_ldata10by10.color.b = atoi(split[5].c_str());
        buf_ldata10by10.color.a = atoi(split[6].c_str());
        buf_ldata10by10.bot = atof(split[7].c_str());
        buf_ldata10by10.top = atof(split[8].c_str());

        buf_xy10by10.resize(row);
        for(int i = 0 ; i < row ; i++){
            buf_xy10by10[i].resize(col);
        }
        for(int i = 0 ; i < row*col ; i++){
            getline(readfile, line);
            split = T2D::string_split(line, ' ');
            int nr = atoi(split[0].c_str());
            int nc = atoi(split[1].c_str());
            int nsize = atoi(split[2].c_str());

            buf_xy.clear();
            for(int i = 0 ; i < nsize ; i++){
                getline(readfile, line);
                split = T2D::string_split(line, ' ');
                B_BOX buf;
                buf.minx = atof(split[0].c_str());
                buf.miny = atof(split[1].c_str());
                buf.maxx = atof(split[2].c_str());
                buf.maxy = atof(split[3].c_str());
                buf_xy.push_back(buf);
            }
            buf_xy10by10[nr][nc] = buf_xy;
        }
        buf_ldata10by10.xy = buf_xy10by10;
        LayoutData10by10.push_back(buf_ldata10by10);
    }
}

vector<string> T2D::string_split(string input, char delimiter) {
    vector<string> answer;
    stringstream ss(input);
    string temp;

    while(getline(ss, temp, delimiter)) {
        if(temp != ""){
            answer.push_back(temp);
        }
    }

    return answer;
}
!@hash[]!@file[]./all_data.cpp!@hash[]!@code[]#include "all_data.h"
#include <QString>
#include <QTextStream>
#include <QFileDialog>
#include <QVector>

all_data::all_data(QObject *parent) :
    QObject(parent)
{

}

all_data::~all_data()
{

}


void all_data::receiveSelectFileName(QString file_name)
{
    int row = 0;
    int column = 0;
    QFile file(file_name);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;
    QString getLine;
    QStringList list;
    QTextStream fileStream(&file);
    while (!fileStream.atEnd()) {
            getLine.append(fileStream.readLine());
            getLine.append(" ");
            list << (getLine.split(" ", Qt::SkipEmptyParts));
            row++;
            getLine.clear();
    }   // while End

    column = list.count()/row;

    for(int i=0 ; i<row ; i++)
    {
           QVector <QString> tempvector;
           for(int j=0 ; j<column ; j++)
           {
               int num1;
               num1 = j + column*i;
               tempvector.append(list[num1]);
           }
           inputDataVector.append(tempvector);
    }
    emit sendSplitData(row, column, inputDataVector);
    return;
}
!@hash[]!@file[]./filedb.cpp!@hash[]!@code[]#include "filedb.h"
#include <QFile>
#include <QVector>
#include <QTextStream>
#include <QList>
#include <QDebug>

FileDb::FileDb()
{

}

void FileDb::openFile(QString fileNameInfo,QVector<QList<float>> &vecList,
                      float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize)
{    
    QFile file(fileNameInfo);

    if (file.open(QIODevice::ReadOnly) | (QIODevice::Text))
    {
        QTextStream openFile(&file);
        while(!openFile.atEnd())
        {
            auto dataString = openFile.readLine().split(",");
            QList<float> data;
            for (auto &tempdata : dataString)
            {
                 data.append(tempdata.toFloat());
            }
            vecList.push_back(data);
            qDebug()<< "strVector : " << data;

            if(data.size() == 8)
            {
                if(xMinSize > data[2]){xMinSize = data[2];}
                if(yMinSize > data[3]){yMinSize = data[3];}
                if(xMaxSize < data[4]){xMaxSize = data[4];}
                if(yMaxSize < data[5]){yMaxSize = data[5];}
            }
        }
        file.close();
    }
    else
    {        
        return;
    }

    return;

}
!@hash[]!@file[]./formhier.cpp!@hash[]!@code[]#include "formhier.h"
#include "ui_formhier.h"
#include "mainwindow.h"
#include <QTableWidget>
#include <QDebug>


FormHier::FormHier(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormHier)
{
    ui->setupUi(this);
    // QTableWidget defalut ¬ê¸° ¤ì 
    QStringList defalutTableHeader;
    defalutTableHeader << "LayerName" << "LayerNum" << "LayerType" << "Red" << "Green" << "Blue";

    ui->tableWidget->setColumnCount(6);
    ui->tableWidget->setRowCount(10);
    ui->tableWidget->setColumnWidth(0,80);
    ui->tableWidget->setColumnWidth(1,80);
    ui->tableWidget->setColumnWidth(2,80);
    ui->tableWidget->setColumnWidth(3,50);
    ui->tableWidget->setColumnWidth(4,50);
    ui->tableWidget->setColumnWidth(5,50);
    ui->tableWidget->setHorizontalHeaderLabels(defalutTableHeader);

    ui->tableWidget->horizontalHeader()->setStyleSheet("QHeaderView::section {background-color:#404040;color:#FFFFFF;}");

//    tempcolor = ui->tableWidget->setBackgroundRole();
//    ui->tableWidget->setHorizontalHeaderItem(0,QColor(128,128,128));

}

FormHier::~FormHier()
{
    delete ui;
}

//void FormHier::testMyData(){
//    this->dataset->split_datas[0][0] = QString("No, I'm not fool!!!");
//}

//void FormHier::ReceiveSplitData(QStringList list, int row, int column,  QVector <QVector <QString>> &inputDataVector)
void FormHier::ReceiveSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector)
{
//    qDebug() << "xxxxxxxxxxxxxxxxxxxxxxxxx";
//    qDebug() << "row" << row;
//    qDebug() << "column" << column;
//    qDebug() << "1st" << inputDataVector.value(0);
//    qDebug() << "2nd" << inputDataVector.value(1);
//    qDebug() << "3rd" << inputDataVector.value(2);
//    qDebug() << "1st_1st" << inputDataVector.value(0).value(0);

// QTableWidget ì QStringList ë¡ë§ ë°ê¸°ë¬¸ë£ë
    QStringList vectorTOqstringlist;
    QStringList vectorTOqstringlistHoriLabels;

// QTableWidget ¬ê¸° ¤ì 
    ui->tableWidget->setColumnCount(column);
    ui->tableWidget->setRowCount(row);

// Table Header Font size/bold change
    QFont font = ui->tableWidget->horizontalHeader()->font();
    font.setBold(true);
    font.setPointSize(10);
    ui->tableWidget->horizontalHeader()->setFont(font);

// Table ì±ì°ê¸
    for (int i=0; i<row ; i++)
    {
        for (int j=0; j<column ; j++)
        {
            vectorTOqstringlist << inputDataVector.value(i+1).value(j);
            vectorTOqstringlistHoriLabels << inputDataVector.value(0).value(j);
            ui->tableWidget->setItem(i,j,new QTableWidgetItem(vectorTOqstringlist[i*column+j]));
            ui->tableWidget->setHorizontalHeaderLabels(vectorTOqstringlistHoriLabels);
        }

    }
//    ui->tableWidget->set;
//    ui->tableWidget->setColumnWidth(0,80);
//    ui->tableWidget->setColumnWidth(1,80);
//    ui->tableWidget->setColumnWidth(2,80);
//    ui->tableWidget->setColumnWidth(3,50);
//    ui->tableWidget->setColumnWidth(4,50);
//    ui->tableWidget->setColumnWidth(5,50);



}
!@hash[]!@file[]./forminfo.cpp!@hash[]!@code[]#include "forminfo.h"
#include "ui_forminfo.h"
#include <QDebug>
#include "cmath"

FormInfo::FormInfo(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormInfo)
{
    ui->setupUi(this);

    QString init_x = "";
    QString init_y = "";
    QString init_z = "";
    QString init_t = "";
    QString init_r = "";
    QString init_m = "";

    ui->pos_x->setText(init_x);
    ui->pos_y->setText(init_y);
    ui->pos_z->setText(init_z);
    ui->ang_tilt->setText(init_t);
    ui->ang_rotation->setText(init_r);
    ui->zoom->setText(init_m);
}

FormInfo::~FormInfo()
{
    delete ui;
}

void FormInfo::receiveFile(T2D &t2d)
{
    rendering_full = &t2d;
    m_min_x = t2d.LayoutMinMax.minx;
    m_max_x = t2d.LayoutMinMax.maxx;
    m_min_y = t2d.LayoutMinMax.miny;
    m_max_y = t2d.LayoutMinMax.maxy;
    m_min_z = t2d.LayoutMinMax.minz;
    m_max_z = t2d.LayoutMinMax.maxz;
}

void FormInfo::outputText()
{
    double rot = pos->rotation;
    if (rot <0) {
        rot = rot+360;
    }
    ui->pos_x->setText(QString::number(round(pos->x*10000)/10000));
    ui->pos_y->setText(QString::number(round(pos->y*10000)/10000));
    ui->pos_z->setText(QString::number(round(pos->z*10000)/10000));
    ui->ang_tilt->setText(QString::number(round(pos->tilt)));
    //ui->ang_rotation->setText(QString::number(round(pos->rotation*10000)/10000));
    ui->ang_rotation->setText(QString::number(round(360-rot)));
    ui->zoom->setText(QString::number(round(pos->zoom*100))+"%");
}

void FormInfo::receivePointPos(POS_MONITORING &pos)
{
    this->pos = &pos;
    temp_pos.x = pos.x;
    temp_pos.y = pos.y;
    temp_pos.z = pos.z;
    temp_pos.tilt = pos.tilt;
    temp_pos.rotation = pos.rotation;
    temp_pos.zoom = pos.zoom;
    temp_pos.window_zoom = 1;
}

void FormInfo::changePos()
{
    temp_pos.x = pos->x;
    temp_pos.y = pos->y;
    temp_pos.z = pos->z;
    temp_pos.tilt = pos->tilt;
    temp_pos.rotation = pos->rotation;
    temp_pos.zoom = pos->zoom;
    outputText();
}

void FormInfo::moveRender(float x, float y)
{
    const double pi = 3.1415926;

    qDebug()<< "moveRender";
    pointX = initPointX+x*cos(infoRot*pi/180)*infoZoom + y*sin(infoRot*pi/180)*sin(infoTilt*pi/180)*infoZoom;
    pointY = initPointY+x*sin(infoRot*pi/180)*infoZoom + y*cos(infoRot*pi/180)*sin(infoTilt*pi/180)*infoZoom;
    pointZ = initPointZ+y*cos(infoTilt*pi/180)*infoZoom;

    ui->pos_x->setText(QString::number(round(pointX*10000)/10000));
    ui->pos_y->setText(QString::number(round(pointY*10000)/10000));
    ui->pos_z->setText(QString::number(round(pointZ*10000)/10000));

}

bool FormInfo::checkNum(const QString &str)
{
    if(str.toDouble() == 0 && str != "0")
    // «ìë¡ë°ê¿¨ë 0ìë° string  0 ë ê²½ì°ë ë¬¸ì
    {
        return false;
    }
    else
    {
        return true;
    }
}

void FormInfo::checkText(double *point, const QString &arg1, double min_limit, double max_limit, int type)
{
    double double_arg = arg1.toDouble();
    if(checkNum(arg1)) // «ì¸ì ì
    {
        if(double_arg >= min_limit && double_arg <= max_limit) //tilt
        {
            if (type == 6) //zoom
            {
                *point = double_arg/100;
            }
            else if (type == 5) //rotation
            {
                *point = 360-double_arg;
            }
            else
            {
                *point = double_arg;
            }
        }
    }
    else if(arg1.isEmpty() || arg1.contains("-") || arg1.contains("0."))
    {

    }    
    else // ê¸°ì¡´ ê°ì¼ë¡ ì
    {
        outputText();
    }
}


void FormInfo::on_pos_x_textEdited(const QString &arg1)
{
    double min_limit = m_min_x;
    double max_limit = m_max_x;
    int type = 1;
    checkText(&temp_pos.x,arg1,min_limit,max_limit,type);
}

void FormInfo::on_pos_y_textEdited(const QString &arg1)
{
    double min_limit = m_min_y;
    double max_limit = m_max_y;
    int type = 2;
    checkText(&temp_pos.y,arg1,min_limit,max_limit,type);

}

void FormInfo::on_pos_z_textEdited(const QString &arg1)
{
    double min_limit = m_min_z;
    double max_limit = m_max_z;
    int type = 3;
    checkText(&temp_pos.z,arg1,min_limit,max_limit,type);
}

void FormInfo::on_ang_tilt_textEdited(const QString &arg1)
{
    double min_limit = m_min_tilt;
    double max_limit = m_max_tilt;
    int type = 4;
    checkText(&temp_pos.tilt,arg1,min_limit,max_limit,type);
}

void FormInfo::on_ang_rotation_textEdited(const QString &arg1)
{
    double min_limit = m_min_rot;
    double max_limit = m_max_rot;
    int type = 5;
    checkText(&temp_pos.rotation,arg1,min_limit,max_limit,type);
}

void FormInfo::on_zoom_textEdited(const QString &arg1)
{
    double min_limit = m_min_zoom;
    double max_limit = m_max_zoom;
    int type = 6;
    checkText(&temp_pos.zoom,arg1,min_limit,max_limit,type);
}

void FormInfo::inputPos()
{
    pos->x = temp_pos.x;
    pos->y = temp_pos.y;
    pos->z = temp_pos.z;
    pos->tilt = temp_pos.tilt;
    pos->rotation = temp_pos.rotation;
    pos->zoom = temp_pos.zoom;
    qDebug()<< "inputPos : " << pos->x << ","
                             << pos->y << ","
                             << pos->z << ","
                             << pos->tilt << ","
                             << pos->rotation << ","
                             << pos->zoom;
    emit signalDirectlyInputPos();
}

void FormInfo::on_pos_x_returnPressed()
{
    inputPos();
}

void FormInfo::on_pos_y_returnPressed()
{
    inputPos();
}

void FormInfo::on_pos_z_returnPressed()
{
    inputPos();
}

void FormInfo::on_ang_tilt_returnPressed()
{
    inputPos();
}

void FormInfo::on_ang_rotation_returnPressed()
{
    inputPos();
}

void FormInfo::on_zoom_returnPressed()
{
    inputPos();
}

void FormInfo::on_pos_x_editingFinished()
{
    ui->pos_x->setText(QString::number(round(temp_pos.x*10000)/10000));
}

void FormInfo::on_pos_y_editingFinished()
{
    ui->pos_y->setText(QString::number(round(temp_pos.y*10000)/10000));
}

void FormInfo::on_pos_z_editingFinished()
{
    ui->pos_z->setText(QString::number(round(temp_pos.z*10000)/10000));
}

void FormInfo::on_ang_tilt_editingFinished()
{
    ui->ang_tilt->setText(QString::number(round(temp_pos.tilt*10000)/10000));
}

void FormInfo::on_ang_rotation_editingFinished()
{
    ui->ang_rotation->setText(QString::number(round((360-temp_pos.rotation)*10000)/10000));
}

void FormInfo::on_zoom_editingFinished()
{
    ui->zoom->setText(QString::number(round(pos->zoom*100))+"%");
}
!@hash[]!@file[]./formlayer.cpp!@hash[]!@code[]#include "formlayer.h"
#include "ui_formlayer.h"
#include "Rendering/Src/dtaorendersystem.h"
#include "Rendering/Src/lve_model.hpp"
#include <string>



FormLayer::FormLayer(LveWindow *w, QWidget *parent) :
    QDialog(parent), m_window(w),
    ui(new Ui::FormLayer)
{
    ui->setupUi(this);
    MakeLayerInformationTableHeader();
}

FormLayer::~FormLayer()
{
    delete ui;
}

void FormLayer::ReceiveLayerInformation(T2D &t2d)
{
    ui->tableWidget->clearContents();
    t2d_layer_information = &t2d;
    MakeLayerInformationTableHeader();
    MakeLayerInformationTalbe();
}

void FormLayer::MakeLayerInformationTalbe()
{
    // QTableWidget ¬ê¸° ¤ì 
    ui->tableWidget->setColumnCount(table_default_column);
    ui->tableWidget->setRowCount(t2d_layer_information->LayoutData10by10.size());
    ui->tableWidget->setColumnWidth(5,80);

    // Table ì±ì°ê¸
    for (int i=1; i < t2d_layer_information->LayoutData10by10.size() ; i++)
    {
        MakeTableWidgetItemForText(i);
        MakeCheckBox(i);
        MakeColorButton(i);
        MakeSliderForOpacity(i);
    }
    MakeHeaderCheckBoxAndSlider();

    // Table Edit ê¸ì, ¤ì¤  í ê¸ì
    ui->tableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);
    ui->tableWidget->setSelectionMode(QAbstractItemView::SingleSelection);
}

void FormLayer::on_checkboxInTable_stateChanged()
{
    int checkboxrow = -1;
    QCheckBox *checkboxInTable = qobject_cast<QCheckBox*>(sender());
    if (!checkboxInTable)
        return;

    checkboxrow = FindCheckBoxRow(checkboxInTable);

    if (checkboxrow == 0) {
        ChangeAllCheckBoxState(checkboxInTable);
        return;
    }

    // selected checkbox layer name
    QTableWidgetItem *readcheckbox = ui->tableWidget->item(checkboxrow,2);
    QString selectedLayer = readcheckbox->text();
    QString printLayer = "selectedLayer = " + selectedLayer;

    // selected checkbox layer num
    QTableWidgetItem *ReadLayerNumber = ui->tableWidget->item(checkboxrow,3);
    float LayerNumber = stof(ReadLayerNumber->text().toStdString());

    if (checkboxInTable->isChecked()) {
        ChangeCheckBoxStateToOn(checkboxrow, LayerNumber, printLayer);
    } else {
        ChangeCheckBoxStateToOff(checkboxrow, LayerNumber, printLayer);
    }
}

void FormLayer::on_colorbutton_clicked()
{
    QString OldLayerColorRed = "";
    QString OldLayerColorGreen = "";
    QString OldLayerColorBlue = "";
    QString OldLayerColorAlpha = "";
    int OldLayerColorRedNum = 0;
    int OldLayerColorGreenNum = 0;
    int OldLayerColorBlueNum = 0;
    int OldLayerColorAlphaNum = 0;
    QRgb orc = qRgba(0, 0, 0, 0);

    QPushButton *ColorCheckButton = qobject_cast<QPushButton*>(sender());

    int colorbuttonRow = ui->tableWidget->currentRow();
    data_row_for_t2d = colorbuttonRow-1;

    GetPushButtonOldColor(ColorCheckButton, &OldLayerColorRedNum, &OldLayerColorGreenNum, &OldLayerColorBlueNum, &OldLayerColorAlphaNum, &orc);
    EnterPushButtonNewColor(&colorbuttonRow, &orc);
}

void FormLayer::on_opacityslider_valueChanged(int Opacity)
{
    // ui->tableWidget->currentRow() ë¡ì°¾ì¼¤ê³  ë©´, current row ê° -1 ë¡ì´
    int sliderrow = -1;
    int sliderrow_for_t2d = -1;
    QString LayerColorname;
    QString LayerColorText;
    QSlider *OpacityInTalbe = qobject_cast<QSlider*>(sender());

    for (int i = 0; i < ui->tableWidget->rowCount(); i++) {
        QWidget *widget = ui->tableWidget->cellWidget(i, 5);
        QSlider *slider = widget->findChild<QSlider*>();

        if (slider == OpacityInTalbe) {
            sliderrow = i;
            sliderrow_for_t2d = sliderrow-1;
            if (sliderrow == 0){
                for (int k=1; k < ui->tableWidget->rowCount(); k++) {
                    QWidget *SliderChangeWidget = ui->tableWidget->cellWidget(k, 5);
                    QSlider *SliderChange = SliderChangeWidget->findChild<QSlider*>();
                    SliderChange->setValue(Opacity);
                    t2d_layer_information->LayoutData10by10[sliderrow_for_t2d].color.a = Opacity;
                    emit outputLayerStatus(empty_for_emit);
                }
            } else {
                QTableWidgetItem *ReadLayer = ui->tableWidget->item(sliderrow,2);
                QString selectedLayer = ReadLayer->text();
                QString printLayer = "selectedLayer = " + selectedLayer;
                printLayer = printLayer + "  Layer  Opacity = " + QString::number(Opacity);
                QString OldColorStyleSheet = ui->tableWidget->cellWidget(sliderrow,1)->styleSheet();
                QStringList splittext = OldColorStyleSheet.split("(");
                QString splitrgbtemp = splittext[1].remove(")");
                QStringList splitrgb = splitrgbtemp.split(",");

                QString OldLayerColorRed = splitrgb[0];
                QString OldLayerColorGreen = splitrgb[1];
                QString OldLayerColorBlue = splitrgb[2];
                QString OldLayerColorAlpha = QString::number(Opacity);

                LayerColorText = "background-color: rgba(" + OldLayerColorRed;
                LayerColorText = LayerColorText + "," + OldLayerColorGreen + "," + OldLayerColorBlue + "," + OldLayerColorAlpha + ")";
                ui->tableWidget->cellWidget(sliderrow,1)->setStyleSheet(LayerColorText);
                t2d_layer_information->LayoutData10by10[sliderrow_for_t2d].color.a = Opacity;
                emit outputLayerStatus(printLayer);

                QTableWidgetItem *ReadLayerNumber = ui->tableWidget->item(sliderrow,3);
                float LayerNumber = stof(ReadLayerNumber->text().toStdString());
                DtaoRenderSystem *renderer = this->m_window->getRenderer();
                renderer->getCustomOpacity(LayerNumber,Opacity/(float)255);
            }
            break;
        }
    }
}

void FormLayer::OpacitySliderValueChange(int OpacityValue){

    qDebug() << "test number ======================================= " << OpacityValue;
    emit outputLayerStatus(empty_for_emit);
}

void FormLayer::MakeLayerInformationTableHeader(){
    QString TalbeHeader[] = {"","Color","Layer\nName","Layer\nNum","Layer\nType","Opacity\n"};
    ui->tableWidget->setColumnCount(6);
    ui->tableWidget->setRowCount(10);
    ui->tableWidget->setColumnWidth(0,20);
    ui->tableWidget->setColumnWidth(1,40);
    ui->tableWidget->setColumnWidth(2,40);
    ui->tableWidget->setColumnWidth(3,40);
    ui->tableWidget->setColumnWidth(4,40);
    ui->tableWidget->setColumnWidth(5,60);

    /// TableWidget Title Format ¤ì 
    QBrush brush(QColor(255, 255, 255, 255));
    brush.setStyle(Qt::SolidPattern);
    QFont font;
    font.setPointSize(8);
    font.setBold(true);
    font.setWeight(55);

    /// TableWidget Title ë ¥ ë°ë°ì
    for (int i=1; i<6; i++){
        QTableWidgetItem *TableHeaderItem = new QTableWidgetItem;
        TableHeaderItem->setText(TalbeHeader[i]);
        TableHeaderItem->setTextAlignment(Qt::AlignCenter);
        TableHeaderItem->setFont(font);
        TableHeaderItem->setForeground(brush);
        ui->tableWidget->setItem(0,i,TableHeaderItem);
        ui->tableWidget->setRowHeight(0,50);
        ui->tableWidget->item(0,i)->setBackground(QBrush(QColor(100,100,100)));
    }
}

void FormLayer::MakeTableWidgetItemForText(int table_row){
    data_row_for_t2d = table_row-1;
    QTableWidgetItem *tableitem_name = new QTableWidgetItem;
    QTableWidgetItem *tableitem_num = new QTableWidgetItem;
    QTableWidgetItem *tableitem_type = new QTableWidgetItem;

    tableitem_name->setText(t2d_layer_information->LayoutData10by10[data_row_for_t2d].layername.c_str());
    tableitem_num->setText(QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].layernum));
    tableitem_type->setText(QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].datatype));

    tableitem_name->setTextAlignment(Qt::AlignCenter);
    tableitem_num->setTextAlignment(Qt::AlignCenter);
    tableitem_type->setTextAlignment(Qt::AlignCenter);

    ui->tableWidget->setItem((table_row),2,tableitem_name);
    ui->tableWidget->setItem((table_row),3,tableitem_num);
    ui->tableWidget->setItem((table_row),4,tableitem_type);
}

void FormLayer::MakeSliderForOpacity(int table_row){
    data_row_for_t2d = table_row-1;
    QSlider *OpacitySlider = new QSlider(Qt::Horizontal);
    QWidget *OpacitySliderWidget = new QWidget();
    OpacitySlider->setRange(0,255);
    OpacitySlider->setValue(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a);
    OpacitySlider->setFocusPolicy(Qt::StrongFocus);
    QHBoxLayout *OpacityLayout = new QHBoxLayout(OpacitySliderWidget);
    OpacityLayout->addWidget(OpacitySlider);
    OpacitySliderWidget->setLayout(OpacityLayout);
    ui->tableWidget->setCellWidget(table_row, 5, OpacitySliderWidget);
    QObject::connect(OpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(on_opacityslider_valueChanged(int)));
}

void FormLayer::MakeCheckBox(int table_row){
    data_row_for_t2d = table_row-1;
    QCheckBox *checkBoxItem = new QCheckBox();
    checkBoxItem->setCheckState(Qt::Unchecked);
    QWidget *checkboxWidget = new QWidget();
    QHBoxLayout *checkboxLayout = new QHBoxLayout(checkboxWidget);
    checkboxLayout->addWidget(checkBoxItem);
    checkboxLayout->setAlignment(Qt::AlignCenter);
    checkboxLayout->setContentsMargins(0,0,0,0);
    checkboxWidget->setLayout(checkboxLayout);
    ui->tableWidget->setCellWidget(table_row,0,checkboxWidget);
    QObject::connect(checkBoxItem, SIGNAL(stateChanged(int)), this, SLOT(on_checkboxInTable_stateChanged()));
}

void FormLayer::MakeColorButton(int table_row){
    QString LayerColorRed;
    QString LayerColorGreen;
    QString LayerColorBlue;
    QString LayerColorAlpha;
    QString LayerColorText;
    data_row_for_t2d = table_row-1;
    // Layer color rgb defalut value
    int DefaultRedColor = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.r;
    int DefaultGreenColor = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.g;
    int DefaultBlueColor = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.b;
    int DefaultAlpha = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a;
    QColor DefaultColor = QColor(DefaultRedColor, DefaultGreenColor, DefaultBlueColor, DefaultAlpha);

    // Layer color rgb defalut value
    LayerColorRed = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.r);
    LayerColorGreen = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.g);
    LayerColorBlue = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.b);
    LayerColorAlpha = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a);

    LayerColorText = "background-color: rgba(" + LayerColorRed;
    LayerColorText = LayerColorText + "," + LayerColorGreen + "," + LayerColorBlue + "," + LayerColorAlpha + ")";

    // color pushbutton ì±ì°ê¸
    QPushButton *colorbutton = new QPushButton();
    colorbutton->setStyleSheet(LayerColorText);
    ui->tableWidget->setCellWidget(table_row,1,colorbutton);
    QObject::connect(colorbutton, SIGNAL(clicked()), this, SLOT(on_colorbutton_clicked()));
}

void FormLayer::MakeHeaderCheckBoxAndSlider(){
    //tableWidget title checkbox
    QCheckBox *checkBoxItem = new QCheckBox();
    checkBoxItem->setCheckState(Qt::Unchecked);
    QWidget *checkboxWidget = new QWidget();
    QHBoxLayout *checkboxLayout = new QHBoxLayout(checkboxWidget);
    checkboxLayout->addWidget(checkBoxItem);
    checkboxLayout->setAlignment(Qt::AlignCenter);
    checkboxLayout->setContentsMargins(0,0,0,0);
    checkboxWidget->setLayout(checkboxLayout);
    ui->tableWidget->setCellWidget(0,0,checkboxWidget);
    QObject::connect(checkBoxItem, SIGNAL(stateChanged(int)), this, SLOT(on_checkboxInTable_stateChanged()));

    //tableWidget title slider
    QSpacerItem *HeaderVerticalSpacer = new QSpacerItem(0,20,QSizePolicy::Fixed, QSizePolicy::Fixed);
    QSlider *HeaderOpacitySlider = new QSlider();
    HeaderOpacitySlider->setOrientation(Qt::Horizontal);
    HeaderOpacitySlider->setRange(0,255);
    HeaderOpacitySlider->setValue(200);
    QWidget *HeaderSliderWidget = new QWidget();
    QVBoxLayout *HeaderSliderLayout = new QVBoxLayout(HeaderSliderWidget);
    HeaderSliderLayout->addItem(HeaderVerticalSpacer);
    HeaderSliderLayout->addWidget(HeaderOpacitySlider);
    HeaderSliderWidget->setLayout(HeaderSliderLayout);
    ui->tableWidget->setCellWidget(0,5,HeaderSliderWidget);
    QObject::connect(HeaderOpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(on_opacityslider_valueChanged(int)));
}

int FormLayer::FindCheckBoxRow(QCheckBox *checkBoxInCell){
    QCheckBox &temp = *checkBoxInCell;
    for (int i = 0; i < ui->tableWidget->rowCount(); i++) {
        QWidget *widget = ui->tableWidget->cellWidget(i, 0);
        QCheckBox *checkbox = widget->findChild<QCheckBox*>();
        if (checkbox == &temp) {
            checkboxrow = i;
            break;
        }
    }
    return checkboxrow;
}

void FormLayer::ChangeAllCheckBoxState(QCheckBox *checkBoxInCell){
    if (checkBoxInCell->isChecked()) {
        for (int i = 1; i < ui->tableWidget->rowCount(); i++) {
            data_row_for_t2d = i-1;
            QWidget *widget = ui->tableWidget->cellWidget(i, 0);
            QCheckBox *checkbox = widget->findChild<QCheckBox*>();
            checkbox->setCheckState(Qt::Checked);
            t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = true;
        }
        qDebug() << "All Layer Checkbox Checked.";
        emit outputLayerStatus(CommentAllCheckedCheckBox);

    } else {
        for (int i = 1; i < ui->tableWidget->rowCount(); i++) {
            data_row_for_t2d = i-1;
            QWidget *widget = ui->tableWidget->cellWidget(i, 0);
            QCheckBox *checkbox = widget->findChild<QCheckBox*>();
            checkbox->setCheckState(Qt::Unchecked);
            t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = false;
        }
        qDebug() << "All Layer Checkbox Unchecked.";
        emit outputLayerStatus(CommentAllUncheckedCheckBox);
    }
}

void FormLayer::ChangeCheckBoxStateToOn(int check_box_row, float layer_num, QString print_comment){
    data_row_for_t2d = check_box_row-1;
    DtaoRenderSystem *renderer = this->m_window->getRenderer();
    renderer->getCustomVisiblity(layer_num, true);
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = true;
    print_comment = print_comment + "  Layer  On";
    emit outputLayerStatus(print_comment);
}

void FormLayer::ChangeCheckBoxStateToOff(int check_box_row, float layer_num, QString print_comment){
    data_row_for_t2d = check_box_row-1;
    DtaoRenderSystem *renderer = this->m_window->getRenderer();
    renderer->getCustomVisiblity(layer_num, false);
    print_comment = print_comment + "  Layer  Off";
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = false;
    emit outputLayerStatus(print_comment);
}

void FormLayer::GetPushButtonOldColor(QPushButton *old_push_button, int *oldred, int *oldgreen, int *oldblue, int *oldalpha, QRgb *oldrgba){
    QPushButton &oldcolor = *old_push_button;
    QString OldColorStyleSheet = oldcolor.styleSheet();
    QStringList splittext = OldColorStyleSheet.split("(");
    QString splitrgbtemp = splittext[1].remove(")");
    QStringList splitrgb = splitrgbtemp.split(",");

    QString OldLayerColorRed = splitrgb[0];
    QString OldLayerColorGreen = splitrgb[1];
    QString OldLayerColorBlue = splitrgb[2];
    QString OldLayerColorAlpha = splitrgb[3];

    *oldred = OldLayerColorRed.toInt();
    *oldgreen = OldLayerColorGreen.toInt();
    *oldblue = OldLayerColorBlue.toInt();
    *oldalpha = OldLayerColorAlpha.toInt();

    *oldrgba = qRgba(*oldred, *oldgreen, *oldblue, *oldalpha);
}

void FormLayer::EnterPushButtonNewColor(int *selected_color_button_row, QRgb *oldrgba){
    QString LayerColorText;
    QRgb chc = QColorDialog::getRgba(*oldrgba);
    int NewColorRed = qRed(chc);
    int NewColorGreen = qGreen(chc);
    int NewColorBlue = qBlue(chc);
    int NewColorAlpha = qAlpha(chc);

    LayerColorText = "background-color: rgba(" + QString::number(NewColorRed);
    LayerColorText = LayerColorText + "," + QString::number(NewColorGreen) + "," + QString::number(NewColorBlue) + "," + QString::number(NewColorAlpha) + ")";
    ui->tableWidget->cellWidget(*selected_color_button_row,1)->setStyleSheet(LayerColorText);

    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.r = NewColorRed;
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.g = NewColorGreen;
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.b = NewColorBlue;
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a = NewColorAlpha;

    float LayerNumber = stof(ui->tableWidget->item(*selected_color_button_row,3)->text().toStdString());
    DtaoRenderSystem *renderer = this->m_window->getRenderer();
    renderer->getCustomColor(LayerNumber, glm::vec3 {NewColorRed/(float)255,NewColorGreen/(float)255,NewColorBlue/(float)255});

    emit outputLayerStatus(empty_for_emit);

    QWidget *SliderChangeWidget = ui->tableWidget->cellWidget(*selected_color_button_row, 5);
    QSlider *SliderChange = SliderChangeWidget->findChild<QSlider*>();
    SliderChange->setValue(NewColorAlpha);
}
!@hash[]!@file[]./formmap.cpp!@hash[]!@code[]#include "formmap.h"
#include "ui_formmap.h"
#include <QGraphicsItem>
#include <QGraphicsRectItem>
#include <QVector>
#include <iostream>
#include <QDebug>
#include <QRect>
#include <QKeyEvent>

SuperItem::SuperItem(QGraphicsItem* parent) : QGraphicsItem(parent)
{
    setFlag(QGraphicsItem::ItemIsMovable);
}

void SuperItem::slotMove(POS_MONITORING *pos)
{
    double delta_x = pos->x - m_pos_past_x;
    double delta_y = pos->y - m_pos_past_y;
    double rot = 360 - pos->rotation;

    if (delta_x !=0 && delta_y !=0)
    {
        qDebug() << "delta x :" << delta_x << " || delta y :" << delta_y;
        moveBy(delta_x, -1 * delta_y);
        m_pos_past_x = this->x();
        m_pos_past_y = this->y();
    }



    QTransform trans;
    trans.rotate(rot);
    trans.scale(m_view_size*m_zoom_init/pos->zoom, (m_view_size*m_zoom_init/pos->zoom) * (pos->tilt / 90));
      //zoom ì´ê¸°ê° 25%ë©..
    setTransform(trans);

}

void SuperItem::slotInitMove(double x, double y)
{
    moveBy(x,y);
}

void SuperItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    painter->setPen(Qt::red);
    painter->drawRoundedRect(-88,-88,175,175,5,5);
    painter->setPen(Qt::blue);
    painter->drawLine(-86,-86,86,-86);
}

QRectF SuperItem::boundingRect() const{
    return QRectF(-89,-89,176,176);
}



FormMap::FormMap(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormMap)
{
    ui->setupUi(this);

}

FormMap::~FormMap()
{
    delete ui;
}

void FormMap::receiveFile(T2D &t2d)
{
    m_width = t2d.LayoutMinMax.maxx - t2d.LayoutMinMax.minx;
    m_height = t2d.LayoutMinMax.maxy - t2d.LayoutMinMax.miny;
    m_scale = m_box_size/qMax(m_width,m_height);
    m_width_scaled = m_scale * m_width;
    m_height_scaled = m_scale * m_height;
    double window_width = ui->graphicsView->size().width();
    double window_height = ui->graphicsView->size().height();

    QGraphicsRectItem *rectItem = new QGraphicsRectItem;
    QGraphicsScene *scene = new QGraphicsScene(this);
    rectItem->setRect(-(m_width_scaled/2),-(m_height_scaled/2),m_width_scaled,m_height_scaled);
    rectItem->setBrush(QBrush(QColor(Qt::gray)));
    rectItem->setPos(window_width/2,-window_height/2); //ì¢ì¸¡ (0,0) ì ë¶ì¤ì¼ë¡ ´ë
    scene->addItem(rectItem);
            //

    SuperItem *super = new SuperItem;
    scene->addItem(super);

    QObject::connect(this,&FormMap::signalMove,super,&SuperItem::slotMove);
    QObject::connect(this,&FormMap::signalInitMove,super,&SuperItem::slotInitMove);

    emit signalInitMove(window_width/2,-window_height/2);

    ui->graphicsView->setScene(scene);

}

void FormMap::receivePointPos(POS_MONITORING &pos)
{
    this->pos = &pos;
}
void FormMap::changePos()
{
    emit signalMove(pos);
}




    //if (funcName == "moveGdsX")
    //{
    //    pointX = pointX + value;
    //    initPointX = pointX;
    //    emit signalMove(value,0,0,999,999);
    //}
    //if (funcName == "moveGdsY")
    //{
    //    pointY = pointY + value;
    //    initPointY = pointY;
    //    emit signalMove(0, value,0,999,999);
    //}
    //if (funcName == "rotateRenderX")
    //{
    //    infoRot = initRot + value;
    //    if (infoRot>360)
    //        infoRot = infoRot - 360;
    //    if (infoRot<0)
    //        infoRot = infoRot + 360;
    //    emit signalMove(0, 0 ,0,infoRot,999);
    //}
    //if (funcName == "rotateRenderY")
    //{
    //    infoTilt = initTilt + value;
    //    if (infoTilt>90)
    //        infoTilt = 90;
    //    if (infoTilt<-90)
    //        infoTilt = -90;
    //    emit signalMove(0, 0 ,0,999,infoTilt);
    //}
    //if (funcName == "moveZoom")
    //{
    //    infoZoom = infoZoom + infoZoom*value/1500;        //¼ì  ì´ë¥100% ë¡¤ì ì ì, ê²°êµ­ ì´ê¸°ê°ì GDS Size °ë¼ ë°ëì.
    //    if (infoZoom < 0.01)
    //        infoZoom = 0.01;
    //    if (infoZoom > 100)
    //        infoZoom = 100;
    //    emit signalMove(0, 0, infoZoom, 999, 999);
    //}
    //if (funcName == "moveRenderX")
    //{
    //    x = value;
    //}
    //if (funcName == "moveRenderY")
    //{
    //    y = value;
    //}
    //if (funcName == "mouseRelease")
    //{
    //    initTilt = infoTilt;
    //    initRot = infoRot;
    //    initPointX = pointX;
    //    initPointY = pointY;
    //    initPointZ = pointZ;
    //}
//}

//void SuperItem::keyPressEvent(QKeyEvent *event){
//    switch(event->key()){
//    case Qt::Key_D:{
//        moveBy(30,0);
//        qDebug() << "press D";
//        break;
//        }
//    case Qt::Key_A:{
//        moveBy(-30,0);
//        break;
//        }
//    case Qt::Key_W:{
//        moveBy(0,-30);
//        break;
//        }
//    case Qt::Key_S:{
//        moveBy(0,30);
//        break;
//        }
//    }
//    update();

//}
!@hash[]!@file[]./formtop.cpp!@hash[]!@code[]#include "formtop.h"
#include "ui_formtop.h"
#include <QGraphicsItem>
#include <QScrollBar>
#include <QVector>
#include <QMap>
#include <iostream>
#include <QDebug>


FormTop::FormTop(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormTop)
{
    int slider_init_value = 50;

    ui->setupUi(this);
    this->m_scene = new QGraphicsScene(this);
    trans.scale(1,-1);
    ui->horizontalSlider->setValue(slider_init_value);

}


FormTop::~FormTop()
{
    delete ui;
}

void FormTop::receiveFile(T2D &t2d)
{
    drawingClear();
    m_scene->clear();
    rendering_full = &t2d;            
    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        for(int row = 0 ; row < (int)rendering_full->LayoutData10by10[layer].xy.size() ; row++)
        {
            rendering_full->LayoutData10by10[layer].xy_filtered.resize(rendering_full->LayoutData10by10[layer].xy.size());
            for(int col = 0 ; col < (int)rendering_full->LayoutData10by10[layer].xy[row].size() ; col++)
            {
                rendering_full->LayoutData10by10[layer].xy_filtered[row].resize(rendering_full->LayoutData10by10[layer].xy[row].size());
            }
        }
    }



    m_scene->setBackgroundBrush(QBrush(QColor(Qt::white)));

    drawing();
}

void FormTop::drawing()
{
    areaFilterRect();
    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        //layer_enviroment  ë¹êµì¬ for skip
        if( rendering_full->LayoutData10by10[layer].checking == 0){continue;}
        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                for(int n = 0 ; n < (int)(rendering_full->LayoutData10by10[layer].xy_filtered[row][col]).size(); n++)
                {
                    addRectItem(layer,row,col,n,trans);
                }
            }
        }
    }

    ui->graphicsView->setScene(m_scene);
}

void FormTop::drawingClear()
{
    // ê¸°ì¡´ë vector ë¥¨ê²¨ì¼ : delete ë¥í´
    for(auto cur_item : rectItemList)
    {
        delete cur_item;
    }
    rectItemList.clear();

}

void FormTop::receivePointPos(POS_MONITORING &pos)
{
    this->pos = &pos;
    temp_pos.x = pos.x;
    temp_pos.y = pos.y;
}

void FormTop::changePos()
{    
    if(temp_pos.x != pos->x || temp_pos.y != pos->y)
    {
        m_min_x_size = pos->x - m_area / m_area_scale;
        m_max_x_size = pos->x + m_area / m_area_scale;
        m_min_y_size = pos->y - m_area / m_area_scale;
        m_max_y_size = pos->y + m_area / m_area_scale;

        temp_pos.x = pos->x;
        temp_pos.y = pos->y;

        drawingClear();
        drawing();
    }
}

void FormTop::on_horizontalSlider_valueChanged(int value)
{
    m_area = value;

    if(init_check)
    {
        qDebug() << "pos init";
        m_min_x_size = 0 - m_area / m_area_scale;
        m_max_x_size = 0 + m_area / m_area_scale;
        m_min_y_size = 0 - m_area / m_area_scale;
        m_max_y_size = 0 + m_area / m_area_scale;
        init_check = false;
    }
    else
    {
        qDebug() << "pos working";
        m_min_x_size = pos->x - m_area / m_area_scale;
        m_max_x_size = pos->x + m_area / m_area_scale;
        m_min_y_size = pos->y - m_area / m_area_scale;
        m_max_y_size = pos->y + m_area / m_area_scale;

        drawingClear();
        drawing();
    }
}

void FormTop::addRectItem(int layer, int row, int col, int n, QTransform trans)
{

    QGraphicsRectItem *rectItem = new QGraphicsRectItem;
    rectItemList.push_back(rectItem);

    float opacity = rendering_full->LayoutData10by10[layer].color.a;
    opacity = opacity/255;

    float x = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].minx);
    float y = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].miny);
    float w = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].maxx-rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].minx);
    float h = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].maxy-rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].miny);

    rectItem->setRect(x,y,w,h);
    rectItem->setBrush(QBrush(QColor(rendering_full->LayoutData10by10[layer].color.r,rendering_full->LayoutData10by10[layer].color.g,rendering_full->LayoutData10by10[layer].color.b,rendering_full->LayoutData10by10[layer].color.a)));
    rectItem->setOpacity(opacity);
    qDebug()<< " rect    : " << rectItem->rect() << ":: row/col : " << row << "/" << col << " " << n;
    qDebug()<< " opacity : " << rendering_full->LayoutData10by10[layer].color.a << " : " << opacity;
    rectItem->setZValue(rendering_full->LayoutData10by10[layer].bot);

    rectItem->setTransform(trans);
    m_scene->addItem(rectItem);
}

int FormTop::extPos(double *pos, double *min, double *max)
{
    double area = m_area / m_area_scale; // 0.05 = 50/1000
    int pos_col_row = (*pos-*min)/m_block_size; // 30.0413/10 = 3
    int max_col_row = (*max-*min)/m_block_size;


    //block ¼ë¡ ë¥¸ ê²½ê³ë©ê·¼ì²ì ê²½ì° external ì¶ê
    if ((*pos - *min)<area && pos_col_row > 0) // 30.0413 - 3*10 = 0.0413 < 0.05
    {
        return pos_col_row - 1;
    }
    else if ((*max - *pos)<area && pos_col_row < max_col_row) // 39.9811 col 3 : (3+1)*10 - 39.9811 = 0.0189 < 0.05
    {
        return pos_col_row + 1;
    }

    return pos_col_row;
}

void FormTop::filterRenderingData(int layer, int row, int col, int n)
{
    if(rendering_full->LayoutData10by10[layer].xy[row][col][n].minx > m_max_x_size){return;}
    if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx < m_min_x_size){return;}
    if(rendering_full->LayoutData10by10[layer].xy[row][col][n].miny > m_max_y_size){return;}
    if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy < m_min_y_size){return;}

    double minx, maxx, miny, maxy;

    if(rendering_full->LayoutData10by10[layer].xy[row][col][n].minx < m_min_x_size) //area ë³´ë¤ ì´ê°ë©ë¦
    {
        minx = m_min_x_size;
    }
    else
    {
        minx = rendering_full->LayoutData10by10[layer].xy[row][col][n].minx;
    }

    if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx > m_max_x_size) //area ë³´ë¤ ì´ê°ë©ë¦
    {
        maxx = m_max_x_size;
    }
    else
    {
        maxx = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx;
    }

    if(rendering_full->LayoutData10by10[layer].xy[row][col][n].miny < m_min_y_size) //area ë³´ë¤ ì´ê°ë©ë¦
    {
        miny = m_min_y_size;
    }
    else
    {
        miny = rendering_full->LayoutData10by10[layer].xy[row][col][n].miny;
    }

    if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy > m_max_y_size) //area ë³´ë¤ ì´ê°ë©ë¦
    {
        maxy = m_max_y_size;
    }
    else
    {
        maxy = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy;
    }

    B_BOX temp;
    temp.minx = minx;
    temp.miny = miny;
    temp.maxx = maxx;
    temp.maxy = maxy;

    rendering_full->LayoutData10by10[layer].xy_filtered[row][col].push_back(temp);
}

void FormTop::areaFilterRect()
{
    //filter BBOX clear

    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                rendering_full->LayoutData10by10[layer].xy_filtered[row][col].clear();
            }
        }
    }

    int pos_col = (pos->x - rendering_full->LayoutMinMax.minx)/m_block_size; //ì´ ìë   23.3841 / 10 = 2.33841 -> int 2
    int ext_col = extPos(&pos->x, &rendering_full->LayoutMinMax.minx, &rendering_full->LayoutMinMax.maxx);
    m_begin_col = qMin(pos_col,ext_col);
    m_end_col = qMax(pos_col,ext_col)+1;

    int pos_row = (pos->y - rendering_full->LayoutMinMax.miny)/m_block_size;
    int ext_row = extPos(&pos->y, &rendering_full->LayoutMinMax.miny,&rendering_full->LayoutMinMax.maxy);
    m_begin_row = qMin(pos_row,ext_row);
    m_end_row = qMax(pos_col,ext_row)+1;


    //layer
    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        //layer_enviroment  ë¹êµì¬ for skip

        if( rendering_full->LayoutData10by10[layer].checking == 0){continue;}

        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                for(int n = 0 ; n < (int)(rendering_full->LayoutData10by10[layer].xy[row][col]).size(); n++)
                {                
                    filterRenderingData(layer,row,col,n);
                }
            }
        }
    }

}










!@hash[]!@file[]./gitmerge.cpp!@hash[]!@code[]#include "gitmerge.h"

#include <QFile>
#include <QTextStream>
#include <QDebug>

//git test

GitMerge::GitMerge()
{
    split1 = hash;
    split2 = hash;
    split1.append(file);
    split2.append(code);

    QString totalMerge;
    QString preMergeFile;
    QString updateMergeFile;
    this->mergeFiles(totalMerge);
    this->openPreMergeFile(preMergeFile);
    this->openUpdateMergeFile(updateMergeFile);
    this->writeMergeFile("./gitMerge.txt", totalMerge);
    //    if (compareFiles(preMergeFile, updateMergeFile))
    //    {
    //        if(compareFiles(preMergeFile, totalMerge))
    //        {
    //            qDebug() << "gitMerge file and code files are not changed " ;
    //            return;
    //        }
    //        else
    //        {
    //            this->writeMergeFile("./gitMerge.txt", totalMerge);
    ////            this->writeMergeFile("./gitMerge.back", totalMerge);
    //        }
    //    }
    //    else
    //    {
    //        this->writeMergeFile("./gitMerge.back", updateMergeFile);
    //        this->makeCodeFiles(totalMerge, updateMergeFile);
    //    }
}

void GitMerge::mergeFiles(QString &totalMerge)
{
    QFile file("./IInterface.pro");


    if(!file.open(QFile::ReadOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for reading ";
        return;
    }

    QTextStream in(&file);
    QString merge = in.readAll();
    QStringList mergeList = merge.split("\n");
    qDebug()<< "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
    for (auto &itemMerge : mergeList)
    {

        itemMerge = itemMerge.remove("\\");
        itemMerge = itemMerge.trimmed();
        //ì£¼ìì²ë¦¬´ì¼ ë¤.
        if (itemMerge.contains(".cpp", Qt::CaseInsensitive) || itemMerge.contains(".h", Qt::CaseInsensitive) || itemMerge.contains(".ui", Qt::CaseInsensitive))
        {
            QFile codeFile(itemMerge.prepend("./"));
            if(!codeFile.open(QFile::ReadOnly | QFile::Text))
            {
                qDebug() << " Could not open the code file for reading " ;
                return;
            }
            QTextStream codeIn(&codeFile);
            QString codeText = codeIn.readAll();

            totalMerge.append(split1);
            totalMerge.append(itemMerge);
            totalMerge.append(split2);
            totalMerge.append(codeText);
            codeFile.close();

        }

    }
    totalMerge.append(split1);
    totalMerge.append("./IInterface.pro");
    totalMerge.append(split2);
    totalMerge.append(merge);

    file.close();
}

void GitMerge::openPreMergeFile(QString &preMergeFile)
{
    QString fileName = "./gitMerge.back";
    QFile file(fileName);
    if(!file.open(QFile::ReadOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for reading ";
        preMergeFile = "";
        if(!file.open(QFile::WriteOnly | QFile::Text))
        {
            return;
        }
        QTextStream out(&file);
        out << "";
        file.close();
        return;
    }
    QTextStream in(&file);
    preMergeFile = in.readAll();
    file.close();
}
void GitMerge::openUpdateMergeFile(QString &updateMergeFile)
{
    QString fileName = "./gitMerge.txt";
    QFile file(fileName);
    if(!file.open(QFile::ReadOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for reading ";
        updateMergeFile = "";
        if(!file.open(QFile::WriteOnly | QFile::Text))
        {
            return;
        }
        QTextStream out(&file);
        out << "";
        file.close();
        return;
    }
    QTextStream in(&file);
    updateMergeFile = in.readAll();
    file.close();
}

bool GitMerge::compareFiles(QString &A, QString &B)
{
    if (A==B)
    {
        return true;
    }
    else
    {
        return false;
    }

}

void GitMerge::writeMergeFile(QString fileName, QString &originFile)
{
    QFile file(fileName);
    if(!file.open(QFile::WriteOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for writing ";
        return;
    }
    QTextStream out(&file);
    out << originFile;
    file.flush();
    file.close();

}

void GitMerge::makeCodeFiles(QString &codeFile, QString &gitMergeFile)
{
    QStringList codeList = codeFile.split(split1);
    QStringList fileList = gitMergeFile.split(split1);
    QStringList codeListDivide;
    QStringList fileListDivide;
    for (int i = 1; i < fileList.size(); i++)
    {
        fileListDivide = fileList[i].split(split2);
        for (int j = 1; j < codeList.size(); j++)
        {
            codeListDivide = codeList[j].split(split2);
            if (codeListDivide[0] == fileListDivide[0])
            {
                if (codeListDivide[1] != fileListDivide[1])
                {
                    QFile file_gitback(codeListDivide[0].append("_back"));
                    if(!file_gitback.open(QFile::WriteOnly | QFile::Text))
                    {
                        qDebug() << " Could not open the file for writing ";
                        return;
                    }
                    QTextStream out_gitback(&file_gitback);
                    out_gitback << codeListDivide[1];
                    file_gitback.flush();
                    file_gitback.close();

                    QFile file(fileListDivide[0]);
                    if(!file.open(QFile::WriteOnly | QFile::Text))
                    {
                        qDebug() << " Could not open the file for writing ";
                        return;
                    }
                    QTextStream out(&file);
                    out << fileListDivide[1];
                    file.flush();
                    file.close();
                }
                break;
            }
            if (j == codeList.size()-1) // ì°¾ìë´¤ëê¸°ì¡´ ì¼ë¤.
            {
                QFile file(fileListDivide[0]);
                if(!file.open(QFile::WriteOnly | QFile::Text))
                {
                    qDebug() << " Could not open the file for writing ";
                    return;
                }
                QTextStream out(&file);
                out << fileListDivide[1];
                file.flush();
                file.close();
            }


        }
    }

}
!@hash[]!@file[]./main.cpp!@hash[]!@code[]#include "mainwindow.h"
#include "gitmerge.h"

#include <QApplication>
#include <QVulkanInstance>
#include <QLoggingCategory>
#include <fstream>
#include <string>
#include <iostream>
#include "formtop.h"

#include "Rendering/Src/lve_window.hpp"
#include "Rendering/Src/simple_render_system.hpp"

Q_LOGGING_CATEGORY(lcVk, "qt.vulkan")

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

///////// git merge
    GitMerge gitMerge;
/// /////

    QLoggingCategory::setFilterRules(QStringLiteral("qt.vulkan=true"));

    QVulkanInstance inst;
    LveWindow *vulkanWindow = new LveWindow;

    //inst.setLayers(QByteArrayList() << "VK_LAYER_LUNARG_standard_validation");


    if (!inst.create())
        qFatal("Failed to create Vulkan instance: %d", inst.errorCode());

    vulkanWindow->setVulkanInstance(&inst);

    MainWindow mainWindow(vulkanWindow);
    QObject::connect(vulkanWindow, &LveWindow::signalInfoText, &mainWindow, &MainWindow::slotInfoText);



    QRect size = mainWindow.geometry();
    mainWindow.shareGeo(size);
    qDebug() << "Main geo : " << mainWindow.geometry();

    mainWindow.show();

    return app.exec();
}





!@hash[]!@file[]./mainwindow.cpp!@hash[]!@code[]#include "mainwindow.h"
#include "ui_mainwindow.h"

#include "Rendering/Src/dtaorendersystem.h"
#include "Rendering/Src/lve_model.hpp"


#include <QMouseEvent>
#include <QKeyEvent>
#include <QDockWidget>
#include <QGraphicsRectItem>
#include <QGraphicsOpacityEffect>
#include <QFile>
#include <QFileDialog>
#include <QString>

#include <fstream>
#include <iostream>
#include <string>
#include <QIODevice>
#include <QTextStream>

MainWindow::MainWindow(LveWindow *w)
    : m_window(w)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QWidget *wrapper = QWidget::createWindowContainer(w);
    ui->graphicsView->setViewport(wrapper);

    dockHier = new QDockWidget(tr("Hierarchy"), this);
    dockHier->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockHier->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockHier->setObjectName("DockWidgetHier");
    addDockWidget(Qt::RightDockWidgetArea, dockHier);
    formHier = new FormHier;
    dockHier->setWidget(formHier);

    dockLayer = new QDockWidget(tr("Layer Information"), this);
    dockLayer->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockLayer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockLayer->setObjectName("DockWidgetLayer");
    addDockWidget(Qt::RightDockWidgetArea, dockLayer);
    formLayer = new FormLayer(this->m_window);
    dockLayer->setWidget(formLayer);

    dockMap = new QDockWidget(tr("Map"), this);
    dockMap->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockMap->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockMap->setObjectName("DockWidgetMap");
    addDockWidget(Qt::LeftDockWidgetArea, dockMap);
    formMap = new FormMap;
    dockMap->setWidget(formMap);

    dockTop = new QDockWidget(tr("Topview"), this);
    dockTop->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockTop->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockTop->setObjectName("DockWidgetTop");
    addDockWidget(Qt::LeftDockWidgetArea, dockTop);
    formTop = new FormTop;
    dockTop->setWidget(formTop);

    dockInfo = new QDockWidget(tr("Info"), this);
    dockInfo->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockInfo->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockInfo->setObjectName("DockWidgetInfo");
    addDockWidget(Qt::LeftDockWidgetArea, dockInfo);
    formInfo = new FormInfo;
    dockInfo->setWidget(formInfo);

    resizeDocks({dockInfo, dockTop, dockMap, dockLayer, dockHier}, {200,200}, Qt::Horizontal);
    resizeDocks({dockTop, dockMap}, {200,200}, Qt::Vertical);
    resizeDocks({dockLayer, dockHier}, {350,300}, Qt::Vertical);

    input_dataS = new all_data;

    // test //
    pos.x = 0;
    pos.y = 0;
    pos.z = 0;
    pos.tilt = 90;
    pos.rotation = 0;
    pos.zoom = 1;
    pos.window_zoom = 1;
    formMap->receivePointPos(pos);
    formTop->receivePointPos(pos);
    formInfo->receivePointPos(pos);

    /// connect ////////////////////
    QObject::connect(ui->actionOpen_file, SIGNAL(triggered()), this, SLOT(on_actionOpen_file_triggered));
    QObject::connect(this, SIGNAL(sendSelectFileName(QString)), input_dataS, SLOT(receiveSelectFileName(QString)));
    QObject::connect(input_dataS, SIGNAL(sendSplitData(int, int, const QVector <QVector <QString>> &)), formHier, SLOT(ReceiveSplitData(int, int, const QVector <QVector <QString>> &)));
    QObject::connect(input_dataS, SIGNAL(sendSplitData(int, int, const QVector <QVector <QString>> &)), formLayer, SLOT(ReceiveSplitData(int, int, const QVector <QVector <QString>> &)));
    QObject::connect(formLayer, SIGNAL(outputLayerStatus(QString)), this, SLOT(inputLayerStatus(QString)));
    QObject::connect(formInfo, SIGNAL(signalDirectlyInputPos()), this, SLOT(slotDirectlyInputPos()));
}

void MainWindow::shareGeo(QRect size)
{
    QRect windowSize = size;
    qDebug() << "shareGeo : " << windowSize;
}


MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::slotInfoText(QString funcName, POS_MONITORING value)
{

    if(value.x != pos_past.x ||
       value.y != pos_past.y ||
       value.z != pos_past.z ||
       (value.tilt - pos_past.tilt) > 0.01 ||
       (value.rotation - pos_past.rotation) > 0.01 ||
       value.zoom != pos_past.zoom)
    {

        qDebug()<< "changePos";

        pos.x = value.x;
        pos.y = value.y;
        pos.z = value.z;
        pos.tilt = value.tilt;
        pos.rotation = value.rotation;
        pos.zoom = value.zoom;

        formMap->changePos();
        formTop->changePos();
        formInfo->changePos();

        pos_past.x = pos.x;
        pos_past.y = pos.y;
        pos_past.z = pos.z;
        pos_past.tilt = pos.tilt;
        pos_past.rotation = pos.rotation;
        pos_past.zoom = pos.zoom;
    }


    //qDebug() << "slotInfoText" << funcName << value.x << " "<< value.y << " "<< value.z << " ";
///// temp //////
//    QString text = funcName + " : " ;
//    for (int i = text.size() ; i < 30 ; i++)
//    {
//        text.append(" ");
//    }

//    statusText.prepend(text);

//    if (statusText.size() > 120)
//        statusText.remove(120,statusText.size()-120);
//    ui->statusbar->showMessage(statusText);

}

void MainWindow::on_actionOpen_file_triggered()
{

    QString file_name = QFileDialog::getOpenFileName(this, "ì¼  í",".","Files(*.*)");
    //qDebug() << file_name;

    emit sendSelectFileName(file_name);

}

void MainWindow::inputLayerStatus(QString text)
{
    ui->statusbar->showMessage(text);
    formTop->drawingClear();
    formTop->drawing();
}

void MainWindow::inputPosInformation()
{

    //execute (pos)
}

void MainWindow::on_actionOpen_Layout_triggered()
{
    QString file_name = QFileDialog::getOpenFileName(this, "ì¼  í",".","Files(*.*)");
    DtaoRenderSystem * renderer = this->m_window->getRenderer();

    //renderer->createNewObject(MODEL_TYPE::MODEL_TYPE_LAYOUT, file_name.toStdString());


}

void MainWindow::on_actionOpen_DB_triggered(){
    std::cout << "callv" << std::endl;
    QString file_name = QFileDialog::getOpenFileName(this, "OpenDB", ".", "Text (*.txt) ;; Files (*.*)");
    if(file_name != ""){
        std::cout << file_name.toStdString() << std::endl;
        this->t2d.text2data(file_name.toStdString());

//        printf("%-9f %-9f %-9f %-9f %-9f %-9f", t2d.LayoutMinMax.minx, t2d.LayoutMinMax.miny, t2d.LayoutMinMax.maxx, t2d.LayoutMinMax.maxy, t2d.LayoutMinMax.minz, t2d.LayoutMinMax.maxz);
//        for(int i = 0 ; i < t2d.LayoutData10by10.size() ; i++){
//            printf("\n%-9s %-9d %-9d %-9d %-9d %-9d %-9d %-9f %-9f ",
//                   t2d.LayoutData10by10[i].layername.c_str(),
//                   t2d.LayoutData10by10[i].layernum,
//                   t2d.LayoutData10by10[i].datatype,
//                   t2d.LayoutData10by10[i].color.r,
//                   t2d.LayoutData10by10[i].color.g,
//                   t2d.LayoutData10by10[i].color.b,
//                   t2d.LayoutData10by10[i].color.a,
//                   t2d.LayoutData10by10[i].bot,
//                   t2d.LayoutData10by10[i].top);
//            for(int j = 0 ; j < (t2d.LayoutData10by10[i].xy).size() ; j++){
//                for(int x = 0 ; x < (t2d.LayoutData10by10[i].xy[j]).size() ; x++){
//                    printf("\n%d %d %d", j, x, (t2d.LayoutData10by10[i].xy[j][x]).size());
//                    for(int y = 0 ; y < (t2d.LayoutData10by10[i].xy[j][x]).size() ; y++){
//                        printf("\n%-9f %-9f %-9f %-9f",
//                               t2d.LayoutData10by10[i].xy[j][x][y].minx,
//                               t2d.LayoutData10by10[i].xy[j][x][y].miny,
//                               t2d.LayoutData10by10[i].xy[j][x][y].maxx,
//                               t2d.LayoutData10by10[i].xy[j][x][y].maxy);
//                    }
//                }
//            }
//        }
        //to map data



        pos.x = t2d.LayoutMinMax.minx;
        pos.y = t2d.LayoutMinMax.miny;
        pos.z = 0;
        pos.tilt = 90;
        pos.rotation = 0;
        pos.zoom = 1;
        formInfo->outputText();

        //to top data


        DtaoRenderSystem * renderer = this->m_window->getRenderer();

        renderer->createT2DObject(MODEL_TYPE::MODEL_TYPE_LAYOUT, t2d);

        formInfo->receiveFile(t2d);
        formTop->receiveFile(t2d);
        formMap->receiveFile(t2d);
        formLayer->ReceiveLayerInformation(t2d);        
        //test



    }
    fflush(stdout);
    cout << "test end" << endl;

}

void MainWindow::slotDirectlyInputPos() //point info ì ì§ì  ë ¥ê²½ì°
{
    formMap->changePos();
    formTop->changePos();
    //ì²­¬í­ 230324 vulkan ìì ¬ê¸°¤í
}

void MainWindow::on_actionTop_triggered()
{
    qDebug() << "go?";
    //cocococo
}

void MainWindow::on_docker_Map_triggered()
{
    if (dockMap->isHidden()){
        MainWindow::restoreGeometry(dock_widget_geometry);
        MainWindow::restoreState(dock_widget_state);
        dockLayer->show();

    } else {
        dock_widget_geometry = MainWindow::saveGeometry();
        dock_widget_state = MainWindow::saveState();
        dockMap->hide();
    }
}

void MainWindow::on_docker_TopView_triggered()
{
    if (dockTop->isHidden()){
        MainWindow::restoreGeometry(dock_widget_geometry);
        MainWindow::restoreState(dock_widget_state);
        dockTop->show();

    } else {
        dock_widget_geometry = MainWindow::saveGeometry();
        dock_widget_state = MainWindow::saveState();
        dockTop->hide();
    }
}

void MainWindow::on_docker_Info_triggered()
{
    if (dockInfo->isHidden()){
        MainWindow::restoreGeometry(dock_widget_geometry);
        MainWindow::restoreState(dock_widget_state);
        dockInfo->show();

    } else {
        dock_widget_geometry = MainWindow::saveGeometry();
        dock_widget_state = MainWindow::saveState();
        dockInfo->hide();
    }
}

void MainWindow::on_docker_Hier_triggered()
{
    if (dockHier->isHidden()){
        MainWindow::restoreGeometry(dock_widget_geometry);
        MainWindow::restoreState(dock_widget_state);
        dockHier->show();

    } else {
        dock_widget_geometry = MainWindow::saveGeometry();
        dock_widget_state = MainWindow::saveState();
        dockHier->hide();
    }
}

void MainWindow::on_docker_Layer_triggered()
{
    if (dockLayer->isHidden()){
        MainWindow::restoreGeometry(dock_widget_geometry);
        MainWindow::restoreState(dock_widget_state);
        dockLayer->show();

    } else {
        dock_widget_geometry = MainWindow::saveGeometry();
        dock_widget_state = MainWindow::saveState();
        dockLayer->hide();
    }
}
!@hash[]!@file[]./Rendering/Src/LayoutModel.h!@hash[]!@code[]#pragma once

#include "lve_model.hpp"
#include "T2D.h"

class LayoutModel : public LveModel
{
public:
    LayoutModel(LveDevice& device, MODEL_TYPE model_type, T2D &t2d);
    ~LayoutModel();

    LayoutModel() = delete;
    LayoutModel(const LayoutModel&) = delete;
    LayoutModel& operator=(const LayoutModel&) = delete;

private:
    LayoutDataManager layout_data;

public:
    virtual void makeRenderingData(T2D &t2d);
    virtual void loadData(T2D &t2d);
    virtual void makeVertices();
    virtual void makeIndices();

    void makeCubeVertices();
    void makeIndicesForFace();
    void makeIndicesForEdge();

    void makeCubeVertices_map();
    void makeIndicesForFace_map();
    void makeIndicesForEdge_map();


    LayoutDataManager* getLayoutDataManager() {return &this->layout_data;}

};



!@hash[]!@file[]./Rendering/Src/LayoutPEXData.h!@hash[]!@code[]#pragma once
#include <iostream>
#include <string>
#include <vector>
#include "T2D.h"


void testPEXData();
void testLayoutData();

enum LAYOUTINFO_INDEX {
    //LAYOUTINFO_IDX_STRUCTURE = 0,
    //LAYOUTINFO_IDX_CELLNAME = 1,
    LAYOUTINFO_IDX_LAYER = 0,
    LAYOUTINFO_IDX_DATATYPE = 1,
    LAYOUTINFO_IDX_LEFT = 2,
    LAYOUTINFO_IDX_BOTTOM = 3,
    LAYOUTINFO_IDX_RIGHT = 4,
    LAYOUTINFO_IDX_TOP = 5,
    LAYOUTINFO_IDX_ZSTART = 6,
    LAYOUTINFO_IDX_ZEND = 7,
    LAYOUTINFO_IDX_DEFAULT = -1,

};

enum LAYOUT_LAYER_TYPE {
    LAYOUT_LAYER_TYPE_1 = 0,
    LAYOUT_LAYER_TYPE_DEFAULT = 99
};

enum PEXINFO_INDEX {
    PEXINFO_INDEX_NAME = 0,

    PEXINFO_INDEX_NODE1_NAME = 1,
    PEXINFO_INDEX_NODE1_X = 2,
    PEXINFO_INDEX_NODE1_Y = 3,
    PEXINFO_INDEX_NODE1_ZSTART = 4,
    PEXINFO_INDEX_NODE1_ZEND = 5,
    PEXINFO_INDEX_NODE1_LVL = 6,
    PEXINFO_INDEX_NODE1_LAYER_NUMBER = 7,
    PEXINFO_INDEX_NODE1_LAYER_DATATYPE = 8,
    PEXINFO_INDEX_NODE2_NAME = 9,
    PEXINFO_INDEX_NODE2_X = 10,
    PEXINFO_INDEX_NODE2_Y = 11,
    PEXINFO_INDEX_NODE2_ZSTART = 12,
    PEXINFO_INDEX_NODE2_ZEND = 13,
    PEXINFO_INDEX_NODE2_LVL = 14,
    PEXINFO_INDEX_NODE2_LAYER_NUMBER = 15,
    PEXINFO_INDEX_NODE2_LAYER_DATATYPE = 16,

    PEXINFO_INDEX_VALUE = 17,
    PEXINFO_INDEX_DESCRIPTION = 18,
    PEXINFO_INDEX_DEFULT = 999
};

enum PEXResDirection {
    RES_DIRECTION_VERTICAL = 0,
    RES_DIRECTION_HORIZONTAL = 1,
    RES_DIRECTION_NONE = 99
};

struct cube_info {
    double minx;
    double miny;
    double maxx;
    double maxy;
    double minz;
    double maxz;
};

struct coord3d {
    double x;
    double y;
    double z;
};

struct cube_vertex {
    float layernum;
    coord3d vertex[8];
};

struct node {
    double x;
    double y;
    double z_start;
    double z_end;
    unsigned int layer_number;
    unsigned int layer_datatype;
    std::string name;
};
typedef struct node pex_node;

class LayoutItem {
public:
    LayoutItem();
    ~LayoutItem();
    LayoutItem(const cube_info& pattern_, const int layer_number_, const int layer_datatype_, LAYOUT_LAYER_TYPE layer_type_);

public:
    cube_info pattern;
    unsigned int layer_number;
    unsigned int layer_datatype;
    LAYOUT_LAYER_TYPE layer_type;
};


class LayoutDataManager
{
public:
    LayoutDataManager();
    ~LayoutDataManager();

private:
    std::string file_path;
    std::vector<LayoutItem> patterns;
    T2D *t2d_ptr;


    double scale;

    double layout_min_x;
    double layout_max_x;
    double layout_min_y;
    double layout_max_y;
    double layout_min_z;
    double layout_max_z;
    double x_diff;
    double y_diff;
    double z_diff;



public:
    std::vector<LayoutItem> &getPatterns() { return this->patterns; }
    std::vector<LDATA10BY10> &getPatterns_t2d() { return this->t2d_ptr->LayoutData10by10; }

    void loadLayoutData(T2D &t2d);
    void clear() { this->patterns.clear(); };
    void printLayoutData() {};
    static bool compareByLength( const LDATA10BY10 &a, const LDATA10BY10 &b);

    double getMinX() { return this->layout_min_x; }
    double getMaxX() { return this->layout_max_x; }
    double getMinY() { return this->layout_min_y; }
    double getMaxY() { return this->layout_max_y; }
    double getMinZ() { return this->layout_min_z; }
    double getMaxZ() { return this->layout_max_z; }
    double getDiffX() { return this->x_diff; }
    double getDiffY() { return this->y_diff; }
    double getDiffZ() { return this->z_diff; }
    double getScale() { return this->scale; }

private:
    void calculateScale();

};

class PEXItem
{
public:
    PEXItem();
    ~PEXItem();
    PEXItem(const node& node1_, const node& node2_, const double& value_, const std::string& name_);

public:
    node node1;
    node node2;
    double value;
    std::string name;

public:
    void setNode1(node& node_) { this->node1 = node_; }
    void setNode2(node& node_) { this->node2 = node_; }
    void setValue(double value_) { this->value = value_; }

    node& getNode1() { return this->node1; }
    node& getNode2() { return this->node2; }
    double getValue() { return this->value; }

    virtual void print();
};



class PEXResistor : public PEXItem
{
public:
    PEXResistor();
    ~PEXResistor();
    PEXResistor(const std::string& name_, const node& node1_, const node& node2_, const double& value_, const PEXResDirection& direction_);

private:
    PEXResDirection direction;

public:
    void setDirection(PEXResDirection direction_) { this->direction = direction_; }
    PEXResDirection getDirection() const { return this->direction; }

    static PEXResDirection checkDirectionFromDescription(const std::string& description);

    void print();
};

class PEXCapacitor : public PEXItem
{
public:
    PEXCapacitor();
    ~PEXCapacitor();
    PEXCapacitor(const std::string& name_, const node& node1_, const node& node2_, const double& value_);

public:
    void print();
};


class PEXResistorDataManager
{
public:
    PEXResistorDataManager();
    ~PEXResistorDataManager();

private:
    std::string file_path;

    std::vector<PEXResistor> resistors;

    double max_resistor_vertical;
    double min_resistor_vertical;
    double max_resistor_horizontal;
    double min_resistor_horizontal;

public:
    std::vector<PEXResistor>& getResistors() { return this->resistors; }

    void loadData(const std::string file_path);
    void clear();
    void printData();

    double getMinResistorVerticalValue() { return this->min_resistor_vertical; }
    double getMaxResistorVerticalValue() { return this->max_resistor_vertical; }
    double getMinResistorHorizontalValue() { return this->min_resistor_horizontal; }
    double getMaxResistorHorizontalValue() { return this->max_resistor_horizontal; }

private:
    void updateMinMaxRes(const double& value, const PEXResDirection direction);
};

class PEXCapacitorDataManager
{
public:
    PEXCapacitorDataManager();
    ~PEXCapacitorDataManager();

private:
    std::string file_path;

    std::vector<PEXCapacitor> capasitors;

    double max_capacitor;
    double min_capacitor;

public:
    std::vector<PEXCapacitor>& getCapacitors() { return this->capasitors; }

    void loadData(const std::string file_path);
    void clear();
    void printData();

    double getMinCapacitorValue() { return this->min_capacitor; }
    double getMaxCapacitorValue() { return this->max_capacitor; }

private:
    void updateMinMaxCap(const double& value);
};

!@hash[]!@file[]./Rendering/Src/PEXCapacitorModel.h!@hash[]!@code[]#pragma once
#include "lve_model.hpp"
#include "LayoutPEXData.h"

#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <limits>
#include <thread>
#include <queue>
#include <mutex>
#include <cstdio>


typedef unsigned int uint;

class PEXCapacitorModel : public LveModel
{
public:
    struct cap_node {
        double x;
        double y;
        uint layer_number;
        uint layer_datatype;
        std::string name;
        double value;
        uint connected_count;
    };

    struct pattern_cap {
        cube_info pattern;
        uint layer_number;
        uint layer_datatype;
        double cap_value;
        double normalized_cap_value;
        uint cap_count;
        pattern_cap(cube_info& pattern_, uint number_, uint datatype_, double value_, double norm_value_, uint count_) :
            pattern(pattern_), layer_number(number_),
            layer_datatype(datatype_),
            cap_value(value_), normalized_cap_value(norm_value_),
            cap_count(count_) {}

    };

public:
    PEXCapacitorModel(
            LveDevice& device, MODEL_TYPE model_type,
            const std::string& data_file = "", LayoutDataManager* layout_data_ = nullptr);
    ~PEXCapacitorModel();

    PEXCapacitorModel() = delete;
    PEXCapacitorModel(const PEXCapacitorModel&) = delete;
    PEXCapacitorModel& operator=(const PEXCapacitorModel&) = delete;

private:
    PEXCapacitorDataManager pex_data;
    std::map<std::string, size_t> cap_node_name_to_index_map;
    LayoutDataManager* layout_data = nullptr;

    std::vector<cap_node> cap_nodes;
    std::map<std::string, std::vector<cap_node*>> layer_to_cap_node_map;

    std::vector<pattern_cap> pattern_caps;
    std::map<std::string, std::vector<pattern_cap*>> layer_to_pattern_cap_map;

    std::set<std::pair<uint, uint>> layers;

    double max_cap = std::numeric_limits<double>::min();

    size_t num_threads = { 4 };
    std::vector<std::thread> threads;
    std::queue<std::string> layers_queue;
    std::mutex mutex_layers_queue;

public:
    virtual void makeRenderingData(const std::string& file_path = "");
    virtual void loadData(const std::string& file_path = "");
    virtual void makeVertices();
    virtual void makeIndices();

    void makeCubeVertices();

private:
    void makeCapNodesFromPEXData();
    void makePatternCapsFromLayoutData();

    void attachCapToPattern();
    void makeLayerToCapNodeMap();
    void makeLayerToPatternCapMap();

    void matchCapWithPatternThread(std::queue<std::string>* layers, std::mutex* mutex_);
    void matchCapWithPattern(std::vector<cap_node*>& caps, std::vector<pattern_cap*>& patterns);
    void matchCapWithPattern(
            std::map<std::string, std::vector<cap_node*>>& cap_layer_map_,
            std::map<std::string, std::vector<pattern_cap*>>& pattern_layer_map_,
            uint target_layer_number, uint target_layer_datatype);
    bool isPatternIncludeCap(const pattern_cap& pattern, const cap_node& cap);

    void setLayoutDataManager(LayoutDataManager* layout_data_) { this->layout_data = layout_data_; }
    void addNewCapNode(pex_node& new_node, double value);

    std::string getLayerString(uint layer_number, uint layer_datatype);

    void normalizePatternCap();

    void makeLayersQueueForThreadJob();




    void printCapNodes();
    void printPatternCaps(FILE* stream = stdout);
    void printLayerToCapNodeMap(FILE* stream = stdout);
    void printLayerToPatternCapMap(const char* msg = "");
    void printLayerList();
};


!@hash[]!@file[]./Rendering/Src/PEXResistorModel.h!@hash[]!@code[]#pragma once

#include "lve_model.hpp"



class PEXResistorModel : public LveModel
{
public:

    PEXResistorModel(LveDevice& device, MODEL_TYPE model_type, const std::string& data_file = "");
    ~PEXResistorModel();

    PEXResistorModel() = delete;
    PEXResistorModel(const PEXResistorModel&) = delete;
    PEXResistorModel& operator=(const PEXResistorModel&) = delete;

private:
    PEXResistorDataManager pex_data;
    double res_cube_thickness;


public:
    virtual void makeRenderingData(const std::string& file_path = "");
    virtual void loadData(const std::string& file_path = "");
    virtual void makeVertices();
    virtual void makeIndices();

    void makeCubeVertices();
    void makeCubes();
    void makeCube(const PEXResistor& in_res, cube_info& out_cube, PEXResDirection direction);
    void setResCubeThickness(double value) { this->res_cube_thickness = value; }

private:

};



!@hash[]!@file[]./Rendering/Src/dtaorendersystem.h!@hash[]!@code[]#ifndef DTAORENDERSYSTEM_H
#define DTAORENDERSYSTEM_H

#include <QVulkanWindow>
#include <QVulkanWindowRenderer>
#include <QVulkanDeviceFunctions>
#include <vulkan/vulkan.h>

#include "lve_window.hpp"
#include "lve_device.hpp"
#include "lve_game_object.hpp"
#include "simple_render_system.hpp"
#include "lve_camera.hpp"
#include "keyboard_movement_controller.hpp"
#include "T2D.h"

#include <iostream>
#include <vector>


class LayoutModel;

class DtaoRenderSystem : public QVulkanWindowRenderer
{
public:
    DtaoRenderSystem(LveWindow *w);
    ~DtaoRenderSystem();

    DtaoRenderSystem(const DtaoRenderSystem &) = delete;
    DtaoRenderSystem &operator=(const DtaoRenderSystem &) = delete;


    void initResources() override;
    void initSwapChainResources() override;
    void releaseSwapChainResources() override;
    void releaseResources() override;

    void startNextFrame() override;

    float getRenderScale() {return this->trans_info.scale;}
    LayoutModel* getLayoutModel();
    bool isRenderModelLoaded(){return this->render_object_created;}

public:
    LveCamera camera{};
    KeyboardMovementController cameraController{};


private:
    QVulkanDeviceFunctions *m_devFuncs = nullptr;

    void loadGameObjects();

    LveWindow* lveWindow = nullptr;
    LveDevice* lveDevice = nullptr;
    SimpleRenderSystem* simpleRenderSystem = nullptr;

    std::vector<LveGameObject> gameObjects{};
    bool render_object_created = {false};


    struct TRANS_INFORMATION{
       float trans_x;
       float trans_y;
       float trans_z;
       float scale;
    };
    TRANS_INFORMATION trans_info;
    std::shared_ptr<LayoutModel> layout_model = {nullptr};


public:
    void createNewObject(MODEL_TYPE model_type, const std::string & file_path);
    void createT2DObject(MODEL_TYPE model_type, T2D t2d);
    void getCustomColor(float layernumber, glm::vec3 rgb);
    void getCustomOpacity(float layernumber, float opacity);
    void getCustomVisiblity(float layernumber, bool visibility);

private:
    void createNewLayoutObject(const std::string & file_path);
    void createT2DLayoutObject(T2D & t2d);
    void createNewPEXCapObject(const std::string & file_path);
    void createNewPEXResObject(const std::string & file_path);
    void createNewAxisObject(const std::string & file_path);


private:
    void createLveDevice();
    void deleteLveDevice();
    void createSimpleRenderSystem();
    void deleteSimpleRenderSystem();
    void beginRenderPass(VkCommandBuffer command_buffer);
    float aspect;

};

#endif // DTAORENDERSYSTEM_H
!@hash[]!@file[]./Rendering/Src/keyboard_movement_controller.hpp!@hash[]!@code[]#pragma once

#include <QKeyEvent>
#include <QMouseEvent>
#include "lve_game_object.hpp"
#include "lve_window.hpp"
#include "lve_camera.hpp"
//#include "defineParam.h"



class KeyboardMovementController {
public:
    struct CameraMoveKeyMappings {
        int rotateLeft = Qt::Key_A;
        int rotateRight = Qt::Key_D;
        int moveForward = Qt::Key_W;
        int moveBackward = Qt::Key_S;
        int rotateForward = Qt::Key_E;
        int rotateBackward = Qt::Key_Q;
        int moveUp = Qt::Key_Up;
        int moveDown= Qt::Key_Down;
        int moveLeft= Qt::Key_Left;
        int moveRight= Qt::Key_Right;
        int toggleDemension= Qt::Key_T;
        Qt::MouseButtons mouseLeft = Qt::LeftButton;
        Qt::MouseButtons mouseRight = Qt::RightButton;
        Qt::MouseButtons mouseMiddle = Qt::MiddleButton;
    };

    struct CameraMovingContinousFlags {
        bool rotateLeft = false;
        bool rotateRight = false;
        bool moveForward = false;
        bool moveBackward = false;
        bool rotateForward = false;
        bool rotateBackward = false;
        bool moveUp = false;
        bool moveDown= false;
        bool moveLeft= false;
        bool moveRight= false;
        bool toggleDemension = false;
        bool toggleDemensionXY = false;
        bool mouseLeft= false;
        bool mouseRight= false;
        bool mouseMiddle= false;
    };

    struct MousePosition {
        QPoint pressPosition;
        QPoint releasePosition;
        QPoint currentPosition;
        QPoint scroll;
        QPoint scrollClicked;
    };

    void moveCamera(Qt::Key key, float dt, LveCamera& camera, float render_scale);
    CameraMoveKeyMappings camera_move_key;
    MousePosition mouse_position;

    void moveCamera(float dt, LveCamera& camera, float render_scale,std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow);
    void moveCameraMouse(LveCamera& camera, float render_scale,std::vector<LveGameObject>& gameObjects,LveWindow* lvewindow);
    void setPerspective(LveCamera& camera, float aspect);
    void moveKeyPressed(Qt::Key key);
    void moveKeyReleased(Qt::Key key);
    void moveButtonPressed(Qt::MouseButtons buttons);
    void moveButtonReleased(Qt::MouseButtons buttons);
    void setAllMoveFlagOff();
    void setMouseFlagOff();
    void setMousePosition(QPoint position, int mode);
    void setMouseScroll(QPoint position);
    CameraMovingContinousFlags camera_moving_flag;
    POS_MONITORING monitor;


    float moveSpeed{ 0.05f };
    float lookSpeed{ 1.5f };
    int xpos_prev;
    int ypos_prev;
    float perspectiveNear{ 0.1f };


};

!@hash[]!@file[]./Rendering/Src/lve_camera.hpp!@hash[]!@code[]#pragma once

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>
#include <glm/gtx/matrix_decompose.hpp>



class LveCamera {
public:
    void setOrthographicProjection(
            float left, float right, float top, float bottom, float near, float far);
    void setPerspectiveProjection(float fovy, float aspect, float near, float far);

    void setViewDirection(
            glm::vec3 position, glm::vec3 direction, glm::vec3 up = glm::vec3{0.f, -1.f, 0.f});
    void setViewTarget(
            glm::vec3 position, glm::vec3 target, glm::vec3 up = glm::vec3{0.f, -1.f, 0.f});
    void setViewYXZ(glm::vec3 position, glm::vec3 rotation);

    const glm::mat4& getProjection() const { return projectionMatrix; }
    const glm::mat4& getView() const { return viewMatrix; }
    void decomposeView(glm::mat4 viewMat);

public:
    glm::mat4 projectionMatrix{1.f};
    glm::mat4 viewMatrix{1.f};

    glm::vec3 scale_d;
    glm::quat rotation_d;
    glm::vec3 translation_d;
    glm::vec3 skew_d;
    glm::vec4 perspective_d;
    bool isperspective = true;

};

!@hash[]!@file[]./Rendering/Src/lve_device.hpp!@hash[]!@code[]#pragma once

#include <QVulkanInstance>
#include <vulkan/vulkan.h>

// std lib headers
#include <string>
#include <vector>

#include "lve_window.hpp"


struct SwapChainSupportDetails {
    VkSurfaceCapabilitiesKHR capabilities;
    std::vector<VkSurfaceFormatKHR> formats;
    std::vector<VkPresentModeKHR> presentModes;
};

struct QueueFamilyIndices {
    uint32_t graphicsFamily;
    uint32_t presentFamily;
    bool graphicsFamilyHasValue = false;
    bool presentFamilyHasValue = false;
    bool isComplete() { return graphicsFamilyHasValue && presentFamilyHasValue; }
};

class LveDevice {
public:
#ifdef NDEBUG
    const bool enableValidationLayers = false;
#else
    const bool enableValidationLayers = true;
#endif

    LveDevice(LveWindow* window, QVulkanInstance* qvk_inst);
    ~LveDevice();

    // Not copyable or movable
    LveDevice(const LveDevice &) = delete;
    LveDevice &operator=(const LveDevice &) = delete;
    LveDevice(LveDevice &&) = delete;
    LveDevice &operator=(LveDevice &&) = delete;

    VkCommandPool getVkCommandPool() { return commandPool; }
    VkDevice device() { return device_; }
    VkSurfaceKHR surface() { return surface_; }
    VkQueue graphicsQueue() { return graphicsQueue_; }
    VkQueue presentQueue() { return presentQueue_; }
    VkInstance getInstance() { return this->instance;}

    SwapChainSupportDetails getSwapChainSupport() { return querySwapChainSupport(physicalDevice); }
    uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties);
    QueueFamilyIndices findPhysicalQueueFamilies() { return findQueueFamilies(physicalDevice); }
    VkFormat findSupportedFormat(
            const std::vector<VkFormat> &candidates, VkImageTiling tiling, VkFormatFeatureFlags features);

    // Buffer Helper Functions
    void createBuffer(
            VkDeviceSize size,
            VkBufferUsageFlags usage,
            VkMemoryPropertyFlags properties,
            VkBuffer &buffer,
            VkDeviceMemory &bufferMemory);
    VkCommandBuffer beginSingleTimeCommands();
    void endSingleTimeCommands(VkCommandBuffer commandBuffer);
    void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size);
    void copyBufferToImage(
            VkBuffer buffer, VkImage image, uint32_t width, uint32_t height, uint32_t layerCount);

    void createImageWithInfo(
            const VkImageCreateInfo &imageInfo,
            VkMemoryPropertyFlags properties,
            VkImage &image,
            VkDeviceMemory &imageMemory);

    VkPhysicalDeviceProperties properties;

private:
    void createInstance();
    void setupDebugMessenger();
    void createSurface();
    void pickPhysicalDevice();
    void createLogicalDevice();
    void createCommandPool();

    // helper functions
    bool isDeviceSuitable(VkPhysicalDevice device);
    std::vector<const char *> getRequiredExtensions();
    bool checkValidationLayerSupport();
    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device);
    void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT &createInfo);
    void hasRequiredInstanceExtensions();
    bool checkDeviceExtensionSupport(VkPhysicalDevice device);
    SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device);

    VkInstance instance;
    VkDebugUtilsMessengerEXT debugMessenger;
    VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
    LveWindow * window;
    QVulkanInstance * qvk_instance;
    VkCommandPool commandPool;

    VkDevice device_;
    VkSurfaceKHR surface_;
    VkQueue graphicsQueue_;
    VkQueue presentQueue_;

    const std::vector<const char *> validationLayers = {"VK_LAYER_KHRONOS_validation"};
    const std::vector<const char *> deviceExtensions = {VK_KHR_SWAPCHAIN_EXTENSION_NAME};
};

!@hash[]!@file[]./Rendering/Src/lve_game_object.hpp!@hash[]!@code[]#pragma once

#include "lve_model.hpp"

// libs
#include <glm/gtc/matrix_transform.hpp>
#include <glm/glm.hpp> //vec3, vec4, ivec4, mat4
#include <glm/gtc/type_ptr.hpp> //value_ptr

// std
#include <memory>


struct TransformComponent {
    glm::vec3 translation{};
    glm::vec3 scale{ 1.f, 1.f, 1.f };
    glm::vec3 rotation{};

    // Matrix corrsponds to Translate * Ry * Rx * Rz * Scale
    // Rotations correspond to Tait-bryan angles of Y(1), X(2), Z(3)
    // https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
    glm::mat4 mat4() {
        glm::mat4 glm_mat4 = glm::mat4{ 1 };
        //glm_mat4 = glm::rotate(glm_mat4,  rotation.x, glm::vec3(1.0f, 0.0f, 0.0f));
        //glm_mat4 = glm::rotate(glm_mat4, rotation.y, glm::vec3(0.0f, 1.0f, 0.0f));
        //glm_mat4 = glm::rotate(glm_mat4, rotation.z, glm::vec3(1.0f, 0.0f, 1.0f));
        glm_mat4 = glm::scale(glm_mat4, scale);
        glm_mat4 = glm::translate(glm_mat4, translation);


        return glm_mat4;
    }
};

class LveGameObject {
public:
    using id_t = unsigned int;

    static LveGameObject createGameObject() {
        static id_t currentId = 0;
        std::cout << "\n\n***LveGameObject :: id : " << currentId << "\n\n";
        return LveGameObject{ currentId++ };
    }

    LveGameObject(const LveGameObject&) = delete;
    LveGameObject& operator=(const LveGameObject&) = delete;
    LveGameObject(LveGameObject&&) = default;
    LveGameObject& operator=(LveGameObject&&) = default;

    id_t getId() { return id; }

    void setEdgeLineEnable(bool flag) { this->edge_line_enabled = flag; }
    void setAxisLineEnable(bool flag) { this->axis_line_enabled = flag; }

public:
    std::shared_ptr<LveModel> model{};
    //LveModel* model{};
    glm::vec3 color{};
    TransformComponent transform{};

private:
    LveGameObject(id_t objId) : id{ objId } {}

    id_t id;

private:
    bool edge_line_enabled = { true };
    bool axis_line_enabled = { true };
};

class DTAOObject {
public:
    using id_t = unsigned int;

    static DTAOObject createObject() {
        static id_t currentId = 0;
        std::cout << "\n\n***DTAOObject :: id : " << currentId << "\n\n";
        return DTAOObject{ currentId++ };
    }

    DTAOObject(const DTAOObject&) = delete;
    DTAOObject& operator=(const DTAOObject&) = delete;
    DTAOObject(DTAOObject&&) = default;
    DTAOObject& operator=(DTAOObject&&) = default;

    id_t getId() { return id; }

    void setEdgeLineEnable(bool flag) { this->edge_line_enabled = flag; }
    void setAxisLineEnable(bool flag) { this->axis_line_enabled = flag; }

public:
    std::shared_ptr<LveModel> model{};
    //LveModel* model{};
    glm::vec3 color{};
    TransformComponent transform{};

private:
    DTAOObject(id_t objId) : id{ objId } {}

    id_t id;

private:
    bool edge_line_enabled = { true };
    bool axis_line_enabled = { true };
};
!@hash[]!@file[]./Rendering/Src/lve_model.hpp!@hash[]!@code[]#pragma once

#include "lve_device.hpp"

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>

// std
#include <vector>

#include <string>
#include <iostream>

#include <map>
//#include <ranges>
#include "LayoutPEXData.h"

typedef enum MODEL_TYPE {
    MODEL_TYPE_LAYOUT = 0,
    MODEL_TYPE_AXIS,
    MODEL_TYPE_PEX_RESISTOR,
    MODEL_TYPE_PEX_CAPACITOR,
    MODEL_TYPE_DEFAULT
} MODEL_TYPE;




class LveModel {
public:
    struct Vertex {
        glm::vec3 position{};
        glm::vec3 color{};
        glm::vec3 normal{};

        static std::vector<VkVertexInputBindingDescription> getBindingDescriptions();
        static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions();
    };

    struct LayerProperty {
        bool visiblity;
        glm::vec3 color{};
        float opacity;
    };

    LveModel(LveDevice& device, MODEL_TYPE model_type);
    ~LveModel();

    LveModel() = delete;
    LveModel(const LveModel&) = delete;
    LveModel& operator=(const LveModel&) = delete;

    //void bind(VkCommandBuffer commandBuffer);
    void bindVertexBuffer(VkCommandBuffer commandBuffer);
    void bindVertexBuffer_map(VkCommandBuffer commandBuffer);
    void bindIndexBufferForFace(VkCommandBuffer commandBuffer);
    void bindIndexBufferForFace_map(VkCommandBuffer commandBuffer);
    void bindDrawVertexIndexBufferForFace_map(VkCommandBuffer commandBuffer);
    void bindDrawVertexIndexBufferForFace_layer(VkCommandBuffer commandBuffer, const float layer);
    void bindDrawIndexBufferForEdge_layer(VkCommandBuffer commandBuffer, const float layer);
    void bindIndexBufferForEdge(VkCommandBuffer commandBuffer);
    void drawForFace(VkCommandBuffer commandBuffer);
    void drawForEdge(VkCommandBuffer commandBuffer);


public:
    void createBuffers();
    void destroyBuffers();
    void createVertexBuffers(const std::vector<Vertex>& vertices, VkBuffer& buffer, VkDeviceMemory& memory);
    void createIndexBuffers(const std::vector<uint32_t>& indices, VkBuffer & buffer, VkDeviceMemory & memory);
    LveDevice& lveDevice;
    VkBuffer vertexBuffer{};
    VkDeviceMemory vertexBufferMemory{};
    std::map<float, VkBuffer> layerbyVertexBuffers;
    std::map<float, VkDeviceMemory> layerbyVertexBuffersMemory;
    uint32_t vertexCount{};

    VkBuffer indexBufferForFace{};
    VkDeviceMemory indexBufferMemoryForFace{};
    VkBuffer indexBufferForEdge{};
    VkDeviceMemory indexBufferMemoryForEdge{};

    std::map<float, VkBuffer> layerbyFaceIndexBuffers;
    std::map<float, VkDeviceMemory> layerbyFaceIndexBuffersMemory;
    std::map<float, VkBuffer> layerbyEdgeIndexBuffers;
    std::map<float, VkDeviceMemory> layerbyEdgeIndexBuffersMemory;

    MODEL_TYPE model_type{};

public:
    //std::string layout_info_file;
    std::vector<cube_info> cube_infos{};
    std::vector<cube_vertex> cube_vertices{};

    std::vector<Vertex> vertices{};
    std::vector<uint32_t> indices_face{};
    std::vector<uint32_t> indices_edge{};
    std::vector<float> drawing_order_layerby{};

    std::map<float, std::vector<Vertex>> layerby_vertices;
    std::map<float, std::vector<uint32_t>> layerby_face;
    std::map<float, std::vector<uint32_t>> layerby_edge;
    std::map<float, LayerProperty> layerList;
    std::map<float, glm::vec3> init_layerby_color;
    void changeLayerColor(float layernumber, glm::vec3 rgb);
    void changeLayerOpacity(float layernumber, float opacity);
    void changeLayerVisiblity(float layernumber, bool visiblity);
    bool visible{true};
    float opacity{ 1.0f };

public:
    MODEL_TYPE getModelType() { return this->model_type; }

public:
    //void setLayoutInfoFile(const std::string file_path) { this->layout_info_file = file_path; }
    virtual void makeRenderingData(const std::string& file_path = "") {(void)file_path;};
    virtual void loadData(const std::string& file_path = "") {(void)file_path;};
    virtual void makeVertices() {};
    virtual void makeIndices() {};

    void makeAxisData(const float axis_length = (2.0f));
    void setVisible(bool flag) { this->visible = flag; }
    bool getVisible() { return this->visible; }
    void toggleVisible() { this->visible = !this->visible; }
    void updateOpacity(float amount);
    float getOpacity() { return this->opacity; }
    std::map<float, LayerProperty> getLayer();
};

!@hash[]!@file[]./Rendering/Src/lve_pipeline.hpp!@hash[]!@code[]#pragma once

#include "lve_device.hpp"

// std
#include <string>
#include <vector>



struct PipelineConfigInfo {
    PipelineConfigInfo() = default;
    PipelineConfigInfo(const PipelineConfigInfo&) = delete;
    PipelineConfigInfo& operator=(const PipelineConfigInfo&) = delete;

    VkPipelineViewportStateCreateInfo viewportInfo;
    VkPipelineInputAssemblyStateCreateInfo inputAssemblyInfo;
    VkPipelineRasterizationStateCreateInfo rasterizationInfo;
    VkPipelineMultisampleStateCreateInfo multisampleInfo;
    VkPipelineColorBlendAttachmentState colorBlendAttachment;
    VkPipelineColorBlendStateCreateInfo colorBlendInfo;
    VkPipelineDepthStencilStateCreateInfo depthStencilInfo;
    std::vector<VkDynamicState> dynamicStateEnables;
    VkPipelineDynamicStateCreateInfo dynamicStateInfo;
    VkPipelineLayout pipelineLayout = nullptr;
    VkRenderPass renderPass = nullptr;
    uint32_t subpass = 0;
};

class LvePipeline {
public:
    LvePipeline(
            LveDevice& device,
            const std::string& vertFilepath,
            const std::string& fragFilepath,
            const PipelineConfigInfo& configInfo);
    ~LvePipeline();

    LvePipeline(const LvePipeline&) = delete;
    LvePipeline& operator=(const LvePipeline&) = delete;

    void bind(VkCommandBuffer commandBuffer);

    static void defaultPipelineConfigInfo(PipelineConfigInfo& configInfo);

private:
    static std::vector<char> readFile(const std::string& filepath);

    void createGraphicsPipeline(
            const std::string& vertFilepath,
            const std::string& fragFilepath,
            const PipelineConfigInfo& configInfo);

    void createShaderModule(const std::vector<char>& code, VkShaderModule* shaderModule);

    LveDevice& lveDevice;
    VkPipeline graphicsPipeline;
    VkShaderModule vertShaderModule;
    VkShaderModule fragShaderModule;
};

!@hash[]!@file[]./Rendering/Src/lve_window.hpp!@hash[]!@code[]#ifndef LVEWINDOW_H
#define LVEWINDOW_H
#include <vulkan/vulkan.h>
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/string_cast.hpp>

#include <QVulkanWindow>
#include "defineParam.h"
//#include <QVulkanWindowRenderer>

//#include "dtaorendersystem.h"

class QVulkanWidowRenderer;
class DtaoRenderSystem;

class LveWindow : public QVulkanWindow
{
    Q_OBJECT

public:
    LveWindow();
    ~LveWindow();

    LveWindow(const LveWindow &) = delete;
    LveWindow &operator=(const LveWindow &) = delete;

public:
    QVulkanWindowRenderer *createRenderer() override;
    //QVulkanWindowRenderer * getRenderer(){ return this->m_renderer;}
    //LveCamera* camera;
    void emitStatus(float value);

public:
    DtaoRenderSystem * getRenderer(){return this->m_renderer;}

private:
    DtaoRenderSystem *m_renderer;
    //QVulkanWindowRenderer * m_renderer;

    void wheelEvent(QWheelEvent *) override;
    void mousePressEvent(QMouseEvent *) override;
    void mouseReleaseEvent(QMouseEvent *) override;
    void mouseMoveEvent(QMouseEvent *) override;
    void keyPressEvent(QKeyEvent *) override;
    void keyReleaseEvent(QKeyEvent *) override;

    bool keyCtrl = false;
    bool keyShift = false;
    bool keyAlt = false;

    int m_mouseButton = 0;


    QPoint m_lastPos;

signals:
    void signalInfoText(QString funcName, POS_MONITORING value);
};

#endif // LVEWINDOW_H
!@hash[]!@file[]./Rendering/Src/simple_render_system.hpp!@hash[]!@code[]#pragma once
#include <vulkan/vulkan.h>

#include "lve_camera.hpp"
#include "lve_device.hpp"
#include "lve_game_object.hpp"
#include "lve_pipeline.hpp"

// std
#include <memory>
#include <vector>


class SimpleRenderSystem {


public:

    SimpleRenderSystem(LveDevice& device, VkRenderPass renderPass);
    ~SimpleRenderSystem();

    SimpleRenderSystem(const SimpleRenderSystem&) = delete;
    SimpleRenderSystem& operator=(const SimpleRenderSystem&) = delete;

    void renderGameObjects(
            VkCommandBuffer commandBuffer,
            std::vector<LveGameObject>& gameObjects,
            const LveCamera& camera);

private:
    void createPipelineLayout(VkPipelineLayout & pipeline_layout);
    void createPipelineForFace(VkRenderPass renderPass);
    void createPipelineForEdge(VkRenderPass renderPass);
    void createPipelineForPEXResistor(VkRenderPass renderPass);
    void createPipelineForPEXCapacitor(VkRenderPass renderPass);

    LveDevice& lveDevice;

    std::unique_ptr<LvePipeline> lvePipelineForLayoutFace;
    VkPipelineLayout pipelineLayoutForLayoutFace;

    std::unique_ptr<LvePipeline> lvePipelineForLayoutEdge;
    VkPipelineLayout pipelineLayoutForLayoutEdge;

    std::unique_ptr<LvePipeline> lvePipelineForPEXResistor;
    VkPipelineLayout pipelineLayoutForPEXResistor;

    std::unique_ptr<LvePipeline> lvePipelineForPEXCapacitor;
    VkPipelineLayout pipelineLayoutForPEXCapacitor;
};

!@hash[]!@file[]./T2D.h!@hash[]!@code[]#ifndef T2D_H
#define T2D_H

#include "defineParam.h"

#include <iostream>
#include <vector>
#include <sstream>
#include <fstream>

using namespace std;

class T2D{
    public:
        bool text2data(std::string file_name);

        std::vector<LDATA10BY10> LayoutData10by10;
        MIN_MAX_XYZ LayoutMinMax;

        LDATA10BY10 buf_ldata10by10;
        vector<vector<vector<B_BOX>>> buf_xy10by10;
        vector<B_BOX> buf_xy;
        static std::vector<std::string> string_split(std::string input, char delimiter);
};

#endif // T2D_H
!@hash[]!@file[]./all_data.h!@hash[]!@code[]#ifndef ALL_DATA_H
#define ALL_DATA_H

#include <QObject>
#include <QDebug>
#include <QVector>


class all_data : public QObject
{
    Q_OBJECT
//    Q_DECLARE_METATYPE(QVector <QVector <QString>>);

public:
    all_data(QObject *parent = nullptr);
    ~all_data();

public:
    QVector <QVector <QString>> inputDataVector;

public slots:
    void receiveSelectFileName(QString file_name);

signals:
    void sendSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector);


};

#endif // ALL_DATA_H
!@hash[]!@file[]./defineParam.h!@hash[]!@code[]#ifndef DEFINETYPE_H
#define DEFINETYPE_H

#include <iostream>
#include <vector>

using namespace std;

struct POS_MONITORING{
    double x;
    double y;
    double z;
    double tilt;
    double rotation;
    double zoom;
    double window_zoom;
};

struct B_BOX{
    double minx;
    double miny;
    double maxx;
    double maxy;
};

struct COLOR_RGBA{
    int r;
    int g;
    int b;
    int a;
};

struct LDATA10BY10{
    bool checking;
    std::string layername;
    int layernum;
    int datatype;
    COLOR_RGBA color;
    double bot;
    double top;
    std::vector<std::vector<std::vector<B_BOX>>> xy;
    std::vector<std::vector<std::vector<B_BOX>>> xy_filtered;
};

struct MIN_MAX_XYZ{
    double minx;
    double maxx;
    double miny;
    double maxy;
    double minz;
    double maxz;
};


#endif // DEFINETYPE_H


!@hash[]!@file[]./filedb.h!@hash[]!@code[]#ifndef FILEDB_H
#define FILEDB_H

#include <QVector>


class FileDb
{
public:
    FileDb();
    void openFile(QString fileNameInfo,QVector<QList<float>> &vecList,
                  float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize);
};

#endif // FILEDB_H
!@hash[]!@file[]./formhier.h!@hash[]!@code[]#ifndef FORMHIER_H
#define FORMHIER_H

#include <QDialog>
//#include "all_data.h"
//#include "mainwindow.h"

namespace Ui {
class FormHier;
}

class FormHier : public QDialog
{
    Q_OBJECT

public slots:
    void ReceiveSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector);
//    void ReceiveSplitData(QStringList list, int row, int column);

public:
    FormHier(QWidget *parent = nullptr);
    ~FormHier();
    Ui::FormHier *ui;

public:
    //MyDataSet *dataset = nullptr;

public:
    //void setMyDataSet(MyDataSet * dataset_){ this->dataset = dataset_;}
    //void testMyData();

};

#endif // FORMHIER_H

/////
!@hash[]!@file[]./forminfo.h!@hash[]!@code[]#ifndef FORMINFO_H
#define FORMINFO_H

#include <QDialog>
#include <QLineEdit>
#include <glm/gtx/string_cast.hpp>
#include "T2D.h"
#include "defineParam.h"

namespace Ui {
class FormInfo;
}

class FormInfo : public QDialog
{
    Q_OBJECT

public:
    explicit FormInfo(QWidget *parent = nullptr);
    ~FormInfo();
    void receiveFile(T2D &t2d);
    void outputText();
    void receivePointPos(POS_MONITORING &pos);
    void changePos();

public slots:
    void moveRender(float x, float y);

private:
    bool checkNum(const QString &str);
    void checkText(double *point, const QString &str, double min_limit, double max_limit, int type);

    T2D *rendering_full;
    Ui::FormInfo *ui;
    POS_MONITORING *pos;
    POS_MONITORING temp_pos;
    float pointX = 0;
    float pointY = 0;
    float pointZ = 0;
    float infoTilt = 90;
    float infoRot = 0;
    float infoZoom = 1; //Zoom ì´ê¸°ê°ì GDS size ë¥ê°ê³  ì  ì

    float initRot = 0;
    float initTilt = 90;
    float initPointX = 0;
    float initPointY = 0;
    float initPointZ = 0;

    float x = 0;
    float y = 0;

    double m_temp_x = 0;
    double m_temp_y = 0;
    double m_temp_z = 0;
    double m_temp_tilt = 0;
    double m_temp_rot = 0;
    double m_temp_zoom = 0;

    double m_min_x = 0;
    double m_max_x = 0;
    double m_min_y = 0;
    double m_max_y = 0;
    double m_min_z = 0;
    double m_max_z = 0;
    double m_min_tilt = -90;
    double m_max_tilt = 90;
    double m_min_rot = 0;
    double m_max_rot = 360;
    double m_min_zoom = 0.01;
    double m_max_zoom = 999;

signals:
    void signalDirectlyInputPos();
private slots:
    void on_pos_x_textEdited(const QString &arg1);
    void on_pos_y_textEdited(const QString &arg1);
    void on_pos_z_textEdited(const QString &arg1);
    void on_ang_tilt_textEdited(const QString &arg1);
    void on_ang_rotation_textEdited(const QString &arg1);
    void on_zoom_textEdited(const QString &arg1);
    void inputPos();
    void on_pos_x_returnPressed();
    void on_pos_y_returnPressed();
    void on_pos_z_returnPressed();
    void on_ang_tilt_returnPressed();
    void on_ang_rotation_returnPressed();
    void on_zoom_returnPressed();
    void on_pos_x_editingFinished();
    void on_pos_y_editingFinished();
    void on_pos_z_editingFinished();
    void on_ang_tilt_editingFinished();
    void on_ang_rotation_editingFinished();
    void on_zoom_editingFinished();

};

#endif // FORMINFO_H
!@hash[]!@file[]./formlayer.h!@hash[]!@code[]#ifndef FORMLAYER_H
#define FORMLAYER_H

#include <QDialog>
#include <QColorDialog>
#include <QtWidgets/QCheckBox>
#include <QTableWidget>
#include <QTableWidgetItem>
#include <QCheckBox>
#include <QPushButton>
#include <QtWidgets/QSlider>
#include <QRgba64>
#include <QDebug>
#include "Rendering/Src/lve_window.hpp"
#include "Rendering/Src/dtaorendersystem.h"
#include "T2D.h"


namespace Ui {
class FormLayer;
}

class FormLayer : public QDialog
{
    Q_OBJECT

public:
    explicit FormLayer(LveWindow *w, QWidget *parent = nullptr);
    ~FormLayer();
    void ReceiveLayerInformation(T2D &t2d);
    void MakeLayerInformationTableHeader();
    void MakeLayerInformationTalbe();
    void MakeTableWidgetItemForText(int);
    void MakeSliderForOpacity(int);
    void MakeCheckBox(int);
    void MakeColorButton(int);
    void MakeHeaderCheckBoxAndSlider();
    void ChangeAllCheckBoxState(QCheckBox *);
    void ChangeCheckBoxStateToOn(int, float, QString);
    void ChangeCheckBoxStateToOff(int, float, QString);
    void GetPushButtonOldColor(QPushButton *, int *, int *, int *, int *, QRgb *);
    void EnterPushButtonNewColor(int *, QRgb *);
    int FindCheckBoxRow(QCheckBox *);

public slots:
    void on_checkboxInTable_stateChanged();
    void on_colorbutton_clicked();
    void on_opacityslider_valueChanged(int);
    void OpacitySliderValueChange(int);

private:
    LveWindow *m_window;
    Ui::FormLayer *ui;
    T2D *t2d_layer_information;
    int data_row_for_t2d = -1;
    int checkboxrow = -1;
    int table_default_column = 6;
    QString empty_for_emit = "";
    QString CommentAllCheckedCheckBox = "All Layer Checked";
    QString CommentAllUncheckedCheckBox = "All Layer Unchecked";


signals:
    void outputLayerStatus(QString printLayer);

};

#endif // FORMLAYER_H
!@hash[]!@file[]./formmap.h!@hash[]!@code[]#ifndef FORMMAP_H
#define FORMMAP_H
#include <glm/gtx/string_cast.hpp>
#include <QDialog>
#include <QGraphicsRectItem>
#include "defineParam.h"
#include "T2D.h"

namespace Ui {
class FormMap;
}

class SuperItem : public QObject, public QGraphicsItem
{
    Q_OBJECT
public:
    SuperItem(QGraphicsItem* parent = NULL);
public slots:
    void slotMove(POS_MONITORING *pos);
    void slotInitMove(double x, double y);

protected:
    void paint(QPainter *painter,
               const QStyleOptionGraphicsItem *option,
               QWidget *widget);    
    QRectF boundingRect() const;


//    virtual void keyPressEvent(QKeyEvent *evnet);

private:
    double m_pos_past_x = 0;
    double m_pos_past_y = 0;
    double m_view_size = 1;
    double m_zoom_init = 1;

};

class FormMap : public QDialog
{
    Q_OBJECT

public:
    explicit FormMap(QWidget *parent = nullptr);
    ~FormMap();
    void receiveFile(T2D &t2d);
    void receivePointPos(POS_MONITORING &pos);
    void changePos();

signals:
    void signalMove(POS_MONITORING *pos);
    void signalInitMove(double x, double y);

private:    
    Ui::FormMap *ui;
    QGraphicsRectItem *rectItem;
    QGraphicsRectItem *rectItem2;
    QRect *rect;
    double m_width;
    double m_height;
    double m_scale = 1;
    double m_box_size = 178;
    double m_width_scaled;
    double m_height_scaled;

    SuperItem *super;

    POS_MONITORING *pos;

    float pointX = 0;
    float pointY = 0;
    float pointZ = 0;
    float infoTilt = 90;
    float infoRot = 0;
    float infoZoom = 1; //Zoom ì´ê¸°ê°ì GDS size ë¥ê°ê³  ì  ì

    float initRot = 0;
    float initTilt = 90;
    float initPointX = 0;
    float initPointY = 0;
    float initPointZ = 0;

    float x = 0;
    float y = 0;
};



#endif // FORMMAP_H
!@hash[]!@file[]./formtop.h!@hash[]!@code[]#ifndef FORMTOP_H
#define FORMTOP_H

#include "T2D.h"
#include "defineParam.h"
#include <QDialog>
#include <QGraphicsItem>
#include <QVector>
#include <QGraphicsRectItem>

namespace Ui {
class FormTop;
}

class FormTop : public QDialog
{
    Q_OBJECT

public:
    explicit FormTop(QWidget *parent = nullptr);
    ~FormTop();

    void receiveFile(T2D &t2d);
    void drawing();
    void drawingClear();
    void receivePointPos(POS_MONITORING &pos);
    void changePos();
//    void receiveFile(QVector<QList<float>> **mapFile);

private slots:
    void on_horizontalSlider_valueChanged(int value);

private:
    void addRectItem(int layer, int row, int col, int n, QTransform trans);    
    int extPos(double *pos, double *min, double *max);
    void filterRenderingData(int layer, int row, int col, int n);
    void areaFilterRect();
    Ui::FormTop *ui;
    T2D *rendering_full;        
    POS_MONITORING *pos;
    POS_MONITORING temp_pos;
    QGraphicsScene *m_scene;
    QVector<QGraphicsRectItem*> rectItemList;
    QTransform trans;
    int m_begin_x = 0, m_begin_y = 0, m_end_x = 1, m_end_y = 1, m_scale = 500;
    float m_min_x = 0, m_min_y =0, m_max_x =0, m_max_y=0;
    bool init_check = true;

    int m_begin_row = 0, m_end_row = 1, m_begin_col = 0, m_end_col = 1;
    int m_block_size = 10; //10um
    double m_area = 50, m_area_scale = 100 ; // 50/1000 = 0.05um(0.001~0.099)
    double m_min_x_size = -0.5, m_max_x_size = 0.5, m_min_y_size = -0.5, m_max_y_size = 0.5;

};

#endif // FORMTOP_H
!@hash[]!@file[]./gitmerge.h!@hash[]!@code[]#ifndef GITMERGE_H
#define GITMERGE_H

#include <QString>

class GitMerge
{
public:
    GitMerge();
private:
    void mergeFiles(QString &totalMerge);
    void openPreMergeFile(QString &preMergeFile);
    void openUpdateMergeFile(QString &updateMergeFile);
    bool compareFiles(QString &A, QString &B);
    void writeMergeFile(QString fileName, QString &originFile);
    void makeCodeFiles(QString &codeFile, QString &gitMergeFile);

    QString split1;
    QString split2;
    QString hash = "!@hash[]";
    QString file = "!@file[]";
    QString code = "!@code[]";
};

#endif // GITMERGE_H
!@hash[]!@file[]./mainwindow.h!@hash[]!@code[]#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include "Rendering/Src/lve_window.hpp"

#include <QMainWindow>
#include <QVulkanWindow>
#include <QDockWidget>
#include "formhier.h"
#include "formlayer.h"
#include "formtop.h"
#include "forminfo.h"
#include "formmap.h"
#include "filedb.h"
#include "all_data.h"
#include <QVector>
#include "defineParam.h"

#include "T2D.h"

class LveWindow;

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; class LayerForm; }
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(LveWindow *w);
    ~MainWindow();

    void shareGeo(QRect size);

    T2D t2d;

public slots:

    void slotInfoText(QString funcName, POS_MONITORING value);
    void inputLayerStatus(QString text);
    void on_actionOpen_file_triggered();
    void inputPosInformation();

signals:
    void signalInfoText(QString funcName, float value);
    void sendSelectFileName(QString file_name);


private slots:
    void on_actionOpen_Layout_triggered();
    void on_actionOpen_DB_triggered();
    void slotDirectlyInputPos();

    void on_actionTop_triggered();
    void on_docker_TopView_triggered();
    void on_docker_Map_triggered();
    void on_docker_Info_triggered();
    void on_docker_Hier_triggered();
    void on_docker_Layer_triggered();

private:
    LveWindow *m_window;
    Ui::MainWindow *ui;
    QString statusText;
    FormHier *formHier;
    FormLayer *formLayer;
    FormTop *formTop;
    FormInfo *formInfo;
    FormMap *formMap;
    QDockWidget *dockHier;
    QDockWidget *dockLayer;
    QDockWidget *dockMap;
    QDockWidget *dockTop;
    QDockWidget *dockInfo;
    SuperItem *superItem;
    QRect *windowSize;
    FileDb *fileDb;
    all_data *input_dataS;
    QStringList split_data;
    POS_MONITORING pos;
    POS_MONITORING pos_past;
    QByteArray dock_widget_geometry;
    QByteArray dock_widget_state;



};

#endif // MAINWINDOW_H
!@hash[]!@file[]./formhier.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormHier</class>
 <widget class="QDialog" name="FormHier">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>320</width>
    <height>300</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>320</width>
    <height>100</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QTableWidget" name="tableWidget">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>300</width>
         <height>100</height>
        </size>
       </property>
       <property name="sizeAdjustPolicy">
        <enum>QAbstractScrollArea::AdjustToContents</enum>
       </property>
       <property name="editTriggers">
        <set>QAbstractItemView::NoEditTriggers</set>
       </property>
       <property name="alternatingRowColors">
        <bool>true</bool>
       </property>
       <property name="gridStyle">
        <enum>Qt::SolidLine</enum>
       </property>
       <attribute name="horizontalHeaderCascadingSectionResizes">
        <bool>false</bool>
       </attribute>
       <attribute name="horizontalHeaderStretchLastSection">
        <bool>false</bool>
       </attribute>
       <attribute name="verticalHeaderVisible">
        <bool>false</bool>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./forminfo.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormInfo</class>
 <widget class="QDialog" name="FormInfo">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>400</height>
   </rect>
  </property>
  <property name="maximumSize">
   <size>
    <width>200</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="2">
      <widget class="QLabel" name="label_4">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Z</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="1">
      <widget class="QLabel" name="label_11">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Rotation</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="2">
      <widget class="QLabel" name="label_12">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Zoom</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="1">
      <widget class="QLabel" name="label_2">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Y</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="1">
      <widget class="QLineEdit" name="pos_y">
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="2">
      <widget class="QLineEdit" name="zoom">
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="0">
      <widget class="QLabel" name="label">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>X</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="0">
      <widget class="QLineEdit" name="ang_tilt">
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="0">
      <widget class="QLabel" name="label_10">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Tilt</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="0">
      <widget class="QLineEdit" name="pos_x">
       <property name="inputMask">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="1">
      <widget class="QLineEdit" name="ang_rotation">
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="2">
      <widget class="QLineEdit" name="pos_z">
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QListWidget" name="listWidget"/>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>pos_x</tabstop>
  <tabstop>pos_y</tabstop>
  <tabstop>pos_z</tabstop>
  <tabstop>ang_tilt</tabstop>
  <tabstop>ang_rotation</tabstop>
  <tabstop>zoom</tabstop>
  <tabstop>listWidget</tabstop>
 </tabstops>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./formlayer.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormLayer</class>
 <widget class="QDialog" name="FormLayer">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>320</width>
    <height>400</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>320</width>
    <height>0</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>430</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QTableWidget" name="tableWidget">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="focusPolicy">
        <enum>Qt::ClickFocus</enum>
       </property>
       <property name="tabKeyNavigation">
        <bool>true</bool>
       </property>
       <property name="alternatingRowColors">
        <bool>true</bool>
       </property>
       <property name="textElideMode">
        <enum>Qt::ElideMiddle</enum>
       </property>
       <attribute name="horizontalHeaderVisible">
        <bool>false</bool>
       </attribute>
       <attribute name="verticalHeaderVisible">
        <bool>false</bool>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./formmap.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormMap</class>
 <widget class="QDialog" name="FormMap">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>200</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>200</width>
    <height>200</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGraphicsView" name="graphicsView">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="minimumSize">
      <size>
       <width>0</width>
       <height>0</height>
      </size>
     </property>
     <property name="verticalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
     <property name="horizontalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./formtop.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormTop</class>
 <widget class="QDialog" name="FormTop">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>200</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>200</width>
    <height>200</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGraphicsView" name="graphicsView"/>
   </item>
   <item>
    <widget class="QSlider" name="horizontalSlider">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./mainwindow.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1024</width>
    <height>768</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
     <widget class="QGraphicsView" name="graphicsView"/>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>1024</width>
     <height>20</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>File</string>
    </property>
    <addaction name="actionOpen_file"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_Layout"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_DB"/>
   </widget>
   <widget class="QMenu" name="menuView">
    <property name="title">
     <string>View</string>
    </property>
    <addaction name="actionLayer_information"/>
   </widget>
   <widget class="QMenu" name="menuCamera">
    <property name="title">
     <string>Camera</string>
    </property>
    <addaction name="actionTop"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuView"/>
   <addaction name="menuCamera"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="toolBar">
   <property name="windowTitle">
    <string>toolBar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="actionTop"/>
   <addaction name="separator"/>
   <addaction name="docker_Map"/>
   <addaction name="docker_TopView"/>
   <addaction name="docker_Info"/>
   <addaction name="docker_Hier"/>
   <addaction name="docker_Layer"/>
  </widget>
  <action name="actionOpen_file">
   <property name="text">
    <string>Open file</string>
   </property>
  </action>
  <action name="actionLayer_information">
   <property name="text">
    <string>Layer information</string>
   </property>
  </action>
  <action name="actionOpen_Layout">
   <property name="text">
    <string>Open Layout</string>
   </property>
  </action>
  <action name="actionOpen_DB">
   <property name="text">
    <string>Open DB</string>
   </property>
  </action>
  <action name="actionTop">
   <property name="text">
    <string>Top</string>
   </property>
  </action>
  <action name="docker_Map">
   <property name="icon">
    <iconset>
     <normaloff>ImageFile/Map_Icon_50by50.png</normaloff>
     <normalon>ImageFile/box-shadow.png</normalon>ImageFile/Map_Icon_50by50.png</iconset>
   </property>
   <property name="text">
    <string>docker_Map</string>
   </property>
   <property name="toolTip">
    <string>docker_Map</string>
   </property>
  </action>
  <action name="docker_TopView">
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Top_View_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_TopView</string>
   </property>
   <property name="toolTip">
    <string>docker_TopView</string>
   </property>
  </action>
  <action name="docker_Info">
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Info_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_Info</string>
   </property>
   <property name="toolTip">
    <string>docker_Info</string>
   </property>
  </action>
  <action name="docker_Hier">
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Hier_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_Hier</string>
   </property>
   <property name="toolTip">
    <string>docker_Hier</string>
   </property>
  </action>
  <action name="docker_Layer">
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Layer_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_Layer</string>
   </property>
   <property name="toolTip">
    <string>docker_Layer</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./IInterface.pro!@hash[]!@code[]QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++17
QMAKE_CXXFLAGS += -std=c++17

# You can make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
    Rendering/Src/LayoutData.cpp \
    Rendering/Src/LayoutModel.cpp \
    Rendering/Src/PEXCapacitorModel.cpp \
    Rendering/Src/PEXData.cpp \
    Rendering/Src/PEXResistorModel.cpp \
    Rendering/Src/dtaorendersystem.cpp \
    Rendering/Src/keyboard_movement_controller.cpp \
    Rendering/Src/lve_camera.cpp \
    Rendering/Src/lve_device.cpp \
    Rendering/Src/lve_model.cpp \
    Rendering/Src/lve_pipeline.cpp \
    Rendering/Src/lve_window.cpp \
    Rendering/Src/simple_render_system.cpp \
    T2D.cpp \
    all_data.cpp \
    filedb.cpp \
    formhier.cpp \
    forminfo.cpp \
    formlayer.cpp \
    formmap.cpp \
    formtop.cpp \
    gitmerge.cpp \
    main.cpp \
    mainwindow.cpp

HEADERS += \
    Rendering/Src/LayoutModel.h \
    Rendering/Src/LayoutPEXData.h \
    Rendering/Src/PEXCapacitorModel.h \
    Rendering/Src/PEXResistorModel.h \
    Rendering/Src/dtaorendersystem.h \
    Rendering/Src/keyboard_movement_controller.hpp \
    Rendering/Src/lve_camera.hpp \
    Rendering/Src/lve_device.hpp \
    Rendering/Src/lve_game_object.hpp \
    Rendering/Src/lve_model.hpp \
    Rendering/Src/lve_pipeline.hpp \
    Rendering/Src/lve_window.hpp \
    Rendering/Src/simple_render_system.hpp \
    T2D.h \
    all_data.h \
    defineParam.h \
    filedb.h \
    formhier.h \
    forminfo.h \
    formlayer.h \
    formmap.h \
    formtop.h \
    gitmerge.h \
    mainwindow.h

FORMS += \
    formhier.ui \
    forminfo.ui \
    formlayer.ui \
    formmap.ui \
    formtop.ui \
    mainwindow.ui

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target


RESOURCES += \
    Resources.qrc

DISTFILES += \
    ImageFile/box-shadow.png \
    Rendering/Data/MVP_PEX_RC_r1_0130.csv \
    Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv \
    Rendering/Data/big_test_espin.csv \
    Rendering/Data/layout_input_data.csv \
    Rendering/Data/layout_input_data_old_format.csv \
    Rendering/Data/pex_cap_test.csv \
    Rendering/Data/pex_res_test.csv \
    Rendering/Data/pex_res_test_beol_only.csv \
    Rendering/Data/pex_res_test_simple.csv \
    Rendering/Data/test_espin.csv \
    Rendering/shaders/compile.bat \
    Rendering/shaders/simple_shader.frag \
    Rendering/shaders/simple_shader.frag.spv \
    Rendering/shaders/simple_shader.frag_edge.spv \
    Rendering/shaders/simple_shader.frag_pex.spv \
    Rendering/shaders/simple_shader.vert \
    Rendering/shaders/simple_shader.vert.spv \
    Rendering/shaders/simple_shader.vert_edge.spv \
    Rendering/shaders/simple_shader.vert_pex.spv \
    Rendering/shaders/simple_shader_edge.frag \
    Rendering/shaders/simple_shader_edge.vert \
    Rendering/shaders/simple_shader_pex.frag \
    Rendering/shaders/simple_shader_pex.vert



INCLUDEPATH += $$PWD/../../Library/glm-0.9.9.8



unix:!macx|win32: LIBS += -L$$PWD/../../Library/VulkanSDK/1.3.239.0/Lib/ -lvulkan-1

INCLUDEPATH += $$PWD/../../Library/VulkanSDK/1.3.239.0/Lib
DEPENDPATH += $$PWD/../../Library/VulkanSDK/1.3.239.0/Lib

INCLUDEPATH += $$PWD/../../Library/glm-0.9.9.8/glm



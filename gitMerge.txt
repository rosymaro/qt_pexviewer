::::./Rendering/Src/LayoutData.cpp::::#include "LayoutPEXData.h"

#include <iostream>
#include <string>
#include <vector>
#include <limits>
#include <cstdio>
#include <chrono>

#include "rapidcsv.h"

#include <QFile>

using namespace std;

inline double coord_normalize(double in_value, double move, double scale) {
    //return 2 * (in_value - min_value) / (max_value - min_value) - 1.0f;
    //return (2 * (in_value - move) / (scale)-1.0f);
    return 2 * ((in_value - move) * (scale)) - 1.0f;
}



LayoutItem::LayoutItem() : pattern{}, layer_number{}, layer_datatype{}, layer_type{} {
}
LayoutItem::~LayoutItem() {
}

LayoutItem::LayoutItem(const cube_info& pattern_, const int layer_number_, const int layer_datatype_, LAYOUT_LAYER_TYPE layer_type_)
    : pattern(pattern_), layer_number(layer_number_), layer_datatype(layer_datatype_), layer_type(layer_type_) {
}


LayoutDataManager::LayoutDataManager()
    : file_path{}, patterns{}, scale(1.0),
      layout_min_x{}, layout_max_x{}, layout_min_y{}, layout_max_y{}, layout_min_z{}, layout_max_z{} {
}

LayoutDataManager::~LayoutDataManager() {
    this->patterns.clear();
}

void LayoutDataManager::calculateScale() {
    double x_diff = this->layout_max_x - this->layout_min_x;
    double y_diff = this->layout_max_y - this->layout_min_y;
    double z_diff = this->layout_max_z - this->layout_min_z;

    double max_diff = x_diff > y_diff ? x_diff : y_diff;
    max_diff = max_diff > z_diff ? max_diff : z_diff;

    this->scale = 1.0f / max_diff;
}

void LayoutDataManager::loadLayoutData(const std::string file_path) {
    if (!QFile::exists(file_path.c_str())) {
        cerr << "File is not exist : " << file_path << endl;
        return;
    }


    std::chrono::system_clock::time_point start, end;
    std::chrono::seconds run_time;

    start = std::chrono::system_clock::now();

    rapidcsv::Document infile(file_path, rapidcsv::LabelParams(-1, -1));

    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutDataManager / loadLayoutData / rapidcsv::infile [sec] : "
              << run_time.count() << "\n";

    std::vector<float> bbox = infile.GetRow<float>(0);
    this->layout_min_x = bbox[0];
    this->layout_min_y = bbox[1];
    this->layout_max_x = bbox[2];
    this->layout_max_y = bbox[3];
    this->layout_min_z = bbox[4];
    this->layout_max_z = bbox[5];

    calculateScale();

    size_t line_count = infile.GetRowCount();
    cube_info cur_cube;
    int layer_number, layer_datatype;

    start = std::chrono::system_clock::now();

    for (size_t i = 1; i < line_count; ++i) { //first line is bbox area
        vector<string> line = infile.GetRow<string>(i);
        //if (line[LAYOUTINFO_IDX_STRUCTURE] != "Poly") continue;
        //if (std::stoi(line[LAYOUTINFO_IDX_NUMPOINTS]) != 4) continue;

        layer_number = std::stoi(line[LAYOUTINFO_IDX_LAYER]);
        layer_datatype = std::stoi(line[LAYOUTINFO_IDX_DATATYPE]);

        cur_cube.minz = std::stof(line[LAYOUTINFO_IDX_ZSTART]);
        cur_cube.maxz = std::stof(line[LAYOUTINFO_IDX_ZEND]);
        if (cur_cube.minz == cur_cube.maxz) continue;

        cur_cube.minx = std::stof(line[LAYOUTINFO_IDX_LEFT]);
        cur_cube.maxx = std::stof(line[LAYOUTINFO_IDX_RIGHT]);
        cur_cube.miny = std::stof(line[LAYOUTINFO_IDX_BOTTOM]);
        cur_cube.maxy = std::stof(line[LAYOUTINFO_IDX_TOP]);

        //cur_cube.minx = coord_normalize(cur_cube.minx, this->layout_min_x, scale);
        //cur_cube.maxx = coord_normalize(cur_cube.maxx, this->layout_min_x, scale);
        //cur_cube.miny = coord_normalize(cur_cube.miny, this->layout_min_y, scale);
        //cur_cube.maxy = coord_normalize(cur_cube.maxy, this->layout_min_y, scale);
        //cur_cube.minz = coord_normalize(cur_cube.minz, this->layout_min_z, scale);
        //cur_cube.maxz = coord_normalize(cur_cube.maxz, this->layout_min_z, scale);

        this->patterns.push_back(LayoutItem(cur_cube, layer_number, layer_datatype, LAYOUT_LAYER_TYPE::LAYOUT_LAYER_TYPE_DEFAULT));

    }

    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutDataManager / loadLayoutData / pattern push [sec] : "
              << run_time.count() << "\n";

    infile.Clear();

    /*
        printf("\n\nLayout Info Data\n\n");
        for (auto& cur_pattern : this->patterns) {
            printf("left/bottom/right/top/z-start/z-end = %.4f/%.4f/%.4f/%.4f/%.4f/%.4f/\n",
                cur_pattern.pattern.minx, cur_pattern.pattern.miny,
                cur_pattern.pattern.maxx, cur_pattern.pattern.maxy,
         cur_pattern.pattern.minz, cur_pattern.pattern.maxz);
        }
        //*/
}

void testLayoutData() {
    LayoutDataManager layout_data;
    layout_data.loadLayoutData("Data/layout_input_data.csv");

}

::::./Rendering/Src/LayoutModel.cpp::::#include "LayoutModel.h"

#include <iostream>
#include <string>
#include <vector>
#include <chrono>

#include "LayoutPEXData.h"

#include <QFile>


LayoutModel::LayoutModel(LveDevice& device, MODEL_TYPE model_type, const std::string& data_file)
    : LveModel(device, model_type), layout_data{} {
    this->makeRenderingData(data_file);
    this->createBuffers();
}

LayoutModel::~LayoutModel() {
    this->layout_data.clear();
}

void LayoutModel::makeRenderingData(const std::string& file_path) {
    if (!QFile::exists(file_path.c_str())) {
        std::cerr << "Error! " << file_path << " is not exist!!\n";
        return;
    }

    std::chrono::system_clock::time_point start, end;
    std::chrono::seconds run_time;

    start = std::chrono::system_clock::now();
    loadData(file_path);
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / loadData [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeCubeVertices();
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / makeCubeVertices [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeVertices();
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / lmakeVertices [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeIndices();
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / makeIndices [sec] : "
              << run_time.count() << "\n";
}

void LayoutModel::loadData(const std::string& file_path) {
    this->layout_data.loadLayoutData(file_path);
}

void LayoutModel::makeCubeVertices() {
    std::vector<LayoutItem>& layout_items = this->layout_data.getPatterns();
    std::vector<LayoutItem>::iterator it = layout_items.begin();
    cube_vertex cur_cube_vertices;


    for (it = layout_items.begin(); it != layout_items.end(); ++it) {
        cur_cube_vertices.layernum = it->layer_number;
        cur_cube_vertices.vertex[0] = { it->pattern.minx, it->pattern.maxy, it->pattern.maxz };
        cur_cube_vertices.vertex[1] = { it->pattern.minx, it->pattern.miny, it->pattern.maxz };
        cur_cube_vertices.vertex[2] = { it->pattern.maxx, it->pattern.miny, it->pattern.maxz };
        cur_cube_vertices.vertex[3] = { it->pattern.maxx, it->pattern.maxy, it->pattern.maxz };

        cur_cube_vertices.vertex[4] = { it->pattern.minx, it->pattern.maxy, it->pattern.minz };
        cur_cube_vertices.vertex[5] = { it->pattern.minx, it->pattern.miny, it->pattern.minz };
        cur_cube_vertices.vertex[6] = { it->pattern.maxx, it->pattern.miny, it->pattern.minz };
        cur_cube_vertices.vertex[7] = { it->pattern.maxx, it->pattern.maxy, it->pattern.minz };

        this->cube_vertices.push_back(cur_cube_vertices);
        //std::cout << cube_vertices.back().layernum << '\n';
    }
}

void LayoutModel::makeVertices() {
    Vertex temp_vertex;

    float up_color = 0.15f;
    float down_color = 0.6f;

    for (const auto& cur_cube : this->cube_vertices) {
        for (int i = 0; i < 8; ++i) {
            temp_vertex.position = { cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };

            if (i < 4) temp_vertex.color = { up_color , up_color , up_color };
            else       temp_vertex.color = { down_color , down_color , down_color };

            layerby_vertices[cur_cube.layernum].push_back(temp_vertex);
        }
    }
}

void LayoutModel::makeIndices() {
    //makeIndicesForFace();
    makeIndicesForFace_map();
    //makeIndicesForEdge();
    makeIndicesForEdge_map();
}

void LayoutModel::makeIndicesForFace_map() {
    //size_t layer_count = this->layerby_vertices.size();

    uint32_t start_idx = 0;
    std::map<float, std::vector<uint32_t>>& indices = this->layerby_face;
    for (auto const& [key, val] : layerby_vertices) {
        size_t cube_count_by_layer = val.size() / 8;
        for (size_t i = 0; i < cube_count_by_layer; ++i) {
            start_idx = 8 * i;
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 0);//top

            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 3);//right

            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 0);//front

            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 4);//bottom

            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 0);//left

            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 1);//back
        }
    }

}

void LayoutModel::makeIndicesForEdge_map() {
    //size_t layer_count = this->layerby_vertices.size();

    std::map<float, std::vector<uint32_t>>& indices = this->layerby_edge;
    uint32_t start_idx = 0;
    for (auto const& [key, val] : layerby_vertices) {
        size_t cube_count_by_layer = val.size() / 8;
        for (size_t i = 0; i < cube_count_by_layer; ++i) {
            start_idx = 8 * i;
            //top
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 1);
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 3);
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 0);

            //bottom
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 4);

            //right
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 3);

            //left
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 4);
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 1);
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 0);

            //front
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 3);
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 4);
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 0);

            //back
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 1);
        }
    }

}

void LayoutModel::makeIndicesForFace() {
    size_t cube_count = this->cube_vertices.size();

    uint32_t start_idx = 0;
    std::vector<uint32_t>& indices = this->indices_face;
    for (int i = 0; i < cube_count; ++i) {
        start_idx = 8 * i;
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);//top

        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);//right

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);//front

        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);//bottom

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);//left

        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);//back
    }
}


void LayoutModel::makeIndicesForEdge() {
    size_t cube_count = this->cube_vertices.size();

    std::vector<uint32_t>& indices = this->indices_edge;
    uint32_t start_idx = 0;
    for (int i = 0; i < cube_count; ++i, start_idx += 8) {
        //top
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);

        //bottom
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);

        //right
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);

        //left
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);

        //front
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);

        //back
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);
    }
}


::::./Rendering/Src/PEXCapacitorModel.cpp::::#include "PEXCapacitorModel.h"

#include <iostream>
#include <map>
#include <vector>
#include <math.h>
#include <cstdio>
#include <thread>
#include <mutex>

#include "LayoutPEXData.h"

using namespace std;

PEXCapacitorModel::PEXCapacitorModel(
        LveDevice& device,
        MODEL_TYPE model_type,
        const std::string& data_file,
        LayoutDataManager* layout_data_)
    : LveModel(device, model_type), pex_data{}, cap_node_name_to_index_map{}, layout_data{ layout_data_ } {

    this->makePatternCapsFromLayoutData();
    this->makeRenderingData(data_file);
    this->createBuffers();
}


PEXCapacitorModel::~PEXCapacitorModel() {
    for (auto& cur_item : this->layer_to_pattern_cap_map) cur_item.second.clear();
    this->layer_to_pattern_cap_map.clear();
    this->pattern_caps.clear();
}

void PEXCapacitorModel::makePatternCapsFromLayoutData() {
    std::vector<LayoutItem>& layout_items = this->layout_data->getPatterns();
    if (layout_items.empty()) {
        std::cerr << "Error! empty patten @PEXCapacitorModel::makePatternWCapsFromLayoutData()\n";
    }

    for (auto& layout_item : layout_items) {
        this->pattern_caps.push_back(
                    pattern_cap(layout_item.pattern, layout_item.layer_number, layout_item.layer_datatype, 0.0, 0.0, 0)
                    );

        this->layers.insert({ layout_item.layer_number, layout_item.layer_datatype });
    }
}

void PEXCapacitorModel::makeRenderingData(const std::string& file_path) {
    loadData(file_path);
    makeCapNodesFromPEXData();

    attachCapToPattern();
    normalizePatternCap();
    //printLayerToPatternCapMap("After Normalization Cap");

    makeCubeVertices();
    makeVertices();
    makeIndices();

    for (auto& cur_item : this->layer_to_cap_node_map) cur_item.second.clear();
    this->layer_to_cap_node_map.clear();
    this->cap_nodes.clear();
    this->layers.clear();
}

void PEXCapacitorModel::loadData(const std::string& file_path) {
    this->pex_data.loadData(file_path);
    //this->pex_data.printPEXData();
}


void PEXCapacitorModel::makeCapNodesFromPEXData() {
    this->cap_node_name_to_index_map.clear();
    std::map<std::string, size_t>::iterator it;
    for (auto& pex_item : this->pex_data.getCapacitors()) {
        //node1
        std::string& node1_name = pex_item.node1.name;
        it = this->cap_node_name_to_index_map.find(node1_name);
        if (it == this->cap_node_name_to_index_map.end()) addNewCapNode(pex_item.node1, pex_item.value);
        else {
            this->cap_nodes[it->second].value += pex_item.value;
            this->cap_nodes[it->second].connected_count++;
        }

        //node2
        std::string& node2_name = pex_item.node2.name;
        it = this->cap_node_name_to_index_map.find(node2_name);
        if (it == this->cap_node_name_to_index_map.end()) addNewCapNode(pex_item.node2, pex_item.value);
        else {
            this->cap_nodes[it->second].value += pex_item.value;
            this->cap_nodes[it->second].connected_count++;
        }
    }//for(auto & pex_item : this->pex_data.getCapacitors())
    this->pex_data.clear();
    this->cap_node_name_to_index_map.clear();
}


void PEXCapacitorModel::addNewCapNode(pex_node& pex_node, double value) {
    cap_node new_cap_node{};
    new_cap_node.name = pex_node.name;
    new_cap_node.layer_number = pex_node.layer_number;
    new_cap_node.layer_datatype = pex_node.layer_datatype;
    new_cap_node.x = pex_node.x;
    new_cap_node.y = pex_node.y;
    new_cap_node.value = value;
    new_cap_node.connected_count = 1;

    this->cap_nodes.push_back(new_cap_node);
    this->cap_node_name_to_index_map.insert(std::pair<std::string, size_t>(new_cap_node.name, this->cap_nodes.size() - 1));
}


void PEXCapacitorModel::attachCapToPattern() {
    makeLayerToCapNodeMap();
    makeLayerToPatternCapMap();

    /*
        //捍纺贸府肺 函版秦具 窃
        //matchCapWithPattern(this->cap_layer_map, this->pattern_layer_map, 17, 0);
        for (auto& cur_layer : this->layers) {
            string layer = getLayerString(cur_layer.first, cur_layer.second);
            map<string, vector<cap_node*>>::iterator it_layer_to_cap_node_map = this->layer_to_cap_node_map.find(layer);
            map<string, vector<pattern_cap*>>::iterator it_layer_to_pattern_cap_map = this->layer_to_pattern_cap_map.find(layer);
            if (it_layer_to_cap_node_map == this->layer_to_cap_node_map.end()
                || it_layer_to_pattern_cap_map == this->layer_to_pattern_cap_map.end()) continue;

            std::vector<cap_node*>& caps = it_layer_to_cap_node_map->second;
            std::vector<pattern_cap*>& patterns = it_layer_to_pattern_cap_map->second;

            matchCapWithPattern(caps, patterns);
            //matchCapWithPattern(this->layer_to_cap_node_map, this->layer_to_pattern_cap_map, cur_layer.first, cur_layer.second);
        }
        */

    makeLayersQueueForThreadJob();
    for (size_t i = 0; i < this->num_threads; ++i) {

        this->threads.push_back(
                    std::thread(&PEXCapacitorModel::matchCapWithPatternThread, this, &this->layers_queue, &this->mutex_layers_queue));
    }

    for (auto& thread : this->threads)
        thread.join();

    /*
        FILE* out_file = NULL;
        fopen_s(&out_file, "pattern_caps_info_thread.txt", "w");
        if (out_file != NULL) {
            printPatternCaps(out_file);
            fclose(out_file);
        }
        else printPatternCaps(stdout);
        */
}

void PEXCapacitorModel::matchCapWithPatternThread(std::queue<std::string>* layers, std::mutex* mutex_) {
    while (1) {
        mutex_->lock();
        if (layers->empty()) {
            mutex_->unlock();
            break;
        }

        string layer = layers->front();
        layers->pop();
        mutex_->unlock();

        map<string, vector<cap_node*>>::iterator it_layer_to_cap_node_map = this->layer_to_cap_node_map.find(layer);
        map<string, vector<pattern_cap*>>::iterator it_layer_to_pattern_cap_map = this->layer_to_pattern_cap_map.find(layer);
        if (it_layer_to_cap_node_map == this->layer_to_cap_node_map.end()
                || it_layer_to_pattern_cap_map == this->layer_to_pattern_cap_map.end()) continue;;

        std::vector<cap_node*>& caps = it_layer_to_cap_node_map->second;
        std::vector<pattern_cap*>& patterns = it_layer_to_pattern_cap_map->second;
        //matchCapWithPattern(caps, patterns);
        for (auto& cap : caps) {
            for (auto& pattern : patterns) {
                if (isPatternIncludeCap(*pattern, *cap)) {
                    pattern->cap_count++;
                    pattern->cap_value += cap->value;
                    break;
                }
            }//for cap : caps
        }//for pattern : patterns

    }//while 1
}


void PEXCapacitorModel::makeLayersQueueForThreadJob() {
    for (auto& cur_layer : this->layers) {
        string layer = getLayerString(cur_layer.first, cur_layer.second);
        this->layers_queue.push(layer);
    }
}

void PEXCapacitorModel::matchCapWithPattern(
        std::vector<cap_node*>& caps,
        std::vector<pattern_cap*>& patterns
        ) {

    for (auto& cap : caps) {
        for (auto& pattern : patterns) {
            if (isPatternIncludeCap(*pattern, *cap)) {
                pattern->cap_count++;
                pattern->cap_value += cap->value;
                break;
            }
        }//for cap : caps
    }//for pattern : patterns

}

void PEXCapacitorModel::matchCapWithPattern(
        std::map<std::string, std::vector<cap_node*>>& cap_layer_map_,
        std::map<std::string, std::vector<pattern_cap*>>& pattern_layer_map_,
        uint target_layer_number, uint target_layer_datatype) {

    //string layer = std::to_string(target_layer_number) + "." + std::to_string(target_layer_datatype);
    string layer = getLayerString(target_layer_number, target_layer_datatype);
    std::map<std::string, std::vector<cap_node*>>::iterator it_cap_layer_map = cap_layer_map_.find(layer);
    std::map<std::string, std::vector<pattern_cap*>>::iterator it_pattern_layer_map = pattern_layer_map_.find(layer);
    if (it_cap_layer_map == cap_layer_map_.end() || it_pattern_layer_map == pattern_layer_map_.end()) return;

    std::vector<cap_node*>& caps = it_cap_layer_map->second;
    std::vector<pattern_cap*>& patterns = it_pattern_layer_map->second;

    for (auto& cap : caps) {
        for (auto& pattern : patterns) {
            if (isPatternIncludeCap(*pattern, *cap)) {
                pattern->cap_count++;
                pattern->cap_value += cap->value;
                break;
            }
        }//for cap : caps
    }//for pattern : patterns
}

void PEXCapacitorModel::makeLayerToCapNodeMap() {
    this->layer_to_cap_node_map.clear();
    map<string, vector<cap_node*>>::iterator it;
    for (auto& cur_cap : this->cap_nodes) {
        //std::string layer = std::to_string(cur_cap.layer_number) + "." + std::to_string(cur_cap.layer_datatype);
        string layer = getLayerString(cur_cap.layer_number, cur_cap.layer_datatype);
        it = this->layer_to_cap_node_map.find(layer);
        if (it == this->layer_to_cap_node_map.end()) {
            vector<cap_node*>* new_cap_list = new vector<cap_node*>;
            new_cap_list->push_back(&cur_cap);
            this->layer_to_cap_node_map.insert(pair<string, vector<cap_node*>>(layer, *new_cap_list));
        }
        else {
            it->second.push_back(&cur_cap);
        }
    }//for (auto& cur_cap : this->cap_nodes)

    //printLayerToCapNodeMap();
}


void PEXCapacitorModel::makeLayerToPatternCapMap() {
    this->layer_to_pattern_cap_map.clear();
    map<string, vector<pattern_cap*>>::iterator it;
    for (auto& cur_pattern : this->pattern_caps) {
        //string layer = std::to_string(cur_pattern.layer_number) + "." + std::to_string(cur_pattern.layer_datatype);
        string layer = getLayerString(cur_pattern.layer_number, cur_pattern.layer_datatype);
        it = this->layer_to_pattern_cap_map.find(layer);
        if (it == this->layer_to_pattern_cap_map.end()) {
            vector<pattern_cap*>* new_pattern_list = new vector<pattern_cap*>;
            new_pattern_list->push_back(&cur_pattern);
            this->layer_to_pattern_cap_map.insert(pair<string, vector<pattern_cap*>>(layer, *new_pattern_list));
        }
        else {
            it->second.push_back(&cur_pattern);
        }
    }//for (auto& cur_pattern : this->pattern_caps)

    //printLayerToPatternCapMap();
}


void PEXCapacitorModel::normalizePatternCap() {
    for (auto& cur_pattern_cap : this->pattern_caps) {
        if (cur_pattern_cap.cap_value > this->max_cap) this->max_cap = cur_pattern_cap.cap_value;
    }

    for (auto& cur_pattern_cap : this->pattern_caps) {
        cur_pattern_cap.normalized_cap_value = 1.0 / (std::log((cur_pattern_cap.cap_value / this->max_cap)) * (-1.0) + 1.0);
    }
}


inline std::string PEXCapacitorModel::getLayerString(uint layer_number, uint layer_datatype) {
    return (std::string(std::to_string(layer_number) + "." + std::to_string(layer_datatype)));
}


bool PEXCapacitorModel::isPatternIncludeCap(const pattern_cap& pattern, const cap_node& cap) {
    if (cap.x < pattern.pattern.minx) return false;
    if (cap.x > pattern.pattern.maxx) return false;
    if (cap.y < pattern.pattern.miny) return false;
    if (cap.y > pattern.pattern.maxy) return false;
    return true;
}

void PEXCapacitorModel::makeCubeVertices() {
    cube_vertex cur_cube_vertices;
    std::vector<pattern_cap>::iterator it;
    for (it = this->pattern_caps.begin(); it != this->pattern_caps.end(); ++it) {
        cur_cube_vertices.vertex[0] = { it->pattern.minx, it->pattern.maxy, it->pattern.maxz };
        cur_cube_vertices.vertex[1] = { it->pattern.minx, it->pattern.miny, it->pattern.maxz };
        cur_cube_vertices.vertex[2] = { it->pattern.maxx, it->pattern.miny, it->pattern.maxz };
        cur_cube_vertices.vertex[3] = { it->pattern.maxx, it->pattern.maxy, it->pattern.maxz };

        cur_cube_vertices.vertex[4] = { it->pattern.minx, it->pattern.maxy, it->pattern.minz };
        cur_cube_vertices.vertex[5] = { it->pattern.minx, it->pattern.miny, it->pattern.minz };
        cur_cube_vertices.vertex[6] = { it->pattern.maxx, it->pattern.miny, it->pattern.minz };
        cur_cube_vertices.vertex[7] = { it->pattern.maxx, it->pattern.maxy, it->pattern.minz };

        this->cube_vertices.push_back(cur_cube_vertices);
    }
}

void PEXCapacitorModel::makeVertices() {
    Vertex temp_vertex;
    float cap_color_r{}, cap_color_g{}, cap_color_b{};

    std::vector<pattern_cap>::iterator cur_pattern_cap = this->pattern_caps.begin();
    for (const auto& cur_cube : this->cube_vertices) {
        cap_color_r = cur_pattern_cap->normalized_cap_value;
        cap_color_g = 0.0f; // cur_pattern_cap->normalized_cap_value;
        cap_color_b = 0.0f;

        for (int i = 0; i < 8; ++i) {
            temp_vertex.position = { cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };
            temp_vertex.color = { cap_color_r , cap_color_g , cap_color_b };
            vertices.push_back(temp_vertex);
        }
        cur_pattern_cap++;
    }
}


void PEXCapacitorModel::makeIndices() {
    size_t cube_count = this->cube_vertices.size();

    std::vector<uint32_t>& indices = this->indices_edge;
    uint32_t start_idx = 0;
    for (size_t i = 0; i < cube_count; ++i, start_idx += 8) {
        //top
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);

        //bottom
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);

        //right
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);

        //left
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);

        //front
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);

        //back
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);
    }
}


void PEXCapacitorModel::printCapNodes() {
    printf("***** PEX ITEM LIST\n");
    int i = 1;
    for (auto& pex_item : this->pex_data.getCapacitors()) {
        printf("%dth PEX Item\n", i++);
        pex_item.print();
        printf("\n");
    }

    printf("***** CAP NODE LIST\n");
    i = 1;
    for (auto& cap_node : this->cap_node_name_to_index_map) {
        printf("%dth Cap Node Item\n", i++);
        printf("\nNode Name = %s / Layer# = %d.%d / x,y = %.4f,%.4f / Value = %e / Neibor = %d\n",
               this->cap_nodes[cap_node.second].name.c_str(),
                this->cap_nodes[cap_node.second].layer_number,
                this->cap_nodes[cap_node.second].layer_datatype,
                this->cap_nodes[cap_node.second].x,
                this->cap_nodes[cap_node.second].y,
                this->cap_nodes[cap_node.second].value,
                this->cap_nodes[cap_node.second].connected_count);
        printf("\n");
    }
}

void PEXCapacitorModel::printPatternCaps(FILE* out_stream) {
    fprintf(out_stream, "\n\n###############################################\n");
    fprintf(out_stream, "### PatternCap List\n");
    for (auto& pattern : this->pattern_caps) {
        fprintf(out_stream, "\nLayer = %u.%u, Cap count = %u, Total Caps = %e\n",
                pattern.layer_number, pattern.layer_datatype, pattern.cap_count, pattern.cap_value);
        fprintf(out_stream, "\tLeft ~ Right/Bottom ~ Top = %.6f ~ %.6f / %.6f ~ %.6f\n",
                pattern.pattern.minx, pattern.pattern.maxx, pattern.pattern.miny, pattern.pattern.maxy);
    }
}

void PEXCapacitorModel::printLayerToCapNodeMap(FILE* out_stream) {
    fprintf(out_stream, "\n\n\n####################################################\n");
    fprintf(out_stream, "Cap Layer Map\n");
    for (auto& cur_item : this->layer_to_cap_node_map) {
        fprintf(out_stream, "\nLayer = %s :: name / cap count / cap value \n", cur_item.first.c_str());
        for (auto cur_cap : cur_item.second) {
            fprintf(out_stream, "\t%s / %u / %e / %.6f, %.6f\n",
                    cur_cap->name.c_str(), cur_cap->connected_count, cur_cap->value, cur_cap->x, cur_cap->y);
        }
    }
}

void PEXCapacitorModel::printLayerToPatternCapMap(const char* msg) {
    printf("\n\n\n####################################################\n");
    printf("Pattern Layer Map :: %s\n", msg);
    for (auto& cur_item : this->layer_to_pattern_cap_map) {
        printf("\nLayer = %s :: left ~ right / bottom ~ top - cap count, cap value, norm cap value\n", cur_item.first.c_str());
        for (auto cur_pattern : cur_item.second) {
            printf("\t%.6f ~ %.6f / %.6f ~ %.6f - ",
                   cur_pattern->pattern.minx, cur_pattern->pattern.maxx, cur_pattern->pattern.miny, cur_pattern->pattern.maxy);
            printf("%u, %e, %f\n", cur_pattern->cap_count, cur_pattern->cap_value, cur_pattern->normalized_cap_value);
        }
    }
}

void PEXCapacitorModel::printLayerList() {
    printf("\n\n\n####################################################\n");
    printf("Layer List\n");
    for (auto& cur_layer : this->layers) {
        printf("\t%u.%u\n", cur_layer.first, cur_layer.second);
    }
}




::::./Rendering/Src/PEXData.cpp::::#include "LayoutPEXData.h"
#include <iostream>
#include <string>
#include <vector>

#include <limits>
#include <cstdio>

#include "rapidcsv.h"

#include <QFile>

using namespace std;


/// <summary>
/// PEXItem
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXItem::PEXItem() : node1{}, node2{}, name{} {
    this->value = 0.0;
}

PEXItem::PEXItem(const node& node1_, const node& node2_, const double& value_, const string& name_) :
    node1(node1_), node2(node2_), value(value_), name(name_) {
}

PEXItem::~PEXItem() {
}

void PEXItem::print() {
    printf("%s\n", this->name.c_str());
    printf("Node1 name/layer#/x1,y1/Z-s,Z-e = %s / %d.%d / %.5f,%.5f / %.5f,%.5f\n",
           this->node1.name.c_str(), this->node1.layer_number, this->node1.layer_datatype,
           this->node1.x, this->node1.y, this->node1.z_start, this->node1.z_end);
    printf("Node2 name/layer#/x1,y1/Z-s,Z-e = %s / %d.%d / %.5f,%.5f / %.5f,%.5f\n",
           this->node1.name.c_str(), this->node1.layer_number, this->node1.layer_datatype,
           this->node2.x, this->node2.y, this->node2.z_start, this->node2.z_end);
}

/// <summary>
/// PEXResistor
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXResistor::PEXResistor() : PEXItem(), direction(RES_DIRECTION_NONE) {
}
PEXResistor::PEXResistor(const string& name_, const node& node1_, const node& node2_, const double& value_, const PEXResDirection& direction_) :
    PEXItem(node1_, node2_, value_, name_), direction(direction_) {
}

void PEXResistor::print() {
    PEXItem::print();
    printf("Direction = ");
    if (this->direction == RES_DIRECTION_VERTICAL) printf("Vertical\n");
    else printf("Horizontal\n");
    printf("Resistor Value = %10.5f\n\n", this->getValue());
}

PEXResistor::~PEXResistor() {
}

PEXResDirection PEXResistor::checkDirectionFromDescription(const std::string& description) {
    PEXResDirection direction;
    if (description.find("$a") == std::string::npos) {
        direction = RES_DIRECTION_HORIZONTAL;
    }
    else {
        direction = RES_DIRECTION_VERTICAL;
    }
    //printf("#####Description = %s, ", description.c_str());
    //if (direction == RES_DIRECTION_VERTICAL) printf("Vertical\n");
    //else printf("Horizontal\n");

    return direction;
}

/// <summary>
/// PEXCapacitor
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXCapacitor::PEXCapacitor() : PEXItem() {
}
PEXCapacitor::PEXCapacitor(const std::string& name_, const node& node1_, const node& node2_, const double& value_) :
    PEXItem(node1_, node2_, value_, name_) {
}
PEXCapacitor::~PEXCapacitor() {
}

void PEXCapacitor::print() {
    PEXItem::print();
    printf("Capacitor Value = %10.5e\n\n", this->getValue());
}

/// <summary>
/// PEXResistorDataManager
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXResistorDataManager::PEXResistorDataManager() {
    this->resistors = {};
    this->file_path = "";
    this->max_resistor_vertical = std::numeric_limits<double>::min();
    this->min_resistor_vertical = std::numeric_limits<double>::max();
    this->max_resistor_horizontal = std::numeric_limits<double>::min();
    this->min_resistor_horizontal = std::numeric_limits<double>::max();
}

PEXResistorDataManager::~PEXResistorDataManager() {
    printf("\n\n\t~PEXDataManager\n");
    this->resistors.clear();
}

void PEXResistorDataManager::clear() {
    this->resistors.clear();
}

void PEXResistorDataManager::loadData(const std::string file_path) {
    if (!QFile::exists(file_path.c_str())) {
        cerr << "Error! " << file_path << " is not exist!!\n";
        return;
    }

    this->file_path = file_path;
    rapidcsv::Document infile(file_path, rapidcsv::LabelParams(-1, -1));

    string item_name{}, node1_lvl{}, node2_lvl{};
    node node1{}, node2{};
    string description{};
    double value = 0.0;

    size_t line_count = infile.GetRowCount();
    for (size_t i = 1; i < line_count; ++i) {
        vector<string> line = infile.GetRow<string>(i);

        item_name = line[PEXINFO_INDEX::PEXINFO_INDEX_NAME];
        if (item_name[0] != 'R') continue;

        node1.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_NAME];
        node1.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_X]);
        node1.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_Y]);
        node1.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZSTART]);
        node1.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZEND]);
        node1.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_NUMBER]);
        node1.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_DATATYPE]);

        node2.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_NAME];
        node2.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_X]);
        node2.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_Y]);
        node2.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZSTART]);
        node2.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZEND]);
        node2.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_NUMBER]);
        node2.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_DATATYPE]);

        value = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_VALUE]);

        node1_lvl = line[PEXINFO_INDEX_NODE1_LVL];
        node2_lvl = line[PEXINFO_INDEX_NODE2_LVL];


        if (node1_lvl == "RX") {
            node1.x = node2.x;
            node1.y = node2.y;
        }

        description = line[PEXINFO_INDEX::PEXINFO_INDEX_DESCRIPTION];
        PEXResDirection resistor_direction = PEXResistor::checkDirectionFromDescription(description);
        if (value > 0) updateMinMaxRes(value, resistor_direction); //烙狼狼 内靛, 0焊促 累篮 历亲篮 公矫
        this->resistors.push_back(PEXResistor(item_name, node1, node2, value, resistor_direction));
    }
}

inline void PEXResistorDataManager::updateMinMaxRes(const double& new_value, const PEXResDirection direction) {
    if (direction == PEXResDirection::RES_DIRECTION_VERTICAL) {
        if (this->min_resistor_vertical > new_value) this->min_resistor_vertical = new_value;
        if (this->max_resistor_vertical < new_value) this->max_resistor_vertical = new_value;
    }
    else {
        if (this->min_resistor_horizontal > new_value) this->min_resistor_horizontal = new_value;
        if (this->max_resistor_horizontal < new_value) this->max_resistor_horizontal = new_value;
    }

}

void PEXResistorDataManager::printData() {
    for (auto item : this->resistors) {
        item.print();
    }
    printf("##Resistor Count : %lld, Vertical Res Max = %10.5f, Min = %10.5f, Horizontal Res Max = %10.5f, Min = %10.5f\n",
           this->resistors.size(),
           this->getMaxResistorVerticalValue(), this->getMinResistorVerticalValue(),
           this->getMaxResistorHorizontalValue(), this->getMinResistorHorizontalValue());
}


/// <summary>
/// PEXCapacitorDataManager
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXCapacitorDataManager::PEXCapacitorDataManager() {
    this->capasitors = {};
    this->file_path = "";
    this->max_capacitor = std::numeric_limits<double>::min();
    this->min_capacitor = std::numeric_limits<double>::max();
}

PEXCapacitorDataManager::~PEXCapacitorDataManager() {
    this->capasitors.clear();
}

void PEXCapacitorDataManager::clear() {
    this->capasitors.clear();
}

void PEXCapacitorDataManager::loadData(const std::string file_path) {
    if (!QFile::exists(file_path.c_str())) {
        cerr << "Error! " << file_path << " is not exist!!\n";
        return;
    }

    this->file_path = file_path;
    rapidcsv::Document infile(file_path, rapidcsv::LabelParams(-1, -1));

    string item_name{}, node1_lvl{}, node2_lvl{};
    node node1{}, node2{};
    string description{};
    double value = 0.0;

    size_t line_count = infile.GetRowCount();
    for (size_t i = 1; i < line_count; ++i) {
        vector<string> line = infile.GetRow<string>(i);

        item_name = line[PEXINFO_INDEX::PEXINFO_INDEX_NAME];
        if (item_name[0] != 'C') continue;

        node1.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_NAME];
        node1.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_X]);
        node1.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_Y]);
        node1.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZSTART]);
        node1.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZEND]);
        node1.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_NUMBER]);
        node1.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_DATATYPE]);

        node2.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_NAME];
        node2.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_X]);
        node2.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_Y]);
        node2.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZSTART]);
        node2.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZEND]);
        node2.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_NUMBER]);
        node2.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_DATATYPE]);

        value = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_VALUE]);

        node1_lvl = line[PEXINFO_INDEX_NODE1_LVL];
        node2_lvl = line[PEXINFO_INDEX_NODE2_LVL];

        updateMinMaxCap(value);
        this->capasitors.push_back(PEXCapacitor(item_name, node1, node2, value));
    }
}


inline void PEXCapacitorDataManager::updateMinMaxCap(const double& new_value) {
    if (this->min_capacitor > new_value) this->min_capacitor = new_value;
    if (this->max_capacitor < new_value) this->max_capacitor = new_value;
}


void PEXCapacitorDataManager::printData() {

    std::cout << "\n\nPEX Capacitors\n";
    for (auto item : this->capasitors) {
        item.print();
    }
    printf("##Capacitor Count : %lld, Max cap = %10.5e, Min cap = %10.5e\n",
           this->capasitors.size(), this->getMaxCapacitorValue(), this->getMinCapacitorValue());
}


void testPEXData() {
    PEXResistorDataManager resistor_data;
    resistor_data.loadData("Data/MVP_PEX_RC_r1_0130_0208version.csv");
    resistor_data.printData();

    PEXCapacitorDataManager capacitor_data;
    capacitor_data.loadData("Data/MVP_PEX_RC_r1_0130_0208version.csv");
    capacitor_data.printData();
}
::::./Rendering/Src/PEXResistorModel.cpp::::#include "PEXResistorModel.h"

#include <iostream>
#include <string>
#include <vector>

#include "LayoutPEXData.h"

#include <QFile>


PEXResistorModel::PEXResistorModel(LveDevice& device, MODEL_TYPE model_type, const std::string& data_file)
    : LveModel(device, model_type), pex_data{} {
    this->res_cube_thickness = 0.005;
    this->makeRenderingData(data_file);
    this->createBuffers();
}

PEXResistorModel::~PEXResistorModel() {
    this->pex_data.clear();
}

void PEXResistorModel::makeRenderingData(const std::string& file_path) {
    if (!QFile::exists(file_path.c_str())) {
        std::cerr << "Error! " << file_path << " is not exist!!\n";
        return;
    }

    loadData(file_path);
    makeCubes();
    makeCubeVertices();
    makeVertices();
    makeIndices();

    printf("\nPEX Resistor\n");
    printf("\tresistor count      : %lld\n", this->pex_data.getResistors().size());
    printf("\tcube_info count     : %lld\n", this->cube_infos.size());
    printf("\tcube_vertices count : %lld\n", this->cube_vertices.size());
    printf("\tVertices count      : %lld\n", this->vertices.size());
    printf("\tIndices count       : %lld\n", this->indices_face.size());

}

void PEXResistorModel::loadData(const std::string& file_path) {
    this->pex_data.loadData(file_path);
    //this->pex_data.printData();
}

void PEXResistorModel::makeCubes() {
    std::vector<PEXResistor>& resistors = this->pex_data.getResistors();
    cube_info cur_cube{};
    for (auto cur_res : resistors) {
        this->makeCube(cur_res, cur_cube, cur_res.getDirection());
        this->cube_infos.push_back(cur_cube);
    }
}

void PEXResistorModel::makeCube(const PEXResistor& res, cube_info& cube, PEXResDirection res_direction) {
    if (res_direction == RES_DIRECTION_VERTICAL) {
        cube.minx = res.node1.x - this->res_cube_thickness;
        cube.maxx = res.node1.x + this->res_cube_thickness;
        cube.miny = res.node1.y - this->res_cube_thickness;
        cube.maxy = res.node1.y + this->res_cube_thickness;
        cube.minz = res.node1.z_end;
        cube.maxz = res.node2.z_start;
    }
    else if (res_direction == RES_DIRECTION_HORIZONTAL) {
        if (res.node1.x == res.node2.x) {//run-length direction : y
            cube.minx = res.node1.x - this->res_cube_thickness;
            cube.maxx = res.node1.x + this->res_cube_thickness;
            cube.miny = res.node1.y < res.node2.y ? res.node1.y : res.node2.y;
            cube.maxy = res.node1.y < res.node2.y ? res.node2.y : res.node1.y;
        }
        else if(res.node1.y == res.node2.y ) {//run-length direction : x
            cube.minx = res.node1.x < res.node2.x ? res.node1.x : res.node2.x;
            cube.maxx = res.node1.x < res.node2.x ? res.node2.x : res.node1.x;
            cube.miny = res.node1.y - this->res_cube_thickness;
            cube.maxy = res.node1.y + this->res_cube_thickness;
        }

        double midz = (res.node1.z_start + res.node1.z_end) * 0.5;
        cube.minz = midz - this->res_cube_thickness;
        cube.maxz = midz + this->res_cube_thickness;
    }
    else {
        std::cerr << "\nResistor has no direction\n";
    }
}


void PEXResistorModel::makeCubeVertices() {
    std::vector<cube_info>::const_iterator it;
    cube_vertex cur_cube_vertices;

    for (it = this->cube_infos.begin(); it != this->cube_infos.end(); ++it) {
        cur_cube_vertices.vertex[0] = { it->minx, it->maxy, it->maxz };
        cur_cube_vertices.vertex[1] = { it->minx, it->miny, it->maxz };
        cur_cube_vertices.vertex[2] = { it->maxx, it->miny, it->maxz };
        cur_cube_vertices.vertex[3] = { it->maxx, it->maxy, it->maxz };

        cur_cube_vertices.vertex[4] = { it->minx, it->maxy, it->minz };
        cur_cube_vertices.vertex[5] = { it->minx, it->miny, it->minz };
        cur_cube_vertices.vertex[6] = { it->maxx, it->miny, it->minz };
        cur_cube_vertices.vertex[7] = { it->maxx, it->maxy, it->minz };

        this->cube_vertices.push_back(cur_cube_vertices);
    }
}

void PEXResistorModel::makeVertices() {
    Vertex temp_vertex;

    double max_vertical_res = this->pex_data.getMaxResistorVerticalValue();
    //double min_vertical_res = this->pex_data.getMinResistorVerticalValue();
    double max_horizontal_res = this->pex_data.getMaxResistorHorizontalValue();
    //double min_horizontal_res = this->pex_data.getMinResistorHorizontalValue();
    double max_res = max_vertical_res > max_horizontal_res ? max_vertical_res : max_horizontal_res;

    std::vector<PEXResistor>::iterator cur_resistor = this->pex_data.getResistors().begin();
    double resistor_value{};
    PEXResDirection resistor_direction{};

    for (const auto& cur_cube : this->cube_vertices) {
        resistor_value = cur_resistor->getValue();
        resistor_direction = cur_resistor->getDirection();

        for (int i = 0; i < 8; ++i) {
            temp_vertex.position = {
                cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };
            if (resistor_direction == PEXResDirection::RES_DIRECTION_VERTICAL) {
                temp_vertex.color = { static_cast<float>(resistor_value / max_res), 0.0f, 0.0f };
            }
            else {
                temp_vertex.color = { 0.0f, 0.0f, static_cast<float>(resistor_value / max_res) };
            }
            vertices.push_back(temp_vertex);
        }//for i 0 to 8
        cur_resistor++;
    }//for auto cur_vertices : this->cubes_vertices
}


void PEXResistorModel::makeIndices() {
    size_t cube_count = this->cube_vertices.size();

    uint32_t start_idx = 0;
    std::vector<uint32_t>& indices = this->indices_face;
    for (size_t i = 0; i < cube_count; ++i) {
        start_idx = 8 * i;
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);//top

        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);//right

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);//front

        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);//bottom

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);//left

        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);//back
    }

}




::::./Rendering/Src/dtaorendersystem.cpp::::

#include <QVulkanWindow>
#include <QVulkanInstance>
#include <vulkan/vulkan.h>

#include <QFileDialog>

#include "dtaorendersystem.h"

#include "lve_model.hpp"
#include "LayoutModel.h"
#include "PEXResistorModel.h"
#include "PEXCapacitorModel.h"


DtaoRenderSystem::DtaoRenderSystem(LveWindow *w)
    : lveWindow(w)
{
    this->trans_info = {};
    qDebug() << "\n$$$$$ DtaoRenderSystem()";
}

DtaoRenderSystem::~DtaoRenderSystem()
{
    deleteSimpleRenderSystem();
    deleteLveDevice();
}

void DtaoRenderSystem::beginRenderPass(VkCommandBuffer command_buffer){
    const QSize sz = this->lveWindow->swapChainImageSize();

    VkClearColorValue clearColor = {{ 0, 0, 0, 1 }};
    VkClearDepthStencilValue clearDS = { 1, 0 };
    VkClearValue clearValues[3];
    memset(clearValues, 0, sizeof(clearValues));
    clearValues[0].color = clearValues[2].color = clearColor;
    clearValues[1].depthStencil = clearDS;

    VkRenderPassBeginInfo rpBeginInfo;
    memset(&rpBeginInfo, 0, sizeof(rpBeginInfo));
    rpBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    rpBeginInfo.renderPass = lveWindow->defaultRenderPass();
    rpBeginInfo.framebuffer = lveWindow->currentFramebuffer();
    rpBeginInfo.renderArea.extent.width = sz.width();
    rpBeginInfo.renderArea.extent.height = sz.height();
    rpBeginInfo.clearValueCount = lveWindow->sampleCountFlagBits() > VK_SAMPLE_COUNT_1_BIT ? 3 : 2;
    rpBeginInfo.pClearValues = clearValues;
    m_devFuncs->vkCmdBeginRenderPass(command_buffer, &rpBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

    VkViewport viewport;
    viewport.x = viewport.y = 0;
    viewport.width = sz.width();
    viewport.height = sz.height();
    viewport.minDepth = 0;
    viewport.maxDepth = 1;
    m_devFuncs->vkCmdSetViewport(command_buffer, 0, 1, &viewport);

    VkRect2D scissor;
    scissor.offset.x = scissor.offset.y = 0;
    scissor.extent.width = viewport.width;
    scissor.extent.height = viewport.height;
    m_devFuncs->vkCmdSetScissor(command_buffer, 0, 1, &scissor);
}

void DtaoRenderSystem::startNextFrame(){
    this->cameraController.moveCamera(
                1.0, this->camera, this->getRenderScale(), this->gameObjects);
    this->cameraController.moveCameraMouse(
                this->camera, this->getRenderScale(), this->gameObjects);

    VkCommandBuffer command_buffer = this->lveWindow->currentCommandBuffer();
    beginRenderPass(command_buffer);

    this->simpleRenderSystem->renderGameObjects(
                command_buffer, this->gameObjects, this->camera);

    m_devFuncs->vkCmdEndRenderPass(command_buffer);

    lveWindow->frameReady();
    lveWindow->requestUpdate(); // render continuously, throttled by the presentation rate
}

void DtaoRenderSystem::initResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::initResources()";
    createLveDevice();
    createSimpleRenderSystem();
    //if(!this->render_object_created) loadGameObjects();

    this->camera.setViewTarget(
                glm::vec3(1.0f,1.0f,1.0f),
                glm::vec3(0.0f, 0.0f, 0.0f),
                glm::vec3(0.0f, 0.0f, 1.0f));

    VkDevice dev = this->lveWindow->device();
    m_devFuncs = this->lveWindow->vulkanInstance()->deviceFunctions(dev);

    qDebug() << "\tDevice = " << this->lveDevice->device();

}

void DtaoRenderSystem::releaseResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::releaseResources()";

    deleteSimpleRenderSystem();
    deleteLveDevice();
}

void DtaoRenderSystem::initSwapChainResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::initSwapChainResources()";
    const QSize sz = this->lveWindow->swapChainImageSize();
    float aspect = sz.width()/(double)sz.height();
    this->camera.setPerspectiveProjection(glm::radians(50.f), aspect, 0.1f, 100.f);
}


void DtaoRenderSystem::releaseSwapChainResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::releaseSwapChainResources()";
}

void DtaoRenderSystem::createLveDevice(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::createLveDevice()";
    this->lveDevice = new LveDevice(this->lveWindow, this->lveWindow->vulkanInstance());
}

void DtaoRenderSystem::deleteLveDevice(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::deleteLveDevice()";
    delete this->lveDevice;
}

void DtaoRenderSystem::createSimpleRenderSystem(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::createSimpleRenderSystem()";
    VkRenderPass renderpass = this->lveWindow->defaultRenderPass();
    this->simpleRenderSystem = new SimpleRenderSystem(*this->lveDevice, renderpass);
}

void DtaoRenderSystem::deleteSimpleRenderSystem(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::deleteSimpleRenderSystem()";
    delete this->simpleRenderSystem;
}

void DtaoRenderSystem::createNewObject(MODEL_TYPE model_type, const std::string & file_path) {
    if( model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) createNewLayoutObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) createNewPEXCapObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) createNewPEXResObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_AXIS) createNewAxisObject(file_path);
}

void DtaoRenderSystem::createNewLayoutObject(const std::string & file_path){

    //Layout model
    std::string layout_info_file_path = file_path;
    std::shared_ptr<LayoutModel> model
            = std::make_unique<LayoutModel>(
                *this->lveDevice, MODEL_TYPE_LAYOUT, layout_info_file_path);
    model->opacity = 0.5f;

    LayoutDataManager* layout_data = model->getLayoutDataManager();
    this->trans_info.trans_x = static_cast<float>( layout_data->getMinX());
    this->trans_info.trans_y = static_cast<float>( layout_data->getMinY());
    this->trans_info.trans_z = static_cast<float>( layout_data->getMinZ());
    this->trans_info.scale = static_cast<float>( layout_data->getScale());

    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x, -this->trans_info.trans_y, -this->trans_info.trans_z};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
    this->render_object_created = true;
    this->layout_model = model;
}

void DtaoRenderSystem::createNewPEXResObject( const std::string & file_path){
    //PEX Resistor model
    std::string res_info_file_path = file_path;
    std::shared_ptr<PEXResistorModel> model
            = std::make_unique<PEXResistorModel>(
                *this->lveDevice, MODEL_TYPE_PEX_RESISTOR, res_info_file_path);

    //Resistor Object
    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x, -this->trans_info.trans_y, -this->trans_info.trans_z};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
}

void DtaoRenderSystem::createNewPEXCapObject( const std::string & file_path){
    //PEX Capacitor model
    std::string cap_info_file_path = file_path;
    std::shared_ptr<PEXCapacitorModel> model
            = std::make_unique<PEXCapacitorModel>(
                *this->lveDevice, MODEL_TYPE_PEX_CAPACITOR,
                cap_info_file_path, this->layout_model->getLayoutDataManager());

    //Capacitor Object
    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x, -this->trans_info.trans_y, -this->trans_info.trans_z};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
}

void DtaoRenderSystem::createNewAxisObject(const std::string & file_path){
    (void)(file_path);
    //Axis model
    std::shared_ptr<LveModel> model
            = std::make_unique<LveModel>(*this->lveDevice, MODEL_TYPE_AXIS);

    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {0.0f, 0.0f, 0.0f};
    new_object.transform.scale = { 1.0f, 1.0f, 1.0f };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
}

/*
void DtaoRenderSystem::loadGameObjects() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::loadGameObjects()";
    return;

    auto cube = LveGameObject::createGameObject();

    //Layout model
    std::string layout_info_file_path = "Rendering/Data/layout_input_data.csv";
    //std::string layout_info_file_path = "Rendering/Data/big_test_espin.csv";
    std::shared_ptr<LayoutModel> layout_model
            = std::make_unique<LayoutModel>(*this->lveDevice, MODEL_TYPE_LAYOUT, layout_info_file_path);
    layout_model->opacity = 0.5f;

    LayoutDataManager* layout_data = layout_model->getLayoutDataManager();
    float trans_x = static_cast<float>(layout_data->getMinX());
    float trans_y = static_cast<float>(layout_data->getMinY());
    float trans_z = static_cast<float>(layout_data->getMinZ());
    float scale = static_cast<float>(layout_data->getScale());

    this->render_scale = scale;

    //Axis model
    std::shared_ptr<LveModel> axis_model
            = std::make_unique<LveModel>(*this->lveDevice, MODEL_TYPE_AXIS);

    //PEX Resistor model
    std::string res_info_file_path = "Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv";
    std::shared_ptr<PEXResistorModel> res_model
            = std::make_unique<PEXResistorModel>(*this->lveDevice, MODEL_TYPE_PEX_RESISTOR, res_info_file_path);

    //PEX Capacitor model
    std::string cap_info_file_path = "Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv";
    std::shared_ptr<PEXCapacitorModel> cap_model
            = std::make_unique<PEXCapacitorModel>(*this->lveDevice, MODEL_TYPE_PEX_CAPACITOR, cap_info_file_path, layout_model->getLayoutDataManager());


    //Resistor Object
    cube = LveGameObject::createGameObject();
    cube.model = res_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Capacitor Object
    cube = LveGameObject::createGameObject();
    cube.model = cap_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Layout Object
    cube = LveGameObject::createGameObject();
    cube.model = layout_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Axis Object
    cube = LveGameObject::createGameObject();
    cube.model = axis_model;
    cube.transform.translation = { 0.0f, 0.0f, 0.0f };
    cube.transform.scale = { 1.0f, 1.0f, 1.0f };
    gameObjects.push_back(std::move(cube));

    this->render_object_created = true;
}
*/
::::./Rendering/Src/keyboard_movement_controller.cpp::::#include "keyboard_movement_controller.hpp"

#define GLM_ENABLE_EXPERIMENTAL

// std
#include <limits>
#include <iostream>

#include <glm/gtx/string_cast.hpp>
#include "lve_model.hpp"

void KeyboardMovementController::setAllMoveFlagOff() {
    camera_moving_flag.rotateLeft = false;
    camera_moving_flag.rotateRight = false;
    camera_moving_flag.moveForward = false;
    camera_moving_flag.moveBackward = false;
    camera_moving_flag.rotateForward = false;
    camera_moving_flag.rotateBackward = false;
}

void KeyboardMovementController::setMouseFlagOff() {
    camera_moving_flag.mouseLeft = false;
    camera_moving_flag.mouseRight = false;
}

void KeyboardMovementController::moveKeyPressed(Qt::Key key) {
    //setAllMoveFlagOff();
    if (key == camera_move_key.moveForward) camera_moving_flag.moveForward = true;
    if (key == camera_move_key.moveBackward) camera_moving_flag.moveBackward = true;
    if (key == camera_move_key.rotateRight) camera_moving_flag.rotateRight = true;
    if (key == camera_move_key.rotateLeft) camera_moving_flag.rotateLeft = true;
    if (key == camera_move_key.rotateForward) camera_moving_flag.rotateForward = true;
    if (key == camera_move_key.rotateBackward) camera_moving_flag.rotateBackward = true;
    if (key == camera_move_key.moveUp) camera_moving_flag.moveUp = true;
    if (key == camera_move_key.moveDown) camera_moving_flag.moveDown = true;
    if (key == camera_move_key.moveLeft) camera_moving_flag.moveLeft = true;
    if (key == camera_move_key.moveRight) camera_moving_flag.moveRight = true;

}

void KeyboardMovementController::moveKeyReleased(Qt::Key key) {
    //setAllMoveFlagOff();
    if (key == camera_move_key.moveForward) camera_moving_flag.moveForward = false;
    if (key == camera_move_key.moveBackward) camera_moving_flag.moveBackward = false;
    if (key == camera_move_key.rotateRight) camera_moving_flag.rotateRight = false;
    if (key == camera_move_key.rotateLeft) camera_moving_flag.rotateLeft = false;
    if (key == camera_move_key.rotateForward) camera_moving_flag.rotateForward = false;
    if (key == camera_move_key.rotateBackward) camera_moving_flag.rotateBackward = false;
    if (key == camera_move_key.moveUp) camera_moving_flag.moveUp = false;
    if (key == camera_move_key.moveDown) camera_moving_flag.moveDown = false;
    if (key == camera_move_key.moveLeft) camera_moving_flag.moveLeft = false;
    if (key == camera_move_key.moveRight) camera_moving_flag.moveRight = false;
}

void KeyboardMovementController::setMousePosition(QPoint position, int mode) {
    mouse_position.currentPosition = position;
    if (mode == 1) {
        mouse_position.pressPosition = position;
        mouse_position.currentPosition = position;
        xpos_prev = position.x();
        ypos_prev = position.y();
    }
    if (mode == 2) {
        mouse_position.releasePosition = position;
        mouse_position.currentPosition = position;
    }

    //qDebug()<< position.y();
}

void KeyboardMovementController::setMouseScroll(QPoint scroll) {
    mouse_position.scroll = scroll;
}

void KeyboardMovementController::moveButtonPressed(Qt::MouseButtons buttons) {
    setMouseFlagOff();
    if (buttons == camera_move_key.mouseLeft) camera_moving_flag.mouseLeft = true;
    if (buttons == camera_move_key.mouseRight) camera_moving_flag.mouseRight = true;


}

void KeyboardMovementController::moveButtonReleased(Qt::MouseButtons buttons) {
    setMouseFlagOff();
    if (buttons == camera_move_key.mouseLeft) camera_moving_flag.mouseLeft = true;
    if (buttons == camera_move_key.mouseRight) camera_moving_flag.mouseRight = true;
    //qDebug()<<
}

void KeyboardMovementController::moveCamera(
    float dt, LveCamera& camera, float render_scale, std::vector<LveGameObject>& gameObjects) {
    float scale = 0.0f;
    float rotate_lr = 0.0f;
    float rotate_ud = 0.0f;
    float obj_scale = 2.0f / render_scale;

    if (camera_moving_flag.moveForward) scale = 1.0f + 0.01f * obj_scale;
    else if (camera_moving_flag.moveBackward) scale = 1.0f - 0.01f * obj_scale;

    if (camera_moving_flag.rotateRight) rotate_lr = -0.1f * obj_scale;
    else if (camera_moving_flag.rotateLeft) rotate_lr = 0.1f * obj_scale;

    if (camera_moving_flag.rotateForward) rotate_ud = -0.1f * obj_scale;
    else if (camera_moving_flag.rotateBackward) rotate_ud = 0.1f * obj_scale;
    //if (glfwGetMouseButton(window, camera_move_key.mouseLeft) == GLFW_PRESS) scale = 1.0f + 0.0001f * obj_scale;
    //if (glfwGetMouseButton(window, camera_move_key.mouseRight) == GLFW_PRESS) scale = 1.0f - 0.0001f * obj_scale;

    if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr), glm::vec3(0.0f, 0.0f, 1.0f));
        //std::cout << glm::to_string(camera.rotation_d) << '\n';
    }

    glm::vec3 direction{ camera.viewMatrix[0][2], camera.viewMatrix[1][2], 0 };
    const glm::vec3 u{ glm::normalize(glm::cross(direction, glm::normalize(glm::cross(direction, glm::vec3{0,1,0})))) };
    const glm::vec3 v{ glm::normalize(glm::cross(u,glm::vec3{0,0,1})) };

    if (glm::dot(rotate_ud, rotate_ud) > std::numeric_limits<float>::epsilon()) {

        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_ud), u);
    }

    if (glm::dot(scale, scale) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(scale, scale, scale));
    }


    glm::vec3 moveDir{ 0.f };
    camera.decomposeView(camera.getView());

    if (camera.rotation_d.x * camera.rotation_d.y > 0) {
        if (camera_moving_flag.moveRight) moveDir -= u;
        if (camera_moving_flag.moveLeft)  moveDir += u;
        if (camera_moving_flag.moveUp)  moveDir += v;
        if (camera_moving_flag.moveDown)  moveDir -= v;
    }
    else {
        if (camera_moving_flag.moveRight) moveDir += u;
        if (camera_moving_flag.moveLeft)  moveDir -= u;
        if (camera_moving_flag.moveUp)  moveDir -= v;
        if (camera_moving_flag.moveDown)  moveDir += v;
    }


    if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon()) {
        //camera.decomposeView(camera.getView());
        //std::cout << glm::to_string(camera.rotation_d) << '\n';
        for (auto& gameobject : gameObjects) {
            if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
                gameobject.transform.translation += obj_scale * moveSpeed * dt * glm::normalize(moveDir);
                //camera.viewMatrix = glm::translate(camera.getView(), moveSpeed * dt * moveDir);
            }
        }

    }
}

void KeyboardMovementController::moveCameraMouse(LveCamera& camera, float render_scale, std::vector<LveGameObject>& gameObjects) {
    if (camera_moving_flag.mouseRight)
    {
        std::cout << "rotation enable" << std::endl;
        float rotate_lr = 0.0f;
        float rotate_ud = 0.0f;

        rotate_lr = mouse_position.currentPosition.x() - xpos_prev;
        rotate_ud = mouse_position.currentPosition.y() - ypos_prev;

        glm::vec3 direction{ camera.viewMatrix[0][2], camera.viewMatrix[1][2], 0 };
        const glm::vec3 u{ glm::normalize(glm::cross(direction,glm::normalize(glm::cross(direction, glm::vec3{0,1,0})))) };
        const glm::vec3 v{ glm::normalize(glm::cross(u,glm::vec3{0,0,1})) };

        if (glm::dot(rotate_ud, rotate_ud) > std::numeric_limits<float>::epsilon()) {
            if (camera.viewMatrix[1][0] > 0) {
                camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_ud*0.5f), u);
            }
            else {
                camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(-rotate_ud*0.5f), u);
            }

        }

        if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
            camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr*0.5f), glm::vec3(0.0f, 0.0f, 1.0f));
            //std::cout << glm::to_string(camera.rotation_d) << '\n';
        }

        xpos_prev = mouse_position.currentPosition.x();
        ypos_prev = mouse_position.currentPosition.y();
    }
    else if (camera_moving_flag.mouseLeft)
    {
        float camera_scale = sqrt(pow(camera.viewMatrix[0][2], 2) + pow(camera.viewMatrix[1][2], 2) + pow(camera.viewMatrix[2][2], 2));
        float obj_scale = gameObjects.begin()->transform.scale.x;

        float scale = 2.0f / camera_scale / obj_scale;
        glm::vec3 moveDir{ 0.f };
        float movement_lr = mouse_position.currentPosition.x() - xpos_prev;
        float movement_ud = mouse_position.currentPosition.y() - ypos_prev;

        glm::vec3 direction{ camera.viewMatrix[0][2], camera.viewMatrix[1][2], 0 };
        const glm::vec3 u{ glm::normalize(glm::cross(direction, glm::vec3{0,0,1})) };
        const glm::vec3 v{ glm::normalize(glm::cross(u,glm::vec3{0,0,1})) };


        if (camera.viewMatrix[2][2] > 0 && camera.viewMatrix[2][1] > 0) {

            moveDir -= u * (movement_lr);
            moveDir -= v * (movement_ud);
        }
        else if (camera.viewMatrix[2][2] < 0 && camera.viewMatrix[2][1] > 0) {
            moveDir -= u * (movement_lr);
            moveDir += v * (movement_ud);
        }
        else if (camera.viewMatrix[2][2] < 0 && camera.viewMatrix[2][1] < 0) {
            moveDir += u * (movement_lr);
            moveDir -= v * (movement_ud);
        }
        else {
            moveDir += u * (movement_lr);
            moveDir += v * (movement_ud);
        }


        if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon()) {

            //camera.decomposeView(camera.getView());
            //std::cout << glm::to_string(camera.rotation_d) << '\n';
            for (auto& gameobject : gameObjects) {
                if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
                    gameobject.transform.translation += scale * 0.01f * glm::normalize(moveDir);
                    //camera.viewMatrix = glm::translate(camera.getView(), moveSpeed * dt * moveDir);
                }
            }
        }

        xpos_prev = mouse_position.currentPosition.x();
        ypos_prev = mouse_position.currentPosition.y();
    }

    if (mouse_position.scroll.y() != 0) {
        float scale_mouse = 1.0f + 0.1f * (mouse_position.scroll.y() / 120);
        camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(scale_mouse, scale_mouse, scale_mouse));
        mouse_position.scroll.setY(0);
    }
}









/*
void KeyboardMovementController::moveCamera(
        Qt::Key key, float dt, LveCamera& camera,
        float render_scale) {

    qDebug()<< "Pressed Key @ KeyboardMovementController::moveCamera : " << key;

    float scale = 0.0f;
    float rotate_lr = 0.0f;
    float rotate_ud = 0.0f;
    float obj_scale = 2.0f / render_scale;

    if (key == camera_move_key.moveForward) scale = 1.0f + 0.01f * obj_scale;
    if (key == camera_move_key.moveBackward) scale = 1.0f - 0.01f * obj_scale;
    if (key == camera_move_key.rotateRight) rotate_lr = -0.1f * obj_scale;
    if (key == camera_move_key.rotateLeft) rotate_lr = 0.1f * obj_scale;
    if (key == camera_move_key.rotateForward) rotate_ud = -0.1f * obj_scale;
    if (key == camera_move_key.rotateBackward) rotate_ud = 0.1f * obj_scale;
    //if (glfwGetMouseButton(window, camera_move_key.mouseLeft) == GLFW_PRESS) scale = 1.0f + 0.0001f * obj_scale;
    //if (glfwGetMouseButton(window, camera_move_key.mouseRight) == GLFW_PRESS) scale = 1.0f - 0.0001f * obj_scale;

    if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr), glm::vec3(0.0f, 0.0f, 1.0f));
        //std::cout << glm::to_string(camera.rotation_d) << '\n';
    }

    glm::vec3 direction{ camera.viewMatrix[0][2], camera.viewMatrix[1][2], 0 };
    const glm::vec3 u{ glm::normalize(glm::cross(direction, glm::normalize(glm::cross(direction, glm::vec3{0,1,0})))) };
    const glm::vec3 v{ glm::normalize(glm::cross(u,glm::vec3{0,0,1})) };

    if (glm::dot(rotate_ud, rotate_ud) > std::numeric_limits<float>::epsilon()) {

        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_ud), u);
    }

    if (glm::dot(scale, scale) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(scale, scale, scale));
    }
}


void KeyboardMovementController::visibleSetting(GLFWwindow* window, std::vector<LveGameObject>& gameObjects) {
    MODEL_TYPE target_model_type = MODEL_TYPE::MODEL_TYPE_DEFAULT;
    bool opacity_mode = false;
    double opacity = 0.0;
    if (glfwGetKey(window, model_visible_set.layout_key) == GLFW_PRESS) model_visible_set.layout_key_pressed = true;
    else if (glfwGetKey(window, model_visible_set.resistor_key) == GLFW_PRESS) model_visible_set.resistor_key_pressed = true;
    else if (glfwGetKey(window, model_visible_set.capacitor_key) == GLFW_PRESS) model_visible_set.capacitor_key_pressed = true;
    else if (glfwGetKey(window, model_visible_set.axis_key) == GLFW_PRESS) model_visible_set.axis_key_pressed = true;
    else if (glfwGetKey(window, model_visible_set.opacity_plus_key) == GLFW_PRESS) model_visible_set.opacity_plus_key_pressed = true;
    else if (glfwGetKey(window, model_visible_set.opacity_minus_key) == GLFW_PRESS) model_visible_set.opacity_minus_key_pressed = true;

    if (glfwGetKey(window, model_visible_set.layout_key) == GLFW_RELEASE && model_visible_set.layout_key_pressed) {
        model_visible_set.layout_key_pressed = false;
        target_model_type = MODEL_TYPE::MODEL_TYPE_LAYOUT;
    }
    else if (glfwGetKey(window, model_visible_set.resistor_key) == GLFW_RELEASE && model_visible_set.resistor_key_pressed) {
        model_visible_set.resistor_key_pressed = false;
        target_model_type = MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR;
    }
    else if (glfwGetKey(window, model_visible_set.capacitor_key) == GLFW_RELEASE && model_visible_set.capacitor_key_pressed) {
        model_visible_set.capacitor_key_pressed = false;
        target_model_type = MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR;
    }
    else if (glfwGetKey(window, model_visible_set.axis_key) == GLFW_RELEASE && model_visible_set.axis_key_pressed) {
        model_visible_set.axis_key_pressed = false;
        target_model_type = MODEL_TYPE::MODEL_TYPE_AXIS;
    }
    else if (glfwGetKey(window, model_visible_set.opacity_plus_key) == GLFW_RELEASE && model_visible_set.opacity_plus_key_pressed) {
        model_visible_set.opacity_plus_key_pressed = false;
        opacity_mode = true;
        opacity = 0.1f;
        target_model_type = MODEL_TYPE::MODEL_TYPE_LAYOUT;
    }
    else if (glfwGetKey(window, model_visible_set.opacity_minus_key) == GLFW_RELEASE && model_visible_set.opacity_minus_key_pressed) {
        model_visible_set.opacity_minus_key_pressed = false;
        opacity_mode = true;
        opacity = -0.1f;
        target_model_type = MODEL_TYPE::MODEL_TYPE_LAYOUT;
    }

    if (target_model_type != MODEL_TYPE::MODEL_TYPE_DEFAULT) {
        for (auto& obj : gameObjects) {
            if (obj.model->getModelType() == target_model_type) {
                if (opacity_mode) obj.model->updateOpacity(opacity);
                else obj.model->toggleVisible();
            }
        }
    }
}

void KeyboardMovementController::moveCamera(GLFWwindow* window, float dt, LveCamera& camera, std::vector<LveGameObject>& gameObjects) {

    float scale = 0.0f;
    float rotate_lr = 0.0f;
    float rotate_ud = 0.0f;
    float obj_scale = 2.0f / gameObjects.begin()->transform.scale.x;

    if (glfwGetKey(window, camera_move_key.moveForward) == GLFW_PRESS) scale = 1.0f + 0.0001f * obj_scale;
    if (glfwGetKey(window, camera_move_key.moveBackward) == GLFW_PRESS) scale = 1.0f - 0.0001f * obj_scale;
    if (glfwGetKey(window, camera_move_key.moveRight) == GLFW_PRESS) rotate_lr = -0.001f * obj_scale;
    if (glfwGetKey(window, camera_move_key.moveLeft) == GLFW_PRESS) rotate_lr = 0.001f * obj_scale;
    if (glfwGetKey(window, camera_move_key.moveUp) == GLFW_PRESS) rotate_ud = -0.001f * obj_scale;
    if (glfwGetKey(window, camera_move_key.moveDown) == GLFW_PRESS) rotate_ud = 0.001f * obj_scale;
    //if (glfwGetMouseButton(window, camera_move_key.mouseLeft) == GLFW_PRESS) scale = 1.0f + 0.0001f * obj_scale;
    //if (glfwGetMouseButton(window, camera_move_key.mouseRight) == GLFW_PRESS) scale = 1.0f - 0.0001f * obj_scale;

    if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr), glm::vec3(0.0f, 0.0f, 1.0f));
        //std::cout << glm::to_string(camera.rotation_d) << '\n';
    }

    glm::vec3 direction{ camera.viewMatrix[0][2], camera.viewMatrix[1][2], 0 };
    const glm::vec3 u{ glm::normalize(glm::cross(direction, glm::normalize(glm::cross(direction, glm::vec3{0,1,0})))) };
    const glm::vec3 v{ glm::normalize(glm::cross(u,glm::vec3{0,0,1})) };

    if (glm::dot(rotate_ud, rotate_ud) > std::numeric_limits<float>::epsilon()) {

        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_ud), u);
    }

    if (glm::dot(scale, scale) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(scale, scale, scale));
    }


    glm::vec3 moveDir{ 0.f };
    camera.decomposeView(camera.getView());
    if (camera.rotation_d.x * camera.rotation_d.y > 0) {
        if (glfwGetKey(window, keys.lookRight) == GLFW_PRESS) moveDir -= u;
        if (glfwGetKey(window, keys.lookLeft) == GLFW_PRESS) moveDir += u;
        if (glfwGetKey(window, keys.lookUp) == GLFW_PRESS) moveDir += v;
        if (glfwGetKey(window, keys.lookDown) == GLFW_PRESS) moveDir -= v;
    }
    else {
        if (glfwGetKey(window, keys.lookRight) == GLFW_PRESS) moveDir += u;
        if (glfwGetKey(window, keys.lookLeft) == GLFW_PRESS) moveDir -= u;
        if (glfwGetKey(window, keys.lookUp) == GLFW_PRESS) moveDir -= v;
        if (glfwGetKey(window, keys.lookDown) == GLFW_PRESS) moveDir += v;
    }


    if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon()) {
        //camera.decomposeView(camera.getView());
        //std::cout << glm::to_string(camera.rotation_d) << '\n';
        for (auto& gameobject : gameObjects) {
            if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
                gameobject.transform.translation += obj_scale * moveSpeed * dt * glm::normalize(moveDir);
                //camera.viewMatrix = glm::translate(camera.getView(), moveSpeed * dt * moveDir);
            }
        }

    }
}

void KeyboardMovementController::moveInPlaneXZ(
        GLFWwindow* window, float dt, std::vector<LveGameObject>& gameObjects) {
    glm::vec3 rotate{ 0 };

    //std::cout << "moveInPlaneXZ\n";
    //if (glfwGetKey(window, keys.lookRight) == GLFW_PRESS) rotate.y += 1.f;
    //if (glfwGetKey(window, keys.lookLeft) == GLFW_PRESS) rotate.y -= 1.f;
    //if (glfwGetKey(window, keys.lookUp) == GLFW_PRESS) rotate.x += 1.f;
    //if (glfwGetKey(window, keys.lookDown) == GLFW_PRESS) rotate.x -= 1.f;
    //if (glfwGetMouseButton(window, keys.mouseLeft) == GLFW_PRESS) {
    //    // glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    //
    //    int width, height;
    //    glfwGetWindowSize(window, &width, &height);
    //
    //
    //    oldXPos = mouseX, oldYPos = mouseY;
    //
    //    glfwGetCursorPos(window, &mouseX, &mouseY);
    //
    //    float xDelta, yDelta;
    //    xDelta = (mouseX - oldXPos) / width;
    //    yDelta = (mouseY - oldYPos) / height;
    //
    //    rotate.y -= xDelta * 1000;
    //    rotate.x += yDelta * 1000 * height / width;
    //
    //    // std::cout <<"old" << oldXPos << " " << oldYPos << "\n";
    //    // std::cout << mouseX << " " << mouseY << "\n";
    //}
    //if (glfwGetMouseButton(window, keys.mouseLeft) == GLFW_RELEASE) {
    //    glfwGetCursorPos(window, &mouseX, &mouseY);
    //    oldXPos = mouseX, oldYPos = mouseY;
    //};

    //if (glm::dot(rotate, rotate) > std::numeric_limits<float>::epsilon()) {
    //
    //    gameObject.transform.rotation += lookSpeed * dt * rotate;
    //}

    // limit pitch values between about +/- 85ish degrees
    //gameObject.transform.rotation.x = glm::clamp(gameObject.transform.rotation.x, -1.5f, 1.5f);
    //gameObject.transform.rotation.y = glm::mod(gameObject.transform.rotation.y, glm::two_pi<float>());

    float yaw = 20.f;
    const glm::vec3 forwardDir{ 0.f, -1.f, 0.f };
    const glm::vec3 rightDir{ 1.f, 0.f, 0.f };
    const glm::vec3 upDir{ 0.f, -1.f, 0.f };

    glm::vec3 moveDir{ 0.f };
    if (glfwGetKey(window, keys.moveForward) == GLFW_PRESS) moveDir += forwardDir;
    if (glfwGetKey(window, keys.moveBackward) == GLFW_PRESS) moveDir -= forwardDir;
    if (glfwGetKey(window, keys.lookRight) == GLFW_PRESS) moveDir += rightDir;
    if (glfwGetKey(window, keys.lookLeft) == GLFW_PRESS) moveDir -= rightDir;
    if (glfwGetKey(window, keys.lookUp) == GLFW_PRESS) moveDir += forwardDir;
    if (glfwGetKey(window, keys.lookDown) == GLFW_PRESS) moveDir -= forwardDir;

    if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon()) {
        for (auto& gameobject : gameObjects) {
            if (gameobject.model->getModelType() == MODEL_TYPE::MODEL_TYPE_AXIS) {
                //gameobject.transform.translation += moveSpeed * dt * glm::normalize(moveDir);
            }


        }

    }
}
*/
::::./Rendering/Src/lve_camera.cpp::::#include "lve_camera.hpp"

// std
#include <cassert>
#include <limits>
#include <glm/glm.hpp> //vec3, vec4, ivec4, mat4
#include <glm/gtc/matrix_transform.hpp> //translate, rotate, scale, perspective 
#include <glm/gtc/type_ptr.hpp> //value_ptr


void LveCamera::setOrthographicProjection(
    float left, float right, float top, float bottom, float near, float far) {
  projectionMatrix = glm::mat4{1.0f};
  projectionMatrix[0][0] = 2.f / (right - left);
  projectionMatrix[1][1] = 2.f / (bottom - top);
  projectionMatrix[2][2] = 1.f / (far - near);
  projectionMatrix[3][0] = -(right + left) / (right - left);
  projectionMatrix[3][1] = -(bottom + top) / (bottom - top);
  projectionMatrix[3][2] = -near / (far - near);
}

void LveCamera::setPerspectiveProjection(float fovy, float aspect, float near, float far) {
    projectionMatrix = glm::perspective(fovy, aspect, near, far);
    //  assert(glm::abs(aspect - std::numeric_limits<float>::epsilon()) > 0.0f);
    //  const float tanHalfFovy = tan(fovy / 2.f);
    //  projectionMatrix = glm::mat4{0.0f};
    //  projectionMatrix[0][0] = 1.f / (aspect * tanHalfFovy);
    //  projectionMatrix[1][1] = 1.f / (tanHalfFovy);
    //  projectionMatrix[2][2] = far / (far - near);
    //  projectionMatrix[2][3] = 1.f;
    //  projectionMatrix[3][2] = -(far * near) / (far - near);
}

void LveCamera::setViewYXZ(glm::vec3 position, glm::vec3 rotation) {
    const float c3 = glm::cos(rotation.z);
    const float s3 = glm::sin(rotation.z);
    const float c2 = glm::cos(rotation.x);
    const float s2 = glm::sin(rotation.x);
    const float c1 = glm::cos(rotation.y);
    const float s1 = glm::sin(rotation.y);
    const glm::vec3 u{ (c1 * c3 + s1 * s2 * s3), (c2 * s3), (c1 * s2 * s3 - c3 * s1) };
    const glm::vec3 v{ (c3 * s1 * s2 - c1 * s3), (c2 * c3), (c1 * c3 * s2 + s1 * s3) };
    const glm::vec3 w{ (c2 * s1), (-s2), (c1 * c2) };
    viewMatrix = glm::mat4{ 1.f };
    viewMatrix[0][0] = u.x;
    viewMatrix[1][0] = u.y;
    viewMatrix[2][0] = u.z;
    viewMatrix[0][1] = v.x;
    viewMatrix[1][1] = v.y;
    viewMatrix[2][1] = v.z;
    viewMatrix[0][2] = w.x;
    viewMatrix[1][2] = w.y;
    viewMatrix[2][2] = w.z;
    viewMatrix[3][0] = -glm::dot(u, position);
    viewMatrix[3][1] = -glm::dot(v, position);
    viewMatrix[3][2] = -glm::dot(w, position);
}

void LveCamera::setViewDirection(glm::vec3 position, glm::vec3 direction, glm::vec3 up) {
  const glm::vec3 w{glm::normalize(direction)};
  const glm::vec3 u{glm::normalize(glm::cross(w, up))};
  const glm::vec3 v{glm::cross(w, u)};

  viewMatrix = glm::mat4{1.f};
  viewMatrix[0][0] = u.x;
  viewMatrix[1][0] = u.y;
  viewMatrix[2][0] = u.z;
  viewMatrix[0][1] = v.x;
  viewMatrix[1][1] = v.y;
  viewMatrix[2][1] = v.z;
  viewMatrix[0][2] = w.x;
  viewMatrix[1][2] = w.y;
  viewMatrix[2][2] = w.z;
  viewMatrix[3][0] = -glm::dot(u, position);
  viewMatrix[3][1] = -glm::dot(v, position);
  viewMatrix[3][2] = -glm::dot(w, position);
}

void LveCamera::setViewTarget(glm::vec3 position, glm::vec3 target, glm::vec3 up) {
    viewMatrix = glm::lookAt(position, target, up);
    //setViewDirection(position, target - position, up);
}

void LveCamera::decomposeView(glm::mat4 viewMat) {
    glm::decompose(viewMat, scale_d, rotation_d, translation_d, skew_d, perspective_d);
    rotation_d = glm::conjugate(rotation_d);
}

::::./Rendering/Src/lve_device.cpp::::
#include <vulkan/vulkan.h>
#include "lve_device.hpp"



// std headers
#include <cstring>
#include <iostream>
#include <set>
#include <unordered_set>


// class member functions
LveDevice::LveDevice(LveWindow* window_, QVulkanInstance* qvk_instance_)
    : window(window_), qvk_instance(qvk_instance_) {
    qDebug() << "\n$$$$$ LveDevice()";
    createInstance();
    //setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createCommandPool();
}


LveDevice::~LveDevice() {
    qDebug() << "\n$$$$$ ~LveDevice()";
    vkDestroyCommandPool(device_, commandPool, nullptr);
}

void LveDevice::createInstance() {
    this->instance = this->qvk_instance->vkInstance();
}

void LveDevice::pickPhysicalDevice() {
    uint32_t deviceCount = 0;
    vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr);
    if (deviceCount == 0) {
        throw std::runtime_error("failed to find GPUs with Vulkan support!");
    }

    std::vector<VkPhysicalDevice> devices(deviceCount);
    vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data());

    for (const auto &device : devices) {
        VkPhysicalDeviceProperties prop_temp;
        vkGetPhysicalDeviceProperties(device, &prop_temp);

        if (isDeviceSuitable(device)) {
            physicalDevice = device;
            break;
        }
    }

    if (physicalDevice == VK_NULL_HANDLE) {
        throw std::runtime_error("failed to find a suitable GPU!");
    }

    vkGetPhysicalDeviceProperties(physicalDevice, &properties);
}

void LveDevice::createLogicalDevice() {

    QueueFamilyIndices indices = findQueueFamilies(physicalDevice);
    device_ = this->window->device();
    vkGetDeviceQueue(device_, indices.graphicsFamily, 0, &graphicsQueue_);
    vkGetDeviceQueue(device_, indices.presentFamily, 0, &presentQueue_);
}

void LveDevice::createCommandPool() {
    QueueFamilyIndices queueFamilyIndices = findPhysicalQueueFamilies();

    VkCommandPoolCreateInfo poolInfo = {};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily;
    poolInfo.flags =
            VK_COMMAND_POOL_CREATE_TRANSIENT_BIT | VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;

    if (vkCreateCommandPool(device_, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
        throw std::runtime_error("failed to create command pool!");
    }
}


void LveDevice::createSurface() {
    this->surface_ = this->qvk_instance->surfaceForWindow(this->window);
}


bool LveDevice::isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    bool extensionsSupported = checkDeviceExtensionSupport(device);

    bool swapChainAdequate = false;
    if (extensionsSupported) {
        SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);
        swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty();
    }

    VkPhysicalDeviceFeatures supportedFeatures;
    vkGetPhysicalDeviceFeatures(device, &supportedFeatures);

    return indices.isComplete() && extensionsSupported && swapChainAdequate &&
            supportedFeatures.samplerAnisotropy;
}



bool LveDevice::checkValidationLayerSupport() {
    uint32_t layerCount;
    vkEnumerateInstanceLayerProperties(&layerCount, nullptr);

    std::vector<VkLayerProperties> availableLayers(layerCount);
    vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data());

    for (const char *layerName : validationLayers) {
        bool layerFound = false;

        for (const auto &layerProperties : availableLayers) {
            if (strcmp(layerName, layerProperties.layerName) == 0) {
                layerFound = true;
                break;
            }
        }

        if (!layerFound) {
            return false;
        }
    }

    return true;
}


std::vector<const char *> LveDevice::getRequiredExtensions() {

    std::vector<const char *> extensions{};

    //auto supported_extensions = QVulkanInstance::supportedExtensions();
    //for(auto & cur_ext : supported_extensions){
    //    extensions.push_back(cur_ext.name.data());
    //}

    extensions.push_back("VK_KHR_surface");
    extensions.push_back("VK_KHR_win32_surface");
    //extensions.push_back(VK_KHR_SURFACE_EXTENSION_NAME);
    if (enableValidationLayers) {
        extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
    }

    return extensions;
}


void LveDevice::hasRequiredInstanceExtensions() {
    uint32_t extensionCount = 0;
    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr);
    std::vector<VkExtensionProperties> extensions(extensionCount);
    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data());


    qDebug() << "available extensions:";
    std::unordered_set<std::string> available;
    for (const auto &extension : extensions) {
        qDebug() << "\t" << extension.extensionName;
        available.insert(extension.extensionName);
    }

    qDebug() << "required extensions:";
    auto requiredExtensions = getRequiredExtensions();
    for (const auto &required : requiredExtensions) {
        qDebug() << "\t" << required;
        if (available.find(required) == available.end()) {
            throw std::runtime_error("Missing required glfw extension");
        }
    }
}


bool LveDevice::checkDeviceExtensionSupport(VkPhysicalDevice device) {
    uint32_t extensionCount;
    vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);

    std::vector<VkExtensionProperties> availableExtensions(extensionCount);
    vkEnumerateDeviceExtensionProperties(
                device,
                nullptr,
                &extensionCount,
                availableExtensions.data());

    std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());

    for (const auto &extension : availableExtensions) {
        requiredExtensions.erase(extension.extensionName);
    }

    return requiredExtensions.empty();
}


QueueFamilyIndices LveDevice::findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;

    uint32_t queueFamilyCount = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);

    std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());

    int i = 0;
    for (const auto &queueFamily : queueFamilies) {
        if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
            indices.graphicsFamily = i;
            indices.graphicsFamilyHasValue = true;
        }
        VkBool32 presentSupport = false;
        vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface_, &presentSupport);
        if (queueFamily.queueCount > 0 && presentSupport) {
            indices.presentFamily = i;
            indices.presentFamilyHasValue = true;
        }
        if (indices.isComplete()) {
            break;
        }

        i++;
    }

    return indices;
}

SwapChainSupportDetails LveDevice::querySwapChainSupport(VkPhysicalDevice device) {
    SwapChainSupportDetails details;
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface_, &details.capabilities);

    uint32_t formatCount;
    vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface_, &formatCount, nullptr);

    if (formatCount != 0) {
        details.formats.resize(formatCount);
        vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface_, &formatCount, details.formats.data());
    }

    uint32_t presentModeCount;
    vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface_, &presentModeCount, nullptr);

    if (presentModeCount != 0) {
        details.presentModes.resize(presentModeCount);
        vkGetPhysicalDeviceSurfacePresentModesKHR(
                    device,
                    surface_,
                    &presentModeCount,
                    details.presentModes.data());
    }
    return details;
}

VkFormat LveDevice::findSupportedFormat(
        const std::vector<VkFormat> &candidates, VkImageTiling tiling, VkFormatFeatureFlags features) {
    for (VkFormat format : candidates) {
        VkFormatProperties props;
        vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &props);

        if (tiling == VK_IMAGE_TILING_LINEAR && (props.linearTilingFeatures & features) == features) {
            return format;
        } else if (
                   tiling == VK_IMAGE_TILING_OPTIMAL && (props.optimalTilingFeatures & features) == features) {
            return format;
        }
    }
    throw std::runtime_error("failed to find supported format!");
}

uint32_t LveDevice::findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {
    VkPhysicalDeviceMemoryProperties memProperties;
    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);
    for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
        if ((typeFilter & (1 << i)) &&
                (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
            return i;
        }
    }

    throw std::runtime_error("failed to find suitable memory type!");
}

void LveDevice::createBuffer(
        VkDeviceSize size,
        VkBufferUsageFlags usage,
        VkMemoryPropertyFlags properties,
        VkBuffer &buffer,
        VkDeviceMemory &bufferMemory) {
    VkBufferCreateInfo bufferInfo{};
    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    bufferInfo.size = size;
    bufferInfo.usage = usage;
    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    if (vkCreateBuffer(device_, &bufferInfo, nullptr, &buffer) != VK_SUCCESS) {
        throw std::runtime_error("failed to create buffer!");
    }

    VkMemoryRequirements memRequirements;
    vkGetBufferMemoryRequirements(device_, buffer, &memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(device_, &allocInfo, nullptr, &bufferMemory) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate vertex buffer memory!");
    }

    vkBindBufferMemory(device_, buffer, bufferMemory, 0);
}

VkCommandBuffer LveDevice::beginSingleTimeCommands() {
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandPool = commandPool;
    allocInfo.commandBufferCount = 1;

    VkCommandBuffer commandBuffer;
    vkAllocateCommandBuffers(device_, &allocInfo, &commandBuffer);

    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

    vkBeginCommandBuffer(commandBuffer, &beginInfo);
    return commandBuffer;
}

void LveDevice::endSingleTimeCommands(VkCommandBuffer commandBuffer) {
    vkEndCommandBuffer(commandBuffer);

    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &commandBuffer;

    vkQueueSubmit(graphicsQueue_, 1, &submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(graphicsQueue_);

    vkFreeCommandBuffers(device_, commandPool, 1, &commandBuffer);
}

void LveDevice::copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkBufferCopy copyRegion{};
    copyRegion.srcOffset = 0;  // Optional
    copyRegion.dstOffset = 0;  // Optional
    copyRegion.size = size;
    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);

    endSingleTimeCommands(commandBuffer);
}

void LveDevice::copyBufferToImage(
        VkBuffer buffer, VkImage image, uint32_t width, uint32_t height, uint32_t layerCount) {
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkBufferImageCopy region{};
    region.bufferOffset = 0;
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;

    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = layerCount;

    region.imageOffset = {0, 0, 0};
    region.imageExtent = {width, height, 1};

    vkCmdCopyBufferToImage(
                commandBuffer,
                buffer,
                image,
                VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                1,
                &region);
    endSingleTimeCommands(commandBuffer);
}

void LveDevice::createImageWithInfo(
        const VkImageCreateInfo &imageInfo,
        VkMemoryPropertyFlags properties,
        VkImage &image,
        VkDeviceMemory &imageMemory) {
    if (vkCreateImage(device_, &imageInfo, nullptr, &image) != VK_SUCCESS) {
        throw std::runtime_error("failed to create image!");
    }

    VkMemoryRequirements memRequirements;
    vkGetImageMemoryRequirements(device_, image, &memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(device_, &allocInfo, nullptr, &imageMemory) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate image memory!");
    }

    if (vkBindImageMemory(device_, image, imageMemory, 0) != VK_SUCCESS) {
        throw std::runtime_error("failed to bind image memory!");
    }
}

::::./Rendering/Src/lve_model.cpp::::#include <vulkan/vulkan.h>

#include "lve_model.hpp"
#include "rapidcsv.h"

// std
#include <cassert>
#include <cstring>

using namespace std;

inline float coord_normalize(float in_value, float move, float scale) {
    //return 2 * (in_value - min_value) / (max_value - min_value) - 1.0f;
    return (2 * (in_value - move) / (scale)-1.0f);
}



LveModel::LveModel(LveDevice& device, MODEL_TYPE type)
    : lveDevice{ device }, model_type(type) {
    if (type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        makeAxisData();
        createBuffers();
    }

    //createBuffers();
}

LveModel::~LveModel() {
    destroyBuffers();

    this->cube_infos.clear();
    this->cube_vertices.clear();
    this->vertices.clear();
    this->layerby_vertices.clear();
    this->indices_face.clear();
    this->layerby_face.clear();
    this->indices_edge.clear();
    this->layerby_edge.clear();
}

void LveModel::createBuffers() {

    if (this->model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) {
        for (auto const& [key, val] : layerby_vertices) {
            std::map<float, VkBuffer>& buffers = this->layerbyVertexBuffers;
            std::map<float, VkDeviceMemory>& buffersmemory = this->layerbyVertexBuffersMemory;
            createVertexBuffers(val, buffers[key], buffersmemory[key]);

            std::map<float, VkBuffer>& facebuffers = this->layerbyFaceIndexBuffers;
            std::map<float, VkDeviceMemory>& facebuffersmemory = this->layerbyFaceIndexBuffersMemory;
            createIndexBuffers(layerby_face[key], facebuffers[key], facebuffersmemory[key]);

            std::map<float, VkBuffer>& edgebuffers = this->layerbyEdgeIndexBuffers;
            std::map<float, VkDeviceMemory>& edgebuffersmemory = this->layerbyEdgeIndexBuffersMemory;
            createIndexBuffers(layerby_edge[key], edgebuffers[key], edgebuffersmemory[key]);
        }
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        createVertexBuffers(vertices, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) {
        createVertexBuffers(vertices, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_face, this->indexBufferForFace, this->indexBufferMemoryForFace);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) {
        createVertexBuffers(vertices, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
    }
}

void LveModel::destroyBuffers() {
    if (this->model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) {
        for (auto const& [key, val] : layerbyFaceIndexBuffers) {
            vkDestroyBuffer(lveDevice.device(), layerbyVertexBuffers[key], nullptr);
            vkFreeMemory(lveDevice.device(), layerbyVertexBuffersMemory[key], nullptr);
            vkDestroyBuffer(lveDevice.device(), val, nullptr);
            vkFreeMemory(lveDevice.device(), layerbyFaceIndexBuffersMemory[key], nullptr);
            vkDestroyBuffer(lveDevice.device(), layerbyEdgeIndexBuffers[key], nullptr);
            vkFreeMemory(lveDevice.device(), layerbyEdgeIndexBuffersMemory[key], nullptr);
        }

        //vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        //vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForFace, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForFace, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }

}
void LveModel::createVertexBuffers(
        const std::vector<Vertex>& vertices,
        VkBuffer& buffer,
        VkDeviceMemory& memory) {
    vertexCount = static_cast<uint32_t>(vertices.size());
    assert(vertexCount >= 3 && "Vertex count must be at least 3");
    VkDeviceSize bufferSize = sizeof(vertices[0]) * vertexCount;

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, vertices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}

void LveModel::createIndexBuffers(
        const std::vector<uint32_t>& indices,
        VkBuffer& buffer,
        VkDeviceMemory& memory) {
    assert( !indices.empty() && "Index size can't be zero");
    VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, indices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}

void LveModel::drawForFace(VkCommandBuffer commandBuffer) {
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_face.size()), 1, 0, 0, 0);
}

void LveModel::drawForEdge(VkCommandBuffer commandBuffer) {
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_edge.size()), 1, 0, 0, 0);
}

void LveModel::bindVertexBuffer(VkCommandBuffer commandBuffer) {
    VkBuffer buffers[] = {vertexBuffer};
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
}

void LveModel::bindDrawVertexIndexBufferForFace_layer(VkCommandBuffer commandBuffer, const float layer) {
    VkBuffer buffers[] = { layerbyVertexBuffers[layer] };
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
    vkCmdBindIndexBuffer(commandBuffer, layerbyFaceIndexBuffers[layer], 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_face[layer].size()), 1, 0, 0, 0);
}

void LveModel::bindDrawIndexBufferForEdge_layer(VkCommandBuffer commandBuffer, const float layer) {
    vkCmdBindIndexBuffer(commandBuffer, layerbyEdgeIndexBuffers[layer], 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_edge[layer].size()), 1, 0, 0, 0);
}



void LveModel::bindIndexBufferForFace(VkCommandBuffer commandBuffer) {
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForFace, 0, VK_INDEX_TYPE_UINT32);
}

void LveModel::bindIndexBufferForEdge(VkCommandBuffer commandBuffer) {
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForEdge, 0, VK_INDEX_TYPE_UINT32);
}


std::vector<VkVertexInputBindingDescription> LveModel::Vertex::getBindingDescriptions() {
    std::vector<VkVertexInputBindingDescription> bindingDescriptions(1);
    bindingDescriptions[0].binding = 0;
    bindingDescriptions[0].stride = sizeof(Vertex);
    bindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    return bindingDescriptions;
}

std::vector<VkVertexInputAttributeDescription> LveModel::Vertex::getAttributeDescriptions() {
    std::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);
    attributeDescriptions[0].binding = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset = offsetof(Vertex, position);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(Vertex, color);
    return attributeDescriptions;
}

void LveModel::makeAxisData(const float axis_length) {
    this->vertices.clear();
    this->vertices = {
        { { -axis_length, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f } },
        { {  axis_length, 0.0f, 0.0f }, { 1.0f, 0.0f, 0.0f } },
        { { 0.0f, -axis_length, 0.0f }, { 1.0f, 1.0f, 1.0f } },
        { { 0.0f,  axis_length, 0.0f }, { 0.0f, 1.0f, 0.0f } },
        { { 0.0f, 0.0f, -axis_length }, { 1.0f, 1.0f, 1.0f } },
        { { 0.0f, 0.0f,  axis_length }, { 0.0f, 0.0f, 1.0f } }
    };

    vector<uint32_t>& indices = this->indices_edge;
    indices.clear();
    indices.push_back(0);
    indices.push_back(1);
    indices.push_back(2);
    indices.push_back(3);
    indices.push_back(4);
    indices.push_back(5);
}

void LveModel::updateOpacity(float amount) {
    this->opacity += amount;
    if (this->opacity > 1.0f) this->opacity = 1.0f;
    if (this->opacity < 0.0f) this->opacity = 0.0f;
}

std::map<float, glm::vec3> LveModel::getLayer() {
    vector<glm::vec3> it = { glm::vec3{0.1,0.5,0.8},glm::vec3{0.8,0.4,0.2},glm::vec3{0.5,0.9,0.9} };
    int a = 0;
    for (auto const& [key, val] : layerby_vertices) {

        layerList.insert({ key, it.at(a%3)});
        a++;
    }

    return layerList;
}

::::./Rendering/Src/lve_pipeline.cpp::::#include <vulkan/vulkan.h>

#include "lve_pipeline.hpp"
#include "lve_model.hpp"

// std
#include <cassert>
#include <fstream>
#include <iostream>
#include <stdexcept>



LvePipeline::LvePipeline(
        LveDevice& device,
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo)
    : lveDevice{device} {
    createGraphicsPipeline(vertFilepath, fragFilepath, configInfo);
}

LvePipeline::~LvePipeline() {
    vkDestroyShaderModule(lveDevice.device(), vertShaderModule, nullptr);
    vkDestroyShaderModule(lveDevice.device(), fragShaderModule, nullptr);
    vkDestroyPipeline(lveDevice.device(), graphicsPipeline, nullptr);
}

std::vector<char> LvePipeline::readFile(const std::string& filepath) {
    std::ifstream file{filepath, std::ios::ate | std::ios::binary};

    if (!file.is_open()) {
        throw std::runtime_error("failed to open file: " + filepath);
    }

    size_t fileSize = static_cast<size_t>(file.tellg());
    std::vector<char> buffer(fileSize);

    file.seekg(0);
    file.read(buffer.data(), fileSize);

    file.close();
    return buffer;
}

void LvePipeline::createGraphicsPipeline(
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo) {
    assert(
                configInfo.pipelineLayout != VK_NULL_HANDLE &&
            "Cannot create graphics pipeline: no pipelineLayout provided in configInfo");
    assert(
                configInfo.renderPass != VK_NULL_HANDLE &&
            "Cannot create graphics pipeline: no renderPass provided in configInfo");

    auto vertCode = readFile(vertFilepath);
    auto fragCode = readFile(fragFilepath);

    createShaderModule(vertCode, &vertShaderModule);
    createShaderModule(fragCode, &fragShaderModule);

    VkPipelineShaderStageCreateInfo shaderStages[2];
    shaderStages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    shaderStages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
    shaderStages[0].module = vertShaderModule;
    shaderStages[0].pName = "main";
    shaderStages[0].flags = 0;
    shaderStages[0].pNext = nullptr;
    shaderStages[0].pSpecializationInfo = nullptr;
    shaderStages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    shaderStages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    shaderStages[1].module = fragShaderModule;
    shaderStages[1].pName = "main";
    shaderStages[1].flags = 0;
    shaderStages[1].pNext = nullptr;
    shaderStages[1].pSpecializationInfo = nullptr;

    auto bindingDescriptions = LveModel::Vertex::getBindingDescriptions();
    auto attributeDescriptions = LveModel::Vertex::getAttributeDescriptions();
    VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.vertexAttributeDescriptionCount =
            static_cast<uint32_t>(attributeDescriptions.size());
    vertexInputInfo.vertexBindingDescriptionCount = static_cast<uint32_t>(bindingDescriptions.size());
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data();
    vertexInputInfo.pVertexBindingDescriptions = bindingDescriptions.data();

    VkGraphicsPipelineCreateInfo pipelineInfo{};
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &configInfo.inputAssemblyInfo;
    pipelineInfo.pViewportState = &configInfo.viewportInfo;
    pipelineInfo.pRasterizationState = &configInfo.rasterizationInfo;
    pipelineInfo.pMultisampleState = &configInfo.multisampleInfo;
    pipelineInfo.pColorBlendState = &configInfo.colorBlendInfo;
    pipelineInfo.pDepthStencilState = &configInfo.depthStencilInfo;
    pipelineInfo.pDynamicState = &configInfo.dynamicStateInfo;

    pipelineInfo.layout = configInfo.pipelineLayout;
    pipelineInfo.renderPass = configInfo.renderPass;
    pipelineInfo.subpass = configInfo.subpass;

    pipelineInfo.basePipelineIndex = -1;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(
                lveDevice.device(),
                VK_NULL_HANDLE,
                1,
                &pipelineInfo,
                nullptr,
                &graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline");
    }
}

void LvePipeline::createShaderModule(const std::vector<char>& code, VkShaderModule* shaderModule) {
    VkShaderModuleCreateInfo createInfo{};
    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    createInfo.codeSize = code.size();
    createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data());

    if (vkCreateShaderModule(lveDevice.device(), &createInfo, nullptr, shaderModule) != VK_SUCCESS) {
        throw std::runtime_error("failed to create shader module");
    }
}

void LvePipeline::bind(VkCommandBuffer commandBuffer) {
    vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
}

void LvePipeline::defaultPipelineConfigInfo(PipelineConfigInfo& configInfo) {
    configInfo.inputAssemblyInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    configInfo.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    configInfo.inputAssemblyInfo.primitiveRestartEnable = VK_FALSE;

    configInfo.viewportInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    configInfo.viewportInfo.viewportCount = 1;
    configInfo.viewportInfo.pViewports = nullptr;
    configInfo.viewportInfo.scissorCount = 1;
    configInfo.viewportInfo.pScissors = nullptr;

    configInfo.rasterizationInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    configInfo.rasterizationInfo.depthClampEnable = VK_FALSE;
    configInfo.rasterizationInfo.rasterizerDiscardEnable = VK_FALSE;
    configInfo.rasterizationInfo.polygonMode = VK_POLYGON_MODE_FILL;
    configInfo.rasterizationInfo.lineWidth = 1.0f;
    configInfo.rasterizationInfo.cullMode = VK_CULL_MODE_NONE;
    configInfo.rasterizationInfo.frontFace = VK_FRONT_FACE_CLOCKWISE;
    configInfo.rasterizationInfo.depthBiasEnable = VK_FALSE;
    configInfo.rasterizationInfo.depthBiasConstantFactor = 0.0f;  // Optional
    configInfo.rasterizationInfo.depthBiasClamp = 0.0f;           // Optional
    configInfo.rasterizationInfo.depthBiasSlopeFactor = 0.0f;     // Optional

    configInfo.multisampleInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    configInfo.multisampleInfo.sampleShadingEnable = VK_FALSE;
    configInfo.multisampleInfo.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
    configInfo.multisampleInfo.minSampleShading = 1.0f;           // Optional
    configInfo.multisampleInfo.pSampleMask = nullptr;             // Optional
    configInfo.multisampleInfo.alphaToCoverageEnable = VK_FALSE;  // Optional
    configInfo.multisampleInfo.alphaToOneEnable = VK_FALSE;       // Optional

    configInfo.colorBlendAttachment.colorWriteMask =
            VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT |
            VK_COLOR_COMPONENT_A_BIT;
    configInfo.colorBlendAttachment.blendEnable = VK_FALSE;
    configInfo.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;   // Optional
    configInfo.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;  // Optional
    configInfo.colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;              // Optional
    configInfo.colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;   // Optional
    configInfo.colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;  // Optional
    configInfo.colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;              // Optional

    configInfo.colorBlendInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    configInfo.colorBlendInfo.logicOpEnable = VK_FALSE;
    configInfo.colorBlendInfo.logicOp = VK_LOGIC_OP_COPY;  // Optional
    configInfo.colorBlendInfo.attachmentCount = 1;
    configInfo.colorBlendInfo.pAttachments = &configInfo.colorBlendAttachment;
    configInfo.colorBlendInfo.blendConstants[0] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[1] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[2] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[3] = 0.0f;  // Optional

    configInfo.depthStencilInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    configInfo.depthStencilInfo.depthTestEnable = VK_TRUE;
    configInfo.depthStencilInfo.depthWriteEnable = VK_TRUE;
    configInfo.depthStencilInfo.depthCompareOp = VK_COMPARE_OP_LESS;
    configInfo.depthStencilInfo.depthBoundsTestEnable = VK_FALSE;
    configInfo.depthStencilInfo.minDepthBounds = 0.0f;  // Optional
    configInfo.depthStencilInfo.maxDepthBounds = 1.0f;  // Optional
    configInfo.depthStencilInfo.stencilTestEnable = VK_FALSE;
    configInfo.depthStencilInfo.front = {};  // Optional
    configInfo.depthStencilInfo.back = {};   // Optional

    configInfo.dynamicStateEnables = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};
    configInfo.dynamicStateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    configInfo.dynamicStateInfo.pDynamicStates = configInfo.dynamicStateEnables.data();
    configInfo.dynamicStateInfo.dynamicStateCount =
            static_cast<uint32_t>(configInfo.dynamicStateEnables.size());
    configInfo.dynamicStateInfo.flags = 0;
}


::::./Rendering/Src/lve_window.cpp::::
#include <QMouseEvent>
#include <QKeyEvent>
#include <QDockWidget>
#include <QGraphicsRectItem>
#include <QGraphicsOpacityEffect>
#include <QFile>
#include <QFileDialog>
#include <QString>

#include "lve_window.hpp"
#include "dtaorendersystem.h"



LveWindow::LveWindow()
{
}

LveWindow::~LveWindow()
{
    //this->destroy();
}

QVulkanWindowRenderer *LveWindow::createRenderer()
{
    qDebug() << "\n$$$$$ LveWindow::createRenderer()";
    this->m_renderer = new DtaoRenderSystem(this);
    return this->m_renderer;
    //return new DtaoRenderSystem(this);

}

void LveWindow::wheelEvent(QWheelEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    const float amount = e->angleDelta().y() / 8;
    QPoint scroll = e->angleDelta();
    this->m_renderer->cameraController.setMouseScroll(scroll);

    if (keyCtrl == true)
    {
        //      m_rendere->windowZoom(amount);
        QString funcName = "windowZoom";
        float value = amount;
        emit signalInfoText(funcName, value);
        //        qDebug()<<funcName << " : " << value;
    }
    else
    {
        //      m_renderer->moveZoom(amount);
        QString funcName = "moveZoom";
        float value = amount;
        emit signalInfoText(funcName, value);
        //        qDebug()<<funcName << " : " << value;
    }
}

void LveWindow::mousePressEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    m_mouseButton = e->buttons();
    Qt::MouseButtons cur_button = e->buttons();
    QString funcName = "mousePress";
    QPoint position = e->pos();
    //emit signalInfoText(funcName, m_lastPos);
    m_lastPos = e->pos();
    this->m_renderer->cameraController.moveButtonPressed(cur_button);
    this->m_renderer->cameraController.setMousePosition(position, 1);

}

void LveWindow::mouseReleaseEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    m_mouseButton = 0;
    QString funcName = "mouseRelease";
    Qt::MouseButtons cur_button = e->buttons();
    QPoint position = e->pos();
    float value = 0;
    emit signalInfoText(funcName, cur_button);
    this->m_renderer->cameraController.moveButtonReleased(cur_button);
    this->m_renderer->cameraController.setMousePosition(position, 2);
}

void LveWindow::mouseMoveEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    QPoint position = e->pos();
    this->m_renderer->cameraController.setMousePosition(position, 0);
    if (m_mouseButton == 0)
        return;

    int dx = e->pos().x() - m_lastPos.x();
    int dy = e->pos().y() - m_lastPos.y();

    if (dx)
    {
        if (m_mouseButton == 2)
        {
            //            m_renderer->rotateRenderY(dx / 10.0f);
            QString funcName = "rotateRenderX";
            float value = -dx / 10.0f;
            emit signalInfoText(funcName, value);
            qDebug()<< "mouseEvent "<<funcName << " : " << value;
        }
        else if (m_mouseButton == 4)
        {
            //            m_renderer->moveRenderX(dx / 10.0f);
            QString funcName = "moveRenderX";
            float value = -dx / 10.0f;
            emit signalInfoText(funcName, value);
            //            qDebug()<<funcName << " : " << value;
        }
    }

    if (dy)
    {
        if (m_mouseButton == 2)
        {
            //            m_renderer->rotateRenderY(dy / 10.0f);
            QString funcName = "rotateRenderY";
            float value = dy / 10.0f;
            emit signalInfoText(funcName, value);
            //            qDebug()<<funcName << " : " << value;
        }
        else if (m_mouseButton == 4)
        {
            //            m_renderer->moveRenderY(dy / 10.0f);
            QString funcName = "moveRenderY";
            float value = dy / 10.0f;
            emit signalInfoText(funcName, value);
            //            qDebug()<<funcName << " : " << value;
        }
    }
}

void LveWindow::keyPressEvent(QKeyEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    Qt::Key cur_key = (Qt::Key)e->key();

    this->m_renderer->cameraController.moveKeyPressed(cur_key);

}
void LveWindow::keyReleaseEvent(QKeyEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    Qt::Key cur_key = (Qt::Key)e->key();
    this->m_renderer->cameraController.moveKeyReleased(cur_key);
}

::::./Rendering/Src/simple_render_system.cpp::::#include <vulkan/vulkan.h>
#include "simple_render_system.hpp"

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>
#include <glm/gtc/constants.hpp>

// std
#include <array>
#include <cassert>
#include <stdexcept>



struct SimplePushConstantData {
    glm::mat4 transform{ 1.f };
    alignas(16) glm::vec3 color{};
    glm::float32 alpha;
};

SimpleRenderSystem::SimpleRenderSystem(LveDevice& device, VkRenderPass renderPass )
    : lveDevice{ device } {
    createPipelineLayout(this->pipelineLayoutForLayoutFace);
    createPipelineForFace(renderPass);
    createPipelineLayout(this->pipelineLayoutForLayoutEdge);
    createPipelineForEdge(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXResistor);
    createPipelineForPEXResistor(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXCapacitor);
    createPipelineForPEXCapacitor(renderPass);
}

SimpleRenderSystem::~SimpleRenderSystem() {
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForLayoutFace, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForLayoutEdge, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForPEXResistor, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForPEXCapacitor, nullptr);
}


void SimpleRenderSystem::createPipelineLayout(VkPipelineLayout & pipeline_layout) {
    VkPushConstantRange pushConstantRange{};
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange.offset = 0;
    pushConstantRange.size = sizeof(SimplePushConstantData);

    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 0;
    pipelineLayoutInfo.pSetLayouts = nullptr;
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(lveDevice.device(), &pipelineLayoutInfo, nullptr, &pipeline_layout) !=
            VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }
}

void SimpleRenderSystem::createPipelineForFace(VkRenderPass renderPass) {
    assert(pipelineLayoutForLayoutFace != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForLayoutFace;

    pipelineConfig.colorBlendAttachment.blendEnable = VK_TRUE;
    pipelineConfig.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    pipelineConfig.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;

    this->lvePipelineForLayoutFace = std::make_unique<LvePipeline>(
                lveDevice,
                "Rendering/shaders/simple_shader.vert.spv",
                "Rendering/shaders/simple_shader.frag.spv",
                pipelineConfig);
}

void SimpleRenderSystem::createPipelineForEdge(VkRenderPass renderPass) {
    assert(pipelineLayoutForLayoutEdge != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForLayoutEdge;

    pipelineConfig.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForLayoutEdge = std::make_unique<LvePipeline>(
                lveDevice,
                "Rendering/shaders/simple_shader.vert_edge.spv",
                "Rendering/shaders/simple_shader.frag_edge.spv",
                pipelineConfig);
}

void SimpleRenderSystem::createPipelineForPEXResistor(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXResistor != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigResistor{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigResistor);
    pipelineConfigResistor.renderPass = renderPass;
    pipelineConfigResistor.pipelineLayout = pipelineLayoutForPEXResistor;

    this->lvePipelineForPEXResistor = std::make_unique<LvePipeline>(
                lveDevice,
                "Rendering/shaders/simple_shader.vert_pex.spv",
                "Rendering/shaders/simple_shader.frag_pex.spv",
                pipelineConfigResistor);
}

void SimpleRenderSystem::createPipelineForPEXCapacitor(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXCapacitor != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigCapacitor{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigCapacitor);
    pipelineConfigCapacitor.renderPass = renderPass;
    pipelineConfigCapacitor.pipelineLayout = pipelineLayoutForPEXCapacitor;

    pipelineConfigCapacitor.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForPEXCapacitor = std::make_unique<LvePipeline>(
                lveDevice,
                "Rendering/shaders/simple_shader.vert_pex.spv",
                "Rendering/shaders/simple_shader.frag_pex.spv",
                pipelineConfigCapacitor);
}

void SimpleRenderSystem::renderGameObjects(
        VkCommandBuffer commandBuffer,
        std::vector<LveGameObject>& gameObjects,
        const LveCamera& camera) {

    auto proj = camera.getProjection();
    proj[1][1] *= -1;
    auto projectionView = proj * camera.getView();

    SimplePushConstantData push{};
    for (auto& obj : gameObjects) {

        push.transform = projectionView * obj.transform.mat4();

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT && obj.model->getVisible()) {

            for (auto const& [key, val] : obj.model->getLayer() ) {
                lvePipelineForLayoutFace->bind(commandBuffer);
                push.alpha = obj.model->getOpacity();
                push.color = val;
                vkCmdPushConstants(
                            commandBuffer, pipelineLayoutForLayoutFace,
                            VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                            sizeof(SimplePushConstantData), &push);
                obj.model->bindDrawVertexIndexBufferForFace_layer(commandBuffer, key);
                lvePipelineForLayoutEdge->bind(commandBuffer);
                obj.model->bindDrawIndexBufferForEdge_layer(commandBuffer, key);
            }

        }

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_AXIS && obj.model->getVisible()) {
            lvePipelineForLayoutEdge->bind(commandBuffer);
            push.color = glm::vec3(1.0f, 1.0f, 1.0f);
            vkCmdPushConstants(
                        commandBuffer, pipelineLayoutForLayoutEdge,
                        VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                        sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            obj.model->drawForEdge(commandBuffer);
        }

        if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR && obj.model->getVisible()) {
            //*
            push.alpha = 1.0f;
            push.color = glm::vec3(1.0f, 1.0f, 1.0f);
            lvePipelineForPEXResistor->bind(commandBuffer);
            vkCmdPushConstants(
                        commandBuffer, pipelineLayoutForPEXResistor,
                        VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                        sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForFace(commandBuffer);
            obj.model->drawForFace(commandBuffer);
            //*/
        }

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR && obj.model->getVisible()) {
            //*
            lvePipelineForPEXCapacitor->bind(commandBuffer);
            vkCmdPushConstants(
                        commandBuffer, pipelineLayoutForPEXCapacitor,
                        VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                        sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            obj.model->drawForEdge(commandBuffer);
            //*/
        }
    }
}


::::./T2D.cpp::::#include "T2D.h"

using namespace std;

bool T2D::text2data(std::string file_name){
    ifstream readfile(file_name);
    string line;
    vector<string> split;

    getline(readfile, line);
    split = T2D::string_split(line, ' ');
    LayoutMinMax.minx = atof(split[0].c_str());
    LayoutMinMax.miny = atof(split[1].c_str());
    LayoutMinMax.maxx = atof(split[2].c_str());
    LayoutMinMax.maxy = atof(split[3].c_str());
    LayoutMinMax.minz = atof(split[4].c_str());
    LayoutMinMax.maxz = atof(split[5].c_str());
    /*cout << LayoutMinMax.minx << "\t";
    cout << LayoutMinMax.miny << "\t";
    cout << LayoutMinMax.maxx << "\t";
    cout << LayoutMinMax.maxy << "\t";
    cout << LayoutMinMax.minz << "\t";
    cout << LayoutMinMax.maxz << endl;*/
    LayoutData10by10.clear();
    while(getline(readfile, line)){
        split = T2D::string_split(line, ' ');
        int row = atoi(split[9].c_str());
        int col = atoi(split[10].c_str());

        buf_ldata10by10.layername = split[0];
        buf_ldata10by10.layernum = atoi(split[1].c_str());
        buf_ldata10by10.datatype = atoi(split[2].c_str());
        buf_ldata10by10.color.r = atoi(split[3].c_str());
        buf_ldata10by10.color.g = atoi(split[4].c_str());
        buf_ldata10by10.color.b = atoi(split[5].c_str());
        buf_ldata10by10.color.a = atoi(split[6].c_str());
        buf_ldata10by10.bot = atof(split[7].c_str());
        buf_ldata10by10.top = atof(split[8].c_str());

        buf_xy10by10.resize(row);
        for(int i = 0 ; i < row ; i++){
            buf_xy10by10[i].resize(col);
        }
        for(int i = 0 ; i < row*col ; i++){
            getline(readfile, line);
            split = T2D::string_split(line, ' ');
            int nr = atoi(split[0].c_str());
            int nc = atoi(split[1].c_str());
            int nsize = atoi(split[2].c_str());

            buf_xy.clear();
            for(int i = 0 ; i < nsize ; i++){
                getline(readfile, line);
                split = T2D::string_split(line, ' ');
                bBox buf;
                buf.minx = atof(split[0].c_str());
                buf.miny = atof(split[1].c_str());
                buf.maxx = atof(split[2].c_str());
                buf.maxy = atof(split[3].c_str());
                buf_xy.push_back(buf);
            }
            buf_xy10by10[nr][nc] = buf_xy;
        }
        buf_ldata10by10.xy = buf_xy10by10;
        LayoutData10by10.push_back(buf_ldata10by10);
    }
}

vector<string> T2D::string_split(string input, char delimiter) {
    vector<string> answer;
    stringstream ss(input);
    string temp;

    while(getline(ss, temp, delimiter)) {
        if(temp != ""){
            answer.push_back(temp);
        }
    }

    return answer;
}
::::./all_data.cpp::::#include "all_data.h"
#include <QString>
#include <QTextStream>
#include <QFileDialog>
#include <QVector>

all_data::all_data(QObject *parent) :
    QObject(parent)
{

}

all_data::~all_data()
{

}


void all_data::receiveSelectFileName(QString file_name)
{
    int row = 0;
    int column = 0;
    QFile file(file_name);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;
    QString getLine;
    QStringList list;
    QTextStream fileStream(&file);
    while (!fileStream.atEnd()) {
            getLine.append(fileStream.readLine());
            getLine.append(" ");
            list << (getLine.split(" ", Qt::SkipEmptyParts));
            row++;
            getLine.clear();
    }   // while End

    column = list.count()/row;

    for(int i=0 ; i<row ; i++)
    {
           QVector <QString> tempvector;
           for(int j=0 ; j<column ; j++)
           {
               int num1;
               num1 = j + column*i;
               tempvector.append(list[num1]);
           }
           inputDataVector.append(tempvector);
    }
    emit sendSplitData(row, column, inputDataVector);
    return;
}
::::./filedb.cpp::::#include "filedb.h"
#include <QFile>
#include <QVector>
#include <QTextStream>
#include <QList>
#include <QDebug>

FileDb::FileDb()
{

}

void FileDb::openFile(QString fileNameInfo,QVector<QList<float>> &vecList,
                      float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize)
{    
    QFile file(fileNameInfo);

    if (file.open(QIODevice::ReadOnly) | (QIODevice::Text))
    {
        QTextStream openFile(&file);
        while(!openFile.atEnd())
        {
            auto dataString = openFile.readLine().split(",");
            QList<float> data;
            for (auto &tempdata : dataString)
            {
                 data.append(tempdata.toFloat());
            }
            vecList.push_back(data);
            qDebug()<< "strVector : " << data;

            if(data.size() == 8)
            {
                if(xMinSize > data[2]){xMinSize = data[2];}
                if(yMinSize > data[3]){yMinSize = data[3];}
                if(xMaxSize < data[4]){xMaxSize = data[4];}
                if(yMaxSize < data[5]){yMaxSize = data[5];}
            }
        }
        file.close();
    }
    else
    {        
        return;
    }

    return;

}
::::./formhier.cpp::::#include "formhier.h"
#include "ui_formhier.h"
#include "mainwindow.h"
#include <QTableWidget>
#include <QDebug>


FormHier::FormHier(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormHier)
{
    ui->setupUi(this);
    // QTableWidget defalut 赴 れ爼
    QStringList defalutTableHeader;
    defalutTableHeader << "LayerName" << "LayerNum" << "LayerType" << "Red" << "Green" << "Blue";

    ui->tableWidget->setColumnCount(6);
    ui->tableWidget->setRowCount(10);
    ui->tableWidget->setColumnWidth(0,80);
    ui->tableWidget->setColumnWidth(1,80);
    ui->tableWidget->setColumnWidth(2,80);
    ui->tableWidget->setColumnWidth(3,50);
    ui->tableWidget->setColumnWidth(4,50);
    ui->tableWidget->setColumnWidth(5,50);
    ui->tableWidget->setHorizontalHeaderLabels(defalutTableHeader);

    ui->tableWidget->horizontalHeader()->setStyleSheet("QHeaderView::section {background-color:#404040;color:#FFFFFF;}");

//    tempcolor = ui->tableWidget->setBackgroundRole();
//    ui->tableWidget->setHorizontalHeaderItem(0,QColor(128,128,128));

}

FormHier::~FormHier()
{
    delete ui;
}

//void FormHier::testMyData(){
//    this->dataset->split_datas[0][0] = QString("No, I'm not fool!!!");
//}

//void FormHier::ReceiveSplitData(QStringList list, int row, int column,  QVector <QVector <QString>> &inputDataVector)
void FormHier::ReceiveSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector)
{
//    qDebug() << "xxxxxxxxxxxxxxxxxxxxxxxxx";
//    qDebug() << "row" << row;
//    qDebug() << "column" << column;
//    qDebug() << "1st" << inputDataVector.value(0);
//    qDebug() << "2nd" << inputDataVector.value(1);
//    qDebug() << "3rd" << inputDataVector.value(2);
//    qDebug() << "1st_1st" << inputDataVector.value(0).value(0);

// QTableWidget 愳劀 QStringList 搿滊 氚涥赴岆愲曤
    QStringList vectorTOqstringlist;
    QStringList vectorTOqstringlistHoriLabels;

// QTableWidget 赴 れ爼
    ui->tableWidget->setColumnCount(column);
    ui->tableWidget->setRowCount(row);

// Table Header Font size/bold change
    QFont font = ui->tableWidget->horizontalHeader()->font();
    font.setBold(true);
    font.setPointSize(10);
    ui->tableWidget->horizontalHeader()->setFont(font);

// Table 毂勳毎旮
    for (int i=0; i<row ; i++)
    {
        for (int j=0; j<column ; j++)
        {
            vectorTOqstringlist << inputDataVector.value(i+1).value(j);
            vectorTOqstringlistHoriLabels << inputDataVector.value(0).value(j);
            ui->tableWidget->setItem(i,j,new QTableWidgetItem(vectorTOqstringlist[i*column+j]));
            ui->tableWidget->setHorizontalHeaderLabels(vectorTOqstringlistHoriLabels);
        }

    }
//    ui->tableWidget->set;
//    ui->tableWidget->setColumnWidth(0,80);
//    ui->tableWidget->setColumnWidth(1,80);
//    ui->tableWidget->setColumnWidth(2,80);
//    ui->tableWidget->setColumnWidth(3,50);
//    ui->tableWidget->setColumnWidth(4,50);
//    ui->tableWidget->setColumnWidth(5,50);



}
::::./forminfo.cpp::::#include "forminfo.h"
#include "ui_forminfo.h"
#include <QDebug>
#include "cmath"

FormInfo::FormInfo(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormInfo)
{
    ui->setupUi(this);
    ui->pointX->setText(QString::number(round(pointX*10000)/10000));
    ui->pointY->setText(QString::number(round(pointY*10000)/10000));
    ui->pointZ->setText(QString::number(round(pointZ*10000)/10000));
    ui->infoRot->setText(QString::number(round(infoRot*10000)/10000));
    ui->infoTilt->setText(QString::number(round(infoTilt*10000)/10000));
    ui->infoZoom->setText(QString::number(round(1/infoZoom*1000)/10)+"%");
}

void FormInfo::slotInfoText(QString funcName, float value)
{


    if (funcName == "moveGdsX")
    {
        pointX = pointX + value;
        ui->pointX->setText(QString::number(round(pointX*10000)/10000));
        initPointX = pointX;
    }
    if (funcName == "moveGdsY")
    {
        pointY = pointY + value;
        ui->pointY->setText(QString::number(round(pointY*10000)/10000));
        initPointY = pointY;
    }
    if (funcName == "moveGdsZ")
    {
        pointZ = pointZ + value;
        ui->pointZ->setText(QString::number(round(pointZ*10000)/10000));
        initPointZ = pointZ;
    }
    if (funcName == "rotateRenderX")
    {
        infoRot = initRot + value;
        if (infoRot>360)
            infoRot = infoRot - 360;
        if (infoRot<0)
            infoRot = infoRot + 360;
        ui->infoRot->setText(QString::number(round(infoRot*10000)/10000));
    }
    if (funcName == "rotateRenderY")
    {
        qDebug()<<"rotateRenderY";
        infoTilt = initTilt + value;
        if (infoTilt>90)
            infoTilt = 90;
        if (infoTilt<-90)
            infoTilt = -90;
        ui->infoTilt->setText(QString::number(round(infoTilt*10000)/10000));
    }
    if (funcName == "moveZoom")
    {
        qDebug()<<"moveZoom";
        infoZoom = infoZoom + infoZoom*value/1500;        //检爼 掛澊毳100% 搿れ爼勳殧 堨潓, 瓴瓣淡 齑堦赴臧掛 GDS Size 半澕 氚旊�堨潓.
        if (infoZoom < 0.01)
            infoZoom = 0.01;
        if (infoZoom > 100)
            infoZoom = 100;
        ui->infoZoom->setText(QString::number(round(1/infoZoom*1000)/10)+"%");
    }
    if (funcName == "moveRenderX")
    {
        qDebug()<< "moveRenderX";
        x = value;
        moveRender(x,y);
//        pointX = initPointX+value*cos(infoRot*pi/180)*infoZoom;
//        pointY = initPointY+value*sin(infoRot*pi/180)*infoZoom;
//        qDebug() << pointX << " : " << pointY;
//        ui->pointX->setText(QString::number(round(pointX*10000)/10000));
//        ui->pointY->setText(QString::number(round(pointY*10000)/10000));
    }
    if (funcName == "moveRenderY")
    {
        qDebug()<< "moveRenderY";
        y = value;
        moveRender(x,y);
//        pointX = initPointX+value*sin(infoRot*pi/180)*sin(infoTilt*pi/180)*infoZoom;
//        pointY = initPointY+value*cos(infoRot*pi/180)*sin(infoTilt*pi/180)*infoZoom;
//        pointZ = initPointZ+value*cos(infoTilt*pi/180)*infoZoom;
//        qDebug() << pointX << " : " << pointY;
//        ui->pointX->setText(QString::number(round(pointX*10000)/10000));
//        ui->pointY->setText(QString::number(round(pointY*10000)/10000));
//        ui->pointZ->setText(QString::number(round(pointZ*10000)/10000));
    }
    if (funcName == "mouseRelease")
    {
        qDebug()<< "mouseRelease";
        initTilt = infoTilt;
        initRot = infoRot;
        initPointX = pointX;
        initPointY = pointY;
        initPointZ = pointZ;

    }

}

void FormInfo::moveRender(float x, float y)
{
    const double pi = 3.1415926;

    qDebug()<< "moveRender";
    pointX = initPointX+x*cos(infoRot*pi/180)*infoZoom + y*sin(infoRot*pi/180)*sin(infoTilt*pi/180)*infoZoom;
    pointY = initPointY+x*sin(infoRot*pi/180)*infoZoom + y*cos(infoRot*pi/180)*sin(infoTilt*pi/180)*infoZoom;
    pointZ = initPointZ+y*cos(infoTilt*pi/180)*infoZoom;

    ui->pointX->setText(QString::number(round(pointX*10000)/10000));
    ui->pointY->setText(QString::number(round(pointY*10000)/10000));
    ui->pointZ->setText(QString::number(round(pointZ*10000)/10000));

}

FormInfo::~FormInfo()
{
    delete ui;
}
::::./formlayer.cpp::::#include "formlayer.h"
#include "ui_formlayer.h"



FormLayer::FormLayer(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormLayer)
{
    ui->setupUi(this);
    QStringList defalutTableHeader;
    QString TalbeHeader[] = {"","COLOR","Layer\nName","Layer\nNum","Layer\nType","Opacity\n"};

    ui->tableWidget->setColumnCount(6);
    ui->tableWidget->setRowCount(10);
    ui->tableWidget->setColumnWidth(0,15);
    ui->tableWidget->setColumnWidth(1,50);
    ui->tableWidget->setColumnWidth(2,60);
    ui->tableWidget->setColumnWidth(3,60);
    ui->tableWidget->setColumnWidth(4,60);
    ui->tableWidget->setColumnWidth(5,100);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// TableWidget Title Format れ爼
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    QBrush brush(QColor(255, 255, 255, 255));
    brush.setStyle(Qt::SolidPattern);
    QFont font;
    font.setBold(true);
    font.setWeight(75);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// TableWidget Title 呺牓 氚氚橃榿
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    for (int i=1; i<6; i++){
        QTableWidgetItem *TableHeaderItem = new QTableWidgetItem;
        TableHeaderItem->setText(TalbeHeader[i]);
        TableHeaderItem->setTextAlignment(Qt::AlignCenter);
        TableHeaderItem->setFont(font);
        TableHeaderItem->setForeground(brush);
        ui->tableWidget->setItem(0,i,TableHeaderItem);
        ui->tableWidget->setRowHeight(0,50);
        ui->tableWidget->item(0,i)->setBackground(QBrush(QColor(80,80,80)));
    }
}

FormLayer::~FormLayer()
{
    delete ui;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \brief FormLayer::ReceiveSplitData
/// \param row
/// \param column
/// \param inputDataVector
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void FormLayer::ReceiveSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector)
{
// QTableWidget 愳劀 QStringList 搿滊 氚涥赴岆愲曤
    QStringList vectorTOqstringlist;
    QStringList vectorTOqstringlistHoriLabels;
    QStringList vectorTOqstringcolorlist;
    QString LayerColorRed;
    QString LayerColorGreen;
    QString LayerColorBlue;
    QString LayerColorText;
    vectorTOqstringlistHoriLabels << " ";

// QTableWidget 赴 れ爼
    ui->tableWidget->setColumnCount(6);
    ui->tableWidget->setRowCount(row);
//    ui->tableWidget->setItemDelegateForColumn(5,new SliderDelegate);
    ui->tableWidget->setColumnWidth(5,150);

// Table 毂勳毎旮
    int TalbeColumnCount = 3;       //input data 愳劀 臧�column 臧垬
    for (int i=0; i<row ; i++)
    {
       // table value 毂勳毎旮
        for (int j=0; j < TalbeColumnCount ; j++)
        {
            vectorTOqstringlist << inputDataVector.value(i+1).value(j);
//            vectorTOqstringlistHoriLabels << inputDataVector.value(0).value(j+1);
            QTableWidgetItem *tableitem = new QTableWidgetItem;
            tableitem->setText(vectorTOqstringlist[i*TalbeColumnCount+j]);
            tableitem->setTextAlignment(Qt::AlignCenter);
            ui->tableWidget->setItem((i+1),j+2,tableitem);
        }

        //Opacity 毂勳毎旮
        QSlider *OpacitySlider = new QSlider(Qt::Horizontal);
        QWidget *OpacitySliderWidget = new QWidget();
        OpacitySlider->setRange(0,100);
        OpacitySlider->setValue(100);
        OpacitySlider->setFocusPolicy(Qt::StrongFocus);
        QHBoxLayout *OpacityLayout = new QHBoxLayout(OpacitySliderWidget);
        OpacityLayout->addWidget(OpacitySlider);
        OpacitySliderWidget->setLayout(OpacityLayout);

//        OpacitySlider->setTickPosition(QSlider::TicksBothSides);
//        OpacitySlider->setTickInterval(10);
        ui->tableWidget->setCellWidget(i+1, 5, OpacitySliderWidget);
        QObject::connect(OpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(handleOpacitySlider(int)));

        // checkbox 毂勳毎旮
        QCheckBox *checkBoxItem = new QCheckBox();
        checkBoxItem->setCheckState(Qt::Checked);
        QWidget *checkboxWidget = new QWidget();
        QHBoxLayout *checkboxLayout = new QHBoxLayout(checkboxWidget);
        checkboxLayout->addWidget(checkBoxItem);
        checkboxLayout->setAlignment(Qt::AlignCenter);
        checkboxLayout->setContentsMargins(0,0,0,0);
        checkboxWidget->setLayout(checkboxLayout);
        ui->tableWidget->setCellWidget(i+1,0,checkboxWidget);

        QWidget *widget = ui->tableWidget->cellWidget(i+1, 0);
        QCheckBox *checkboxInTable = widget->findChild<QCheckBox *>();
        QObject::connect(checkboxInTable, SIGNAL(stateChanged(int)), this, SLOT(tableWidget_checkBoxChanged()));

        // Layer color rgb defalut value
        LayerColorRed = inputDataVector.value(i+1).value(6);
        LayerColorGreen = inputDataVector.value(i+1).value(7);
        LayerColorBlue = inputDataVector.value(i+1).value(8);

        LayerColorText = "background-color: rgb(" + LayerColorRed;
        LayerColorText = LayerColorText + "," + LayerColorGreen + "," + LayerColorBlue + ")";

        // color pushbutton 毂勳毎旮
        QPushButton *colorbutton = new QPushButton();
        colorbutton->setStyleSheet(LayerColorText);
        ui->tableWidget->setCellWidget(i+1,1,colorbutton);
        QObject::connect(colorbutton, SIGNAL(clicked()), this, SLOT(on_colorbutton_clicked()));
    }

///////////////////////////////tableWidget title checkbox ///////////////////////////////
        QCheckBox *checkBoxItem = new QCheckBox();
        checkBoxItem->setCheckState(Qt::Checked);
        QWidget *checkboxWidget = new QWidget();
        QHBoxLayout *checkboxLayout = new QHBoxLayout(checkboxWidget);
        checkboxLayout->addWidget(checkBoxItem);
        checkboxLayout->setAlignment(Qt::AlignCenter);
        checkboxLayout->setContentsMargins(0,0,0,0);
        checkboxWidget->setLayout(checkboxLayout);
        ui->tableWidget->setCellWidget(0,0,checkboxWidget);

        QWidget *findwidget = ui->tableWidget->cellWidget(0, 0);
        QCheckBox *checkboxInTable = findwidget->findChild<QCheckBox *>();
        QObject::connect(checkboxInTable, SIGNAL(stateChanged(int)), this, SLOT(tableWidget_checkBoxChanged()));

///////////////////////////////tableWidget title slider ///////////////////////////////

        QSpacerItem *HeaderVerticalSpacer = new QSpacerItem(0,20,QSizePolicy::Fixed, QSizePolicy::Fixed);
        QSlider *HeaderOpacitySlider = new QSlider();
        HeaderOpacitySlider->setOrientation(Qt::Horizontal);
        HeaderOpacitySlider->setValue(100);
        HeaderOpacitySlider->setRange(0,100);
        QWidget *HeaderSliderWidget = new QWidget();
        QVBoxLayout *HeaderSliderLayout = new QVBoxLayout(HeaderSliderWidget);
        HeaderSliderLayout->addItem(HeaderVerticalSpacer);
        HeaderSliderLayout->addWidget(HeaderOpacitySlider);
        HeaderSliderWidget->setLayout(HeaderSliderLayout);
        ui->tableWidget->setCellWidget(0,5,HeaderSliderWidget);

        QObject::connect(HeaderOpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(handleOpacitySlider(int)));


}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \brief FormLayer::on_tableWidget_itemChanged
/// \param checkBoxItem
/// description : checkbox 犿儩半澕 Layer On/Off mainwindow status 彀届棎 於滊牓
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void FormLayer::tableWidget_checkBoxChanged()
{
    QCheckBox *checkboxInTable = qobject_cast<QCheckBox*>(sender());
    if (!checkboxInTable)
        return;

    int checkboxrow = -1;
    for (int i = 0; i < ui->tableWidget->rowCount(); i++) {
        QWidget *widget = ui->tableWidget->cellWidget(i, 0);
        QCheckBox *checkbox = widget->findChild<QCheckBox*>();
        if (checkbox == checkboxInTable) {
            checkboxrow = i;
            break;
        }
    }

    if (checkboxrow == 0) {
        QString CommentAllCheckedCheckBox = "All Layer Checked";
        QString CommentAllUncheckedCheckBox = "All Layer Unchecked";

        if (checkboxInTable->isChecked()) {
            for (int i = 1; i < ui->tableWidget->rowCount(); i++) {
                QWidget *widget = ui->tableWidget->cellWidget(i, 0);
                QCheckBox *checkbox = widget->findChild<QCheckBox*>();
                checkbox->setCheckState(Qt::Checked);
            }
            qDebug() << "All Layer Checkbox Checked.";
            emit outputLayerStatus(CommentAllCheckedCheckBox);

        } else {
                for (int i = 1; i < ui->tableWidget->rowCount(); i++) {
                    QWidget *widget = ui->tableWidget->cellWidget(i, 0);
                    QCheckBox *checkbox = widget->findChild<QCheckBox*>();
                    checkbox->setCheckState(Qt::Unchecked);
                }
                qDebug() << "All Layer Checkbox Unchecked.";
                emit outputLayerStatus(CommentAllUncheckedCheckBox);
            }
        return;
    }

    QTableWidgetItem *readcheckbox = ui->tableWidget->item(checkboxrow,2);
    QString selectedLayer = readcheckbox->text();
    QString printLayer = "selectedLayer = " + selectedLayer;

    if (checkboxInTable->isChecked()) {
        printLayer = printLayer + "  Layer  On";
        emit outputLayerStatus(printLayer);
        qDebug() << "Checkbox at row" << checkboxrow << "is checked.";
    } else {
        printLayer = printLayer + "  Layer  Off";
        emit outputLayerStatus(printLayer);
        qDebug() << "Checkbox at row" << checkboxrow << "is unchecked.";
    }
}

void FormLayer::on_colorbutton_clicked()
{
    QString LayerColorname;
    QString LayerColorText;
    QPushButton *ColorCheckButton = qobject_cast<QPushButton*>(sender());

    int colorbuttonRow = ui->tableWidget->currentRow();

    QString OldColorStyleSheet = ColorCheckButton->styleSheet();

    QStringList splittext = OldColorStyleSheet.split("(");
    QString splitrgbtemp = splittext[1].remove(")");
    QStringList splitrgb = splitrgbtemp.split(",");

    qDebug() << "OldColor = " << OldColorStyleSheet;
    qDebug() << "OldColorsplit = " << splitrgb;

//    int LayerColorRed = splitrgb[0].toInt();
//    int LayerColorGreen = splitrgb[1].toInt();
//    int LayerColorBlue = splitrgb[2].toInt();

    QString OldLayerColorRed = splitrgb[0];
    QString OldLayerColorGreen = splitrgb[1];
    QString OldLayerColorBlue = splitrgb[2];
    QString PrintOldLayerColor = "Red Num = " + OldLayerColorRed;
    PrintOldLayerColor = PrintOldLayerColor + "     Green Num = " + OldLayerColorGreen + "      Blue Num = " + OldLayerColorBlue;

//    QRgb LayerColorDefault = qRgb(LayerColorRed, LayerColorGreen, LayerColorBlue);

    QColor color = QColorDialog::getColor(Qt::yellow, this);

    if (color.isValid()){
        LayerColorname = color.name();

        QColor HexColor(LayerColorname);
        int NewColorRed = HexColor.red();
        int NewColorGreen = HexColor.green();
        int NewColorBlue = HexColor.blue();

        LayerColorText = "background-color: rgb(" + QString::number(NewColorRed);
        LayerColorText = LayerColorText + "," + QString::number(NewColorGreen) + "," + QString::number(NewColorBlue) + ")";

//        QStringList newcolorsplittemp = LayerColorText.split(":");
//        QString newcolorsplitrgb = newcolorsplittemp[1].remove(" ");
//        qDebug() << newcolorsplitrgb;



//        qDebug() << "Red = " << NewColorRed << "Green = " << NewColorGreen << "Blue = " << NewColorBlue;
        qDebug() << "NewColor = " <<LayerColorText;

        ui->tableWidget->cellWidget(colorbuttonRow,1)->setStyleSheet(LayerColorText);

    } else {
        ui->tableWidget->cellWidget(colorbuttonRow,1)->setStyleSheet(OldColorStyleSheet);
        emit outputLayerStatus(PrintOldLayerColor);
        qDebug() << "Color is not selected";
    }

//    QRgb test = QColorDialog::getRgba(orc);


}

void FormLayer::handleOpacitySlider(int Opacity)
{
    int sliderrow=-1;
    QSlider *OpacityInTalbe = qobject_cast<QSlider*>(sender());
    for (int i = 0; i < ui->tableWidget->rowCount(); i++) {
        QWidget *widget = ui->tableWidget->cellWidget(i, 5);
        QSlider *slider = widget->findChild<QSlider*>();

        if (slider == OpacityInTalbe) {
            sliderrow = i;

            if (sliderrow == 0){

                for (int k=1; k < ui->tableWidget->rowCount(); k++) {
                    QWidget *SliderChangeWidget = ui->tableWidget->cellWidget(k, 5);
                    QSlider *SliderChange = SliderChangeWidget->findChild<QSlider*>();
                    SliderChange->setValue(Opacity);
                }
            } else {
                QTableWidgetItem *ReadLayer = ui->tableWidget->item(sliderrow,2);
                QString selectedLayer = ReadLayer->text();
                QString printLayer = "selectedLayer = " + selectedLayer;
                printLayer = printLayer + "  Layer  Opacity = " + QString::number(Opacity);
                emit outputLayerStatus(printLayer);
                qDebug() << printLayer;
            }
            break;
        }
    }
}
::::./formmap.cpp::::#include "formmap.h"
#include "ui_formmap.h"
#include <QGraphicsItem>
#include <QGraphicsRectItem>
#include <QVector>
#include <iostream>
#include <QDebug>
#include <QRect>
#include <QKeyEvent>

FormMap::FormMap(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormMap)
{
    ui->setupUi(this);

}

void FormMap::receiveSize(float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize, float &zoomScale)
{
    float scale=1;

    width = xMaxSize-xMinSize;
    height = yMaxSize-yMinSize;
    qDebug() << "scale : " << scale << "| width : " << width << "| height : " << height;
    scale = 178/std::max(width,height);
    width = scale * width;
    height = scale * height;
//    float rectScale = 176*zoomScale; 於旐泟 氤�瓴

    qDebug() << "scale : " << scale << "| width : " << width << "| height : " << height;

    QGraphicsRectItem *rectItem = new QGraphicsRectItem;
    QGraphicsScene *scene = new QGraphicsScene(this);
    rectItem->setRect(-(width/2),-(height/2),width,height);
    rectItem->setBrush(QBrush(QColor(Qt::gray)));
    scene->addItem(rectItem);

    SuperItem *super = new SuperItem;
    scene->addItem(super);
    QObject::connect(this,&FormMap::signalMove,super,&SuperItem::slotMove);

    ui->graphicsView->setScene(scene);

}

void FormMap::slotInfoText(QString funcName, float value)
{

    if (funcName == "moveGdsX")
    {
        pointX = pointX + value;
        initPointX = pointX;
        emit signalMove(value,0,0,999,999);
    }
    if (funcName == "moveGdsY")
    {
        pointY = pointY + value;
        initPointY = pointY;
        emit signalMove(0, value,0,999,999);
    }
    if (funcName == "rotateRenderX")
    {
        infoRot = initRot + value;
        if (infoRot>360)
            infoRot = infoRot - 360;
        if (infoRot<0)
            infoRot = infoRot + 360;
        emit signalMove(0, 0 ,0,infoRot,999);
    }
    if (funcName == "rotateRenderY")
    {
        infoTilt = initTilt + value;
        if (infoTilt>90)
            infoTilt = 90;
        if (infoTilt<-90)
            infoTilt = -90;
        emit signalMove(0, 0 ,0,999,infoTilt);
    }
    if (funcName == "moveZoom")
    {
        infoZoom = infoZoom + infoZoom*value/1500;        //检爼 掛澊毳100% 搿れ爼勳殧 堨潓, 瓴瓣淡 齑堦赴臧掛 GDS Size 半澕 氚旊�堨潓.
        if (infoZoom < 0.01)
            infoZoom = 0.01;
        if (infoZoom > 100)
            infoZoom = 100;
        emit signalMove(0, 0, infoZoom, 999, 999);
    }
    if (funcName == "moveRenderX")
    {
        x = value;
    }
    if (funcName == "moveRenderY")
    {
        y = value;
    }
    if (funcName == "mouseRelease")
    {
        initTilt = infoTilt;
        initRot = infoRot;
        initPointX = pointX;
        initPointY = pointY;
        initPointZ = pointZ;
    }
}

FormMap::~FormMap()
{
    delete ui;
}

SuperItem::SuperItem(QGraphicsItem* parent) : QGraphicsItem(parent)
{
    setFlag(QGraphicsItem::ItemIsMovable);
}



QRectF SuperItem::boundingRect() const{
    return QRectF(-88,-88,175,175);
}

void SuperItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    painter->setPen(Qt::red);
    painter->drawRoundedRect(-88,-88,175,175,5,5);


}

void SuperItem::slotMove(float x, float y, float zoom, float rot, float tilt)
{
    QTransform trans;

    if (zoom != 0)
    {
        _zoom = zoom;
    }
    if (rot != 999)
    {
        _rot = rot;
    }
    if (tilt != 999)
    {
        _tilt = tilt;
    }
    trans.rotate(_rot);
    trans.scale(_zoom, _zoom*_tilt/90);
    setTransform(trans);

    if (x + y !=0)
    {
        moveBy(x, -y);
        qDebug() << "pos : " << pos();
    }






}

//void SuperItem::keyPressEvent(QKeyEvent *event){
//    switch(event->key()){
//    case Qt::Key_D:{
//        moveBy(30,0);
//        qDebug() << "press D";
//        break;
//        }
//    case Qt::Key_A:{
//        moveBy(-30,0);
//        break;
//        }
//    case Qt::Key_W:{
//        moveBy(0,-30);
//        break;
//        }
//    case Qt::Key_S:{
//        moveBy(0,30);
//        break;
//        }
//    }
//    update();

//}
::::./formtop.cpp::::#include "formtop.h"
#include "ui_formtop.h"
#include <QGraphicsItem>
#include <QScrollBar>
#include <QVector>
#include <QMap>
#include <iostream>
#include <QDebug>

FormTop::FormTop(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormTop)
{
    ui->setupUi(this);
}

//void FormTop::receiveFile(QVector<QList<float>> **mapFile)
void FormTop::receiveFile(QVector<QVector<QVector<QList<float>>>>& mapFile)
{
//    QString temp;
//    temp = strVector[1][3];
//    float fTemp = temp.toFloat()*1000000;
//    int iTemp = int(fTemp);
    float minX=0, maxX=0, minY=0, maxY=0;
    float posX = 0, posY =0;
    int areaX = 10, areaY = 10;
    int beginX = 0, beginY = 0, endX = mapFile.size(), endY = mapFile[0].size();
    if (posX - areaX > 0){beginX=posX - areaX;}
    if (posY - areaY > 0){beginY=posY - areaY;}
    if (posX + areaX < mapFile.size()){endX = posX + areaX;}
    if (posY + areaY < mapFile[0].size()){endY = posY + areaY;}



    QMap<int, QColor> mapColor;
    mapColor.insert(0,Qt::white);
    mapColor.insert(15,Qt::red);
    mapColor.insert(16,Qt::yellow);
    mapColor.insert(17,Qt::green);
    mapColor.insert(18,Qt::blue);
    mapColor.insert(19,Qt::magenta);
    mapColor.insert(714,Qt::red);
    mapColor.insert(177,Qt::red);

    qDebug() << "mapColor" <<mapColor;

    QGraphicsScene *scene = new QGraphicsScene(this);
    scene->setBackgroundBrush(QBrush(QColor(Qt::white)));
    //scene->setSceneRect(0,0,200,200);
    QPen mPen;
    mPen.setWidth(5);
    mPen.setColor(Qt::red);
// 旮办〈堧姅 vector 毳波旍暭 : delete 毳勴暣
    //            for(auto cur_item : rectItemList){
    //                delete cur_item;
    //            }
    //            rectItemList.clear();


    QVector<QGraphicsRectItem*> rectItemList;

    QGraphicsLineItem *zeroX = new QGraphicsLineItem;
    QGraphicsLineItem *zeroY = new QGraphicsLineItem;
    QTransform trans;
    trans.scale(1,-1);

    QVector<QList<float>> vecList;
    for (int i = beginX ; i < endX ; i++)
    {
        for (int j = beginY ; j < endY ; j++)
        {
            vecList.append(mapFile[i][j]);
        }
    }

    for (auto &data : vecList)
    {

        if (data.size() == 8)
        {
            QGraphicsRectItem *rectItem = new QGraphicsRectItem;
            rectItemList.push_back(rectItem);


            float x = 500*(data[2]);
            float y = 500*(data[3]);
            float w = 500*(data[4] - data[2]);
            float h = 500*(data[5] - data[3]);

            if (x<minX){minX = x;}
            if (x>maxX){maxX = x;}
            if (y<minY){minY = y;}
            if (y>maxY){maxY = y;}
            rectItem->setRect(x,y,w,h);
            rectItem->setBrush(QBrush(QColor(mapColor[int(data[0])])));
            rectItem->setOpacity(0.5);
            rectItem->setZValue(data[6]);

            rectItem->setTransform(trans);
            scene->addItem(rectItem);
        }
    }
    zeroX->setLine(0,0,maxX,0);
    zeroY->setLine(0,0,0,maxY);
    zeroX->setPen(QPen(QColor(Qt::red)));
    zeroY->setPen(QPen(QColor(Qt::red)));
    zeroX->setZValue(400);
    zeroY->setZValue(400);
    zeroY->setTransform(trans);
    scene->addItem(zeroX);
    scene->addItem(zeroY);
    ui->graphicsView->setScene(scene);
//    float dx = 100-(maxX-minX)/2;
//    float dy = 100-(maxY-minY)/2;



//    ui->graphicsView->horizontalScrollBar()->setValue(ui->graphicsView->horizontalScrollBar()->value()+dx);
//    ui->graphicsView->verticalScrollBar()->setValue(ui->graphicsView->verticalScrollBar()->value()+dy);
//    ui->graphicsView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//    ui->graphicsView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);


}




FormTop::~FormTop()
{
    delete ui;
}
::::./main.cpp::::#include "mainwindow.h"
#include "gitmerge.h"

#include <QApplication>
#include <QVulkanInstance>
#include <QLoggingCategory>
#include <fstream>
#include <string>
#include <iostream>
#include "formtop.h"

#include "Rendering/Src/lve_window.hpp"
#include "Rendering/Src/simple_render_system.hpp"

Q_LOGGING_CATEGORY(lcVk, "qt.vulkan")

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

///////// git merge
    GitMerge gitMerge;
/// /////

    QLoggingCategory::setFilterRules(QStringLiteral("qt.vulkan=true"));

    QVulkanInstance inst;
    LveWindow *vulkanWindow = new LveWindow;

    //inst.setLayers(QByteArrayList() << "VK_LAYER_LUNARG_standard_validation");


    if (!inst.create())
        qFatal("Failed to create Vulkan instance: %d", inst.errorCode());

    vulkanWindow->setVulkanInstance(&inst);

    MainWindow mainWindow(vulkanWindow);
    QObject::connect(vulkanWindow, &LveWindow::signalInfoText, &mainWindow, &MainWindow::slotInfoText);

    QRect size = mainWindow.geometry();
    mainWindow.shareGeo(size);
    qDebug() << "Main geo : " << mainWindow.geometry();

    mainWindow.show();

    return app.exec();
}





::::./mainwindow.cpp::::#include "mainwindow.h"
#include "ui_mainwindow.h"

#include "Rendering/Src/dtaorendersystem.h"
#include "Rendering/Src/lve_model.hpp"

#include <QMouseEvent>
#include <QKeyEvent>
#include <QDockWidget>
#include <QGraphicsRectItem>
#include <QGraphicsOpacityEffect>
#include <QFile>
#include <QFileDialog>
#include <QString>

#include <fstream>
#include <iostream>
#include <string>
#include <QIODevice>
#include <QTextStream>

MainWindow::MainWindow(LveWindow *w)
    : m_window(w)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QWidget *wrapper = QWidget::createWindowContainer(w);
    ui->graphicsView->setViewport(wrapper);

    QDockWidget *dockHier = new QDockWidget(tr("Hierarchy"), this);
    dockHier->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockHier->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addDockWidget(Qt::RightDockWidgetArea, dockHier);
    formHier = new FormHier;
    dockHier->setWidget(formHier);

    QDockWidget *dockLayer = new QDockWidget(tr("Layer Information"), this);
    dockLayer->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockLayer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addDockWidget(Qt::RightDockWidgetArea, dockLayer);
    formLayer = new FormLayer;
    dockLayer->setWidget(formLayer);

    QDockWidget *dockMap = new QDockWidget(tr("Map"), this);
    dockMap->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockMap->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addDockWidget(Qt::LeftDockWidgetArea, dockMap);
    formMap = new FormMap;    
    dockMap->setWidget(formMap);

    QDockWidget *dockTop = new QDockWidget(tr("Topview"), this);
    dockTop->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockTop->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addDockWidget(Qt::LeftDockWidgetArea, dockTop);
    formTop = new FormTop;    
    dockTop->setWidget(formTop);

    QDockWidget *dockInfo = new QDockWidget(tr("Info"), this);
    dockInfo->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockInfo->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addDockWidget(Qt::LeftDockWidgetArea, dockInfo);
    formInfo = new FormInfo;
    dockInfo->setWidget(formInfo);

    resizeDocks({dockInfo, dockTop, dockMap, dockLayer, dockHier}, {200,200}, Qt::Horizontal);
    resizeDocks({dockTop, dockMap}, {200,200}, Qt::Vertical);

    input_dataS = new all_data;


    /// connect ////////////////////
    QObject::connect(ui->actionOpen_file, SIGNAL(triggered()), this, SLOT(on_actionOpen_file_triggered));
    QObject::connect(this, SIGNAL(sendSelectFileName(QString)), input_dataS, SLOT(receiveSelectFileName(QString)));
    QObject::connect(input_dataS, SIGNAL(sendSplitData(int, int, const QVector <QVector <QString>> &)), formHier, SLOT(ReceiveSplitData(int, int, const QVector <QVector <QString>> &)));
    QObject::connect(input_dataS, SIGNAL(sendSplitData(int, int, const QVector <QVector <QString>> &)), formLayer, SLOT(ReceiveSplitData(int, int, const QVector <QVector <QString>> &)));
    QObject::connect(formLayer, SIGNAL(outputLayerStatus(QString)), this, SLOT(inputLayerStatus(QString)));

}

void MainWindow::shareGeo(QRect size)
{
    QRect windowSize = size;
    qDebug() << "shareGeo : " << windowSize;
}


MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::slotInfoText(QString funcName, float value)
{
    formInfo->slotInfoText(funcName,value);
    formMap->slotInfoText(funcName,value);
    qDebug() << "slotInfoText" << value;
///// temp //////
    QString text = funcName + " : " + QString::number(value);
    for (int i = text.size() ; i < 30 ; i++)
    {
        text.append(" ");
    }

    statusText.prepend(text);

    if (statusText.size() > 120)
        statusText.remove(120,statusText.size()-120);
    ui->statusbar->showMessage(statusText);

}

void MainWindow::on_actionOpen_Map_File_triggered()
{
    QString fileNameInfo = QFileDialog::getOpenFileName(this,
                                                        tr("Open map file"),
                                                        ".",
                                                        tr("text (*.txt)")
                                                        );
    FileDb *fileDb = new FileDb;
    QVector<QList<float>> vecList;
    float xMinSize = 0, yMinSize = 0, xMaxSize = 0, yMaxSize = 0;
    fileDb->openFile(fileNameInfo, vecList , xMinSize, yMinSize, xMaxSize, yMaxSize);

    int posScale = 1000, splitSize = 10; //posScale 1措┐ um 渼, posScale 1000措┐ nm 渼
    int n = (int(xMaxSize *posScale)-int(xMinSize *posScale))/splitSize +1;
    int m = (int(yMaxSize *posScale)-int(yMinSize *posScale))/splitSize +1;
    qDebug() << "int n / int m : " << n << " , " <<m;

    ////////////////////////////////////////////////
    QVector<QVector<QVector<QList<float>>>> mapFile(n, QVector<QVector<QList<float>>>(m, {{}}));
//    QVector<QList<float>> mapFile[n][m];
    // 甑“ 氤�瓴届棎 �濌皝勳殧 堨潓
    // 欤柬槙 甑“ : struct(layer, r, g, b, z, thk, opacity, vector())

    mapFile[0][0][0].append({0, 0, xMinSize, yMinSize, xMaxSize, yMaxSize, 0, 0});

    for (auto & data : vecList)
    {
        if(data.size() == 8)
        {
            qDebug() << " " << data[2] << " "<< int(data[2]*100) << " "<< data[3] << " "<< int(data[3]*100);
            int in_n = 0, in_m = 0;
            if(data[2]<0)
            {in_n = n + int(data[2]*100)-1;}
            else
            {in_n = int(data[2]*100);}
            if(data[3]<0)
            {in_m = m + int(data[3]*100)-1;}
            else
            {in_m = int(data[3]*100);}
            mapFile[in_n][in_m].append(data);
        }
    }



    for(int i = 0 ; i < (int(mapFile[0][0][0][2]*1000)-int(mapFile[0][0][0][0]*1000))/10+1 ; i++)
    {
        QDebug oneLine = qDebug();
        for(int j = 0 ; j < (int(mapFile[0][0][0][3]*1000)-int(mapFile[0][0][0][1]*1000))/10+1 ; j++)
        {
            oneLine << "["<<i<<"]["<<j<<"] "<<mapFile[i][j];
        }
        qDebug() << "";
    }

    float zoomScale = std::max(xMaxSize-xMinSize,yMaxSize-yMinSize)/10;
    formMap->receiveSize(xMinSize,yMinSize,xMaxSize,yMaxSize,zoomScale);
    formTop->receiveFile(mapFile);

}

void MainWindow::on_actionOpen_file_triggered()
{

    QString file_name = QFileDialog::getOpenFileName(this, "岇澕 犿儩",".","Files(*.*)");
    //qDebug() << file_name;

    emit sendSelectFileName(file_name);

}

void MainWindow::inputLayerStatus(QString text)
{
    ui->statusbar->showMessage(text);
}



void MainWindow::on_actionOpen_Layout_triggered()
{
    QString file_name = QFileDialog::getOpenFileName(this, "岇澕 犿儩",".","Files(*.*)");
    DtaoRenderSystem * renderer = this->m_window->getRenderer();

    renderer->createNewObject(MODEL_TYPE::MODEL_TYPE_LAYOUT, file_name.toStdString());


}

void MainWindow::on_actionOpen_DB_triggered(){
    std::cout << "callv" << std::endl;
    QString file_name = QFileDialog::getOpenFileName(this, "OpenDB", "C:\\", "Text (*.txt) ;; Files (*.*)");
    if(file_name != ""){
        std::cout << file_name.toStdString() << std::endl;
        this->t2d.text2data(file_name.toStdString());

        printf("%-9f %-9f %-9f %-9f %-9f %-9f", t2d.LayoutMinMax.minx, t2d.LayoutMinMax.miny, t2d.LayoutMinMax.maxx, t2d.LayoutMinMax.maxy, t2d.LayoutMinMax.minz, t2d.LayoutMinMax.maxz);
        for(int i = 0 ; i < t2d.LayoutData10by10.size() ; i++){
            printf("\n%-9s %-9d %-9d %-9d %-9d %-9d %-9d %-9f %-9f ",
                   t2d.LayoutData10by10[i].layername.c_str(),
                   t2d.LayoutData10by10[i].layernum,
                   t2d.LayoutData10by10[i].datatype,
                   t2d.LayoutData10by10[i].color.r,
                   t2d.LayoutData10by10[i].color.g,
                   t2d.LayoutData10by10[i].color.b,
                   t2d.LayoutData10by10[i].color.a,
                   t2d.LayoutData10by10[i].bot,
                   t2d.LayoutData10by10[i].top);
            for(int j = 0 ; j < (t2d.LayoutData10by10[i].xy).size() ; j++){
                for(int x = 0 ; x < (t2d.LayoutData10by10[i].xy[j]).size() ; x++){
                    printf("\n%d %d %d", j, x, (t2d.LayoutData10by10[i].xy[j][x]).size());
                    for(int y = 0 ; y < (t2d.LayoutData10by10[i].xy[j][x]).size() ; y++){
                        printf("\n%-9f %-9f %-9f %-9f",
                               t2d.LayoutData10by10[i].xy[j][x][y].minx,
                               t2d.LayoutData10by10[i].xy[j][x][y].miny,
                               t2d.LayoutData10by10[i].xy[j][x][y].maxx,
                               t2d.LayoutData10by10[i].xy[j][x][y].maxy);
                    }
                }
            }
        }
    }
    fflush(stdout);
    cout << "test end" << endl;
}











::::./trianglerenderer.cpp::::/****************************************************************************
**
** Copyright (C) 2017 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** "Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include "trianglerenderer.h"
#include <QVulkanFunctions>
#include <QFile>

// Note that the vertex data and the projection matrix assume OpenGL. With
// Vulkan Y is negated in clip space and the near/far plane is at 0/1 instead
// of -1/1. These will be corrected for by an extra transformation when
// calculating the modelview-projection matrix.
static float vertexData[] = { // Y up, front = CCW
     0.0f,   0.5f,   1.0f, 0.0f, 0.0f,
    -0.5f,  -0.5f,   0.0f, 1.0f, 0.0f,
     0.5f,  -0.5f,   0.0f, 0.0f, 1.0f
};

static const int UNIFORM_DATA_SIZE = 16 * sizeof(float);

static inline VkDeviceSize aligned(VkDeviceSize v, VkDeviceSize byteAlign)
{
    return (v + byteAlign - 1) & ~(byteAlign - 1);
}

TriangleRenderer::TriangleRenderer(QVulkanWindow *w, bool msaa)
    : m_window(w)
{
    if (msaa) {
        const QVector<int> counts = w->supportedSampleCounts();
        qDebug() << "Supported sample counts:" << counts;
        for (int s = 16; s >= 4; s /= 2) {
            if (counts.contains(s)) {
                qDebug("Requesting sample count %d", s);
                m_window->setSampleCount(s);
                break;
            }
        }
    }
}

VkShaderModule TriangleRenderer::createShader(const QString &name)
{
    QFile file(name);
    if (!file.open(QIODevice::ReadOnly)) {
        qWarning("Failed to read shader %s", qPrintable(name));
        return VK_NULL_HANDLE;
    }
    QByteArray blob = file.readAll();
    file.close();

    VkShaderModuleCreateInfo shaderInfo;
    memset(&shaderInfo, 0, sizeof(shaderInfo));
    shaderInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    shaderInfo.codeSize = blob.size();
    shaderInfo.pCode = reinterpret_cast<const uint32_t *>(blob.constData());
    VkShaderModule shaderModule;
    VkResult err = m_devFuncs->vkCreateShaderModule(m_window->device(), &shaderInfo, nullptr, &shaderModule);
    if (err != VK_SUCCESS) {
        qWarning("Failed to create shader module: %d", err);
        return VK_NULL_HANDLE;
    }

    return shaderModule;
}

void TriangleRenderer::initResources()
{
    qDebug("initResources");

    VkDevice dev = m_window->device();
    m_devFuncs = m_window->vulkanInstance()->deviceFunctions(dev);

    // Prepare the vertex and uniform data. The vertex data will never
    // change so one buffer is sufficient regardless of the value of
    // QVulkanWindow::CONCURRENT_FRAME_COUNT. Uniform data is changing per
    // frame however so active frames have to have a dedicated copy.

    // Use just one memory allocation and one buffer. We will then specify the
    // appropriate offsets for uniform buffers in the VkDescriptorBufferInfo.
    // Have to watch out for
    // VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment, though.

    // The uniform buffer is not strictly required in this example, we could
    // have used push constants as well since our single matrix (64 bytes) fits
    // into the spec mandated minimum limit of 128 bytes. However, once that
    // limit is not sufficient, the per-frame buffers, as shown below, will
    // become necessary.

    const int concurrentFrameCount = m_window->concurrentFrameCount();
    const VkPhysicalDeviceLimits *pdevLimits = &m_window->physicalDeviceProperties()->limits;
    const VkDeviceSize uniAlign = pdevLimits->minUniformBufferOffsetAlignment;
    qDebug("uniform buffer offset alignment is %u", (uint) uniAlign);
    VkBufferCreateInfo bufInfo;
    memset(&bufInfo, 0, sizeof(bufInfo));
    bufInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    // Our internal layout is vertex, uniform, uniform, ... with each uniform buffer start offset aligned to uniAlign.
    const VkDeviceSize vertexAllocSize = aligned(sizeof(vertexData), uniAlign);
    const VkDeviceSize uniformAllocSize = aligned(UNIFORM_DATA_SIZE, uniAlign);
    bufInfo.size = vertexAllocSize + concurrentFrameCount * uniformAllocSize;
    bufInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;

    VkResult err = m_devFuncs->vkCreateBuffer(dev, &bufInfo, nullptr, &m_buf);
    if (err != VK_SUCCESS)
        qFatal("Failed to create buffer: %d", err);

    VkMemoryRequirements memReq;
    m_devFuncs->vkGetBufferMemoryRequirements(dev, m_buf, &memReq);

    VkMemoryAllocateInfo memAllocInfo = {
        VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        nullptr,
        memReq.size,
        m_window->hostVisibleMemoryIndex()
    };

    err = m_devFuncs->vkAllocateMemory(dev, &memAllocInfo, nullptr, &m_bufMem);
    if (err != VK_SUCCESS)
        qFatal("Failed to allocate memory: %d", err);

    err = m_devFuncs->vkBindBufferMemory(dev, m_buf, m_bufMem, 0);
    if (err != VK_SUCCESS)
        qFatal("Failed to bind buffer memory: %d", err);

    quint8 *p;
    err = m_devFuncs->vkMapMemory(dev, m_bufMem, 0, memReq.size, 0, reinterpret_cast<void **>(&p));
    if (err != VK_SUCCESS)
        qFatal("Failed to map memory: %d", err);
    memcpy(p, vertexData, sizeof(vertexData));
    QMatrix4x4 ident;
    memset(m_uniformBufInfo, 0, sizeof(m_uniformBufInfo));
    for (int i = 0; i < concurrentFrameCount; ++i) {
        const VkDeviceSize offset = vertexAllocSize + i * uniformAllocSize;
        memcpy(p + offset, ident.constData(), 16 * sizeof(float));
        m_uniformBufInfo[i].buffer = m_buf;
        m_uniformBufInfo[i].offset = offset;
        m_uniformBufInfo[i].range = uniformAllocSize;
    }
    m_devFuncs->vkUnmapMemory(dev, m_bufMem);

    VkVertexInputBindingDescription vertexBindingDesc = {
        0, // binding
        5 * sizeof(float),
        VK_VERTEX_INPUT_RATE_VERTEX
    };
    VkVertexInputAttributeDescription vertexAttrDesc[] = {
        { // position
            0, // location
            0, // binding
            VK_FORMAT_R32G32_SFLOAT,
            0
        },
        { // color
            1,
            0,
            VK_FORMAT_R32G32B32_SFLOAT,
            2 * sizeof(float)
        }
    };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo;
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.pNext = nullptr;
    vertexInputInfo.flags = 0;
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.pVertexBindingDescriptions = &vertexBindingDesc;
    vertexInputInfo.vertexAttributeDescriptionCount = 2;
    vertexInputInfo.pVertexAttributeDescriptions = vertexAttrDesc;

    // Set up descriptor set and its layout.
    VkDescriptorPoolSize descPoolSizes = { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, uint32_t(concurrentFrameCount) };
    VkDescriptorPoolCreateInfo descPoolInfo;
    memset(&descPoolInfo, 0, sizeof(descPoolInfo));
    descPoolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    descPoolInfo.maxSets = concurrentFrameCount;
    descPoolInfo.poolSizeCount = 1;
    descPoolInfo.pPoolSizes = &descPoolSizes;
    err = m_devFuncs->vkCreateDescriptorPool(dev, &descPoolInfo, nullptr, &m_descPool);
    if (err != VK_SUCCESS)
        qFatal("Failed to create descriptor pool: %d", err);

    VkDescriptorSetLayoutBinding layoutBinding = {
        0, // binding
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        1,
        VK_SHADER_STAGE_VERTEX_BIT,
        nullptr
    };
    VkDescriptorSetLayoutCreateInfo descLayoutInfo = {
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        nullptr,
        0,
        1,
        &layoutBinding
    };
    err = m_devFuncs->vkCreateDescriptorSetLayout(dev, &descLayoutInfo, nullptr, &m_descSetLayout);
    if (err != VK_SUCCESS)
        qFatal("Failed to create descriptor set layout: %d", err);

    for (int i = 0; i < concurrentFrameCount; ++i) {
        VkDescriptorSetAllocateInfo descSetAllocInfo = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
            nullptr,
            m_descPool,
            1,
            &m_descSetLayout
        };
        err = m_devFuncs->vkAllocateDescriptorSets(dev, &descSetAllocInfo, &m_descSet[i]);
        if (err != VK_SUCCESS)
            qFatal("Failed to allocate descriptor set: %d", err);

        VkWriteDescriptorSet descWrite;
        memset(&descWrite, 0, sizeof(descWrite));
        descWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        descWrite.dstSet = m_descSet[i];
        descWrite.descriptorCount = 1;
        descWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        descWrite.pBufferInfo = &m_uniformBufInfo[i];
        m_devFuncs->vkUpdateDescriptorSets(dev, 1, &descWrite, 0, nullptr);
    }

    // Pipeline cache
    VkPipelineCacheCreateInfo pipelineCacheInfo;
    memset(&pipelineCacheInfo, 0, sizeof(pipelineCacheInfo));
    pipelineCacheInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
    err = m_devFuncs->vkCreatePipelineCache(dev, &pipelineCacheInfo, nullptr, &m_pipelineCache);
    if (err != VK_SUCCESS)
        qFatal("Failed to create pipeline cache: %d", err);

    // Pipeline layout
    VkPipelineLayoutCreateInfo pipelineLayoutInfo;
    memset(&pipelineLayoutInfo, 0, sizeof(pipelineLayoutInfo));
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &m_descSetLayout;
    err = m_devFuncs->vkCreatePipelineLayout(dev, &pipelineLayoutInfo, nullptr, &m_pipelineLayout);
    if (err != VK_SUCCESS)
        qFatal("Failed to create pipeline layout: %d", err);

    // Shaders
    VkShaderModule vertShaderModule = createShader(QStringLiteral(":/color_vert.spv"));
    VkShaderModule fragShaderModule = createShader(QStringLiteral(":/color_frag.spv"));

    // Graphics pipeline
    VkGraphicsPipelineCreateInfo pipelineInfo;
    memset(&pipelineInfo, 0, sizeof(pipelineInfo));
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;

    VkPipelineShaderStageCreateInfo shaderStages[2] = {
        {
            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            nullptr,
            0,
            VK_SHADER_STAGE_VERTEX_BIT,
            vertShaderModule,
            "main",
            nullptr
        },
        {
            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            nullptr,
            0,
            VK_SHADER_STAGE_FRAGMENT_BIT,
            fragShaderModule,
            "main",
            nullptr
        }
    };
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;

    pipelineInfo.pVertexInputState = &vertexInputInfo;

    VkPipelineInputAssemblyStateCreateInfo ia;
    memset(&ia, 0, sizeof(ia));
    ia.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    ia.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    pipelineInfo.pInputAssemblyState = &ia;

    // The viewport and scissor will be set dynamically via vkCmdSetViewport/Scissor.
    // This way the pipeline does not need to be touched when resizing the window.
    VkPipelineViewportStateCreateInfo vp;
    memset(&vp, 0, sizeof(vp));
    vp.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    vp.viewportCount = 1;
    vp.scissorCount = 1;
    pipelineInfo.pViewportState = &vp;

    VkPipelineRasterizationStateCreateInfo rs;
    memset(&rs, 0, sizeof(rs));
    rs.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rs.polygonMode = VK_POLYGON_MODE_FILL;
    rs.cullMode = VK_CULL_MODE_NONE; // we want the back face as well
    rs.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rs.lineWidth = 1.0f;
    pipelineInfo.pRasterizationState = &rs;

    VkPipelineMultisampleStateCreateInfo ms;
    memset(&ms, 0, sizeof(ms));
    ms.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    // Enable multisampling.
    ms.rasterizationSamples = m_window->sampleCountFlagBits();
    pipelineInfo.pMultisampleState = &ms;

    VkPipelineDepthStencilStateCreateInfo ds;
    memset(&ds, 0, sizeof(ds));
    ds.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    ds.depthTestEnable = VK_TRUE;
    ds.depthWriteEnable = VK_TRUE;
    ds.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &ds;

    VkPipelineColorBlendStateCreateInfo cb;
    memset(&cb, 0, sizeof(cb));
    cb.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    // no blend, write out all of rgba
    VkPipelineColorBlendAttachmentState att;
    memset(&att, 0, sizeof(att));
    att.colorWriteMask = 0xF;
    cb.attachmentCount = 1;
    cb.pAttachments = &att;
    pipelineInfo.pColorBlendState = &cb;

    VkDynamicState dynEnable[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR };
    VkPipelineDynamicStateCreateInfo dyn;
    memset(&dyn, 0, sizeof(dyn));
    dyn.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dyn.dynamicStateCount = sizeof(dynEnable) / sizeof(VkDynamicState);
    dyn.pDynamicStates = dynEnable;
    pipelineInfo.pDynamicState = &dyn;

    pipelineInfo.layout = m_pipelineLayout;
    pipelineInfo.renderPass = m_window->defaultRenderPass();

    err = m_devFuncs->vkCreateGraphicsPipelines(dev, m_pipelineCache, 1, &pipelineInfo, nullptr, &m_pipeline);
    if (err != VK_SUCCESS)
        qFatal("Failed to create graphics pipeline: %d", err);

    if (vertShaderModule)
        m_devFuncs->vkDestroyShaderModule(dev, vertShaderModule, nullptr);
    if (fragShaderModule)
        m_devFuncs->vkDestroyShaderModule(dev, fragShaderModule, nullptr);
}

void TriangleRenderer::initSwapChainResources()
{
    qDebug("initSwapChainResources");

    // Projection matrix
    m_proj = m_window->clipCorrectionMatrix(); // adjust for Vulkan-OpenGL clip space differences
    const QSize sz = m_window->swapChainImageSize();
    m_proj.perspective(45.0f, sz.width() / (float) sz.height(), 0.01f, 100.0f);
    m_proj.translate(0, 0, -4);
}

void TriangleRenderer::releaseSwapChainResources()
{
    qDebug("releaseSwapChainResources");
}

void TriangleRenderer::releaseResources()
{
    qDebug("releaseResources");

    VkDevice dev = m_window->device();

    if (m_pipeline) {
        m_devFuncs->vkDestroyPipeline(dev, m_pipeline, nullptr);
        m_pipeline = VK_NULL_HANDLE;
    }

    if (m_pipelineLayout) {
        m_devFuncs->vkDestroyPipelineLayout(dev, m_pipelineLayout, nullptr);
        m_pipelineLayout = VK_NULL_HANDLE;
    }

    if (m_pipelineCache) {
        m_devFuncs->vkDestroyPipelineCache(dev, m_pipelineCache, nullptr);
        m_pipelineCache = VK_NULL_HANDLE;
    }

    if (m_descSetLayout) {
        m_devFuncs->vkDestroyDescriptorSetLayout(dev, m_descSetLayout, nullptr);
        m_descSetLayout = VK_NULL_HANDLE;
    }

    if (m_descPool) {
        m_devFuncs->vkDestroyDescriptorPool(dev, m_descPool, nullptr);
        m_descPool = VK_NULL_HANDLE;
    }

    if (m_buf) {
        m_devFuncs->vkDestroyBuffer(dev, m_buf, nullptr);
        m_buf = VK_NULL_HANDLE;
    }

    if (m_bufMem) {
        m_devFuncs->vkFreeMemory(dev, m_bufMem, nullptr);
        m_bufMem = VK_NULL_HANDLE;
    }
}

void TriangleRenderer::startNextFrame()
{
    VkDevice dev = m_window->device();
    VkCommandBuffer cb = m_window->currentCommandBuffer();
    const QSize sz = m_window->swapChainImageSize();

    VkClearColorValue clearColor = {{ 0, 0, 0, 1 }};
    VkClearDepthStencilValue clearDS = { 1, 0 };
    VkClearValue clearValues[3];
    memset(clearValues, 0, sizeof(clearValues));
    clearValues[0].color = clearValues[2].color = clearColor;
    clearValues[1].depthStencil = clearDS;

    VkRenderPassBeginInfo rpBeginInfo;
    memset(&rpBeginInfo, 0, sizeof(rpBeginInfo));
    rpBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    rpBeginInfo.renderPass = m_window->defaultRenderPass();
    rpBeginInfo.framebuffer = m_window->currentFramebuffer();
    rpBeginInfo.renderArea.extent.width = sz.width();
    rpBeginInfo.renderArea.extent.height = sz.height();
    rpBeginInfo.clearValueCount = m_window->sampleCountFlagBits() > VK_SAMPLE_COUNT_1_BIT ? 3 : 2;
    rpBeginInfo.pClearValues = clearValues;
    VkCommandBuffer cmdBuf = m_window->currentCommandBuffer();
    m_devFuncs->vkCmdBeginRenderPass(cmdBuf, &rpBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

    quint8 *p;
    VkResult err = m_devFuncs->vkMapMemory(dev, m_bufMem, m_uniformBufInfo[m_window->currentFrame()].offset,
            UNIFORM_DATA_SIZE, 0, reinterpret_cast<void **>(&p));
    if (err != VK_SUCCESS)
        qFatal("Failed to map memory: %d", err);
    QMatrix4x4 m = m_proj;
    m.rotate(m_rotation, m_rotation_ver , 1, 0);
    memcpy(p, m.constData(), 16 * sizeof(float));
    m_devFuncs->vkUnmapMemory(dev, m_bufMem);

    // Not exactly a real animation system, just advance on every frame for now.
    m_rotation += 1.0f;

    m_devFuncs->vkCmdBindPipeline(cb, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline);
    m_devFuncs->vkCmdBindDescriptorSets(cb, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipelineLayout, 0, 1,
                               &m_descSet[m_window->currentFrame()], 0, nullptr);
    VkDeviceSize vbOffset = 0;
    m_devFuncs->vkCmdBindVertexBuffers(cb, 0, 1, &m_buf, &vbOffset);

    VkViewport viewport;
    viewport.x = viewport.y = 0;
    viewport.width = sz.width();
    viewport.height = sz.height();
    viewport.minDepth = 0;
    viewport.maxDepth = 1;
    m_devFuncs->vkCmdSetViewport(cb, 0, 1, &viewport);

    VkRect2D scissor;
    scissor.offset.x = scissor.offset.y = 0;
    scissor.extent.width = viewport.width;
    scissor.extent.height = viewport.height;
    m_devFuncs->vkCmdSetScissor(cb, 0, 1, &scissor);

    m_devFuncs->vkCmdDraw(cb, 3, 1, 0, 0);

    m_devFuncs->vkCmdEndRenderPass(cmdBuf);

    m_window->frameReady();
    m_window->requestUpdate(); // render continuously, throttled by the presentation rate
}

::::./Rendering/Src/LayoutModel.h::::#pragma once

#include "lve_model.hpp"


class LayoutModel : public LveModel
{
public:
    LayoutModel(LveDevice& device, MODEL_TYPE model_type, const std::string& data_file);
    ~LayoutModel();

    LayoutModel() = delete;
    LayoutModel(const LayoutModel&) = delete;
    LayoutModel& operator=(const LayoutModel&) = delete;

private:
    LayoutDataManager layout_data;

public:
    virtual void makeRenderingData(const std::string& file_path = "");
    virtual void loadData(const std::string& file_path = "");
    virtual void makeVertices();
    virtual void makeIndices();

    void makeCubeVertices();
    void makeIndicesForFace();
    void makeIndicesForEdge();

    void makeCubeVertices_map();
    void makeIndicesForFace_map();
    void makeIndicesForEdge_map();

    LayoutDataManager* getLayoutDataManager() {return &this->layout_data;}

};



::::./Rendering/Src/LayoutPEXData.h::::#pragma once
#include <iostream>
#include <string>
#include <vector>



void testPEXData();
void testLayoutData();

enum LAYOUTINFO_INDEX {
    //LAYOUTINFO_IDX_STRUCTURE = 0,
    //LAYOUTINFO_IDX_CELLNAME = 1,
    LAYOUTINFO_IDX_LAYER = 0,
    LAYOUTINFO_IDX_DATATYPE = 1,
    LAYOUTINFO_IDX_LEFT = 2,
    LAYOUTINFO_IDX_BOTTOM = 3,
    LAYOUTINFO_IDX_RIGHT = 4,
    LAYOUTINFO_IDX_TOP = 5,
    LAYOUTINFO_IDX_ZSTART = 6,
    LAYOUTINFO_IDX_ZEND = 7,
    LAYOUTINFO_IDX_DEFAULT = -1,

};

enum LAYOUT_LAYER_TYPE {
    LAYOUT_LAYER_TYPE_1 = 0,
    LAYOUT_LAYER_TYPE_DEFAULT = 99
};

enum PEXINFO_INDEX {
    PEXINFO_INDEX_NAME = 0,

    PEXINFO_INDEX_NODE1_NAME = 1,
    PEXINFO_INDEX_NODE1_X = 2,
    PEXINFO_INDEX_NODE1_Y = 3,
    PEXINFO_INDEX_NODE1_ZSTART = 4,
    PEXINFO_INDEX_NODE1_ZEND = 5,
    PEXINFO_INDEX_NODE1_LVL = 6,
    PEXINFO_INDEX_NODE1_LAYER_NUMBER = 7,
    PEXINFO_INDEX_NODE1_LAYER_DATATYPE = 8,
    PEXINFO_INDEX_NODE2_NAME = 9,
    PEXINFO_INDEX_NODE2_X = 10,
    PEXINFO_INDEX_NODE2_Y = 11,
    PEXINFO_INDEX_NODE2_ZSTART = 12,
    PEXINFO_INDEX_NODE2_ZEND = 13,
    PEXINFO_INDEX_NODE2_LVL = 14,
    PEXINFO_INDEX_NODE2_LAYER_NUMBER = 15,
    PEXINFO_INDEX_NODE2_LAYER_DATATYPE = 16,

    PEXINFO_INDEX_VALUE = 17,
    PEXINFO_INDEX_DESCRIPTION = 18,
    PEXINFO_INDEX_DEFULT = 999
};

enum PEXResDirection {
    RES_DIRECTION_VERTICAL = 0,
    RES_DIRECTION_HORIZONTAL = 1,
    RES_DIRECTION_NONE = 99
};

struct cube_info {
    double minx;
    double miny;
    double maxx;
    double maxy;
    double minz;
    double maxz;
};

struct coord3d {
    double x;
    double y;
    double z;
};

struct cube_vertex {
    float layernum;
    coord3d vertex[8];
};

struct node {
    double x;
    double y;
    double z_start;
    double z_end;
    unsigned int layer_number;
    unsigned int layer_datatype;
    std::string name;
};
typedef struct node pex_node;

class LayoutItem {
public:
    LayoutItem();
    ~LayoutItem();
    LayoutItem(const cube_info& pattern_, const int layer_number_, const int layer_datatype_, LAYOUT_LAYER_TYPE layer_type_);

public:
    cube_info pattern;
    unsigned int layer_number;
    unsigned int layer_datatype;
    LAYOUT_LAYER_TYPE layer_type;
};


class LayoutDataManager
{
public:
    LayoutDataManager();
    ~LayoutDataManager();

private:
    std::string file_path;
    std::vector<LayoutItem> patterns;

    double scale;

    double layout_min_x;
    double layout_max_x;
    double layout_min_y;
    double layout_max_y;
    double layout_min_z;
    double layout_max_z;



public:
    std::vector<LayoutItem>& getPatterns() { return this->patterns; }

    void loadLayoutData(const std::string file_path);
    void clear() { this->patterns.clear(); };
    void printLayoutData() {};

    double getMinX() { return this->layout_min_x; }
    double getMaxX() { return this->layout_max_x; }
    double getMinY() { return this->layout_min_y; }
    double getMaxY() { return this->layout_max_y; }
    double getMinZ() { return this->layout_min_z; }
    double getMaxZ() { return this->layout_max_z; }
    double getScale() { return this->scale; }

private:
    void calculateScale();

};

class PEXItem
{
public:
    PEXItem();
    ~PEXItem();
    PEXItem(const node& node1_, const node& node2_, const double& value_, const std::string& name_);

public:
    node node1;
    node node2;
    double value;
    std::string name;

public:
    void setNode1(node& node_) { this->node1 = node_; }
    void setNode2(node& node_) { this->node2 = node_; }
    void setValue(double value_) { this->value = value_; }

    node& getNode1() { return this->node1; }
    node& getNode2() { return this->node2; }
    double getValue() { return this->value; }

    virtual void print();
};



class PEXResistor : public PEXItem
{
public:
    PEXResistor();
    ~PEXResistor();
    PEXResistor(const std::string& name_, const node& node1_, const node& node2_, const double& value_, const PEXResDirection& direction_);

private:
    PEXResDirection direction;

public:
    void setDirection(PEXResDirection direction_) { this->direction = direction_; }
    PEXResDirection getDirection() const { return this->direction; }

    static PEXResDirection checkDirectionFromDescription(const std::string& description);

    void print();
};

class PEXCapacitor : public PEXItem
{
public:
    PEXCapacitor();
    ~PEXCapacitor();
    PEXCapacitor(const std::string& name_, const node& node1_, const node& node2_, const double& value_);

public:
    void print();
};


class PEXResistorDataManager
{
public:
    PEXResistorDataManager();
    ~PEXResistorDataManager();

private:
    std::string file_path;

    std::vector<PEXResistor> resistors;

    double max_resistor_vertical;
    double min_resistor_vertical;
    double max_resistor_horizontal;
    double min_resistor_horizontal;

public:
    std::vector<PEXResistor>& getResistors() { return this->resistors; }

    void loadData(const std::string file_path);
    void clear();
    void printData();

    double getMinResistorVerticalValue() { return this->min_resistor_vertical; }
    double getMaxResistorVerticalValue() { return this->max_resistor_vertical; }
    double getMinResistorHorizontalValue() { return this->min_resistor_horizontal; }
    double getMaxResistorHorizontalValue() { return this->max_resistor_horizontal; }

private:
    void updateMinMaxRes(const double& value, const PEXResDirection direction);
};

class PEXCapacitorDataManager
{
public:
    PEXCapacitorDataManager();
    ~PEXCapacitorDataManager();

private:
    std::string file_path;

    std::vector<PEXCapacitor> capasitors;

    double max_capacitor;
    double min_capacitor;

public:
    std::vector<PEXCapacitor>& getCapacitors() { return this->capasitors; }

    void loadData(const std::string file_path);
    void clear();
    void printData();

    double getMinCapacitorValue() { return this->min_capacitor; }
    double getMaxCapacitorValue() { return this->max_capacitor; }

private:
    void updateMinMaxCap(const double& value);
};

::::./Rendering/Src/PEXCapacitorModel.h::::#pragma once
#include "lve_model.hpp"
#include "LayoutPEXData.h"

#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <limits>
#include <thread>
#include <queue>
#include <mutex>
#include <cstdio>


typedef unsigned int uint;

class PEXCapacitorModel : public LveModel
{
public:
    struct cap_node {
        double x;
        double y;
        uint layer_number;
        uint layer_datatype;
        std::string name;
        double value;
        uint connected_count;
    };

    struct pattern_cap {
        cube_info pattern;
        uint layer_number;
        uint layer_datatype;
        double cap_value;
        double normalized_cap_value;
        uint cap_count;
        pattern_cap(cube_info& pattern_, uint number_, uint datatype_, double value_, double norm_value_, uint count_) :
            pattern(pattern_), layer_number(number_),
            layer_datatype(datatype_),
            cap_value(value_), normalized_cap_value(norm_value_),
            cap_count(count_) {}

    };

public:
    PEXCapacitorModel(
            LveDevice& device, MODEL_TYPE model_type,
            const std::string& data_file = "", LayoutDataManager* layout_data_ = nullptr);
    ~PEXCapacitorModel();

    PEXCapacitorModel() = delete;
    PEXCapacitorModel(const PEXCapacitorModel&) = delete;
    PEXCapacitorModel& operator=(const PEXCapacitorModel&) = delete;

private:
    PEXCapacitorDataManager pex_data;
    std::map<std::string, size_t> cap_node_name_to_index_map;
    LayoutDataManager* layout_data = nullptr;

    std::vector<cap_node> cap_nodes;
    std::map<std::string, std::vector<cap_node*>> layer_to_cap_node_map;

    std::vector<pattern_cap> pattern_caps;
    std::map<std::string, std::vector<pattern_cap*>> layer_to_pattern_cap_map;

    std::set<std::pair<uint, uint>> layers;

    double max_cap = std::numeric_limits<double>::min();

    size_t num_threads = { 4 };
    std::vector<std::thread> threads;
    std::queue<std::string> layers_queue;
    std::mutex mutex_layers_queue;

public:
    virtual void makeRenderingData(const std::string& file_path = "");
    virtual void loadData(const std::string& file_path = "");
    virtual void makeVertices();
    virtual void makeIndices();

    void makeCubeVertices();

private:
    void makeCapNodesFromPEXData();
    void makePatternCapsFromLayoutData();

    void attachCapToPattern();
    void makeLayerToCapNodeMap();
    void makeLayerToPatternCapMap();

    void matchCapWithPatternThread(std::queue<std::string>* layers, std::mutex* mutex_);
    void matchCapWithPattern(std::vector<cap_node*>& caps, std::vector<pattern_cap*>& patterns);
    void matchCapWithPattern(
            std::map<std::string, std::vector<cap_node*>>& cap_layer_map_,
            std::map<std::string, std::vector<pattern_cap*>>& pattern_layer_map_,
            uint target_layer_number, uint target_layer_datatype);
    bool isPatternIncludeCap(const pattern_cap& pattern, const cap_node& cap);

    void setLayoutDataManager(LayoutDataManager* layout_data_) { this->layout_data = layout_data_; }
    void addNewCapNode(pex_node& new_node, double value);

    std::string getLayerString(uint layer_number, uint layer_datatype);

    void normalizePatternCap();

    void makeLayersQueueForThreadJob();




    void printCapNodes();
    void printPatternCaps(FILE* stream = stdout);
    void printLayerToCapNodeMap(FILE* stream = stdout);
    void printLayerToPatternCapMap(const char* msg = "");
    void printLayerList();
};


::::./Rendering/Src/PEXResistorModel.h::::#pragma once

#include "lve_model.hpp"



class PEXResistorModel : public LveModel
{
public:

    PEXResistorModel(LveDevice& device, MODEL_TYPE model_type, const std::string& data_file = "");
    ~PEXResistorModel();

    PEXResistorModel() = delete;
    PEXResistorModel(const PEXResistorModel&) = delete;
    PEXResistorModel& operator=(const PEXResistorModel&) = delete;

private:
    PEXResistorDataManager pex_data;
    double res_cube_thickness;


public:
    virtual void makeRenderingData(const std::string& file_path = "");
    virtual void loadData(const std::string& file_path = "");
    virtual void makeVertices();
    virtual void makeIndices();

    void makeCubeVertices();
    void makeCubes();
    void makeCube(const PEXResistor& in_res, cube_info& out_cube, PEXResDirection direction);
    void setResCubeThickness(double value) { this->res_cube_thickness = value; }

private:

};



::::./Rendering/Src/dtaorendersystem.h::::#ifndef DTAORENDERSYSTEM_H
#define DTAORENDERSYSTEM_H

#include <QVulkanWindow>
#include <QVulkanWindowRenderer>
#include <QVulkanDeviceFunctions>
#include <vulkan/vulkan.h>

#include "lve_window.hpp"
#include "lve_device.hpp"
#include "lve_game_object.hpp"
#include "simple_render_system.hpp"
#include "lve_camera.hpp"
#include "keyboard_movement_controller.hpp"


#include <iostream>
#include <vector>


class LayoutModel;

class DtaoRenderSystem : public QVulkanWindowRenderer
{
public:
    DtaoRenderSystem(LveWindow *w);
    ~DtaoRenderSystem();

    DtaoRenderSystem(const DtaoRenderSystem &) = delete;
    DtaoRenderSystem &operator=(const DtaoRenderSystem &) = delete;


    void initResources() override;
    void initSwapChainResources() override;
    void releaseSwapChainResources() override;
    void releaseResources() override;

    void startNextFrame() override;

    float getRenderScale() {return this->trans_info.scale;}
    LayoutModel* getLayoutModel();
    bool isRenderModelLoaded(){return this->render_object_created;}

public:
    LveCamera camera{};
    KeyboardMovementController cameraController{};


private:
    QVulkanDeviceFunctions *m_devFuncs = nullptr;

    void loadGameObjects();

    LveWindow* lveWindow = nullptr;
    LveDevice* lveDevice = nullptr;
    SimpleRenderSystem* simpleRenderSystem = nullptr;

    std::vector<LveGameObject> gameObjects{};
    bool render_object_created = {false};


    struct TRANS_INFORMATION{
       float trans_x;
       float trans_y;
       float trans_z;
       float scale;
    };
    TRANS_INFORMATION trans_info;
    std::shared_ptr<LayoutModel> layout_model = {nullptr};

public:
    void createNewObject(MODEL_TYPE model_type, const std::string & file_path);

private:
    void createNewLayoutObject(const std::string & file_path);
    void createNewPEXCapObject(const std::string & file_path);
    void createNewPEXResObject(const std::string & file_path);
    void createNewAxisObject(const std::string & file_path);


private:
    void createLveDevice();
    void deleteLveDevice();
    void createSimpleRenderSystem();
    void deleteSimpleRenderSystem();
    void beginRenderPass(VkCommandBuffer command_buffer);

};

#endif // DTAORENDERSYSTEM_H
::::./Rendering/Src/keyboard_movement_controller.hpp::::#pragma once

#include <QKeyEvent>
#include <QMouseEvent>
#include "lve_game_object.hpp"
#include "lve_window.hpp"
#include "lve_camera.hpp"


class KeyboardMovementController {
public:
    struct CameraMoveKeyMappings {
        int rotateLeft = Qt::Key_A;
        int rotateRight = Qt::Key_D;
        int moveForward = Qt::Key_W;
        int moveBackward = Qt::Key_S;
        int rotateForward = Qt::Key_E;
        int rotateBackward = Qt::Key_Q;
        int moveUp = Qt::Key_Up;
        int moveDown= Qt::Key_Down;
        int moveLeft= Qt::Key_Left;
        int moveRight= Qt::Key_Right;
        Qt::MouseButtons mouseLeft = Qt::LeftButton;
        Qt::MouseButtons mouseRight = Qt::RightButton;
    };

    struct CameraMovingContinousFlags {
        bool rotateLeft = false;
        bool rotateRight = false;
        bool moveForward = false;
        bool moveBackward = false;
        bool rotateForward = false;
        bool rotateBackward = false;
        bool moveUp = false;
        bool moveDown= false;
        bool moveLeft= false;
        bool moveRight= false;
        bool mouseLeft= false;
        bool mouseRight= false;
    };

    struct MousePosition {
        QPoint pressPosition;
        QPoint releasePosition;
        QPoint currentPosition;
        QPoint scroll;
    };

    void moveCamera(Qt::Key key, float dt, LveCamera& camera, float render_scale);
    CameraMoveKeyMappings camera_move_key;
    MousePosition mouse_position;

    void moveCamera(float dt, LveCamera& camera, float render_scale,std::vector<LveGameObject>& gameObjects);
    void moveCameraMouse(LveCamera& camera, float render_scale,std::vector<LveGameObject>& gameObjects);
    void moveKeyPressed(Qt::Key key);
    void moveKeyReleased(Qt::Key key);
    void moveButtonPressed(Qt::MouseButtons buttons);
    void moveButtonReleased(Qt::MouseButtons buttons);
    void setAllMoveFlagOff();
    void setMouseFlagOff();
    void setMousePosition(QPoint position, int mode);
    void setMouseScroll(QPoint position);
    CameraMovingContinousFlags camera_moving_flag;


    /*
    struct KeyMappings {
        int moveLeft = Qt::Key_A;//'GLFW_KEY_A;
        int moveRight = Qt::Key_D;
        int moveForward = Qt::Key_W;
        int moveBackward = Qt::Key_S;
        int moveUp = Qt::Key_E;
        int moveDown = Qt::Key_Q;
        int lookLeft = Qt::Key_Left;
        int lookRight = Qt::Key_Right;
        int lookUp = Qt::Key_Up;
        int lookDown = Qt::Key_Down;
        //int mouseLeft = GLFW_MOUSE_BUTTON_LEFT;
        //int mouseRight = GLFW_MOUSE_BUTTON_RIGHT;
    };

    struct ModelVisibleSet {

        int edge_key = GLFW_KEY_E;
        int layout_key = GLFW_KEY_L;
        int resistor_key = GLFW_KEY_R;
        int capacitor_key = GLFW_KEY_C;
        int axis_key = GLFW_KEY_X;
        int vertical_resistor_key = GLFW_KEY_V;
        int horizontal_resistor_key = GLFW_KEY_H;
        int opacity_plus_key = GLFW_KEY_O;
        int opacity_minus_key = GLFW_KEY_P;

        bool edge_key_pressed = false;
        bool layout_key_pressed = false;
        bool resistor_key_pressed = false;
        bool capacitor_key_pressed = false;
        bool axis_key_pressed = false;
        bool vertical_resistor_key_pressed = false;
        bool horizontal_resistor_key_pressed = false;
        bool opacity_plus_key_pressed = false;
        bool opacity_minus_key_pressed = false;

    };

    void moveInPlaneXZ(GLFWwindow* window, float dt, std::vector<LveGameObject>& gameObjects);

    void moveCamera(GLFWwindow* window, float dt, LveCamera& camera, std::vector<LveGameObject>& gameObjects);
    CameraMoveKeyMappings camera_move_key;

    void visibleSetting(GLFWwindow* window, std::vector<LveGameObject>& gameObjects);
    ModelVisibleSet model_visible_set;

    void initMouse(GLFWwindow* window);
    static void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);

    KeyMappings keys{};
    double mouseX;
    double mouseY;
    double oldXPos;
    double oldYPos;
    float moveSpeed{ 3.f };
    float lookSpeed{ 1.5f };

    //KeyMappings keys{};
*/
    float moveSpeed{ 0.05f };
    float lookSpeed{ 1.5f };
    int xpos_prev;
    int ypos_prev;
};

::::./Rendering/Src/lve_camera.hpp::::#pragma once

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>
#include <glm/gtx/matrix_decompose.hpp>



class LveCamera {
public:
    void setOrthographicProjection(
            float left, float right, float top, float bottom, float near, float far);
    void setPerspectiveProjection(float fovy, float aspect, float near, float far);

    void setViewDirection(
            glm::vec3 position, glm::vec3 direction, glm::vec3 up = glm::vec3{0.f, -1.f, 0.f});
    void setViewTarget(
            glm::vec3 position, glm::vec3 target, glm::vec3 up = glm::vec3{0.f, -1.f, 0.f});
    void setViewYXZ(glm::vec3 position, glm::vec3 rotation);

    const glm::mat4& getProjection() const { return projectionMatrix; }
    const glm::mat4& getView() const { return viewMatrix; }
    void decomposeView(glm::mat4 viewMat);

public:
    glm::mat4 projectionMatrix{1.f};
    glm::mat4 viewMatrix{1.f};

    glm::vec3 scale_d;
    glm::quat rotation_d;
    glm::vec3 translation_d;
    glm::vec3 skew_d;
    glm::vec4 perspective_d;

};

::::./Rendering/Src/lve_device.hpp::::#pragma once

#include <QVulkanInstance>
#include <vulkan/vulkan.h>

// std lib headers
#include <string>
#include <vector>

#include "lve_window.hpp"


struct SwapChainSupportDetails {
    VkSurfaceCapabilitiesKHR capabilities;
    std::vector<VkSurfaceFormatKHR> formats;
    std::vector<VkPresentModeKHR> presentModes;
};

struct QueueFamilyIndices {
    uint32_t graphicsFamily;
    uint32_t presentFamily;
    bool graphicsFamilyHasValue = false;
    bool presentFamilyHasValue = false;
    bool isComplete() { return graphicsFamilyHasValue && presentFamilyHasValue; }
};

class LveDevice {
public:
#ifdef NDEBUG
    const bool enableValidationLayers = false;
#else
    const bool enableValidationLayers = true;
#endif

    LveDevice(LveWindow* window, QVulkanInstance* qvk_inst);
    ~LveDevice();

    // Not copyable or movable
    LveDevice(const LveDevice &) = delete;
    LveDevice &operator=(const LveDevice &) = delete;
    LveDevice(LveDevice &&) = delete;
    LveDevice &operator=(LveDevice &&) = delete;

    VkCommandPool getVkCommandPool() { return commandPool; }
    VkDevice device() { return device_; }
    VkSurfaceKHR surface() { return surface_; }
    VkQueue graphicsQueue() { return graphicsQueue_; }
    VkQueue presentQueue() { return presentQueue_; }
    VkInstance getInstance() { return this->instance;}

    SwapChainSupportDetails getSwapChainSupport() { return querySwapChainSupport(physicalDevice); }
    uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties);
    QueueFamilyIndices findPhysicalQueueFamilies() { return findQueueFamilies(physicalDevice); }
    VkFormat findSupportedFormat(
            const std::vector<VkFormat> &candidates, VkImageTiling tiling, VkFormatFeatureFlags features);

    // Buffer Helper Functions
    void createBuffer(
            VkDeviceSize size,
            VkBufferUsageFlags usage,
            VkMemoryPropertyFlags properties,
            VkBuffer &buffer,
            VkDeviceMemory &bufferMemory);
    VkCommandBuffer beginSingleTimeCommands();
    void endSingleTimeCommands(VkCommandBuffer commandBuffer);
    void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size);
    void copyBufferToImage(
            VkBuffer buffer, VkImage image, uint32_t width, uint32_t height, uint32_t layerCount);

    void createImageWithInfo(
            const VkImageCreateInfo &imageInfo,
            VkMemoryPropertyFlags properties,
            VkImage &image,
            VkDeviceMemory &imageMemory);

    VkPhysicalDeviceProperties properties;

private:
    void createInstance();
    void setupDebugMessenger();
    void createSurface();
    void pickPhysicalDevice();
    void createLogicalDevice();
    void createCommandPool();

    // helper functions
    bool isDeviceSuitable(VkPhysicalDevice device);
    std::vector<const char *> getRequiredExtensions();
    bool checkValidationLayerSupport();
    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device);
    void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT &createInfo);
    void hasRequiredInstanceExtensions();
    bool checkDeviceExtensionSupport(VkPhysicalDevice device);
    SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device);

    VkInstance instance;
    VkDebugUtilsMessengerEXT debugMessenger;
    VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
    LveWindow * window;
    QVulkanInstance * qvk_instance;
    VkCommandPool commandPool;

    VkDevice device_;
    VkSurfaceKHR surface_;
    VkQueue graphicsQueue_;
    VkQueue presentQueue_;

    const std::vector<const char *> validationLayers = {"VK_LAYER_KHRONOS_validation"};
    const std::vector<const char *> deviceExtensions = {VK_KHR_SWAPCHAIN_EXTENSION_NAME};
};

::::./Rendering/Src/lve_game_object.hpp::::#pragma once

#include "lve_model.hpp"

// libs
#include <glm/gtc/matrix_transform.hpp>
#include <glm/glm.hpp> //vec3, vec4, ivec4, mat4
#include <glm/gtc/type_ptr.hpp> //value_ptr

// std
#include <memory>


struct TransformComponent {
    glm::vec3 translation{};
    glm::vec3 scale{ 1.f, 1.f, 1.f };
    glm::vec3 rotation{};

    // Matrix corrsponds to Translate * Ry * Rx * Rz * Scale
    // Rotations correspond to Tait-bryan angles of Y(1), X(2), Z(3)
    // https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
    glm::mat4 mat4() {
        glm::mat4 glm_mat4 = glm::mat4{ 1 };
        //glm_mat4 = glm::rotate(glm_mat4,  rotation.x, glm::vec3(1.0f, 0.0f, 0.0f));
        //glm_mat4 = glm::rotate(glm_mat4, rotation.y, glm::vec3(0.0f, 1.0f, 0.0f));
        //glm_mat4 = glm::rotate(glm_mat4, rotation.z, glm::vec3(1.0f, 0.0f, 1.0f));
        glm_mat4 = glm::scale(glm_mat4, scale);
        glm_mat4 = glm::translate(glm_mat4, translation);


        return glm_mat4;
    }
};

class LveGameObject {
public:
    using id_t = unsigned int;

    static LveGameObject createGameObject() {
        static id_t currentId = 0;
        std::cout << "\n\n***LveGameObject :: id : " << currentId << "\n\n";
        return LveGameObject{ currentId++ };
    }

    LveGameObject(const LveGameObject&) = delete;
    LveGameObject& operator=(const LveGameObject&) = delete;
    LveGameObject(LveGameObject&&) = default;
    LveGameObject& operator=(LveGameObject&&) = default;

    id_t getId() { return id; }

    void setEdgeLineEnable(bool flag) { this->edge_line_enabled = flag; }
    void setAxisLineEnable(bool flag) { this->axis_line_enabled = flag; }

public:
    std::shared_ptr<LveModel> model{};
    //LveModel* model{};
    glm::vec3 color{};
    TransformComponent transform{};

private:
    LveGameObject(id_t objId) : id{ objId } {}

    id_t id;

private:
    bool edge_line_enabled = { true };
    bool axis_line_enabled = { true };
};

class DTAOObject {
public:
    using id_t = unsigned int;

    static DTAOObject createObject() {
        static id_t currentId = 0;
        std::cout << "\n\n***DTAOObject :: id : " << currentId << "\n\n";
        return DTAOObject{ currentId++ };
    }

    DTAOObject(const DTAOObject&) = delete;
    DTAOObject& operator=(const DTAOObject&) = delete;
    DTAOObject(DTAOObject&&) = default;
    DTAOObject& operator=(DTAOObject&&) = default;

    id_t getId() { return id; }

    void setEdgeLineEnable(bool flag) { this->edge_line_enabled = flag; }
    void setAxisLineEnable(bool flag) { this->axis_line_enabled = flag; }

public:
    std::shared_ptr<LveModel> model{};
    //LveModel* model{};
    glm::vec3 color{};
    TransformComponent transform{};

private:
    DTAOObject(id_t objId) : id{ objId } {}

    id_t id;

private:
    bool edge_line_enabled = { true };
    bool axis_line_enabled = { true };
};
::::./Rendering/Src/lve_model.hpp::::#pragma once

#include "lve_device.hpp"

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>

// std
#include <vector>

#include <string>
#include <iostream>
#include <map>
//#include <ranges>
#include "LayoutPEXData.h"

typedef enum MODEL_TYPE {
    MODEL_TYPE_LAYOUT = 0,
    MODEL_TYPE_AXIS,
    MODEL_TYPE_PEX_RESISTOR,
    MODEL_TYPE_PEX_CAPACITOR,
    MODEL_TYPE_DEFAULT
} MODEL_TYPE;




class LveModel {
public:
    struct Vertex {
        glm::vec3 position{};
        glm::vec3 color{};
        glm::vec3 normal{};

        static std::vector<VkVertexInputBindingDescription> getBindingDescriptions();
        static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions();
    };

    LveModel(LveDevice& device, MODEL_TYPE model_type);
    ~LveModel();

    LveModel() = delete;
    LveModel(const LveModel&) = delete;
    LveModel& operator=(const LveModel&) = delete;

    //void bind(VkCommandBuffer commandBuffer);
    void bindVertexBuffer(VkCommandBuffer commandBuffer);
    void bindVertexBuffer_map(VkCommandBuffer commandBuffer);
    void bindIndexBufferForFace(VkCommandBuffer commandBuffer);
    void bindIndexBufferForFace_map(VkCommandBuffer commandBuffer);
    void bindDrawVertexIndexBufferForFace_map(VkCommandBuffer commandBuffer);
    void bindDrawVertexIndexBufferForFace_layer(VkCommandBuffer commandBuffer, const float layer);
    void bindDrawIndexBufferForEdge_layer(VkCommandBuffer commandBuffer, const float layer);
    void bindIndexBufferForEdge(VkCommandBuffer commandBuffer);
    void drawForFace(VkCommandBuffer commandBuffer);
    void drawForEdge(VkCommandBuffer commandBuffer);


public:
    void createBuffers();
    void destroyBuffers();
    void createVertexBuffers(const std::vector<Vertex>& vertices, VkBuffer& buffer, VkDeviceMemory& memory);
    void createIndexBuffers(const std::vector<uint32_t>& indices, VkBuffer & buffer, VkDeviceMemory & memory);
    LveDevice& lveDevice;
    VkBuffer vertexBuffer{};
    VkDeviceMemory vertexBufferMemory{};
    std::map<float, VkBuffer> layerbyVertexBuffers;
    std::map<float, VkDeviceMemory> layerbyVertexBuffersMemory;
    uint32_t vertexCount{};

    VkBuffer indexBufferForFace{};
    VkDeviceMemory indexBufferMemoryForFace{};
    VkBuffer indexBufferForEdge{};
    VkDeviceMemory indexBufferMemoryForEdge{};

    std::map<float, VkBuffer> layerbyFaceIndexBuffers;
    std::map<float, VkDeviceMemory> layerbyFaceIndexBuffersMemory;
    std::map<float, VkBuffer> layerbyEdgeIndexBuffers;
    std::map<float, VkDeviceMemory> layerbyEdgeIndexBuffersMemory;

    MODEL_TYPE model_type{};

public:
    //std::string layout_info_file;
    std::vector<cube_info> cube_infos{};
    std::vector<cube_vertex> cube_vertices{};

    std::vector<Vertex> vertices{};
    std::vector<uint32_t> indices_face{};
    std::vector<uint32_t> indices_edge{};

    std::map<float, std::vector<Vertex>> layerby_vertices;
    std::map<float, std::vector<uint32_t>> layerby_face;
    std::map<float, std::vector<uint32_t>> layerby_edge;
    std::map<float, glm::vec3> layerList;

    bool visible{true};
    float opacity{ 1.0f };

public:
    MODEL_TYPE getModelType() { return this->model_type; }

public:
    //void setLayoutInfoFile(const std::string file_path) { this->layout_info_file = file_path; }
    virtual void makeRenderingData(const std::string& file_path = "") {(void)file_path;};
    virtual void loadData(const std::string& file_path = "") {(void)file_path;};
    virtual void makeVertices() {};
    virtual void makeIndices() {};

    void makeAxisData(const float axis_length = (2.0f));
    void setVisible(bool flag) { this->visible = flag; }
    bool getVisible() { return this->visible; }
    void toggleVisible() { this->visible = !this->visible; }
    void updateOpacity(float amount);
    float getOpacity() { return this->opacity; }
    std::map<float, glm::vec3> getLayer();
};

::::./Rendering/Src/lve_pipeline.hpp::::#pragma once

#include "lve_device.hpp"

// std
#include <string>
#include <vector>



struct PipelineConfigInfo {
    PipelineConfigInfo() = default;
    PipelineConfigInfo(const PipelineConfigInfo&) = delete;
    PipelineConfigInfo& operator=(const PipelineConfigInfo&) = delete;

    VkPipelineViewportStateCreateInfo viewportInfo;
    VkPipelineInputAssemblyStateCreateInfo inputAssemblyInfo;
    VkPipelineRasterizationStateCreateInfo rasterizationInfo;
    VkPipelineMultisampleStateCreateInfo multisampleInfo;
    VkPipelineColorBlendAttachmentState colorBlendAttachment;
    VkPipelineColorBlendStateCreateInfo colorBlendInfo;
    VkPipelineDepthStencilStateCreateInfo depthStencilInfo;
    std::vector<VkDynamicState> dynamicStateEnables;
    VkPipelineDynamicStateCreateInfo dynamicStateInfo;
    VkPipelineLayout pipelineLayout = nullptr;
    VkRenderPass renderPass = nullptr;
    uint32_t subpass = 0;
};

class LvePipeline {
public:
    LvePipeline(
            LveDevice& device,
            const std::string& vertFilepath,
            const std::string& fragFilepath,
            const PipelineConfigInfo& configInfo);
    ~LvePipeline();

    LvePipeline(const LvePipeline&) = delete;
    LvePipeline& operator=(const LvePipeline&) = delete;

    void bind(VkCommandBuffer commandBuffer);

    static void defaultPipelineConfigInfo(PipelineConfigInfo& configInfo);

private:
    static std::vector<char> readFile(const std::string& filepath);

    void createGraphicsPipeline(
            const std::string& vertFilepath,
            const std::string& fragFilepath,
            const PipelineConfigInfo& configInfo);

    void createShaderModule(const std::vector<char>& code, VkShaderModule* shaderModule);

    LveDevice& lveDevice;
    VkPipeline graphicsPipeline;
    VkShaderModule vertShaderModule;
    VkShaderModule fragShaderModule;
};

::::./Rendering/Src/lve_window.hpp::::#ifndef LVEWINDOW_H
#define LVEWINDOW_H
#include <vulkan/vulkan.h>

#include <QVulkanWindow>
//#include <QVulkanWindowRenderer>

//#include "dtaorendersystem.h"

class QVulkanWidowRenderer;
class DtaoRenderSystem;

class LveWindow : public QVulkanWindow
{
    Q_OBJECT

public:
    LveWindow();
    ~LveWindow();

    LveWindow(const LveWindow &) = delete;
    LveWindow &operator=(const LveWindow &) = delete;

public:
    QVulkanWindowRenderer *createRenderer() override;
    //QVulkanWindowRenderer * getRenderer(){ return this->m_renderer;}
    //LveCamera* camera;

public:
    DtaoRenderSystem * getRenderer(){return this->m_renderer;}

private:
    DtaoRenderSystem *m_renderer;
    //QVulkanWindowRenderer * m_renderer;

    void wheelEvent(QWheelEvent *) override;
    void mousePressEvent(QMouseEvent *) override;
    void mouseReleaseEvent(QMouseEvent *) override;
    void mouseMoveEvent(QMouseEvent *) override;
    void keyPressEvent(QKeyEvent *) override;
    void keyReleaseEvent(QKeyEvent *) override;

    bool keyCtrl = false;
    bool keyShift = false;
    bool keyAlt = false;

    int m_mouseButton = 0;


    QPoint m_lastPos;

signals:
    void signalInfoText(QString funcName, float value);
};

#endif // LVEWINDOW_H
::::./Rendering/Src/rapidcsv.h::::/*
 * rapidcsv.h
 *
 * URL:      https://github.com/d99kris/rapidcsv
 * Version:  8.70
 *
 * Copyright (C) 2017-2022 Kristofer Berggren
 * All rights reserved.
 *
 * rapidcsv is distributed under the BSD 3-Clause license, see LICENSE for details.
 *
 */

#pragma once

#include <algorithm>
#include <cassert>
#include <cmath>
#ifdef HAS_CODECVT
#include <codecvt>
#include <locale>
#endif
#include <fstream>
#include <functional>
#include <iostream>
#include <limits>
#include <map>
#include <sstream>
#include <string>
#include <typeinfo>
#include <vector>

#if defined(_MSC_VER)
#include <BaseTsd.h>
typedef SSIZE_T ssize_t;
#endif

namespace rapidcsv
{
#if defined(_MSC_VER)
    static const bool sPlatformHasCR = true;
#else
    static const bool sPlatformHasCR = false;
#endif

    /**
     * @brief     Datastructure holding parameters controlling how invalid numbers (including
     *            empty strings) should be handled.
     */
    struct ConverterParams
    {
        /**
         * @brief   Constructor
         * @param   pHasDefaultConverter  specifies if conversion of non-numerical strings shall be
         *                                converted to a default numerical value, instead of causing
         *                                an exception to be thrown (default).
         * @param   pDefaultFloat         floating-point default value to represent invalid numbers.
         * @param   pDefaultInteger       integer default value to represent invalid numbers.
         * @param   pNumericLocale        specifies whether to honor LC_NUMERIC locale (default
         *                                true).
         */
        explicit ConverterParams(const bool pHasDefaultConverter = false,
            const long double pDefaultFloat = std::numeric_limits<long double>::signaling_NaN(),
            const long long pDefaultInteger = 0,
            const bool pNumericLocale = true)
            : mHasDefaultConverter(pHasDefaultConverter)
            , mDefaultFloat(pDefaultFloat)
            , mDefaultInteger(pDefaultInteger)
            , mNumericLocale(pNumericLocale)
        {
        }

        /**
         * @brief   specifies if conversion of non-numerical strings shall be converted to a default
         *          numerical value, instead of causing an exception to be thrown (default).
         */
        bool mHasDefaultConverter;

        /**
         * @brief   floating-point default value to represent invalid numbers.
         */
        long double mDefaultFloat;

        /**
         * @brief   integer default value to represent invalid numbers.
         */
        long long mDefaultInteger;

        /**
         * @brief   specifies whether to honor LC_NUMERIC locale.
         */
        bool mNumericLocale;
    };

    /**
     * @brief     Exception thrown when attempting to access Document data in a datatype which
     *            is not supported by the Converter class.
     */
    class no_converter : public std::exception
    {
        /**
         * @brief   Provides details about the exception
         * @returns an explanatory string
         */
        virtual const char* what() const throw()
        {
            return "unsupported conversion datatype";
        }
    };

    /**
     * @brief     Class providing conversion to/from numerical datatypes and strings. Only
     *            intended for rapidcsv internal usage, but exposed externally to allow
     *            specialization for custom datatype conversions.
     */
    template<typename T>
    class Converter
    {
    public:
        /**
         * @brief   Constructor
         * @param   pConverterParams      specifies how conversion of non-numerical values to
         *                                numerical datatype shall be handled.
         */
        Converter(const ConverterParams& pConverterParams)
            : mConverterParams(pConverterParams)
        {
        }

        /**
         * @brief   Converts numerical value to string representation.
         * @param   pVal                  numerical value
         * @param   pStr                  output string
         */
        void ToStr(const T& pVal, std::string& pStr) const
        {
            if (typeid(T) == typeid(int) ||
                typeid(T) == typeid(long) ||
                typeid(T) == typeid(long long) ||
                typeid(T) == typeid(unsigned) ||
                typeid(T) == typeid(unsigned long) ||
                typeid(T) == typeid(unsigned long long) ||
                typeid(T) == typeid(float) ||
                typeid(T) == typeid(double) ||
                typeid(T) == typeid(long double) ||
                typeid(T) == typeid(char))
            {
                std::ostringstream out;
                out << pVal;
                pStr = out.str();
            }
            else
            {
                throw no_converter();
            }
        }

        /**
         * @brief   Converts string holding a numerical value to numerical datatype representation.
         * @param   pVal                  numerical value
         * @param   pStr                  output string
         */
        void ToVal(const std::string& pStr, T& pVal) const
        {
            try
            {
                if (typeid(T) == typeid(int))
                {
                    pVal = static_cast<T>(std::stoi(pStr));
                    return;
                }
                else if (typeid(T) == typeid(long))
                {
                    pVal = static_cast<T>(std::stol(pStr));
                    return;
                }
                else if (typeid(T) == typeid(long long))
                {
                    pVal = static_cast<T>(std::stoll(pStr));
                    return;
                }
                else if (typeid(T) == typeid(unsigned))
                {
                    pVal = static_cast<T>(std::stoul(pStr));
                    return;
                }
                else if (typeid(T) == typeid(unsigned long))
                {
                    pVal = static_cast<T>(std::stoul(pStr));
                    return;
                }
                else if (typeid(T) == typeid(unsigned long long))
                {
                    pVal = static_cast<T>(std::stoull(pStr));
                    return;
                }
            }
            catch (...)
            {
                if (!mConverterParams.mHasDefaultConverter)
                {
                    throw;
                }
                else
                {
                    pVal = static_cast<T>(mConverterParams.mDefaultInteger);
                    return;
                }
            }

            try
            {
                if (mConverterParams.mNumericLocale)
                {
                    if (typeid(T) == typeid(float))
                    {
                        pVal = static_cast<T>(std::stof(pStr));
                        return;
                    }
                    else if (typeid(T) == typeid(double))
                    {
                        pVal = static_cast<T>(std::stod(pStr));
                        return;
                    }
                    else if (typeid(T) == typeid(long double))
                    {
                        pVal = static_cast<T>(std::stold(pStr));
                        return;
                    }
                }
                else
                {
                    if ((typeid(T) == typeid(float)) ||
                        (typeid(T) == typeid(double)) ||
                        (typeid(T) == typeid(long double)))
                    {
                        std::istringstream iss(pStr);
                        iss >> pVal;
                        if (iss.fail() || iss.bad() || !iss.eof())
                        {
                            throw std::invalid_argument("istringstream: no conversion");
                        }
                        return;
                    }
                }
            }
            catch (...)
            {
                if (!mConverterParams.mHasDefaultConverter)
                {
                    throw;
                }
                else
                {
                    pVal = static_cast<T>(mConverterParams.mDefaultFloat);
                    return;
                }
            }

            if (typeid(T) == typeid(char))
            {
                pVal = static_cast<T>(pStr[0]);
                return;
            }
            else
            {
                throw no_converter();
            }
        }

    private:
        const ConverterParams& mConverterParams;
    };

    /**
     * @brief     Specialized implementation handling string to string conversion.
     * @param     pVal                  string
     * @param     pStr                  string
     */
    template<>
    inline void Converter<std::string>::ToStr(const std::string& pVal, std::string& pStr) const
    {
        pStr = pVal;
    }

    /**
     * @brief     Specialized implementation handling string to string conversion.
     * @param     pVal                  string
     * @param     pStr                  string
     */
    template<>
    inline void Converter<std::string>::ToVal(const std::string& pStr, std::string& pVal) const
    {
        pVal = pStr;
    }

    template<typename T>
    using ConvFunc = std::function<void(const std::string& pStr, T& pVal)>;

    /**
     * @brief     Datastructure holding parameters controlling which row and column should be
     *            treated as labels.
     */
    struct LabelParams
    {
        /**
         * @brief   Constructor
         * @param   pColumnNameIdx        specifies the zero-based row index of the column labels, setting
         *                                it to -1 prevents column lookup by label name, and gives access
         *                                to all rows as document data. Default: 0
         * @param   pRowNameIdx           specifies the zero-based column index of the row labels, setting
         *                                it to -1 prevents row lookup by label name, and gives access
         *                                to all columns as document data. Default: -1
         */
        explicit LabelParams(const ssize_t pColumnNameIdx = 0, const ssize_t pRowNameIdx = -1)
            : mColumnNameIdx(pColumnNameIdx)
            , mRowNameIdx(pRowNameIdx)
        {
            if (mColumnNameIdx < -1)
            {
                const std::string errStr = "invalid column name index " +
                    std::to_string(mColumnNameIdx) + " < -1";
                throw std::out_of_range(errStr);
            }

            if (mRowNameIdx < -1)
            {
                const std::string errStr = "invalid row name index " +
                    std::to_string(mRowNameIdx) + " < -1";
                throw std::out_of_range(errStr);
            }
        }

        /**
         * @brief   specifies the zero-based row index of the column labels.
         */
        ssize_t mColumnNameIdx;

        /**
         * @brief   specifies the zero-based column index of the row labels.
         */
        ssize_t mRowNameIdx;
    };

    /**
     * @brief     Datastructure holding parameters controlling how the CSV data fields are separated.
     */
    struct SeparatorParams
    {
        /**
         * @brief   Constructor
         * @param   pSeparator            specifies the column separator (default ',').
         * @param   pTrim                 specifies whether to trim leading and trailing spaces from
         *                                cells read (default false).
         * @param   pHasCR                specifies whether a new document (i.e. not an existing document read)
         *                                should use CR/LF instead of only LF (default is to use standard
         *                                behavior of underlying platforms - CR/LF for Win, and LF for others).
         * @param   pQuotedLinebreaks     specifies whether to allow line breaks in quoted text (default false)
         * @param   pAutoQuote            specifies whether to automatically dequote data during read, and add
         *                                quotes during write (default true).
         * @param   pQuoteChar            specifies the quote character (default '\"').
         */
        explicit SeparatorParams(const char pSeparator = ',', const bool pTrim = false,
            const bool pHasCR = sPlatformHasCR, const bool pQuotedLinebreaks = false,
            const bool pAutoQuote = true, const char pQuoteChar = '"')
            : mSeparator(pSeparator)
            , mTrim(pTrim)
            , mHasCR(pHasCR)
            , mQuotedLinebreaks(pQuotedLinebreaks)
            , mAutoQuote(pAutoQuote)
            , mQuoteChar(pQuoteChar)
        {
        }

        /**
         * @brief   specifies the column separator.
         */
        char mSeparator;

        /**
         * @brief   specifies whether to trim leading and trailing spaces from cells read.
         */
        bool mTrim;

        /**
         * @brief   specifies whether new documents should use CR/LF instead of LF.
         */
        bool mHasCR;

        /**
         * @brief   specifies whether to allow line breaks in quoted text.
         */
        bool mQuotedLinebreaks;

        /**
         * @brief   specifies whether to automatically dequote cell data.
         */
        bool mAutoQuote;

        /**
         * @brief   specifies the quote character.
         */
        char mQuoteChar;
    };

    /**
     * @brief     Datastructure holding parameters controlling how special line formats should be
     *            treated.
     */
    struct LineReaderParams
    {
        /**
         * @brief   Constructor
         * @param   pSkipCommentLines     specifies whether to skip lines prefixed with
         *                                mCommentPrefix. Default: false
         * @param   pCommentPrefix        specifies which prefix character to indicate a comment
         *                                line. Default: #
         * @param   pSkipEmptyLines       specifies whether to skip empty lines. Default: false
         */
        explicit LineReaderParams(const bool pSkipCommentLines = false,
            const char pCommentPrefix = '#',
            const bool pSkipEmptyLines = false)
            : mSkipCommentLines(pSkipCommentLines)
            , mCommentPrefix(pCommentPrefix)
            , mSkipEmptyLines(pSkipEmptyLines)
        {
        }

        /**
         * @brief   specifies whether to skip lines prefixed with mCommentPrefix.
         */
        bool mSkipCommentLines;

        /**
         * @brief   specifies which prefix character to indicate a comment line.
         */
        char mCommentPrefix;

        /**
         * @brief   specifies whether to skip empty lines.
         */
        bool mSkipEmptyLines;
    };

    /**
     * @brief     Class representing a CSV document.
     */
    class Document
    {
    public:
        /**
         * @brief   Constructor
         * @param   pPath                 specifies the path of an existing CSV-file to populate the Document
         *                                data with.
         * @param   pLabelParams          specifies which row and column should be treated as labels.
         * @param   pSeparatorParams      specifies which field and row separators should be used.
         * @param   pConverterParams      specifies how invalid numbers (including empty strings) should be
         *                                handled.
         * @param   pLineReaderParams     specifies how special line formats should be treated.
         */
        explicit Document(const std::string& pPath = std::string(),
            const LabelParams& pLabelParams = LabelParams(),
            const SeparatorParams& pSeparatorParams = SeparatorParams(),
            const ConverterParams& pConverterParams = ConverterParams(),
            const LineReaderParams& pLineReaderParams = LineReaderParams())
            : mPath(pPath)
            , mLabelParams(pLabelParams)
            , mSeparatorParams(pSeparatorParams)
            , mConverterParams(pConverterParams)
            , mLineReaderParams(pLineReaderParams)
            , mData()
            , mColumnNames()
            , mRowNames()
        {
            if (!mPath.empty())
            {
                ReadCsv();
            }
        }

        /**
         * @brief   Constructor
         * @param   pStream               specifies a binary input stream to read CSV data from.
         * @param   pLabelParams          specifies which row and column should be treated as labels.
         * @param   pSeparatorParams      specifies which field and row separators should be used.
         * @param   pConverterParams      specifies how invalid numbers (including empty strings) should be
         *                                handled.
         * @param   pLineReaderParams     specifies how special line formats should be treated.
         */
        explicit Document(std::istream& pStream,
            const LabelParams& pLabelParams = LabelParams(),
            const SeparatorParams& pSeparatorParams = SeparatorParams(),
            const ConverterParams& pConverterParams = ConverterParams(),
            const LineReaderParams& pLineReaderParams = LineReaderParams())
            : mPath()
            , mLabelParams(pLabelParams)
            , mSeparatorParams(pSeparatorParams)
            , mConverterParams(pConverterParams)
            , mLineReaderParams(pLineReaderParams)
            , mData()
            , mColumnNames()
            , mRowNames()
        {
            ReadCsv(pStream);
        }

        /**
         * @brief   Read Document data from file.
         * @param   pPath                 specifies the path of an existing CSV-file to populate the Document
         *                                data with.
         * @param   pLabelParams          specifies which row and column should be treated as labels.
         * @param   pSeparatorParams      specifies which field and row separators should be used.
         * @param   pConverterParams      specifies how invalid numbers (including empty strings) should be
         *                                handled.
         * @param   pLineReaderParams     specifies how special line formats should be treated.
         */
        void Load(const std::string& pPath,
            const LabelParams& pLabelParams = LabelParams(),
            const SeparatorParams& pSeparatorParams = SeparatorParams(),
            const ConverterParams& pConverterParams = ConverterParams(),
            const LineReaderParams& pLineReaderParams = LineReaderParams())
        {
            mPath = pPath;
            mLabelParams = pLabelParams;
            mSeparatorParams = pSeparatorParams;
            mConverterParams = pConverterParams;
            mLineReaderParams = pLineReaderParams;
            ReadCsv();
        }

        /**
         * @brief   Read Document data from stream.
         * @param   pStream               specifies a binary input stream to read CSV data from.
         * @param   pLabelParams          specifies which row and column should be treated as labels.
         * @param   pSeparatorParams      specifies which field and row separators should be used.
         * @param   pConverterParams      specifies how invalid numbers (including empty strings) should be
         *                                handled.
         * @param   pLineReaderParams     specifies how special line formats should be treated.
         */
        void Load(std::istream& pStream,
            const LabelParams& pLabelParams = LabelParams(),
            const SeparatorParams& pSeparatorParams = SeparatorParams(),
            const ConverterParams& pConverterParams = ConverterParams(),
            const LineReaderParams& pLineReaderParams = LineReaderParams())
        {
            mPath = "";
            mLabelParams = pLabelParams;
            mSeparatorParams = pSeparatorParams;
            mConverterParams = pConverterParams;
            mLineReaderParams = pLineReaderParams;
            ReadCsv(pStream);
        }

        /**
         * @brief   Write Document data to file.
         * @param   pPath                 optionally specifies the path where the CSV-file will be created
         *                                (if not specified, the original path provided when creating or
         *                                loading the Document data will be used).
         */
        void Save(const std::string& pPath = std::string())
        {
            if (!pPath.empty())
            {
                mPath = pPath;
            }
            WriteCsv();
        }

        /**
         * @brief   Write Document data to stream.
         * @param   pStream               specifies a binary output stream to write the data to.
         */
        void Save(std::ostream& pStream) const
        {
            WriteCsv(pStream);
        }

        /**
         * @brief   Clears loaded Document data.
         *
         */
        void Clear()
        {
            mData.clear();
            mColumnNames.clear();
            mRowNames.clear();
#ifdef HAS_CODECVT
            mIsUtf16 = false;
            mIsLE = false;
#endif
        }

        /**
         * @brief   Get column index by name.
         * @param   pColumnName           column label name.
         * @returns zero-based column index.
         */
        ssize_t GetColumnIdx(const std::string& pColumnName) const
        {
            if (mLabelParams.mColumnNameIdx >= 0)
            {
                if (mColumnNames.find(pColumnName) != mColumnNames.end())
                {
                    return static_cast<ssize_t>(mColumnNames.at(pColumnName)) - (mLabelParams.mRowNameIdx + 1);
                }
            }
            return -1;
        }

        /**
         * @brief   Get column by index.
         * @param   pColumnIdx            zero-based column index.
         * @returns vector of column data.
         */
        template<typename T>
        std::vector<T> GetColumn(const size_t pColumnIdx) const
        {
            const size_t dataColumnIdx = GetDataColumnIndex(pColumnIdx);
            std::vector<T> column;
            Converter<T> converter(mConverterParams);
            for (auto itRow = mData.begin(); itRow != mData.end(); ++itRow)
            {
                if (std::distance(mData.begin(), itRow) > mLabelParams.mColumnNameIdx)
                {
                    if (dataColumnIdx < itRow->size())
                    {
                        T val;
                        converter.ToVal(itRow->at(dataColumnIdx), val);
                        column.push_back(val);
                    }
                    else
                    {
                        const std::string errStr = "requested column index " +
                            std::to_string(pColumnIdx) + " >= " +
                            std::to_string(itRow->size() - GetDataColumnIndex(0)) +
                            " (number of columns on row index " +
                            std::to_string(std::distance(mData.begin(), itRow) -
                                (mLabelParams.mColumnNameIdx + 1)) + ")";
                        throw std::out_of_range(errStr);
                    }
                }
            }
            return column;
        }

        /**
         * @brief   Get column by index.
         * @param   pColumnIdx            zero-based column index.
         * @param   pToVal                conversion function.
         * @returns vector of column data.
         */
        template<typename T>
        std::vector<T> GetColumn(const size_t pColumnIdx, ConvFunc<T> pToVal) const
        {
            const size_t dataColumnIdx = GetDataColumnIndex(pColumnIdx);
            std::vector<T> column;
            for (auto itRow = mData.begin(); itRow != mData.end(); ++itRow)
            {
                if (std::distance(mData.begin(), itRow) > mLabelParams.mColumnNameIdx)
                {
                    T val;
                    pToVal(itRow->at(dataColumnIdx), val);
                    column.push_back(val);
                }
            }
            return column;
        }

        /**
         * @brief   Get column by name.
         * @param   pColumnName           column label name.
         * @returns vector of column data.
         */
        template<typename T>
        std::vector<T> GetColumn(const std::string& pColumnName) const
        {
            const ssize_t columnIdx = GetColumnIdx(pColumnName);
            if (columnIdx < 0)
            {
                throw std::out_of_range("column not found: " + pColumnName);
            }
            return GetColumn<T>(static_cast<size_t>(columnIdx));
        }

        /**
         * @brief   Get column by name.
         * @param   pColumnName           column label name.
         * @param   pToVal                conversion function.
         * @returns vector of column data.
         */
        template<typename T>
        std::vector<T> GetColumn(const std::string& pColumnName, ConvFunc<T> pToVal) const
        {
            const ssize_t columnIdx = GetColumnIdx(pColumnName);
            if (columnIdx < 0)
            {
                throw std::out_of_range("column not found: " + pColumnName);
            }
            return GetColumn<T>(static_cast<size_t>(columnIdx), pToVal);
        }

        /**
         * @brief   Set column by index.
         * @param   pColumnIdx            zero-based column index.
         * @param   pColumn               vector of column data.
         */
        template<typename T>
        void SetColumn(const size_t pColumnIdx, const std::vector<T>& pColumn)
        {
            const size_t dataColumnIdx = GetDataColumnIndex(pColumnIdx);

            while (GetDataRowIndex(pColumn.size()) > GetDataRowCount())
            {
                std::vector<std::string> row;
                row.resize(GetDataColumnCount());
                mData.push_back(row);
            }

            if ((dataColumnIdx + 1) > GetDataColumnCount())
            {
                for (auto itRow = mData.begin(); itRow != mData.end(); ++itRow)
                {
                    itRow->resize(GetDataColumnIndex(dataColumnIdx + 1));
                }
            }

            Converter<T> converter(mConverterParams);
            for (auto itRow = pColumn.begin(); itRow != pColumn.end(); ++itRow)
            {
                std::string str;
                converter.ToStr(*itRow, str);
                mData.at(static_cast<size_t>(std::distance(pColumn.begin(), itRow) + mLabelParams.mColumnNameIdx + 1)).at(
                    dataColumnIdx) = str;
            }
        }

        /**
         * @brief   Set column by name.
         * @param   pColumnName           column label name.
         * @param   pColumn               vector of column data.
         */
        template<typename T>
        void SetColumn(const std::string& pColumnName, const std::vector<T>& pColumn)
        {
            const ssize_t columnIdx = GetColumnIdx(pColumnName);
            if (columnIdx < 0)
            {
                throw std::out_of_range("column not found: " + pColumnName);
            }
            SetColumn<T>(static_cast<size_t>(columnIdx), pColumn);
        }

        /**
         * @brief   Remove column by index.
         * @param   pColumnIdx            zero-based column index.
         */
        void RemoveColumn(const size_t pColumnIdx)
        {
            const size_t dataColumnIdx = GetDataColumnIndex(pColumnIdx);
            for (auto itRow = mData.begin(); itRow != mData.end(); ++itRow)
            {
                itRow->erase(itRow->begin() + static_cast<ssize_t>(dataColumnIdx));
            }

            UpdateColumnNames();
        }

        /**
         * @brief   Remove column by name.
         * @param   pColumnName           column label name.
         */
        void RemoveColumn(const std::string& pColumnName)
        {
            ssize_t columnIdx = GetColumnIdx(pColumnName);
            if (columnIdx < 0)
            {
                throw std::out_of_range("column not found: " + pColumnName);
            }

            RemoveColumn(static_cast<size_t>(columnIdx));
        }

        /**
         * @brief   Insert column at specified index.
         * @param   pColumnIdx            zero-based column index.
         * @param   pColumn               vector of column data (optional argument).
         * @param   pColumnName           column label name (optional argument).
         */
        template<typename T>
        void InsertColumn(const size_t pColumnIdx, const std::vector<T>& pColumn = std::vector<T>(),
            const std::string& pColumnName = std::string())
        {
            const size_t dataColumnIdx = GetDataColumnIndex(pColumnIdx);

            std::vector<std::string> column;
            if (pColumn.empty())
            {
                column.resize(GetDataRowCount());
            }
            else
            {
                column.resize(GetDataRowIndex(pColumn.size()));
                Converter<T> converter(mConverterParams);
                for (auto itRow = pColumn.begin(); itRow != pColumn.end(); ++itRow)
                {
                    std::string str;
                    converter.ToStr(*itRow, str);
                    const size_t rowIdx =
                        static_cast<size_t>(std::distance(pColumn.begin(), itRow) + (mLabelParams.mColumnNameIdx + 1));
                    column.at(rowIdx) = str;
                }
            }

            while (column.size() > GetDataRowCount())
            {
                std::vector<std::string> row;
                const size_t columnCount = std::max<size_t>(static_cast<size_t>(mLabelParams.mColumnNameIdx + 1),
                    GetDataColumnCount());
                row.resize(columnCount);
                mData.push_back(row);
            }

            for (auto itRow = mData.begin(); itRow != mData.end(); ++itRow)
            {
                const size_t rowIdx = static_cast<size_t>(std::distance(mData.begin(), itRow));
                itRow->insert(itRow->begin() + static_cast<ssize_t>(dataColumnIdx), column.at(rowIdx));
            }

            if (!pColumnName.empty())
            {
                SetColumnName(pColumnIdx, pColumnName);
            }

            UpdateColumnNames();
        }

        /**
         * @brief   Get number of data columns (excluding label columns).
         * @returns column count.
         */
        size_t GetColumnCount() const
        {
            const ssize_t count = static_cast<ssize_t>((mData.size() > 0) ? mData.at(0).size() : 0) -
                (mLabelParams.mRowNameIdx + 1);
            return (count >= 0) ? static_cast<size_t>(count) : 0;
        }

        /**
         * @brief   Get row index by name.
         * @param   pRowName              row label name.
         * @returns zero-based row index.
         */
        ssize_t GetRowIdx(const std::string& pRowName) const
        {
            if (mLabelParams.mRowNameIdx >= 0)
            {
                if (mRowNames.find(pRowName) != mRowNames.end())
                {
                    return static_cast<ssize_t>(mRowNames.at(pRowName)) - (mLabelParams.mColumnNameIdx + 1);
                }
            }
            return -1;
        }

        /**
         * @brief   Get row by index.
         * @param   pRowIdx               zero-based row index.
         * @returns vector of row data.
         */
        template<typename T>
        std::vector<T> GetRow(const size_t pRowIdx) const
        {
            const size_t dataRowIdx = GetDataRowIndex(pRowIdx);
            std::vector<T> row;
            Converter<T> converter(mConverterParams);
            for (auto itCol = mData.at(dataRowIdx).begin(); itCol != mData.at(dataRowIdx).end(); ++itCol)
            {
                if (std::distance(mData.at(dataRowIdx).begin(), itCol) > mLabelParams.mRowNameIdx)
                {
                    T val;
                    converter.ToVal(*itCol, val);
                    row.push_back(val);
                }
            }
            return row;
        }

        /**
         * @brief   Get row by index.
         * @param   pRowIdx               zero-based row index.
         * @param   pToVal                conversion function.
         * @returns vector of row data.
         */
        template<typename T>
        std::vector<T> GetRow(const size_t pRowIdx, ConvFunc<T> pToVal) const
        {
            const size_t dataRowIdx = GetDataRowIndex(pRowIdx);
            std::vector<T> row;
            Converter<T> converter(mConverterParams);
            for (auto itCol = mData.at(dataRowIdx).begin(); itCol != mData.at(dataRowIdx).end(); ++itCol)
            {
                if (std::distance(mData.at(dataRowIdx).begin(), itCol) > mLabelParams.mRowNameIdx)
                {
                    T val;
                    pToVal(*itCol, val);
                    row.push_back(val);
                }
            }
            return row;
        }

        /**
         * @brief   Get row by name.
         * @param   pRowName              row label name.
         * @returns vector of row data.
         */
        template<typename T>
        std::vector<T> GetRow(const std::string& pRowName) const
        {
            ssize_t rowIdx = GetRowIdx(pRowName);
            if (rowIdx < 0)
            {
                throw std::out_of_range("row not found: " + pRowName);
            }
            return GetRow<T>(static_cast<size_t>(rowIdx));
        }

        /**
         * @brief   Get row by name.
         * @param   pRowName              row label name.
         * @param   pToVal                conversion function.
         * @returns vector of row data.
         */
        template<typename T>
        std::vector<T> GetRow(const std::string& pRowName, ConvFunc<T> pToVal) const
        {
            ssize_t rowIdx = GetRowIdx(pRowName);
            if (rowIdx < 0)
            {
                throw std::out_of_range("row not found: " + pRowName);
            }
            return GetRow<T>(static_cast<size_t>(rowIdx), pToVal);
        }

        /**
         * @brief   Set row by index.
         * @param   pRowIdx               zero-based row index.
         * @param   pRow                  vector of row data.
         */
        template<typename T>
        void SetRow(const size_t pRowIdx, const std::vector<T>& pRow)
        {
            const size_t dataRowIdx = GetDataRowIndex(pRowIdx);

            while ((dataRowIdx + 1) > GetDataRowCount())
            {
                std::vector<std::string> row;
                row.resize(GetDataColumnCount());
                mData.push_back(row);
            }

            if (pRow.size() > GetDataColumnCount())
            {
                for (auto itRow = mData.begin(); itRow != mData.end(); ++itRow)
                {
                    itRow->resize(GetDataColumnIndex(pRow.size()));
                }
            }

            Converter<T> converter(mConverterParams);
            for (auto itCol = pRow.begin(); itCol != pRow.end(); ++itCol)
            {
                std::string str;
                converter.ToStr(*itCol, str);
                mData.at(dataRowIdx).at(static_cast<size_t>(std::distance(pRow.begin(),
                    itCol) + mLabelParams.mRowNameIdx + 1)) = str;
            }
        }

        /**
         * @brief   Set row by name.
         * @param   pRowName              row label name.
         * @param   pRow                  vector of row data.
         */
        template<typename T>
        void SetRow(const std::string& pRowName, const std::vector<T>& pRow)
        {
            ssize_t rowIdx = GetRowIdx(pRowName);
            if (rowIdx < 0)
            {
                throw std::out_of_range("row not found: " + pRowName);
            }
            return SetRow<T>(static_cast<size_t>(rowIdx), pRow);
        }

        /**
         * @brief   Remove row by index.
         * @param   pRowIdx               zero-based row index.
         */
        void RemoveRow(const size_t pRowIdx)
        {
            const size_t dataRowIdx = GetDataRowIndex(pRowIdx);
            mData.erase(mData.begin() + static_cast<ssize_t>(dataRowIdx));
            UpdateRowNames();
        }

        /**
         * @brief   Remove row by name.
         * @param   pRowName              row label name.
         */
        void RemoveRow(const std::string& pRowName)
        {
            ssize_t rowIdx = GetRowIdx(pRowName);
            if (rowIdx < 0)
            {
                throw std::out_of_range("row not found: " + pRowName);
            }

            RemoveRow(static_cast<size_t>(rowIdx));
        }

        /**
         * @brief   Insert row at specified index.
         * @param   pRowIdx               zero-based row index.
         * @param   pRow                  vector of row data (optional argument).
         * @param   pRowName              row label name (optional argument).
         */
        template<typename T>
        void InsertRow(const size_t pRowIdx, const std::vector<T>& pRow = std::vector<T>(),
            const std::string& pRowName = std::string())
        {
            const size_t rowIdx = GetDataRowIndex(pRowIdx);

            std::vector<std::string> row;
            if (pRow.empty())
            {
                row.resize(GetDataColumnCount());
            }
            else
            {
                row.resize(GetDataColumnIndex(pRow.size()));
                Converter<T> converter(mConverterParams);
                for (auto itCol = pRow.begin(); itCol != pRow.end(); ++itCol)
                {
                    std::string str;
                    converter.ToStr(*itCol, str);
                    row.at(static_cast<size_t>(std::distance(pRow.begin(), itCol) + mLabelParams.mRowNameIdx + 1)) = str;
                }
            }

            while (rowIdx > GetDataRowCount())
            {
                std::vector<std::string> tempRow;
                tempRow.resize(GetDataColumnCount());
                mData.push_back(tempRow);
            }

            mData.insert(mData.begin() + static_cast<ssize_t>(rowIdx), row);

            if (!pRowName.empty())
            {
                SetRowName(pRowIdx, pRowName);
            }

            UpdateRowNames();
        }

        /**
         * @brief   Get number of data rows (excluding label rows).
         * @returns row count.
         */
        size_t GetRowCount() const
        {
            const ssize_t count = static_cast<ssize_t>(mData.size()) - (mLabelParams.mColumnNameIdx + 1);
            return (count >= 0) ? static_cast<size_t>(count) : 0;
        }

        /**
         * @brief   Get cell by index.
         * @param   pColumnIdx            zero-based column index.
         * @param   pRowIdx               zero-based row index.
         * @returns cell data.
         */
        template<typename T>
        T GetCell(const size_t pColumnIdx, const size_t pRowIdx) const
        {
            const size_t dataColumnIdx = GetDataColumnIndex(pColumnIdx);
            const size_t dataRowIdx = GetDataRowIndex(pRowIdx);

            T val;
            Converter<T> converter(mConverterParams);
            converter.ToVal(mData.at(dataRowIdx).at(dataColumnIdx), val);
            return val;
        }

        /**
         * @brief   Get cell by index.
         * @param   pColumnIdx            zero-based column index.
         * @param   pRowIdx               zero-based row index.
         * @param   pToVal                conversion function.
         * @returns cell data.
         */
        template<typename T>
        T GetCell(const size_t pColumnIdx, const size_t pRowIdx, ConvFunc<T> pToVal) const
        {
            const size_t dataColumnIdx = GetDataColumnIndex(pColumnIdx);
            const size_t dataRowIdx = GetDataRowIndex(pRowIdx);

            T val;
            pToVal(mData.at(dataRowIdx).at(dataColumnIdx), val);
            return val;
        }

        /**
         * @brief   Get cell by name.
         * @param   pColumnName           column label name.
         * @param   pRowName              row label name.
         * @returns cell data.
         */
        template<typename T>
        T GetCell(const std::string& pColumnName, const std::string& pRowName) const
        {
            const ssize_t columnIdx = GetColumnIdx(pColumnName);
            if (columnIdx < 0)
            {
                throw std::out_of_range("column not found: " + pColumnName);
            }

            const ssize_t rowIdx = GetRowIdx(pRowName);
            if (rowIdx < 0)
            {
                throw std::out_of_range("row not found: " + pRowName);
            }

            return GetCell<T>(static_cast<size_t>(columnIdx), static_cast<size_t>(rowIdx));
        }

        /**
         * @brief   Get cell by name.
         * @param   pColumnName           column label name.
         * @param   pRowName              row label name.
         * @param   pToVal                conversion function.
         * @returns cell data.
         */
        template<typename T>
        T GetCell(const std::string& pColumnName, const std::string& pRowName, ConvFunc<T> pToVal) const
        {
            const ssize_t columnIdx = GetColumnIdx(pColumnName);
            if (columnIdx < 0)
            {
                throw std::out_of_range("column not found: " + pColumnName);
            }

            const ssize_t rowIdx = GetRowIdx(pRowName);
            if (rowIdx < 0)
            {
                throw std::out_of_range("row not found: " + pRowName);
            }

            return GetCell<T>(static_cast<size_t>(columnIdx), static_cast<size_t>(rowIdx), pToVal);
        }

        /**
         * @brief   Get cell by column name and row index.
         * @param   pColumnName           column label name.
         * @param   pRowIdx               zero-based row index.
         * @returns cell data.
         */
        template<typename T>
        T GetCell(const std::string& pColumnName, const size_t pRowIdx) const
        {
            const ssize_t columnIdx = GetColumnIdx(pColumnName);
            if (columnIdx < 0)
            {
                throw std::out_of_range("column not found: " + pColumnName);
            }

            return GetCell<T>(static_cast<size_t>(columnIdx), pRowIdx);
        }

        /**
         * @brief   Get cell by column name and row index.
         * @param   pColumnName           column label name.
         * @param   pRowIdx               zero-based row index.
         * @param   pToVal                conversion function.
         * @returns cell data.
         */
        template<typename T>
        T GetCell(const std::string& pColumnName, const size_t pRowIdx, ConvFunc<T> pToVal) const
        {
            const ssize_t columnIdx = GetColumnIdx(pColumnName);
            if (columnIdx < 0)
            {
                throw std::out_of_range("column not found: " + pColumnName);
            }

            return GetCell<T>(static_cast<size_t>(columnIdx), pRowIdx, pToVal);
        }

        /**
         * @brief   Get cell by column index and row name.
         * @param   pColumnIdx            zero-based column index.
         * @param   pRowName              row label name.
         * @returns cell data.
         */
        template<typename T>
        T GetCell(const size_t pColumnIdx, const std::string& pRowName) const
        {
            const ssize_t rowIdx = GetRowIdx(pRowName);
            if (rowIdx < 0)
            {
                throw std::out_of_range("row not found: " + pRowName);
            }

            return GetCell<T>(pColumnIdx, static_cast<size_t>(rowIdx));
        }

        /**
         * @brief   Get cell by column index and row name.
         * @param   pColumnIdx            zero-based column index.
         * @param   pRowName              row label name.
         * @param   pToVal                conversion function.
         * @returns cell data.
         */
        template<typename T>
        T GetCell(const size_t pColumnIdx, const std::string& pRowName, ConvFunc<T> pToVal) const
        {
            const ssize_t rowIdx = GetRowIdx(pRowName);
            if (rowIdx < 0)
            {
                throw std::out_of_range("row not found: " + pRowName);
            }

            return GetCell<T>(pColumnIdx, static_cast<size_t>(rowIdx), pToVal);
        }

        /**
         * @brief   Set cell by index.
         * @param   pRowIdx               zero-based row index.
         * @param   pColumnIdx            zero-based column index.
         * @param   pCell                 cell data.
         */
        template<typename T>
        void SetCell(const size_t pColumnIdx, const size_t pRowIdx, const T& pCell)
        {
            const size_t dataColumnIdx = GetDataColumnIndex(pColumnIdx);
            const size_t dataRowIdx = GetDataRowIndex(pRowIdx);

            while ((dataRowIdx + 1) > GetDataRowCount())
            {
                std::vector<std::string> row;
                row.resize(GetDataColumnCount());
                mData.push_back(row);
            }

            if ((dataColumnIdx + 1) > GetDataColumnCount())
            {
                for (auto itRow = mData.begin(); itRow != mData.end(); ++itRow)
                {
                    itRow->resize(dataColumnIdx + 1);
                }
            }

            std::string str;
            Converter<T> converter(mConverterParams);
            converter.ToStr(pCell, str);
            mData.at(dataRowIdx).at(dataColumnIdx) = str;
        }

        /**
         * @brief   Set cell by name.
         * @param   pColumnName           column label name.
         * @param   pRowName              row label name.
         * @param   pCell                 cell data.
         */
        template<typename T>
        void SetCell(const std::string& pColumnName, const std::string& pRowName, const T& pCell)
        {
            const ssize_t columnIdx = GetColumnIdx(pColumnName);
            if (columnIdx < 0)
            {
                throw std::out_of_range("column not found: " + pColumnName);
            }

            const ssize_t rowIdx = GetRowIdx(pRowName);
            if (rowIdx < 0)
            {
                throw std::out_of_range("row not found: " + pRowName);
            }

            SetCell<T>(static_cast<size_t>(columnIdx), static_cast<size_t>(rowIdx), pCell);
        }

        /**
         * @brief   Get column name
         * @param   pColumnIdx            zero-based column index.
         * @returns column name.
         */
        std::string GetColumnName(const size_t pColumnIdx) const
        {
            const size_t dataColumnIdx = GetDataColumnIndex(pColumnIdx);
            if (mLabelParams.mColumnNameIdx < 0)
            {
                throw std::out_of_range("column name row index < 0: " + std::to_string(mLabelParams.mColumnNameIdx));
            }

            return mData.at(static_cast<size_t>(mLabelParams.mColumnNameIdx)).at(dataColumnIdx);
        }

        /**
         * @brief   Set column name
         * @param   pColumnIdx            zero-based column index.
         * @param   pColumnName           column name.
         */
        void SetColumnName(size_t pColumnIdx, const std::string& pColumnName)
        {
            if (mLabelParams.mColumnNameIdx < 0)
            {
                throw std::out_of_range("column name row index < 0: " + std::to_string(mLabelParams.mColumnNameIdx));
            }

            const size_t dataColumnIdx = GetDataColumnIndex(pColumnIdx);
            mColumnNames[pColumnName] = dataColumnIdx;

            // increase table size if necessary:
            const size_t rowIdx = static_cast<size_t>(mLabelParams.mColumnNameIdx);
            if (rowIdx >= mData.size())
            {
                mData.resize(rowIdx + 1);
            }
            auto& row = mData[rowIdx];
            if (dataColumnIdx >= row.size())
            {
                row.resize(dataColumnIdx + 1);
            }

            mData.at(static_cast<size_t>(mLabelParams.mColumnNameIdx)).at(dataColumnIdx) = pColumnName;
        }

        /**
         * @brief   Get column names
         * @returns vector of column names.
         */
        std::vector<std::string> GetColumnNames() const
        {
            if (mLabelParams.mColumnNameIdx >= 0)
            {
                return std::vector<std::string>(mData.at(static_cast<size_t>(mLabelParams.mColumnNameIdx)).begin() +
                    (mLabelParams.mRowNameIdx + 1),
                    mData.at(static_cast<size_t>(mLabelParams.mColumnNameIdx)).end());
            }

            return std::vector<std::string>();
        }

        /**
         * @brief   Get row name
         * @param   pRowIdx               zero-based column index.
         * @returns row name.
         */
        std::string GetRowName(const size_t pRowIdx) const
        {
            const size_t dataRowIdx = GetDataRowIndex(pRowIdx);
            if (mLabelParams.mRowNameIdx < 0)
            {
                throw std::out_of_range("row name column index < 0: " + std::to_string(mLabelParams.mRowNameIdx));
            }

            return mData.at(dataRowIdx).at(static_cast<size_t>(mLabelParams.mRowNameIdx));
        }

        /**
         * @brief   Set row name
         * @param   pRowIdx               zero-based row index.
         * @param   pRowName              row name.
         */
        void SetRowName(size_t pRowIdx, const std::string& pRowName)
        {
            const size_t dataRowIdx = GetDataRowIndex(pRowIdx);
            mRowNames[pRowName] = dataRowIdx;
            if (mLabelParams.mRowNameIdx < 0)
            {
                throw std::out_of_range("row name column index < 0: " + std::to_string(mLabelParams.mRowNameIdx));
            }

            // increase table size if necessary:
            if (dataRowIdx >= mData.size())
            {
                mData.resize(dataRowIdx + 1);
            }
            auto& row = mData[dataRowIdx];
            if (mLabelParams.mRowNameIdx >= static_cast<ssize_t>(row.size()))
            {
                row.resize(static_cast<size_t>(mLabelParams.mRowNameIdx) + 1);
            }

            mData.at(dataRowIdx).at(static_cast<size_t>(mLabelParams.mRowNameIdx)) = pRowName;
        }

        /**
         * @brief   Get row names
         * @returns vector of row names.
         */
        std::vector<std::string> GetRowNames() const
        {
            std::vector<std::string> rownames;
            if (mLabelParams.mRowNameIdx >= 0)
            {
                for (auto itRow = mData.begin(); itRow != mData.end(); ++itRow)
                {
                    if (std::distance(mData.begin(), itRow) > mLabelParams.mColumnNameIdx)
                    {
                        rownames.push_back(itRow->at(static_cast<size_t>(mLabelParams.mRowNameIdx)));
                    }
                }
            }
            return rownames;
        }

    private:
        void ReadCsv()
        {
            std::ifstream stream;
            stream.exceptions(std::ifstream::failbit | std::ifstream::badbit);
            stream.open(mPath, std::ios::binary);
            ReadCsv(stream);
        }

        void ReadCsv(std::istream& pStream)
        {
            Clear();
            pStream.seekg(0, std::ios::end);
            std::streamsize length = pStream.tellg();
            pStream.seekg(0, std::ios::beg);

#ifdef HAS_CODECVT
            std::vector<char> bom2b(2, '\0');
            if (length >= 2)
            {
                pStream.read(bom2b.data(), 2);
                pStream.seekg(0, std::ios::beg);
            }

            static const std::vector<char> bomU16le = { '\xff', '\xfe' };
            static const std::vector<char> bomU16be = { '\xfe', '\xff' };
            if ((bom2b == bomU16le) || (bom2b == bomU16be))
            {
                mIsUtf16 = true;
                mIsLE = (bom2b == bomU16le);

                std::wifstream wstream;
                wstream.exceptions(std::wifstream::failbit | std::wifstream::badbit);
                wstream.open(mPath, std::ios::binary);
                if (mIsLE)
                {
                    wstream.imbue(std::locale(wstream.getloc(),
                        new std::codecvt_utf16<wchar_t, 0x10ffff,
                        static_cast<std::codecvt_mode>(std::consume_header |
                            std::little_endian)>));
                }
                else
                {
                    wstream.imbue(std::locale(wstream.getloc(),
                        new std::codecvt_utf16<wchar_t, 0x10ffff,
                        std::consume_header>));
                }
                std::wstringstream wss;
                wss << wstream.rdbuf();
                std::string utf8 = ToString(wss.str());
                std::stringstream ss(utf8);
                ParseCsv(ss, static_cast<std::streamsize>(utf8.size()));
            }
            else
#endif
            {
                // check for UTF-8 Byte order mark and skip it when found
                if (length >= 3)
                {
                    std::vector<char> bom3b(3, '\0');
                    pStream.read(bom3b.data(), 3);
                    static const std::vector<char> bomU8 = { '\xef', '\xbb', '\xbf' };
                    if (bom3b != bomU8)
                    {
                        // file does not start with a UTF-8 Byte order mark
                        pStream.seekg(0, std::ios::beg);
                    }
                    else
                    {
                        // file did start with a UTF-8 Byte order mark, simply skip it
                        length -= 3;
                    }
                }

                ParseCsv(pStream, length);
            }
        }

        void ParseCsv(std::istream& pStream, std::streamsize p_FileLength)
        {
            const std::streamsize bufLength = 64 * 1024;
            std::vector<char> buffer(bufLength);
            std::vector<std::string> row;
            std::string cell;
            bool quoted = false;
            int cr = 0;
            int lf = 0;

            while (p_FileLength > 0)
            {
                const std::streamsize toReadLength = std::min<std::streamsize>(p_FileLength, bufLength);
                pStream.read(buffer.data(), toReadLength);

                // With user-specified istream opened in non-binary mode on windows, we may have a
                // data length mismatch, so ensure we don't parse outside actual data length read.
                const std::streamsize readLength = pStream.gcount();
                if (readLength <= 0)
                {
                    break;
                }

                for (size_t i = 0; i < static_cast<size_t>(readLength); ++i)
                {
                    if (buffer[i] == mSeparatorParams.mQuoteChar)
                    {
                        if (cell.empty() || (cell[0] == mSeparatorParams.mQuoteChar))
                        {
                            quoted = !quoted;
                        }
                        cell += buffer[i];
                    }
                    else if (buffer[i] == mSeparatorParams.mSeparator)
                    {
                        if (!quoted)
                        {
                            row.push_back(Unquote(Trim(cell)));
                            cell.clear();
                        }
                        else
                        {
                            cell += buffer[i];
                        }
                    }
                    else if (buffer[i] == '\r')
                    {
                        if (mSeparatorParams.mQuotedLinebreaks && quoted)
                        {
                            cell += buffer[i];
                        }
                        else
                        {
                            ++cr;
                        }
                    }
                    else if (buffer[i] == '\n')
                    {
                        if (mSeparatorParams.mQuotedLinebreaks && quoted)
                        {
                            cell += buffer[i];
                        }
                        else
                        {
                            ++lf;
                            if (mLineReaderParams.mSkipEmptyLines && row.empty() && cell.empty())
                            {
                                // skip empty line
                            }
                            else
                            {
                                row.push_back(Unquote(Trim(cell)));

                                if (mLineReaderParams.mSkipCommentLines && !row.at(0).empty() &&
                                    (row.at(0)[0] == mLineReaderParams.mCommentPrefix))
                                {
                                    // skip comment line
                                }
                                else
                                {
                                    mData.push_back(row);
                                }

                                cell.clear();
                                row.clear();
                                quoted = false;
                            }
                        }
                    }
                    else
                    {
                        cell += buffer[i];
                    }
                }
                p_FileLength -= readLength;
            }

            // Handle last line without linebreak
            if (!cell.empty() || !row.empty())
            {
                row.push_back(Unquote(Trim(cell)));
                cell.clear();
                mData.push_back(row);
                row.clear();
            }

            // Assume CR/LF if at least half the linebreaks have CR
            mSeparatorParams.mHasCR = (cr > (lf / 2));

            // Set up column labels
            UpdateColumnNames();

            // Set up row labels
            UpdateRowNames();
        }

        void WriteCsv() const
        {
#ifdef HAS_CODECVT
            if (mIsUtf16)
            {
                std::stringstream ss;
                WriteCsv(ss);
                std::string utf8 = ss.str();
                std::wstring wstr = ToWString(utf8);

                std::wofstream wstream;
                wstream.exceptions(std::wofstream::failbit | std::wofstream::badbit);
                wstream.open(mPath, std::ios::binary | std::ios::trunc);

                if (mIsLE)
                {
                    wstream.imbue(std::locale(wstream.getloc(),
                        new std::codecvt_utf16<wchar_t, 0x10ffff,
                        static_cast<std::codecvt_mode>(std::little_endian)>));
                }
                else
                {
                    wstream.imbue(std::locale(wstream.getloc(),
                        new std::codecvt_utf16<wchar_t, 0x10ffff>));
                }

                wstream << static_cast<wchar_t>(0xfeff);
                wstream << wstr;
            }
            else
#endif
            {
                std::ofstream stream;
                stream.exceptions(std::ofstream::failbit | std::ofstream::badbit);
                stream.open(mPath, std::ios::binary | std::ios::trunc);
                WriteCsv(stream);
            }
        }

        void WriteCsv(std::ostream& pStream) const
        {
            for (auto itr = mData.begin(); itr != mData.end(); ++itr)
            {
                for (auto itc = itr->begin(); itc != itr->end(); ++itc)
                {
                    if (mSeparatorParams.mAutoQuote &&
                        ((itc->find(mSeparatorParams.mSeparator) != std::string::npos) ||
                            (itc->find(' ') != std::string::npos)))
                    {
                        // escape quotes in string
                        std::string str = *itc;
                        const std::string quoteCharStr = std::string(1, mSeparatorParams.mQuoteChar);
                        ReplaceString(str, quoteCharStr, quoteCharStr + quoteCharStr);

                        pStream << quoteCharStr << str << quoteCharStr;
                    }
                    else
                    {
                        pStream << *itc;
                    }

                    if (std::distance(itc, itr->end()) > 1)
                    {
                        pStream << mSeparatorParams.mSeparator;
                    }
                }
                pStream << (mSeparatorParams.mHasCR ? "\r\n" : "\n");
            }
        }

        size_t GetDataRowCount() const
        {
            return mData.size();
        }

        size_t GetDataColumnCount() const
        {
            return (mData.size() > 0) ? mData.at(0).size() : 0;
        }

        inline size_t GetDataRowIndex(const size_t pRowIdx) const
        {
            return pRowIdx + static_cast<size_t>(mLabelParams.mColumnNameIdx + 1);
        }

        inline size_t GetDataColumnIndex(const size_t pColumnIdx) const
        {
            return pColumnIdx + static_cast<size_t>(mLabelParams.mRowNameIdx + 1);
        }

        std::string Trim(const std::string& pStr) const
        {
            if (mSeparatorParams.mTrim)
            {
                std::string str = pStr;

                // ltrim
                str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](int ch) { return !isspace(ch); }));

                // rtrim
                str.erase(std::find_if(str.rbegin(), str.rend(), [](int ch) { return !isspace(ch); }).base(), str.end());

                return str;
            }
            else
            {
                return pStr;
            }
        }

        std::string Unquote(const std::string& pStr) const
        {
            if (mSeparatorParams.mAutoQuote && (pStr.size() >= 2) &&
                (pStr.front() == mSeparatorParams.mQuoteChar) &&
                (pStr.back() == mSeparatorParams.mQuoteChar))
            {
                // remove start/end quotes
                std::string str = pStr.substr(1, pStr.size() - 2);

                // unescape quotes in string
                const std::string quoteCharStr = std::string(1, mSeparatorParams.mQuoteChar);
                ReplaceString(str, quoteCharStr + quoteCharStr, quoteCharStr);

                return str;
            }
            else
            {
                return pStr;
            }
        }

        void UpdateColumnNames()
        {
            mColumnNames.clear();
            if ((mLabelParams.mColumnNameIdx >= 0) &&
                (static_cast<ssize_t>(mData.size()) > mLabelParams.mColumnNameIdx))
            {
                size_t i = 0;
                for (auto& columnName : mData[static_cast<size_t>(mLabelParams.mColumnNameIdx)])
                {
                    mColumnNames[columnName] = i++;
                }
            }
        }

        void UpdateRowNames()
        {
            mRowNames.clear();
            if ((mLabelParams.mRowNameIdx >= 0) &&
                (static_cast<ssize_t>(mData.size()) >
                    (mLabelParams.mColumnNameIdx + 1)))
            {
                size_t i = 0;
                for (auto& dataRow : mData)
                {
                    if (static_cast<ssize_t>(dataRow.size()) > mLabelParams.mRowNameIdx)
                    {
                        mRowNames[dataRow[static_cast<size_t>(mLabelParams.mRowNameIdx)]] = i++;
                    }
                }
            }
        }

#ifdef HAS_CODECVT
#if defined(_MSC_VER)
#pragma warning (push)
#pragma warning (disable: 4996)
#endif
        static std::string ToString(const std::wstring& pWStr)
        {
            return std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t>{ }.to_bytes(pWStr);
        }

        static std::wstring ToWString(const std::string& pStr)
        {
            return std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t>{ }.from_bytes(pStr);
        }
#if defined(_MSC_VER)
#pragma warning (pop)
#endif
#endif

        static void ReplaceString(std::string& pStr, const std::string& pSearch, const std::string& pReplace)
        {
            size_t pos = 0;

            while ((pos = pStr.find(pSearch, pos)) != std::string::npos)
            {
                pStr.replace(pos, pSearch.size(), pReplace);
                pos += pReplace.size();
            }
        }

    private:
        std::string mPath;
        LabelParams mLabelParams;
        SeparatorParams mSeparatorParams;
        ConverterParams mConverterParams;
        LineReaderParams mLineReaderParams;
        std::vector<std::vector<std::string>> mData;
        std::map<std::string, size_t> mColumnNames;
        std::map<std::string, size_t> mRowNames;
#ifdef HAS_CODECVT
        bool mIsUtf16 = false;
        bool mIsLE = false;
#endif
    };
}
::::./Rendering/Src/simple_render_system.hpp::::#pragma once
#include <vulkan/vulkan.h>

#include "lve_camera.hpp"
#include "lve_device.hpp"
#include "lve_game_object.hpp"
#include "lve_pipeline.hpp"

// std
#include <memory>
#include <vector>


class SimpleRenderSystem {


public:

    SimpleRenderSystem(LveDevice& device, VkRenderPass renderPass);
    ~SimpleRenderSystem();

    SimpleRenderSystem(const SimpleRenderSystem&) = delete;
    SimpleRenderSystem& operator=(const SimpleRenderSystem&) = delete;

    void renderGameObjects(
            VkCommandBuffer commandBuffer,
            std::vector<LveGameObject>& gameObjects,
            const LveCamera& camera);

private:
    void createPipelineLayout(VkPipelineLayout & pipeline_layout);
    void createPipelineForFace(VkRenderPass renderPass);
    void createPipelineForEdge(VkRenderPass renderPass);
    void createPipelineForPEXResistor(VkRenderPass renderPass);
    void createPipelineForPEXCapacitor(VkRenderPass renderPass);

    LveDevice& lveDevice;

    std::unique_ptr<LvePipeline> lvePipelineForLayoutFace;
    VkPipelineLayout pipelineLayoutForLayoutFace;

    std::unique_ptr<LvePipeline> lvePipelineForLayoutEdge;
    VkPipelineLayout pipelineLayoutForLayoutEdge;

    std::unique_ptr<LvePipeline> lvePipelineForPEXResistor;
    VkPipelineLayout pipelineLayoutForPEXResistor;

    std::unique_ptr<LvePipeline> lvePipelineForPEXCapacitor;
    VkPipelineLayout pipelineLayoutForPEXCapacitor;
};

::::./T2D.h::::#ifndef T2D_H
#define T2D_H

#include <iostream>
#include <vector>
#include <sstream>
#include <fstream>

using namespace std;

struct bBox{
    double minx;
    double miny;
    double maxx;
    double maxy;
};

struct Color_rgba{
    int r;
    int g;
    int b;
    int a;
};

struct LDATA10by10{
    std::string layername;
    int layernum;
    int datatype;
    Color_rgba color;
    double bot;
    double top;
    std::vector<std::vector<std::vector<bBox>>> xy;
};

struct MinMaxXYZ{
    double minx;
    double maxx;
    double miny;
    double maxy;
    double minz;
    double maxz;
};

class T2D{
    public:
        bool text2data(std::string file_name);

        std::vector<LDATA10by10> LayoutData10by10;
        MinMaxXYZ LayoutMinMax;

        LDATA10by10 buf_ldata10by10;
        vector<vector<vector<bBox>>> buf_xy10by10;
        vector<bBox> buf_xy;
        static std::vector<std::string> string_split(std::string input, char delimiter);
};

#endif // T2D_H
::::./all_data.h::::#ifndef ALL_DATA_H
#define ALL_DATA_H

#include <QObject>
#include <QDebug>
#include <QVector>


class all_data : public QObject
{
    Q_OBJECT
//    Q_DECLARE_METATYPE(QVector <QVector <QString>>);

public:
    all_data(QObject *parent = nullptr);
    ~all_data();

public:
    QVector <QVector <QString>> inputDataVector;

public slots:
    void receiveSelectFileName(QString file_name);

signals:
    void sendSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector);


};

#endif // ALL_DATA_H
::::./filedb.h::::#ifndef FILEDB_H
#define FILEDB_H

#include <QVector>


class FileDb
{
public:
    FileDb();
    void openFile(QString fileNameInfo,QVector<QList<float>> &vecList,
                  float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize);
};

#endif // FILEDB_H
::::./formhier.h::::#ifndef FORMHIER_H
#define FORMHIER_H

#include <QDialog>
//#include "all_data.h"
//#include "mainwindow.h"

namespace Ui {
class FormHier;
}

class FormHier : public QDialog
{
    Q_OBJECT

public slots:
    void ReceiveSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector);
//    void ReceiveSplitData(QStringList list, int row, int column);

public:
    FormHier(QWidget *parent = nullptr);
    ~FormHier();
    Ui::FormHier *ui;

public:
    //MyDataSet *dataset = nullptr;

public:
    //void setMyDataSet(MyDataSet * dataset_){ this->dataset = dataset_;}
    //void testMyData();

};

#endif // FORMHIER_H

/////
::::./forminfo.h::::#ifndef FORMINFO_H
#define FORMINFO_H

#include <QDialog>

namespace Ui {
class FormInfo;
}

class FormInfo : public QDialog
{
    Q_OBJECT

public:
    explicit FormInfo(QWidget *parent = nullptr);
    ~FormInfo();

public slots:
    void slotInfoText(QString funcName, float value);
    void moveRender(float x, float y);

private:
    Ui::FormInfo *ui;
    float pointX = 0;
    float pointY = 0;
    float pointZ = 0;
    float infoTilt = 90;
    float infoRot = 0;
    float infoZoom = 1; //Zoom 齑堦赴臧掛棎 �GDS size 毳臧栮碃� 橃爼 勳殧

    float initRot = 0;
    float initTilt = 90;
    float initPointX = 0;
    float initPointY = 0;
    float initPointZ = 0;

    float x = 0;
    float y = 0;
};

#endif // FORMINFO_H
::::./formlayer.h::::#ifndef FORMLAYER_H
#define FORMLAYER_H

#include <QDialog>
#include <QColorDialog>
#include <QtWidgets/QCheckBox>
#include <QtWidgets>
#include <QTableWidget>
#include <QTableWidgetItem>
#include <QCheckBox>
#include <QPushButton>
#include <QtWidgets/QSlider>
#include <QRgba64>
#include <QDebug>


namespace Ui {
class FormLayer;
}

class FormLayer : public QDialog
{
    Q_OBJECT

public slots:
    void ReceiveSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector);

public:
    explicit FormLayer(QWidget *parent = nullptr);
    ~FormLayer();
    int i;
    int row;
    int column;

//    QTableWidgetItem *checkBoxItem[3];


private slots:
    void tableWidget_checkBoxChanged();
    void on_colorbutton_clicked();
    void handleOpacitySlider(int);

private:
    Ui::FormLayer *ui;

signals:
    void outputLayerStatus(QString printLayer);

};

//class SliderDelegate : public QItemDelegate
//{
//public:
//    SliderDelegate(QWidget *parent = nullptr) : QItemDelegate(parent){
////        SliderDelegate delegate(this);
//    }
//    QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &option,const QModelIndex &index) const override
//    {
//        QSlider *slider = new QSlider(Qt::Horizontal, parent);
//        slider->setRange(0, 100);
//        slider->setGeometry(option.rect);
//        slider->setFocusPolicy(Qt::StrongFocus);
//        slider->setTickPosition(QSlider::TicksBothSides);
//        slider->setTickInterval(10);
//        slider->show();
//        return slider;
//    }

//    void setEditorData(QWidget *editor, const QModelIndex &index) const override
//    {
//        int value = index.model()->data(index, Qt::EditRole).toInt();
//        QSlider *slider = static_cast<QSlider*>(editor);
//        slider->setValue(value);
//        qDebug() << slider;
//    }

//    void setModelData(QWidget *editor, QAbstractItemModel *model,
//                      const QModelIndex &index) const override
//    {
//        QSlider *slider = static_cast<QSlider*>(editor);
//        int value = slider->value();
//        model->setData(index, value, Qt::EditRole);
//    }
//};


#endif // FORMLAYER_H
::::./formmap.h::::#ifndef FORMMAP_H
#define FORMMAP_H

#include <QDialog>
#include <QGraphicsRectItem>

namespace Ui {
class FormMap;
}

class SuperItem : public QObject, public QGraphicsItem
{
    Q_OBJECT
public:
    SuperItem(QGraphicsItem* parent = NULL);
public slots:
    void slotMove(float x, float y, float zoom, float rot, float tilt);

protected:
    void paint(QPainter *painter,
               const QStyleOptionGraphicsItem *option,
               QWidget *widget);
    QRectF boundingRect() const;

//    virtual void keyPressEvent(QKeyEvent *evnet);
    float _zoom = 1;
    float _rot = 0;
    float _tilt = 90;

};

class FormMap : public QDialog
{
    Q_OBJECT

public:
    explicit FormMap(QWidget *parent = nullptr);
    ~FormMap();
    void receiveSize(float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize, float &zoomScale);

public slots:
    void slotInfoText(QString funcName, float value);

signals:
    void signalMove(float x, float y, float zoom, float rot, float tilt);

private:
    Ui::FormMap *ui;
    QGraphicsRectItem *rectItem;
    QGraphicsRectItem *rectItem2;
    QRect *rect;
    float width;
    float height;
    SuperItem *super;

    float pointX = 0;
    float pointY = 0;
    float pointZ = 0;
    float infoTilt = 90;
    float infoRot = 0;
    float infoZoom = 1; //Zoom 齑堦赴臧掛棎 �GDS size 毳臧栮碃� 橃爼 勳殧

    float initRot = 0;
    float initTilt = 90;
    float initPointX = 0;
    float initPointY = 0;
    float initPointZ = 0;

    float x = 0;
    float y = 0;
};



#endif // FORMMAP_H
::::./formtop.h::::#ifndef FORMTOP_H
#define FORMTOP_H

#include <QDialog>

namespace Ui {
class FormTop;
}

class FormTop : public QDialog
{
    Q_OBJECT

public:
    explicit FormTop(QWidget *parent = nullptr);
    ~FormTop();
    void receiveFile(QVector<QVector<QVector<QList<float>>>>& mapFile);
//    void receiveFile(QVector<QList<float>> **mapFile);

private:
    Ui::FormTop *ui;
};

#endif // FORMTOP_H
::::./gitmerge.h::::#ifndef GITMERGE_H
#define GITMERGE_H

#include <QString>

class GitMerge
{
public:
    GitMerge();
private:
    void mergeFiles(QString &totalMerge);
    void openPreMergeFile(QString &preMergeFile);
    void openUpdateMergeFile(QString &updateMergeFile);
    bool compareFiles(QString &A, QString &B);
    void writeMergeFile(QString fileName, QString &originFile);
    void makeCodeFiles(QString &codeFile, QString &gitMergeFile);
};

#endif // GITMERGE_H
::::./mainwindow.h::::#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include "Rendering/Src/lve_window.hpp"

#include <QMainWindow>
#include <QVulkanWindow>
#include <QDockWidget>
#include "formhier.h"
#include "formlayer.h"
#include "formtop.h"
#include "forminfo.h"
#include "formmap.h"
#include "filedb.h"
#include "all_data.h"
#include <QVector>

#include "T2D.h"

class LveWindow;

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; class LayerForm; }
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(LveWindow *w);
    ~MainWindow();

    void shareGeo(QRect size);

    T2D t2d;

public slots:

    void slotInfoText(QString funcName, float value);
    void inputLayerStatus(QString text);
    void on_actionOpen_file_triggered();

signals:
    void signalInfoText(QString funcName, float value);
    void sendSelectFileName(QString file_name);


private slots:
    void on_actionOpen_Map_File_triggered();

    void on_actionOpen_Layout_triggered();

    void on_actionOpen_DB_triggered();

private:
    LveWindow *m_window;
    Ui::MainWindow *ui;
    QString statusText;
    FormHier *formHier;
    FormLayer *formLayer;
    FormTop *formTop;
    FormInfo *formInfo;
    FormMap *formMap;
    SuperItem *superItem;
    QRect *windowSize;
    FileDb *fileDb;
    all_data *input_dataS;
    QStringList split_data;
};

#endif // MAINWINDOW_H
::::./trianglerenderer.h::::/****************************************************************************
**
** Copyright (C) 2017 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** "Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include <QVulkanWindow>

class TriangleRenderer : public QVulkanWindowRenderer
{
public:
    TriangleRenderer(QVulkanWindow *w, bool msaa = false);

    void initResources() override;
    void initSwapChainResources() override;
    void releaseSwapChainResources() override;
    void releaseResources() override;

    void startNextFrame() override;



protected:
    VkShaderModule createShader(const QString &name);

    QVulkanWindow *m_window;
    QVulkanDeviceFunctions *m_devFuncs;

    VkDeviceMemory m_bufMem = VK_NULL_HANDLE;
    VkBuffer m_buf = VK_NULL_HANDLE;
    VkDescriptorBufferInfo m_uniformBufInfo[QVulkanWindow::MAX_CONCURRENT_FRAME_COUNT];

    VkDescriptorPool m_descPool = VK_NULL_HANDLE;
    VkDescriptorSetLayout m_descSetLayout = VK_NULL_HANDLE;
    VkDescriptorSet m_descSet[QVulkanWindow::MAX_CONCURRENT_FRAME_COUNT];

    VkPipelineCache m_pipelineCache = VK_NULL_HANDLE;
    VkPipelineLayout m_pipelineLayout = VK_NULL_HANDLE;
    VkPipeline m_pipeline = VK_NULL_HANDLE;

    QMatrix4x4 m_proj;
    float m_rotation = 0.0f;
    float m_rotation_ver = 0.0f;
};
::::./formhier.ui::::<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormHier</class>
 <widget class="QDialog" name="FormHier">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>510</width>
    <height>300</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>450</width>
    <height>100</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QTableWidget" name="tableWidget">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>260</width>
         <height>100</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>260</width>
         <height>100</height>
        </size>
       </property>
       <property name="sizeAdjustPolicy">
        <enum>QAbstractScrollArea::AdjustToContents</enum>
       </property>
       <property name="editTriggers">
        <set>QAbstractItemView::NoEditTriggers</set>
       </property>
       <property name="alternatingRowColors">
        <bool>true</bool>
       </property>
       <property name="gridStyle">
        <enum>Qt::SolidLine</enum>
       </property>
       <attribute name="horizontalHeaderCascadingSectionResizes">
        <bool>false</bool>
       </attribute>
       <attribute name="horizontalHeaderStretchLastSection">
        <bool>false</bool>
       </attribute>
       <attribute name="verticalHeaderVisible">
        <bool>false</bool>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
::::./forminfo.ui::::<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormInfo</class>
 <widget class="QDialog" name="FormInfo">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>400</height>
   </rect>
  </property>
  <property name="maximumSize">
   <size>
    <width>200</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QLabel" name="label">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>X</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="2">
      <widget class="QLabel" name="infoZoom">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="2">
      <widget class="QLabel" name="pointZ">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="0">
      <widget class="QLabel" name="infoTilt">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="1">
      <widget class="QLabel" name="infoRot">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="1">
      <widget class="QLabel" name="pointY">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="1">
      <widget class="QLabel" name="label_2">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Y</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="2">
      <widget class="QLabel" name="label_4">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Z</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="0">
      <widget class="QLabel" name="pointX">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="0">
      <widget class="QLabel" name="label_10">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Tilt</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="1">
      <widget class="QLabel" name="label_11">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Rotation</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="2">
      <widget class="QLabel" name="label_12">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Zoom</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QListWidget" name="listWidget"/>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
::::./formlayer.ui::::<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormLayer</class>
 <widget class="QDialog" name="FormLayer">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>450</width>
    <height>600</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>450</width>
    <height>300</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>430</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QTableWidget" name="tableWidget">
       <property name="focusPolicy">
        <enum>Qt::ClickFocus</enum>
       </property>
       <property name="alternatingRowColors">
        <bool>true</bool>
       </property>
       <property name="textElideMode">
        <enum>Qt::ElideMiddle</enum>
       </property>
       <attribute name="horizontalHeaderVisible">
        <bool>false</bool>
       </attribute>
       <attribute name="verticalHeaderVisible">
        <bool>false</bool>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
::::./formmap.ui::::<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormMap</class>
 <widget class="QDialog" name="FormMap">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>200</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>200</width>
    <height>200</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGraphicsView" name="graphicsView">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="minimumSize">
      <size>
       <width>0</width>
       <height>0</height>
      </size>
     </property>
     <property name="verticalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
     <property name="horizontalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
::::./formtop.ui::::<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormTop</class>
 <widget class="QDialog" name="FormTop">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>200</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>200</width>
    <height>200</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGraphicsView" name="graphicsView"/>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
::::./mainwindow.ui::::<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1024</width>
    <height>768</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
     <widget class="QGraphicsView" name="graphicsView"/>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>1024</width>
     <height>21</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>File</string>
    </property>
    <addaction name="actionOpen_file"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_Map_File"/>
    <addaction name="actionOpen_Layout"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_DB"/>
   </widget>
   <widget class="QMenu" name="menuView">
    <property name="title">
     <string>View</string>
    </property>
    <addaction name="actionLayer_information"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuView"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="toolBar">
   <property name="windowTitle">
    <string>toolBar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
  </widget>
  <action name="actionOpen_file">
   <property name="text">
    <string>Open file</string>
   </property>
  </action>
  <action name="actionLayer_information">
   <property name="text">
    <string>Layer information</string>
   </property>
  </action>
  <action name="actionOpen_Map_File">
   <property name="text">
    <string>Open Map File</string>
   </property>
  </action>
  <action name="actionOpen_Layout">
   <property name="text">
    <string>Open Layout</string>
   </property>
  </action>
  <action name="actionOpen_DB">
   <property name="text">
    <string>Open DB</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>
::::./IInterface.pro::::QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++17
QMAKE_CXXFLAGS += -std=c++17

# You can make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
    Rendering/Src/LayoutData.cpp \
    Rendering/Src/LayoutModel.cpp \
    Rendering/Src/PEXCapacitorModel.cpp \
    Rendering/Src/PEXData.cpp \
    Rendering/Src/PEXResistorModel.cpp \
    Rendering/Src/dtaorendersystem.cpp \
    Rendering/Src/keyboard_movement_controller.cpp \
    Rendering/Src/lve_camera.cpp \
    Rendering/Src/lve_device.cpp \
    Rendering/Src/lve_model.cpp \
    Rendering/Src/lve_pipeline.cpp \
    Rendering/Src/lve_window.cpp \
    Rendering/Src/simple_render_system.cpp \
    T2D.cpp \
    all_data.cpp \
    filedb.cpp \
    formhier.cpp \
    forminfo.cpp \
    formlayer.cpp \
    formmap.cpp \
    formtop.cpp \
    gitmerge.cpp \
    main.cpp \
    mainwindow.cpp \
    trianglerenderer.cpp

HEADERS += \
    Rendering/Src/LayoutModel.h \
    Rendering/Src/LayoutPEXData.h \
    Rendering/Src/PEXCapacitorModel.h \
    Rendering/Src/PEXResistorModel.h \
    Rendering/Src/dtaorendersystem.h \
    Rendering/Src/keyboard_movement_controller.hpp \
    Rendering/Src/lve_camera.hpp \
    Rendering/Src/lve_device.hpp \
    Rendering/Src/lve_game_object.hpp \
    Rendering/Src/lve_model.hpp \
    Rendering/Src/lve_pipeline.hpp \
    Rendering/Src/lve_window.hpp \
    Rendering/Src/rapidcsv.h \
    Rendering/Src/simple_render_system.hpp \
    T2D.h \
    all_data.h \
    filedb.h \
    formhier.h \
    forminfo.h \
    formlayer.h \
    formmap.h \
    formtop.h \
    gitmerge.h \
    mainwindow.h \
    trianglerenderer.h

FORMS += \
    formhier.ui \
    forminfo.ui \
    formlayer.ui \
    formmap.ui \
    formtop.ui \
    mainwindow.ui

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target


RESOURCES += \
    Resources.qrc

DISTFILES += \
    Rendering/Data/MVP_PEX_RC_r1_0130.csv \
    Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv \
    Rendering/Data/big_test_espin.csv \
    Rendering/Data/layout_input_data.csv \
    Rendering/Data/layout_input_data_old_format.csv \
    Rendering/Data/pex_cap_test.csv \
    Rendering/Data/pex_res_test.csv \
    Rendering/Data/pex_res_test_beol_only.csv \
    Rendering/Data/pex_res_test_simple.csv \
    Rendering/Data/test_espin.csv \
    Rendering/shaders/compile.bat \
    Rendering/shaders/simple_shader.frag \
    Rendering/shaders/simple_shader.frag.spv \
    Rendering/shaders/simple_shader.frag_edge.spv \
    Rendering/shaders/simple_shader.frag_pex.spv \
    Rendering/shaders/simple_shader.vert \
    Rendering/shaders/simple_shader.vert.spv \
    Rendering/shaders/simple_shader.vert_edge.spv \
    Rendering/shaders/simple_shader.vert_pex.spv \
    Rendering/shaders/simple_shader_edge.frag \
    Rendering/shaders/simple_shader_edge.vert \
    Rendering/shaders/simple_shader_pex.frag \
    Rendering/shaders/simple_shader_pex.vert



INCLUDEPATH += $$PWD/../../Library/glm-0.9.9.8



unix:!macx|win32: LIBS += -L$$PWD/../../Library/VulkanSDK/1.3.239.0/Lib/ -lvulkan-1

INCLUDEPATH += $$PWD/../../Library/VulkanSDK/1.3.239.0/Lib
DEPENDPATH += $$PWD/../../Library/VulkanSDK/1.3.239.0/Lib

INCLUDEPATH += $$PWD/../../Library/glm-0.9.9.8/glm



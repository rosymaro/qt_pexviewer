!@hash[]!@file[]./Rendering/Src/LayoutData.cpp!@hash[]!@code[]#include "LayoutPEXData.h"

#include <iostream>
#include <string>
#include <vector>
#include <limits>
#include <cstdio>
#include <chrono>

#include "rapidcsv.h"

#include <QFile>
#include <QDebug>



using namespace std;

inline double coord_normalize(double in_value, double move, double scale) {
    return 2 * ((in_value - move) * (scale)) - 1.0f;
}



LayoutItem::LayoutItem() : pattern{}, layer_number{}, layer_datatype{}, layer_type{} {
}
LayoutItem::~LayoutItem() {
}

LayoutItem::LayoutItem(const cube_info& pattern_, const int layer_number_, const int layer_datatype_, LAYOUT_LAYER_TYPE layer_type_)
    : pattern(pattern_), layer_number(layer_number_), layer_datatype(layer_datatype_), layer_type(layer_type_) {
}


LayoutDataManager::LayoutDataManager()
    : file_path{}, patterns{}, scale(1.0),
      layout_min_x{}, layout_max_x{}, layout_min_y{}, layout_max_y{}, layout_min_z{}, layout_max_z{} {
}

LayoutDataManager::~LayoutDataManager() {
    this->patterns.clear();
}

void LayoutDataManager::calculateScale() {
    x_diff = this->layout_max_x - this->layout_min_x;
    y_diff = this->layout_max_y - this->layout_min_y;
    z_diff = this->layout_max_z - this->layout_min_z;

    double max_diff = x_diff > y_diff ? x_diff : y_diff;
    max_diff = max_diff > z_diff ? max_diff : z_diff;

    this->scale = 1.0f / max_diff;
}

bool LayoutDataManager::compareByLength(const LDATA10BY10 &a, const LDATA10BY10 &b) {
    //qDebug() << "is working";
    return a.top < b.top;
}

void LayoutDataManager::loadLayoutData(T2D &t2d) {
    /*
    if (!QFile::exists(file_path.c_str())) {
        cerr << "File is not exist : " << file_path << endl;
        return;
    }
    */

    std::chrono::system_clock::time_point start, end;
    std::chrono::seconds run_time;

    start = std::chrono::system_clock::now();

   // rapidcsv::Document infile(file_path, rapidcsv::LabelParams(-1, -1));

    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutDataManager / loadLayoutData / rapidcsv::infile [sec] : "
              << run_time.count() << "\n";

    //std::vector<float> bbox = infile.GetRow<float>(0);
    this->layout_min_x = t2d.LayoutMinMax.minx;
    this->layout_min_y = t2d.LayoutMinMax.miny;
    this->layout_max_x = t2d.LayoutMinMax.maxx;
    this->layout_max_y = t2d.LayoutMinMax.maxy;
    this->layout_min_z = t2d.LayoutMinMax.minz;
    this->layout_max_z = t2d.LayoutMinMax.maxz;

    calculateScale();

    t2d_ptr = &t2d;

    //size_t line_count = infile.GetRowCount();
    //cube_info cur_cube;
    //int layer_number, layer_datatype;

    start = std::chrono::system_clock::now();

    /*
    for (size_t i = 1; i < line_count; ++i) { //first line is bbox area
        vector<string> line = infile.GetRow<string>(i);
        //if (line[LAYOUTINFO_IDX_STRUCTURE] != "Poly") continue;
        //if (std::stoi(line[LAYOUTINFO_IDX_NUMPOINTS]) != 4) continue;

        layer_number = std::stoi(line[LAYOUTINFO_IDX_LAYER]);
        layer_datatype = std::stoi(line[LAYOUTINFO_IDX_DATATYPE]);

        cur_cube.minz = std::stof(line[LAYOUTINFO_IDX_ZSTART]);
        cur_cube.maxz = std::stof(line[LAYOUTINFO_IDX_ZEND]);
        if (cur_cube.minz == cur_cube.maxz) continue;

        cur_cube.minx = std::stof(line[LAYOUTINFO_IDX_LEFT]);
        cur_cube.maxx = std::stof(line[LAYOUTINFO_IDX_RIGHT]);
        cur_cube.miny = std::stof(line[LAYOUTINFO_IDX_BOTTOM]);
        cur_cube.maxy = std::stof(line[LAYOUTINFO_IDX_TOP]);

        //cur_cube.minx = coord_normalize(cur_cube.minx, this->layout_min_x, scale);
        //cur_cube.maxx = coord_normalize(cur_cube.maxx, this->layout_min_x, scale);
        //cur_cube.miny = coord_normalize(cur_cube.miny, this->layout_min_y, scale);
        //cur_cube.maxy = coord_normalize(cur_cube.maxy, this->layout_min_y, scale);
        //cur_cube.minz = coord_normalize(cur_cube.minz, this->layout_min_z, scale);
        //cur_cube.maxz = coord_normalize(cur_cube.maxz, this->layout_min_z, scale);

        this->patterns.push_back(LayoutItem(cur_cube, layer_number, layer_datatype, LAYOUT_LAYER_TYPE::LAYOUT_LAYER_TYPE_DEFAULT));

    }*/

    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    start = std::chrono::system_clock::now();
    std::cout << "Run Time / LayoutDataManager / loadLayoutData / pattern push [sec] : "
              << run_time.count() << "\n";

    std::sort(t2d_ptr->LayoutData10by10.begin(), t2d_ptr->LayoutData10by10.end(), compareByLength);


    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    qDebug() << "Run Time / LayoutDataManager / loadLayoutData / pattern sort [sec] : "
              << run_time.count() << "\n";

   // infile.Clear();

    /*
        printf("\n\nLayout Info Data\n\n");
        for (auto& cur_pattern : this->patterns) {
            printf("left/bottom/right/top/z-start/z-end = %.4f/%.4f/%.4f/%.4f/%.4f/%.4f/\n",
                cur_pattern.pattern.minx, cur_pattern.pattern.miny,
                cur_pattern.pattern.maxx, cur_pattern.pattern.maxy,
         cur_pattern.pattern.minz, cur_pattern.pattern.maxz);
        }
        //*/
}

void testLayoutData() {
    //LayoutDataManager layout_data;
    //layout_data.loadLayoutData("Data/layout_input_data.csv");

}

!@hash[]!@file[]./Rendering/Src/LayoutModel.cpp!@hash[]!@code[]#include "LayoutModel.h"

#include <iostream>
#include <string>
#include <vector>
#include <chrono>

#include "LayoutPEXData.h"
#include <unordered_set>
#include <QFile>


LayoutModel::LayoutModel(LveDevice& device, MODEL_TYPE model_type, T2D &t2d)
    : LveModel(device, model_type), layout_data{} {
    this->makeRenderingData(t2d);
    this->createBuffers();
}

LayoutModel::~LayoutModel() {
    this->layout_data.clear();
}

void LayoutModel::makeRenderingData(T2D &t2d) {
    std::chrono::system_clock::time_point start, end;
    std::chrono::seconds run_time;

    start = std::chrono::system_clock::now();
    loadData(t2d);
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / loadData [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeCubeVertices();
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / makeCubeVertices [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeVertices();
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / lmakeVertices [sec] : "
              << run_time.count() << "\n";

    start = std::chrono::system_clock::now();
    makeIndices();
    end = std::chrono::system_clock::now();
    run_time = std::chrono::duration_cast<std::chrono::seconds>(end - start);
    std::cout << "Run Time / LayoutModel / makeIndices [sec] : "
              << run_time.count() << "\n";
}

void LayoutModel::loadData(T2D &t2d) {
    this->layout_data.loadLayoutData(t2d);
}

void LayoutModel::makeCubeVertices() {
    std::vector<LDATA10BY10> &layout_items = this->layout_data.getPatterns_t2d();
    std::vector<LDATA10BY10>::iterator it = layout_items.begin();
    cube_vertex cur_cube_vertices;
    std::unordered_set<string> checking_set;


    for (it = layout_items.begin(); it != layout_items.end(); ++it) {
        cur_cube_vertices.layernum = to_string(it->layernum) + "." + to_string(it->datatype);
        qDebug() <<  QString::fromStdString(cur_cube_vertices.layernum);
        for(auto row : it->xy ){
            for (auto col : row){
                if(col.size() == 0) continue;
                for(auto each_box : col){

                    cur_cube_vertices.vertex[0] = { each_box.minx, each_box.maxy, it->top };
                    cur_cube_vertices.vertex[1] = { each_box.minx, each_box.miny, it->top };
                    cur_cube_vertices.vertex[2] = { each_box.maxx, each_box.miny, it->top };
                    cur_cube_vertices.vertex[3] = { each_box.maxx, each_box.maxy, it->top };

                    cur_cube_vertices.vertex[4] = { each_box.minx, each_box.maxy, it->bot };
                    cur_cube_vertices.vertex[5] = { each_box.minx, each_box.miny, it->bot };
                    cur_cube_vertices.vertex[6] = { each_box.maxx, each_box.miny, it->bot };
                    cur_cube_vertices.vertex[7] = { each_box.maxx, each_box.maxy, it->bot };


                    this->cube_vertices.push_back(cur_cube_vertices);

                    if(checking_set.find(cur_cube_vertices.layernum) == checking_set.end()){
                        checking_set.insert(cur_cube_vertices.layernum);
                        drawing_order_layerby.push_back(cur_cube_vertices.layernum);
                    }
                }

            }
            layerList[cur_cube_vertices.layernum].color = glm::vec3 {it->color.r/(float)255,it->color.g/(float)255, it->color.b/(float)255};
            layerList[cur_cube_vertices.layernum].opacity = it->color.a/(float)255;
            layerList[cur_cube_vertices.layernum].visiblity = it->checking;

        }


        //std::cout << cube_vertices.back().layernum << '\n';
    }
}

void LayoutModel::makeVertices() {
    std::vector<LDATA10BY10> &layout_items = this->layout_data.getPatterns_t2d();
    Vertex temp_vertex;

    float up_color = 0.15f;
    float down_color = 0.6f;

    for (const auto& cur_cube : this->cube_vertices) {
        for (int i = 0; i < 8; ++i) {
            temp_vertex.position = { cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };

            if (i < 4) temp_vertex.color = { up_color , up_color , up_color };
            else       temp_vertex.color = { down_color , down_color , down_color };


            layerby_vertices[cur_cube.layernum].push_back(temp_vertex);
        }
    }
}

void LayoutModel::makeIndices() {
    //makeIndicesForFace();
    makeIndicesForFace_map();
    //makeIndicesForEdge();
    makeIndicesForEdge_map();
}

void LayoutModel::makeIndicesForFace_map() {
    //size_t layer_count = this->layerby_vertices.size();

    uint32_t start_idx = 0;
    std::map<string, std::vector<uint32_t>>& indices = this->layerby_face;
    for (auto const& [key, val] : layerby_vertices) {
        size_t cube_count_by_layer = val.size() / 8;
        for (size_t i = 0; i < cube_count_by_layer; ++i) {
            start_idx = 8 * i;
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 0);//top

            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 3);//right

            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 0);//front

            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 4);//bottom

            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 0);//left

            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 1);//back
        }
    }

    qDebug() << layerby_vertices.size();

}

void LayoutModel::makeIndicesForEdge_map() {
    //size_t layer_count = this->layerby_vertices.size();

    std::map<string, std::vector<uint32_t>>& indices = this->layerby_edge;
    uint32_t start_idx = 0;
    for (auto const& [key, val] : layerby_vertices) {
        size_t cube_count_by_layer = val.size() / 8;
        for (size_t i = 0; i < cube_count_by_layer; ++i) {
            start_idx = 8 * i;
            //top
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 1);
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 3);
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 0);

            //bottom
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 4);

            //right
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 3);

            //left
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 4);
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 1);
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 0);

            //front
            indices[key].push_back(start_idx + 0); indices[key].push_back(start_idx + 3);
            indices[key].push_back(start_idx + 3); indices[key].push_back(start_idx + 7);
            indices[key].push_back(start_idx + 7); indices[key].push_back(start_idx + 4);
            indices[key].push_back(start_idx + 4); indices[key].push_back(start_idx + 0);

            //back
            indices[key].push_back(start_idx + 1); indices[key].push_back(start_idx + 5);
            indices[key].push_back(start_idx + 5); indices[key].push_back(start_idx + 6);
            indices[key].push_back(start_idx + 6); indices[key].push_back(start_idx + 2);
            indices[key].push_back(start_idx + 2); indices[key].push_back(start_idx + 1);
        }
    }

}

void LayoutModel::makeIndicesForFace() {
    size_t cube_count = this->cube_vertices.size();

    uint32_t start_idx = 0;
    std::vector<uint32_t>& indices = this->indices_face;
    for (int i = 0; i < cube_count; ++i) {
        start_idx = 8 * i;
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);//top

        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);//right

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);//front

        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);//bottom

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);//left

        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);//back
    }
}


void LayoutModel::makeIndicesForEdge() {
    size_t cube_count = this->cube_vertices.size();

    std::vector<uint32_t>& indices = this->indices_edge;
    uint32_t start_idx = 0;
    for (int i = 0; i < cube_count; ++i, start_idx += 8) {
        //top
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);

        //bottom
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);

        //right
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);

        //left
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);

        //front
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);

        //back
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);
    }
}


!@hash[]!@file[]./Rendering/Src/PEXCapacitorModel.cpp!@hash[]!@code[]#include "PEXCapacitorModel.h"

#include <iostream>
#include <map>
#include <vector>
#include <math.h>
#include <cstdio>
#include <thread>
#include <mutex>

#include "LayoutPEXData.h"
#include "utils.h"
#include <QString>

using namespace std;

PEXCapacitorModel::PEXCapacitorModel(
    LveDevice& device,
    MODEL_TYPE model_type,
    const QString& data_file,
    T2D* layout_data_)
    : LveModel(device, model_type), pex_data{}, cap_node_name_to_index_map{}, layout_data{ layout_data_ } {

    this->makePatternCapsFromLayoutData();
    this->makeRenderingData(data_file);
    this->createBuffers();
}


PEXCapacitorModel::~PEXCapacitorModel() {
    for (auto& cur_item : this->layer_to_pattern_cap_map) cur_item.second.clear();
    this->layer_to_pattern_cap_map.clear();
    this->pattern_caps.clear();
}

void PEXCapacitorModel::makePatternCapsFromLayoutData() {
    std::vector<LDATA10BY10>& layout_items = this->layout_data->LayoutData10by10;
    std::vector<LDATA10BY10>::iterator it = layout_items.begin();
    pattern_cap pattern_cap_buf;
    if (layout_items.empty()) {
        std::cerr << "Error! empty patten @PEXCapacitorModel::makePatternWCapsFromLayoutData()\n";
    }

    for (it = layout_items.begin(); it != layout_items.end(); ++it) {
        pattern_cap_buf.layer_number = it->layernum;
        pattern_cap_buf.layer_datatype = it->datatype;
        pattern_cap_buf.cap_value = 0;
        pattern_cap_buf.normalized_cap_value = 0;
        pattern_cap_buf.cap_count = 0;
        for (auto row : it->xy) {
            for (auto col : row) {
                if (col.size() == 0) break;
                for (auto each_box : col) {
                    pattern_cap_buf.pattern.minx = each_box.minx;
                    pattern_cap_buf.pattern.miny = each_box.miny;
                    pattern_cap_buf.pattern.minz = it->bot;
                    pattern_cap_buf.pattern.maxx = each_box.maxx;
                    pattern_cap_buf.pattern.maxy = each_box.maxy;
                    pattern_cap_buf.pattern.maxz = it->top;

                    this->pattern_caps.push_back(pattern_cap_buf);
                }
            }
        }

        this->layers.insert({ it->layernum, it->datatype });
    }
}

void PEXCapacitorModel::makeRenderingData(const QString& file_path) {
    loadData(file_path);
    makeCapNodesFromPEXData();

    attachCapToPattern();
    normalizePatternCap();
    //printLayerToPatternCapMap("After Normalization Cap");

    makeCubeVertices();
    makeVertices();
    makeIndices();

    for (auto& cur_item : this->layer_to_cap_node_map) cur_item.second.clear();
    this->layer_to_cap_node_map.clear();
    this->cap_nodes.clear();
    this->layers.clear();
}

void PEXCapacitorModel::loadData(const QString& file_path) {
    this->pex_data.loadData(file_path);
    //this->pex_data.printPEXData();
}


void PEXCapacitorModel::makeCapNodesFromPEXData() {
    this->cap_node_name_to_index_map.clear();
    std::map<std::string, size_t>::iterator it;
    for (auto& pex_item : this->pex_data.getCapacitors()) {
        //node1
        std::string& node1_name = pex_item.node1.name;
        it = this->cap_node_name_to_index_map.find(node1_name);
        if (it == this->cap_node_name_to_index_map.end()) addNewCapNode(pex_item.node1, pex_item.value);
        else {
            this->cap_nodes[it->second].value += pex_item.value;
            this->cap_nodes[it->second].connected_count++;
        }

        //node2
        std::string& node2_name = pex_item.node2.name;
        it = this->cap_node_name_to_index_map.find(node2_name);
        if (it == this->cap_node_name_to_index_map.end()) addNewCapNode(pex_item.node2, pex_item.value);
        else {
            this->cap_nodes[it->second].value += pex_item.value;
            this->cap_nodes[it->second].connected_count++;
        }
    }//for(auto & pex_item : this->pex_data.getCapacitors())
    this->pex_data.clear();
    this->cap_node_name_to_index_map.clear();
}


void PEXCapacitorModel::addNewCapNode(pex_node& pex_node, double value) {
    cap_node new_cap_node{};
    new_cap_node.name = pex_node.name;
    new_cap_node.layer_number = pex_node.layer_number;
    new_cap_node.layer_datatype = pex_node.layer_datatype;
    new_cap_node.x = pex_node.x;
    new_cap_node.y = pex_node.y;
    new_cap_node.value = value;
    new_cap_node.connected_count = 1;

    this->cap_nodes.push_back(new_cap_node);
    this->cap_node_name_to_index_map.insert(std::pair<std::string, size_t>(new_cap_node.name, this->cap_nodes.size() - 1));
}


void PEXCapacitorModel::attachCapToPattern() {
    makeLayerToCapNodeMap();
    makeLayerToPatternCapMap();

    /*
        //????o???? ??????? ??
        //matchCapWithPattern(this->cap_layer_map, this->pattern_layer_map, 17, 0);
        for (auto& cur_layer : this->layers) {
            string layer = getLayerString(cur_layer.first, cur_layer.second);
            map<string, vector<cap_node*>>::iterator it_layer_to_cap_node_map = this->layer_to_cap_node_map.find(layer);
            map<string, vector<pattern_cap*>>::iterator it_layer_to_pattern_cap_map = this->layer_to_pattern_cap_map.find(layer);
            if (it_layer_to_cap_node_map == this->layer_to_cap_node_map.end()
                || it_layer_to_pattern_cap_map == this->layer_to_pattern_cap_map.end()) continue;

            std::vector<cap_node*>& caps = it_layer_to_cap_node_map->second;
            std::vector<pattern_cap*>& patterns = it_layer_to_pattern_cap_map->second;

            matchCapWithPattern(caps, patterns);
            //matchCapWithPattern(this->layer_to_cap_node_map, this->layer_to_pattern_cap_map, cur_layer.first, cur_layer.second);
        }
        */

    makeLayersQueueForThreadJob();
    for (size_t i = 0; i < this->num_threads; ++i) {

        this->threads.push_back(
            std::thread(&PEXCapacitorModel::matchCapWithPatternThread, this, &this->layers_queue, &this->mutex_layers_queue));
    }

    for (auto& thread : this->threads)
        thread.join();

    /*
        FILE* out_file = NULL;
        fopen_s(&out_file, "pattern_caps_info_thread.txt", "w");
        if (out_file != NULL) {
            printPatternCaps(out_file);
            fclose(out_file);
        }
        else printPatternCaps(stdout);
        */
}

void PEXCapacitorModel::matchCapWithPatternThread(std::queue<std::string>* layers, std::mutex* mutex_) {
    while (1) {
        mutex_->lock();
        if (layers->empty()) {
            mutex_->unlock();
            break;
        }

        string layer = layers->front();
        layers->pop();
        mutex_->unlock();

        map<string, vector<cap_node*>>::iterator it_layer_to_cap_node_map = this->layer_to_cap_node_map.find(layer);
        map<string, vector<pattern_cap*>>::iterator it_layer_to_pattern_cap_map = this->layer_to_pattern_cap_map.find(layer);
        if (it_layer_to_cap_node_map == this->layer_to_cap_node_map.end()
            || it_layer_to_pattern_cap_map == this->layer_to_pattern_cap_map.end()) continue;;

        std::vector<cap_node*>& caps = it_layer_to_cap_node_map->second;
        std::vector<pattern_cap*>& patterns = it_layer_to_pattern_cap_map->second;
        //matchCapWithPattern(caps, patterns);
        for (auto& cap : caps) {
            for (auto& pattern : patterns) {
                if (isPatternIncludeCap(*pattern, *cap)) {
                    pattern->cap_count++;
                    pattern->cap_value += cap->value;
                    break;
                }
            }//for cap : caps
        }//for pattern : patterns

    }//while 1
}


void PEXCapacitorModel::makeLayersQueueForThreadJob() {
    for (auto& cur_layer : this->layers) {
        string layer = getLayerString(cur_layer.first, cur_layer.second);
        this->layers_queue.push(layer);
    }
}

void PEXCapacitorModel::matchCapWithPattern(
    std::vector<cap_node*>& caps,
    std::vector<pattern_cap*>& patterns
) {

    for (auto& cap : caps) {
        for (auto& pattern : patterns) {
            if (isPatternIncludeCap(*pattern, *cap)) {
                pattern->cap_count++;
                pattern->cap_value += cap->value;
                break;
            }
        }//for cap : caps
    }//for pattern : patterns

}

void PEXCapacitorModel::matchCapWithPattern(
    std::map<std::string, std::vector<cap_node*>>& cap_layer_map_,
    std::map<std::string, std::vector<pattern_cap*>>& pattern_layer_map_,
    uint target_layer_number, uint target_layer_datatype) {

    //string layer = std::to_string(target_layer_number) + "." + std::to_string(target_layer_datatype);
    string layer = getLayerString(target_layer_number, target_layer_datatype);
    std::map<std::string, std::vector<cap_node*>>::iterator it_cap_layer_map = cap_layer_map_.find(layer);
    std::map<std::string, std::vector<pattern_cap*>>::iterator it_pattern_layer_map = pattern_layer_map_.find(layer);
    if (it_cap_layer_map == cap_layer_map_.end() || it_pattern_layer_map == pattern_layer_map_.end()) return;

    std::vector<cap_node*>& caps = it_cap_layer_map->second;
    std::vector<pattern_cap*>& patterns = it_pattern_layer_map->second;

    for (auto& cap : caps) {
        for (auto& pattern : patterns) {
            if (isPatternIncludeCap(*pattern, *cap)) {
                pattern->cap_count++;
                pattern->cap_value += cap->value;
                break;
            }
        }//for cap : caps
    }//for pattern : patterns
}

void PEXCapacitorModel::makeLayerToCapNodeMap() {
    this->layer_to_cap_node_map.clear();
    map<string, vector<cap_node*>>::iterator it;
    for (auto& cur_cap : this->cap_nodes) {
        //std::string layer = std::to_string(cur_cap.layer_number) + "." + std::to_string(cur_cap.layer_datatype);
        string layer = getLayerString(cur_cap.layer_number, cur_cap.layer_datatype);
        it = this->layer_to_cap_node_map.find(layer);
        if (it == this->layer_to_cap_node_map.end()) {
            vector<cap_node*>* new_cap_list = new vector<cap_node*>;
            new_cap_list->push_back(&cur_cap);
            this->layer_to_cap_node_map.insert(pair<string, vector<cap_node*>>(layer, *new_cap_list));
        }
        else {
            it->second.push_back(&cur_cap);
        }
    }//for (auto& cur_cap : this->cap_nodes)

    //printLayerToCapNodeMap();
}


void PEXCapacitorModel::makeLayerToPatternCapMap() {
    this->layer_to_pattern_cap_map.clear();
    map<string, vector<pattern_cap*>>::iterator it;
    for (auto& cur_pattern : this->pattern_caps) {
        //string layer = std::to_string(cur_pattern.layer_number) + "." + std::to_string(cur_pattern.layer_datatype);
        string layer = getLayerString(cur_pattern.layer_number, cur_pattern.layer_datatype);
        it = this->layer_to_pattern_cap_map.find(layer);
        if (it == this->layer_to_pattern_cap_map.end()) {
            vector<pattern_cap*>* new_pattern_list = new vector<pattern_cap*>;
            new_pattern_list->push_back(&cur_pattern);
            this->layer_to_pattern_cap_map.insert(pair<string, vector<pattern_cap*>>(layer, *new_pattern_list));
        }
        else {
            it->second.push_back(&cur_pattern);
        }
    }//for (auto& cur_pattern : this->pattern_caps)

    //printLayerToPatternCapMap();
}


void PEXCapacitorModel::normalizePatternCap() {
    for (auto& cur_pattern_cap : this->pattern_caps) {
        if (cur_pattern_cap.cap_value > this->max_cap) this->max_cap = cur_pattern_cap.cap_value;
    }

    for (auto& cur_pattern_cap : this->pattern_caps) {
        cur_pattern_cap.normalized_cap_value = 1.0 / (std::log((cur_pattern_cap.cap_value / this->max_cap)) * (-1.0) + 1.0);
    }
}


inline std::string PEXCapacitorModel::getLayerString(uint layer_number, uint layer_datatype) {
    return (std::string(std::to_string(layer_number) + "." + std::to_string(layer_datatype)));
}


bool PEXCapacitorModel::isPatternIncludeCap(const pattern_cap& pattern, const cap_node& cap) {
    if (cap.x < pattern.pattern.minx) return false;
    if (cap.x > pattern.pattern.maxx) return false;
    if (cap.y < pattern.pattern.miny) return false;
    if (cap.y > pattern.pattern.maxy) return false;
    return true;
}

void PEXCapacitorModel::makeCubeVertices() {
    cube_vertex cur_cube_vertices;
    std::vector<pattern_cap>::iterator it;
    for (it = this->pattern_caps.begin(); it != this->pattern_caps.end(); ++it) {
        cur_cube_vertices.vertex[0] = { it->pattern.minx, it->pattern.maxy, it->pattern.maxz };
        cur_cube_vertices.vertex[1] = { it->pattern.minx, it->pattern.miny, it->pattern.maxz };
        cur_cube_vertices.vertex[2] = { it->pattern.maxx, it->pattern.miny, it->pattern.maxz };
        cur_cube_vertices.vertex[3] = { it->pattern.maxx, it->pattern.maxy, it->pattern.maxz };

        cur_cube_vertices.vertex[4] = { it->pattern.minx, it->pattern.maxy, it->pattern.minz };
        cur_cube_vertices.vertex[5] = { it->pattern.minx, it->pattern.miny, it->pattern.minz };
        cur_cube_vertices.vertex[6] = { it->pattern.maxx, it->pattern.miny, it->pattern.minz };
        cur_cube_vertices.vertex[7] = { it->pattern.maxx, it->pattern.maxy, it->pattern.minz };

        this->cube_vertices.push_back(cur_cube_vertices);
    }
}
  
void PEXCapacitorModel::makeVertices() {
    Vertex temp_vertex;
    float cap_color_r{}, cap_color_g{}, cap_color_b{};

    std::vector<pattern_cap>::iterator cur_pattern_cap = this->pattern_caps.begin();

    double capacitor_value{};
    double capacitor_percentile{};
    float temp_color[3] = { 0.0f, 0.0f, 0.0f };
    glm::vec3 capacitor_color = { 0.0f, 0.0f, 0.0f };
    for (const auto& cur_cube : this->cube_vertices) {
        capacitor_value = cur_pattern_cap->cap_value;
        if (cur_pattern_cap->cap_value > 0) {
            capacitor_percentile = percentileOfCapacitor(*cur_pattern_cap);
            capacitor_color = UTILS::getPercentileColour(capacitor_percentile / 100, 0.0, 1.0);
            /*
              std::cout << cur_pattern_cap->cap_value << std::endl;
              std::cout << "normalized_cap_value -----" << cur_pattern_cap->normalized_cap_value << std::endl;
              std::cout << "layer_number -----" << cur_pattern_cap->layer_number << "." << cur_pattern_cap->layer_datatype << std::endl;
              std::cout << "percentile -----" << capacitor_percentile << std::endl;
              std::cout << "r-" << capacitor_color.r << "g-" << capacitor_color.g << "b-" << capacitor_color.b << std::endl;
              */

            for (int i = 0; i < 8; ++i) {
                temp_vertex.position = { cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };
                temp_vertex.color = capacitor_color;
                vertices.push_back(temp_vertex);
            }
        }
        cur_pattern_cap++;
    }
}

void PEXCapacitorModel::makeIndices() {
    size_t cube_count = this->cube_vertices.size();

    std::vector<uint32_t>& indices = this->indices_edge;
    uint32_t start_idx = 0;
    for (size_t i = 0; i < cube_count; ++i, start_idx += 8) {
        //top
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);

        //bottom
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);

        //right
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);

        //left
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);

        //front
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);

        //back
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);
    }
}

double PEXCapacitorModel::percentileOfCapacitor(const pattern_cap& in_cap) {
    std::vector<pattern_cap>::const_iterator it;
    int count = 0;
    int count_all = 0;
    double percent;
    for (it = this->pattern_caps.begin(); it != this->pattern_caps.end(); ++it) {
        if (it->cap_value != 0) {
            if (it->cap_value > in_cap.cap_value) {
                count++;
            }
            count_all++;
        }
    }
    percent = (count * 100) / count_all;
    return percent;
};


void PEXCapacitorModel::printCapNodes() {
    printf("***** PEX ITEM LIST\n");
    int i = 1;
    for (auto& pex_item : this->pex_data.getCapacitors()) {
        printf("%dth PEX Item\n", i++);
        pex_item.print();
        printf("\n");
    }

    printf("***** CAP NODE LIST\n");
    i = 1;
    for (auto& cap_node : this->cap_node_name_to_index_map) {
        printf("%dth Cap Node Item\n", i++);
        printf("\nNode Name = %s / Layer# = %d.%d / x,y = %.4f,%.4f / Value = %e / Neibor = %d\n",
            this->cap_nodes[cap_node.second].name.c_str(),
            this->cap_nodes[cap_node.second].layer_number,
            this->cap_nodes[cap_node.second].layer_datatype,
            this->cap_nodes[cap_node.second].x,
            this->cap_nodes[cap_node.second].y,
            this->cap_nodes[cap_node.second].value,
            this->cap_nodes[cap_node.second].connected_count);
        printf("\n");
    }
}

void PEXCapacitorModel::printPatternCaps(FILE* out_stream) {
    fprintf(out_stream, "\n\n###############################################\n");
    fprintf(out_stream, "### PatternCap List\n");
    for (auto& pattern : this->pattern_caps) {
        fprintf(out_stream, "\nLayer = %u.%u, Cap count = %u, Total Caps = %e\n",
            pattern.layer_number, pattern.layer_datatype, pattern.cap_count, pattern.cap_value);
        fprintf(out_stream, "\tLeft ~ Right/Bottom ~ Top = %.6f ~ %.6f / %.6f ~ %.6f\n",
            pattern.pattern.minx, pattern.pattern.maxx, pattern.pattern.miny, pattern.pattern.maxy);
    }
}

void PEXCapacitorModel::printLayerToCapNodeMap(FILE* out_stream) {
    fprintf(out_stream, "\n\n\n####################################################\n");
    fprintf(out_stream, "Cap Layer Map\n");
    for (auto& cur_item : this->layer_to_cap_node_map) {
        fprintf(out_stream, "\nLayer = %s :: name / cap count / cap value \n", cur_item.first.c_str());
        for (auto cur_cap : cur_item.second) {
            fprintf(out_stream, "\t%s / %u / %e / %.6f, %.6f\n",
                cur_cap->name.c_str(), cur_cap->connected_count, cur_cap->value, cur_cap->x, cur_cap->y);
        }
    }
}

void PEXCapacitorModel::printLayerToPatternCapMap(const char* msg) {
    printf("\n\n\n####################################################\n");
    printf("Pattern Layer Map :: %s\n", msg);
    for (auto& cur_item : this->layer_to_pattern_cap_map) {
        printf("\nLayer = %s :: left ~ right / bottom ~ top - cap count, cap value, norm cap value\n", cur_item.first.c_str());
        for (auto cur_pattern : cur_item.second) {
            printf("\t%.6f ~ %.6f / %.6f ~ %.6f - ",
                cur_pattern->pattern.minx, cur_pattern->pattern.maxx, cur_pattern->pattern.miny, cur_pattern->pattern.maxy);
            printf("%u, %e, %f\n", cur_pattern->cap_count, cur_pattern->cap_value, cur_pattern->normalized_cap_value);
        }
    }
}

void PEXCapacitorModel::printLayerList() {
    printf("\n\n\n####################################################\n");
    printf("Layer List\n");
    for (auto& cur_layer : this->layers) {
        printf("\t%u.%u\n", cur_layer.first, cur_layer.second);
    }
}




!@hash[]!@file[]./Rendering/Src/PEXData.cpp!@hash[]!@code[]#include "LayoutPEXData.h"
#include <iostream>
#include <string>
#include <vector>

#include <limits>
#include <cstdio>

#include "rapidcsv.h"

#include <QFile>
#include <QString>
#include <QDebug>
using namespace std;


/// <summary>
/// PEXItem
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXItem::PEXItem() : node1{}, node2{}, name{} {
    this->value = 0.0;
}

PEXItem::PEXItem(const node& node1_, const node& node2_, const double& value_, const string& name_) :
    node1(node1_), node2(node2_), value(value_), name(name_) {
}

PEXItem::~PEXItem() {
}

void PEXItem::print() {
    printf("%s\n", this->name.c_str());
    printf("Node1 name/layer#/x1,y1/Z-s,Z-e = %s / %d.%d / %.5f,%.5f / %.5f,%.5f\n",
        this->node1.name.c_str(), this->node1.layer_number, this->node1.layer_datatype,
        this->node1.x, this->node1.y, this->node1.z_start, this->node1.z_end);
    printf("Node2 name/layer#/x1,y1/Z-s,Z-e = %s / %d.%d / %.5f,%.5f / %.5f,%.5f\n",
        this->node1.name.c_str(), this->node1.layer_number, this->node1.layer_datatype,
        this->node2.x, this->node2.y, this->node2.z_start, this->node2.z_end);
}


/// <summary>
/// PEXResistor
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXResistor::PEXResistor() : PEXItem(), direction(RES_DIRECTION_NONE) {
}
PEXResistor::PEXResistor(const string& name_, const node& node1_, const node& node2_, const double& value_, const PEXResDirection& direction_) :
    PEXItem(node1_, node2_, value_, name_), direction(direction_) {
}

void PEXResistor::print() {
    PEXItem::print();
    printf("Direction = ");
    if (this->direction == RES_DIRECTION_VERTICAL) printf("Vertical\n");
    else printf("Horizontal\n");
    printf("Resistor Value = %10.5f\n\n", this->getValue());
}

PEXResistor::~PEXResistor() {
}

PEXResDirection PEXResistor::checkDirectionFromDescription(const std::string& description) {
    PEXResDirection direction;
    if (description.find("$a") == std::string::npos) {
        direction = RES_DIRECTION_HORIZONTAL;
    }
    else {
        direction = RES_DIRECTION_VERTICAL;
    }
    //printf("#####Description = %s, ", description.c_str());
    //if (direction == RES_DIRECTION_VERTICAL) printf("Vertical\n");
    //else printf("Horizontal\n");

    return direction;
}

/// <summary>
/// PEXCapacitor
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXCapacitor::PEXCapacitor() : PEXItem() {
}
PEXCapacitor::PEXCapacitor(const std::string& name_, const node& node1_, const node& node2_, const double& value_) :
    PEXItem(node1_, node2_, value_, name_) {
}
PEXCapacitor::~PEXCapacitor() {
}

void PEXCapacitor::print() {
    PEXItem::print();
    printf("Capacitor Value = %10.5e\n\n", this->getValue());
}

/// <summary>
/// PEXResistorDataManager
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXResistorDataManager::PEXResistorDataManager() {
    this->resistors = {};
    this->file_path = "";
    this->max_resistor_vertical = std::numeric_limits<double>::min();
    this->min_resistor_vertical = std::numeric_limits<double>::max();
    this->max_resistor_horizontal = std::numeric_limits<double>::min();
    this->min_resistor_horizontal = std::numeric_limits<double>::max();
}

PEXResistorDataManager::~PEXResistorDataManager() {
    printf("\n\n\t~PEXDataManager\n");
    this->resistors.clear();
    this->resistors_ref.clear();
    this->resistors_of_node.clear();
}

void PEXResistorDataManager::clear() {
    this->resistors.clear();
}

void PEXResistorDataManager::loadData(const QString file_path) {
    if (!QFile::exists(file_path)) {
        qDebug() << "Error! " << file_path << " is not exist!!\n";
        return;
    }
    qDebug() << "resistor parsing start";


    this->file_path = file_path;
    rapidcsv::Document infile(file_path.toStdString(), rapidcsv::LabelParams(-1, -1));

    string item_name{}, node1_lvl{}, node2_lvl{};
    node node1{}, node2{};
    string description{};
    double value = 0.0;

    size_t line_count = infile.GetRowCount();
    for (size_t i = 1; i < line_count; ++i) {
        vector<string> line = infile.GetRow<string>(i);

        item_name = line[PEXINFO_INDEX::PEXINFO_INDEX_NAME];
        if (item_name[0] != 'R') continue;

        node1.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_NAME];
        node1.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_X]);
        node1.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_Y]);
        node1.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZSTART]);
        node1.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZEND]);
        node1.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_NUMBER]);
        node1.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_DATATYPE]);

        node2.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_NAME];
        node2.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_X]);
        node2.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_Y]);
        node2.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZSTART]);
        node2.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZEND]);
        node2.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_NUMBER]);
        node2.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_DATATYPE]);

        value = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_VALUE]);

        node1_lvl = line[PEXINFO_INDEX_NODE1_LVL];
        node2_lvl = line[PEXINFO_INDEX_NODE2_LVL];


        if (node1_lvl == "RX") {
            node1.x = node2.x;
            node1.y = node2.y;
        }

        description = line[PEXINFO_INDEX::PEXINFO_INDEX_DESCRIPTION];
        PEXResDirection resistor_direction = PEXResistor::checkDirectionFromDescription(description);
        if (value > 0.005) {
            updateMinMaxRes(value, resistor_direction); //임의의 코드, 0보다 작은 저항은 무시
            this->resistors_ref.push_back(PEXResistor(item_name, node1, node2, value, resistor_direction));
        }
    }
    this->resistors = this->resistors_ref;
}

void PEXResistorDataManager::groupResistorOfNode() {
    for (const auto& resistor : this->resistors_ref) {
        bool found = false;
        for (auto& resistors_v : this->resistors_of_node) {
            if (!resistors_v.empty()) {
                for (auto& resistor1 : resistors_v) {
                    if (resistor1.node1.name == resistor.node1.name
                        || resistor1.node1.name == resistor.node2.name
                        || resistor1.node2.name == resistor.node1.name
                        || resistor1.node2.name == resistor.node2.name) {
                        resistors_v.push_back(resistor);
                        found = true;
                        break;
                    }
                }
            }
        }
        if (!found) {
            this->resistors_of_node.emplace_back(std::vector<PEXResistor>{resistor});
        }
    }



    int i = 0;
    while (i < this->resistors_of_node.size()) {
        int j = 0;
        while (j < this->resistors_of_node.size()) {
            bool merge = false;
            for (auto& resistor1 : resistors_of_node[i]) {
                if (merge) {
                    break;
                }
                if (i == j) {
                }
                else {
                    for (auto& resistor2 : resistors_of_node[j]) {
                        if (resistor1.node1.name == resistor2.node1.name
                            || resistor1.node1.name == resistor2.node2.name
                            || resistor1.node2.name == resistor2.node1.name
                            || resistor1.node2.name == resistor2.node2.name) {
                            resistors_of_node[i].insert(resistors_of_node[i].end(), resistors_of_node[j].begin(), resistors_of_node[j].end());
                            resistors_of_node.erase(resistors_of_node.begin() + j);
                            merge = true;
                            break;
                        }
                    }
                }
            }
            if (!merge) {
                j++;
            }
        }
        i++;
    }
    qDebug() << "resistors_of_node size confirm &&&&&&&&&&&&&&&&&&&&&&&" << resistors_of_node.size();

    for (auto& loop : resistors_of_node[0]){
        qDebug() << "loop test XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
    }


    for (const auto& nodes : this->resistors_of_node) {

            qDebug() << "------------";
        for (const auto& node : nodes) {
            qDebug() << QString::fromStdString(node.name);
                //<< ", " << node.node1.name << ", " << node.node1.layer_number << ", " << node.node2.name << ", " << node.node2.layer_number << ", ";
        }
    }
};

void PEXResistorDataManager::setDriectionOfResistor(PEXResDirection _direction) {
    std::vector<PEXResistor> _resistors_buf;
    if (this->number_of_resistor_group > -1) {
        for (auto& resistor_ : this->resistors_of_node[number_of_resistor_group % resistors_of_node.size()]) {
            if (resistor_.getDirection() == _direction) {
                _resistors_buf.push_back(resistor_);
            }
        }
        this->resistors = _resistors_buf;
    }
    else if (this->number_of_resistor_group == -1) {
        for (auto& resistor_ : this->resistors_ref) {
            if (resistor_.getDirection() == _direction) {
                _resistors_buf.push_back(resistor_);
            }
        }
        this->resistors = _resistors_buf;
    }
    for (const auto& node : this->resistors) {
        std::cout << node.name << ", " << node.value << ", " << node.node1.name << ", " << node.node1.x << ", " << node.node1.y << ", " << node.node1.z_start << ", " << node.node1.z_end << ", " << node.node1.layer_number << ", " << node.node2.name << ", " << node.node2.x << ", " << node.node2.y << ", " << node.node2.z_start << ", " << node.node2.z_end << ", " << node.node2.layer_number << ", " << std::endl;
    }

}

inline void PEXResistorDataManager::updateMinMaxRes(const double& new_value, const PEXResDirection direction) {
    if (direction == PEXResDirection::RES_DIRECTION_VERTICAL) {
        if (this->min_resistor_vertical > new_value) this->min_resistor_vertical = new_value;
        if (this->max_resistor_vertical < new_value) this->max_resistor_vertical = new_value;
    }
    else {
        if (this->min_resistor_horizontal > new_value) this->min_resistor_horizontal = new_value;
        if (this->max_resistor_horizontal < new_value) this->max_resistor_horizontal = new_value;
    }

}

void PEXResistorDataManager::printData() {
    for (auto item : this->resistors) {
        item.print();
    }
    printf("##Resistor Count : %lld, Vertical Res Max = %10.5f, Min = %10.5f, Horizontal Res Max = %10.5f, Min = %10.5f\n",
        this->resistors.size(),
        this->getMaxResistorVerticalValue(), this->getMinResistorVerticalValue(),
        this->getMaxResistorHorizontalValue(), this->getMinResistorHorizontalValue());
}


/// <summary>
/// PEXCapacitorDataManager
/// ///////////////////////////////////////////////////////////////
/// </summary>
PEXCapacitorDataManager::PEXCapacitorDataManager() {
    this->capasitors = {};
    this->file_path = "";
    this->max_capacitor = std::numeric_limits<double>::min();
    this->min_capacitor = std::numeric_limits<double>::max();
}

PEXCapacitorDataManager::~PEXCapacitorDataManager() {
    this->capasitors.clear();
}

void PEXCapacitorDataManager::clear() {
    this->capasitors.clear();
}

void PEXCapacitorDataManager::loadData(const QString file_path) {
    if (!QFile::exists(file_path)) {
        qDebug() << "Error! " << file_path << " is not exist!!\n";
        return;
    }
    qDebug() << "capacitor parsing start";

    this->file_path = file_path;
    rapidcsv::Document infile(file_path.toStdString(), rapidcsv::LabelParams(-1, -1));

    string item_name{}, node1_lvl{}, node2_lvl{};
    node node1{}, node2{};
    string description{};
    double value = 0.0;

    size_t line_count = infile.GetRowCount();
    for (size_t i = 1; i < line_count; ++i) {
        vector<string> line = infile.GetRow<string>(i);

        item_name = line[PEXINFO_INDEX::PEXINFO_INDEX_NAME];
        if (item_name[0] != 'C') continue;

        node1.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_NAME];
        node1.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_X]);
        node1.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_Y]);
        node1.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZSTART]);
        node1.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_ZEND]);
        node1.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_NUMBER]);
        node1.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE1_LAYER_DATATYPE]);

        node2.name = line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_NAME];
        node2.x = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_X]);
        node2.y = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_Y]);
        node2.z_start = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZSTART]);
        node2.z_end = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_ZEND]);
        node2.layer_number = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_NUMBER]);
        node2.layer_datatype = stoi(line[PEXINFO_INDEX::PEXINFO_INDEX_NODE2_LAYER_DATATYPE]);

        value = stof(line[PEXINFO_INDEX::PEXINFO_INDEX_VALUE]);

        node1_lvl = line[PEXINFO_INDEX_NODE1_LVL];
        node2_lvl = line[PEXINFO_INDEX_NODE2_LVL];

        updateMinMaxCap(value);
        this->capasitors.push_back(PEXCapacitor(item_name, node1, node2, value));
    }
}


inline void PEXCapacitorDataManager::updateMinMaxCap(const double& new_value) {
    if (this->min_capacitor > new_value) this->min_capacitor = new_value;
    if (this->max_capacitor < new_value) this->max_capacitor = new_value;
}


void PEXCapacitorDataManager::printData() {

    std::cout << "\n\nPEX Capacitors\n";
    for (auto item : this->capasitors) {
        item.print();
    }
    printf("##Capacitor Count : %lld, Max cap = %10.5e, Min cap = %10.5e\n",
        this->capasitors.size(), this->getMaxCapacitorValue(), this->getMinCapacitorValue());
}


void testPEXData() {
    PEXResistorDataManager resistor_data;
    resistor_data.loadData("Data/MVP_PEX_RC_r1_0130_0208version.csv");
    resistor_data.printData();

    PEXCapacitorDataManager capacitor_data;
    capacitor_data.loadData("Data/MVP_PEX_RC_r1_0130_0208version.csv");
    capacitor_data.printData();
}
!@hash[]!@file[]./Rendering/Src/PEXResistorModel.cpp!@hash[]!@code[]#include "PEXResistorModel.h"

#include <iostream>
#include <string>
#include <vector>

#include "LayoutPEXData.h"
#include "utils.h"

#include <QFile>
#include <QString>
#include <QDebug>

PEXResistorModel::PEXResistorModel(LveDevice& device, MODEL_TYPE model_type, const QString& data_file)
    : LveModel(device, model_type), pex_data{} {
    this->res_cube_thickness = 0.003;
    this->makeRenderingData(data_file);
    this->createBuffers();
}

PEXResistorModel::~PEXResistorModel() {
    this->pex_data.clear();
}

void PEXResistorModel::makeRenderingData(const QString& file_path) {
    if (!QFile::exists(file_path)) {
        qDebug() << "Error! " << file_path << " is not exist!!\n";
        return;
    }

    loadData(file_path);
    groupResistorOfNode();
    makeCubes();
    makeCubeVertices();
    makeVertices();
    makeIndices();
    makeIndicesForEdge_map();

    printf("\nPEX Resistor\n");
    printf("\tresistor count      : %lld\n", this->pex_data.getResistors().size());
    printf("\tcube_info count     : %lld\n", this->cube_infos.size());
    printf("\tcube_vertices count : %lld\n", this->cube_vertices.size());
    printf("\tVertices count      : %lld\n", this->vertices.size());
    printf("\tIndices count       : %lld\n", this->indices_face.size());

}

void PEXResistorModel::loadData(const QString& file_path) {
    this->pex_data.loadData(file_path);
    //this->pex_data.printData();
}

void PEXResistorModel::groupResistorOfNode() {
    this->pex_data.groupResistorOfNode();
    //this->pex_data.printData();
}

void PEXResistorModel::setDirectionOfResistor(PEXResDirection _direction) {
    this->pex_data.setDriectionOfResistor(_direction);
    //this->pex_data.printData();
}


void PEXResistorModel::increaseNumOfResistorGroup() {
    this->pex_data.increaseNumOfResistorGroup();
    //this->pex_data.printData();
}


void PEXResistorModel::decreaseNumOfResistorGroup() {
    this->pex_data.decreaseNumOfResistorGroup();
    //this->pex_data.printData();
}



void PEXResistorModel::makeCubes() {
    std::vector<PEXResistor>& resistors = this->pex_data.getResistors();
    cube_info cur_cube{};
    for (auto cur_res : resistors) {
        this->makeCube(cur_res, cur_cube, cur_res.getDirection());
        this->cube_infos.push_back(cur_cube);
    }
}

void PEXResistorModel::makeCube(const PEXResistor& res, cube_info& cube, PEXResDirection res_direction) {
    if (res_direction == RES_DIRECTION_VERTICAL) {
        cube.minx = res.node1.x - this->res_cube_thickness;
        cube.maxx = res.node1.x + this->res_cube_thickness;
        cube.miny = res.node1.y - this->res_cube_thickness;
        cube.maxy = res.node1.y + this->res_cube_thickness;
        cube.minz = (res.node1.z_end + res.node1.z_start) / 2;
        cube.maxz = (res.node2.z_end + res.node2.z_start) / 2;
    }
    else if (res_direction == RES_DIRECTION_HORIZONTAL) {
        if (res.node1.x == res.node2.x) {//run-length direction : y
            cube.minx = res.node1.x - this->res_cube_thickness;
            cube.maxx = res.node1.x + this->res_cube_thickness;
            cube.miny = res.node1.y < res.node2.y ? res.node1.y : res.node2.y;
            cube.maxy = res.node1.y < res.node2.y ? res.node2.y : res.node1.y;
        }
        else if (res.node1.y == res.node2.y) {//run-length direction : x
            cube.minx = res.node1.x < res.node2.x ? res.node1.x : res.node2.x;
            cube.maxx = res.node1.x < res.node2.x ? res.node2.x : res.node1.x;
            cube.miny = res.node1.y - this->res_cube_thickness;
            cube.maxy = res.node1.y + this->res_cube_thickness;
        }


        cube.minz = res.node1.z_end;
        cube.maxz = res.node2.z_start;
        /*

                    double midz = (res.node1.z_start + res.node1.z_end) * 0.5;
                    cube.minz = midz - this->res_cube_thickness;
                    cube.maxz = midz + this->res_cube_thickness;
        */
    }
    else {
        std::cerr << "\nResistor has no direction\n";
    }
}


void PEXResistorModel::makeCubeVertices() {
    std::vector<cube_info>::const_iterator it;
    cube_vertex cur_cube_vertices;

    for (it = this->cube_infos.begin(); it != this->cube_infos.end(); ++it) {
        cur_cube_vertices.vertex[0] = { it->minx, it->maxy, it->maxz };
        cur_cube_vertices.vertex[1] = { it->minx, it->miny, it->maxz };
        cur_cube_vertices.vertex[2] = { it->maxx, it->miny, it->maxz };
        cur_cube_vertices.vertex[3] = { it->maxx, it->maxy, it->maxz };

        cur_cube_vertices.vertex[4] = { it->minx, it->maxy, it->minz };
        cur_cube_vertices.vertex[5] = { it->minx, it->miny, it->minz };
        cur_cube_vertices.vertex[6] = { it->maxx, it->miny, it->minz };
        cur_cube_vertices.vertex[7] = { it->maxx, it->maxy, it->minz };

        this->cube_vertices.push_back(cur_cube_vertices);
    }
}

void PEXResistorModel::makeVertices() {
    VertexResistor temp_vertex;

    double max_vertical_res = this->pex_data.getMaxResistorVerticalValue();
    //double min_vertical_res = this->pex_data.getMinResistorVerticalValue();
    double max_horizontal_res = this->pex_data.getMaxResistorHorizontalValue();
    //double min_horizontal_res = this->pex_data.getMinResistorHorizontalValue();
    double max_res = max_vertical_res > max_horizontal_res ? max_vertical_res : max_horizontal_res;

    std::vector<PEXResistor>::iterator cur_resistor = this->pex_data.getResistors().begin();
    double resistor_value{};
    double resistor_percentile{};
    PEXResDirection resistor_direction{};
    float temp_color[3] = { 0.0f, 0.0f, 0.0f };
    glm::vec3 resistor_color;
    for (const auto& cur_cube : this->cube_vertices) {
        resistor_value = cur_resistor->getValue();
        resistor_direction = cur_resistor->getDirection();
        resistor_percentile = percentileOfResistance(*cur_resistor);
        resistor_color = UTILS::getPercentileColour(resistor_percentile / 100, 0.0, 1.0);
        //std::cout << ", " << resistor_value << ", " << resistor_percentile / 100 << "," << resistor_color.r << "," << resistor_color.g << "," << resistor_color.b << "," << std::endl;

        for (int i = 0; i < 8; ++i) {
            temp_vertex.position = {
                cur_cube.vertex[i].x, cur_cube.vertex[i].y, cur_cube.vertex[i].z };
            //if (resistor_direction == PEXResDirection::RES_DIRECTION_VERTICAL) {
            //temp_vertex.color = { resistor_percentile / 100, 0.0f, 1-resistor_percentile/100 };
            temp_vertex.color = { resistor_color,0.2 };
            //	}
                //else {
                    //temp_vertex.color = { 0.0f, 0.0f, static_cast<float>(resistor_value / max_res) };
                //}
            //temp_vertex.color_vert_alpha = { 0.2,1.0,1.0 };
            vertices_resistor.push_back(temp_vertex);
        }//for i 0 to 8
        cur_resistor++;
    }//for auto cur_vertices : this->cubes_vertices
}


void PEXResistorModel::makeIndices() {
    size_t cube_count = this->cube_vertices.size();

    uint32_t start_idx = 0;
    std::vector<uint32_t>& indices = this->indices_face;
    for (int i = 0; i < cube_count; ++i) {
        start_idx = 8 * i;
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);//top

        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);//right

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);//front

        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);//bottom

        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);//left

        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);//back
    }
}

void PEXResistorModel::makeIndicesForEdge_map() {
    size_t cube_count = this->cube_vertices.size();

    std::vector<uint32_t>& indices = this->indices_edge;
    uint32_t start_idx = 0;
    for (int i = 0; i < cube_count; ++i, start_idx += 8) {
        //top
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 0);

        //bottom
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 4);

        //right
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 3);

        //left
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 1);
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 0);

        //front
        indices.push_back(start_idx + 0); indices.push_back(start_idx + 3);
        indices.push_back(start_idx + 3); indices.push_back(start_idx + 7);
        indices.push_back(start_idx + 7); indices.push_back(start_idx + 4);
        indices.push_back(start_idx + 4); indices.push_back(start_idx + 0);

        //back
        indices.push_back(start_idx + 1); indices.push_back(start_idx + 5);
        indices.push_back(start_idx + 5); indices.push_back(start_idx + 6);
        indices.push_back(start_idx + 6); indices.push_back(start_idx + 2);
        indices.push_back(start_idx + 2); indices.push_back(start_idx + 1);
    }
}


double PEXResistorModel::percentileOfResistance(const PEXResistor& in_res) {
    std::vector<PEXResistor>::const_iterator it;
    int count = 0;
    double percent;
    for (it = this->pex_data.getResistors().begin(); it != this->pex_data.getResistors().end(); ++it) {
        if (it->value > in_res.value) {
            count++;
        }
    }
    percent = (count * 100) / this->pex_data.getResistors().size();
    return percent;
};





!@hash[]!@file[]./Rendering/Src/dtaorendersystem.cpp!@hash[]!@code[]

#include <QVulkanWindow>
#include <QVulkanInstance>
#include <vulkan/vulkan.h>

#include <QFileDialog>

#include "dtaorendersystem.h"

#include "lve_model.hpp"
#include "LayoutModel.h"
#include "PEXResistorModel.h"
#include "PEXCapacitorModel.h"

#include "ToyCAD/Src/toycadmodel.h"
#include "ToyCAD/Src/toycaddata.h"


DtaoRenderSystem::DtaoRenderSystem(LveWindow *w)
    : lveWindow(w)
{
    this->trans_info = {};
    this->camera.setViewTarget(
                glm::vec3(0.0f,0.0f,1.0f),
                glm::vec3(0.0f, 0.0f, 0.0f),
                glm::vec3(0.0f, 1.0f, 0.0f));
    qDebug() << "\n$$$$$ DtaoRenderSystem()";
}

DtaoRenderSystem::~DtaoRenderSystem()
{
    deleteSimpleRenderSystem();
    deleteLveDevice();
}

void DtaoRenderSystem::beginRenderPass(VkCommandBuffer command_buffer){
    const QSize sz = this->lveWindow->swapChainImageSize();

    VkClearColorValue clearColor = {{ 0, 0, 0, 1 }};
    VkClearDepthStencilValue clearDS = { 1, 0 };
    VkClearValue clearValues[3];
    memset(clearValues, 0, sizeof(clearValues));
    clearValues[0].color = clearValues[2].color = clearColor;
    clearValues[1].depthStencil = clearDS;

    VkRenderPassBeginInfo rpBeginInfo;
    memset(&rpBeginInfo, 0, sizeof(rpBeginInfo));
    rpBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    rpBeginInfo.renderPass = lveWindow->defaultRenderPass();
    rpBeginInfo.framebuffer = lveWindow->currentFramebuffer();
    rpBeginInfo.renderArea.extent.width = sz.width();
    rpBeginInfo.renderArea.extent.height = sz.height();
    rpBeginInfo.clearValueCount = lveWindow->sampleCountFlagBits() > VK_SAMPLE_COUNT_1_BIT ? 3 : 2;
    rpBeginInfo.pClearValues = clearValues;
    m_devFuncs->vkCmdBeginRenderPass(command_buffer, &rpBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

    VkViewport viewport;
    viewport.x = viewport.y = 0;
    viewport.width = sz.width();
    viewport.height = sz.height();
    viewport.minDepth = 0;
    viewport.maxDepth = 1;
    m_devFuncs->vkCmdSetViewport(command_buffer, 0, 1, &viewport);

    VkRect2D scissor;
    scissor.offset.x = scissor.offset.y = 0;
    scissor.extent.width = viewport.width;
    scissor.extent.height = viewport.height;
    m_devFuncs->vkCmdSetScissor(command_buffer, 0, 1, &scissor);
}

void DtaoRenderSystem::translateLayerPosition(POS_MONITORING value){
    for (auto& gameobject : this->gameObjects) {
        if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
            gameobject.transform.translation = {-value.x*trans_info.scale, -value.y*trans_info.scale, 0};

        }
    }
    camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(value.zoom/cameraController.monitor.zoom,
                                                               value.zoom/cameraController.monitor.zoom,
                                                               value.zoom/cameraController.monitor.zoom));
    glm::vec3 right {camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0]};
    camera.viewMatrix = glm::rotate(camera.getView(), (float)glm::radians(value.tilt-cameraController.monitor.tilt), right);
    camera.viewMatrix = glm::rotate(camera.getView(), (float)glm::radians(value.rotation-cameraController.monitor.rotation), glm::vec3(0.0f, 0.0f, 1.0f));
}

void DtaoRenderSystem::emitMonitor(){


    glm::vec3 forward {camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2]};
    double tilt = asin(forward.z/(sqrt(forward.x*forward.x +forward.y*forward.y+forward.z*forward.z)))*(180/3.141592653589793238463);
    camera.decomposeView(camera.getView());
    camera.rotation_d = glm::conjugate(camera.rotation_d);
    // yaw / z
    double siny_cosp = 2 * (camera.rotation_d.w * camera.rotation_d.z + camera.rotation_d.x * camera.rotation_d.y);
    double cosy_cosp = 1 - 2 * (camera.rotation_d.y * camera.rotation_d.y + camera.rotation_d.z * camera.rotation_d.z);
    double rotation = (double)atan2(siny_cosp, cosy_cosp)*(180/3.141592653589793238463);
    cameraController.monitor.tilt = tilt;
    cameraController.monitor.rotation = rotation;

    if(!gameObjects.empty()){
        cameraController.monitor.x = -(gameObjects[0].transform.translation.x) / trans_info.scale;
        cameraController.monitor.y = -(gameObjects[0].transform.translation.y)/ trans_info.scale;
        cameraController.monitor.z = -gameObjects[0].transform.translation.z/ trans_info.scale;
        cameraController.monitor.zoom = camera.scale_d.x*this->trans_info.scale*camera.std_scale/(2*tan(glm::radians(25.f)));
    }
    if(!toycad_objects.empty()){
        cameraController.monitor.zoom = camera.scale_d.x*this->trans_info.scale*camera.std_scale/(2*tan(glm::radians(25.f)));
    }

    if(this->render_mode != DTAO_RENDER_MODE_TOYCAD){
        QString funcName = "camera_position";
        emit lveWindow->signalInfoText(funcName,cameraController.monitor);
    }
}

void DtaoRenderSystem::startNextFrame(){

    this->cameraController.moveCamera(
                aspect, this->camera, this->getRenderScale(),
                this->gameObjects, lveWindow,
                &this->toycad_objects);
    this->cameraController.moveCameraMouse(
                this->camera, this->getRenderScale(),
                this->gameObjects, lveWindow,
                &this->toycad_objects);

    this->cameraController.onDemo(
                aspect, this->camera, this->getRenderScale(), this->gameObjects, lveWindow);


    this->emitMonitor();


    VkCommandBuffer command_buffer = this->lveWindow->currentCommandBuffer();
    beginRenderPass(command_buffer);

    if(this->render_mode == DTAO_RENDER_MODE_TOYCAD){
        this->simpleRenderSystem->renderToyCADObjects(
                    command_buffer, this->toycad_objects, this->camera);
    }
    else{
        this->simpleRenderSystem->renderGameObjects(
                    command_buffer, this->gameObjects, this->camera);
    }

    m_devFuncs->vkCmdEndRenderPass(command_buffer);

    lveWindow->frameReady();
    lveWindow->requestUpdate(); // render continuously, throttled by the presentation rate
}

void DtaoRenderSystem::initResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::initResources()";
    createLveDevice();
    createSimpleRenderSystem();
    //if(!this->render_object_created) loadGameObjects();



    VkDevice dev = this->lveWindow->device();
    m_devFuncs = this->lveWindow->vulkanInstance()->deviceFunctions(dev);

    qDebug() << "\tDevice = " << this->lveDevice->device();

    //this->createToyCADObjects("ToyCAD/Data/toy_cad_test_data.csv");

}

void DtaoRenderSystem::releaseResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::releaseResources()";

    deleteSimpleRenderSystem();
    deleteLveDevice();
}

void DtaoRenderSystem::initSwapChainResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::initSwapChainResources()";
    const QSize sz = this->lveWindow->swapChainImageSize();
    aspect = sz.width()/(double)sz.height();
    this->camera.setPerspectiveProjection(glm::radians(50.f), aspect, 0.1f, 100.f);
    //this->camera.setOrthographicProjection(-1,1,-1,1,0.1f,100.f);
}


void DtaoRenderSystem::releaseSwapChainResources() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::releaseSwapChainResources()";
}

void DtaoRenderSystem::createLveDevice(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::createLveDevice()";
    this->lveDevice = new LveDevice(this->lveWindow, this->lveWindow->vulkanInstance());
}

void DtaoRenderSystem::deleteLveDevice(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::deleteLveDevice()";
    delete this->lveDevice;
}

void DtaoRenderSystem::createSimpleRenderSystem(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::createSimpleRenderSystem()";
    VkRenderPass renderpass = this->lveWindow->defaultRenderPass();
    this->simpleRenderSystem = new SimpleRenderSystem(*this->lveDevice, renderpass);
}

void DtaoRenderSystem::deleteSimpleRenderSystem(){
    qDebug() << "\n$$$$$ DtaoRenderSystem::deleteSimpleRenderSystem()";
    delete this->simpleRenderSystem;
}
/*
void DtaoRenderSystem::createNewObject(MODEL_TYPE model_type, const std::string & file_path) {
    if( model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) createNewLayoutObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) createNewPEXCapObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) createNewPEXResObject(file_path);
    else if( model_type == MODEL_TYPE::MODEL_TYPE_AXIS) createNewAxisObject(file_path);
}*/

void DtaoRenderSystem::createT2DObject(MODEL_TYPE model_type, T2D t2d) {
    if( model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) createT2DLayoutObject(t2d);
    //else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) createNewPEXCapObject(file_path);
    //else if( model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) createNewPEXResObject(file_path);
    //else if( model_type == MODEL_TYPE::MODEL_TYPE_AXIS) createNewAxisObject(file_path);
}

void DtaoRenderSystem::getCustomColor(string layernumber, glm::vec3 rgb){
    if(!gameObjects.empty()){
        for (auto& obj : gameObjects){
          if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT){
              obj.model->changeLayerColor(layernumber,rgb);
          }
        }

    } else {
        qDebug() << "there is no layer. get layer first!";
    }

}

void DtaoRenderSystem::getCustomOpacity(string layernumber, float opacity){
    if(!gameObjects.empty()){
        for (auto& obj : gameObjects){
          if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT){
              obj.model->changeLayerOpacity(layernumber,opacity);
          }
        }

    } else {
        qDebug() << "there is no layer. get layer first!";
    }
}

void DtaoRenderSystem::getCustomVisiblity(string layernumber, bool visibility){
    if(!gameObjects.empty()){
        for (auto& obj : gameObjects){
          if(obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT){
              obj.model->changeLayerVisiblity(layernumber,visibility);
          }
        }

    } else {
        qDebug() << "there is no layer. get layer first!";
    }
}

void DtaoRenderSystem::createT2DLayoutObject(T2D & t2d){

    //Layout model
    //std::string layout_info_file_path = file_path;
    std::shared_ptr<LayoutModel> model
            = std::make_unique<LayoutModel>(
                *this->lveDevice, MODEL_TYPE_LAYOUT, t2d);
    model->opacity = 0.5f;

    LayoutDataManager* layout_data = model->getLayoutDataManager();
    //this->trans_info.minx = static_cast<float>( layout_data->getMinX());
    //this->trans_info.miny = static_cast<float>( layout_data->getMinY());
    this->trans_info.trans_x = static_cast<float>( layout_data->getMinX()
                                                   + layout_data->getDiffX()/2
                                                   );
    this->trans_info.trans_y = static_cast<float>( layout_data->getMinY()
                                                   + layout_data->getDiffY()/2
                                                   );
    this->trans_info.trans_z = static_cast<float>( layout_data->getMinZ());
    this->trans_info.scale =  static_cast<float>( layout_data->getScale());

    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x*trans_info.scale, -this->trans_info.trans_y*trans_info.scale, -this->trans_info.trans_z*trans_info.scale};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale
    };
    //qDebug()<<layout_data->getDiffY()/2;

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
    this->render_object_created = true;
    this->layout_model = model;
    this->render_mode = DTAO_RENDER_MODE_LAYOUT;
}

/*
void DtaoRenderSystem::createNewLayoutObject(const std::string & file_path){

    //Layout model
    std::string layout_info_file_path = file_path;
    std::shared_ptr<LayoutModel> model
            = std::make_unique<LayoutModel>(
                *this->lveDevice, MODEL_TYPE_LAYOUT, layout_info_file_path);
    model->opacity = 0.5f;

    LayoutDataManager* layout_data = model->getLayoutDataManager();
    this->trans_info.trans_x = static_cast<float>( layout_data->getMinX());
    this->trans_info.trans_y = static_cast<float>( layout_data->getMinY());
    this->trans_info.trans_z = static_cast<float>( layout_data->getMinZ());
    this->trans_info.scale = static_cast<float>( layout_data->getScale());

    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x, -this->trans_info.trans_y, -this->trans_info.trans_z};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
    this->render_object_created = true;
    this->layout_model = model;
}
*/

void DtaoRenderSystem::createNewPEXResObject( const QString & file_path){
    //PEX Resistor model
    QString res_info_file_path = file_path;
    std::shared_ptr<PEXResistorModel> model
            = std::make_unique<PEXResistorModel>(
                *this->lveDevice, MODEL_TYPE_PEX_RESISTOR, res_info_file_path);

    //Resistor Object
    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x*trans_info.scale, -this->trans_info.trans_y*trans_info.scale, -this->trans_info.trans_z*trans_info.scale};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
    this->res_model = model;
    this->render_mode = DTAO_RENDER_MODE_PEX_ALL;
}

void DtaoRenderSystem::createNewPEXCapObject( const QString & file_path,T2D  t2d){
    //PEX Capacitor model
    QString cap_info_file_path = file_path;
    std::shared_ptr<PEXCapacitorModel> model
            = std::make_unique<PEXCapacitorModel>(
                *this->lveDevice, MODEL_TYPE_PEX_CAPACITOR,
                cap_info_file_path, &t2d);

    //Capacitor Object
    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {
        -this->trans_info.trans_x*trans_info.scale, -this->trans_info.trans_y*trans_info.scale, -this->trans_info.trans_z*trans_info.scale};
    new_object.transform.scale = {
        this->trans_info.scale, this->trans_info.scale, this->trans_info.scale };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
    this->render_mode = DTAO_RENDER_MODE_PEX_ALL;
}


void DtaoRenderSystem::createToyCADObjects(const std::string& file_path){

    if(!this->toycad_objects.empty()) this->toycad_objects.clear();

    ToyCADData toycad_data_loader;
    toycad_data_loader.loadToyCADData(file_path);
    std::vector<TOYCAD_DATA>* toycad_data = toycad_data_loader.getCADData();
    TOYCAD_BBOX& toycad_data_bbox = toycad_data_loader.getDataBBox();

    this->trans_info.trans_x = static_cast<float>(toycad_data_bbox.min_x);
    this->trans_info.trans_y = static_cast<float>(toycad_data_bbox.min_y);
    this->trans_info.trans_z = static_cast<float>(toycad_data_bbox.min_z);
    this->trans_info.scale =  static_cast<float>(toycad_data_loader.getScale());

    for(auto & cur_data : *toycad_data){
        std::shared_ptr<ToyCADModel> model
                = std::make_unique<ToyCADModel>(*this->lveDevice, cur_data);

        auto new_object = ToyCADObject::createToyCADObject();
        new_object.model = model;
        new_object.color = glm::vec3{
                cur_data.color_r/255.0f,
                cur_data.color_g/255.0f,
                cur_data.color_b/255.0f};
        new_object.opacity = cur_data.color_a/255.0f;
        new_object.transform.rotation = glm::vec3{
                cur_data.rotation_degree,
                cur_data.rotation_degree,
                cur_data.rotation_degree};
        new_object.visibility = true;
        new_object.transform.translation = glm::vec3{
            (-this->trans_info.trans_x+cur_data.minx)*this->trans_info.scale,
            (-this->trans_info.trans_y+cur_data.miny)*this->trans_info.scale,
            (-this->trans_info.trans_z+cur_data.minz)*this->trans_info.scale};
        new_object.transform.scale = glm::vec3{
                this->trans_info.scale,
                this->trans_info.scale,
                this->trans_info.scale};
        //new_object.scale = 1.0f;

        this->toycad_objects.push_back(std::move(new_object));
    }//for(auto & cur_data : toycad_datas){

    this->render_object_created = true;
    this->render_mode = DTAO_RENDER_MODE_TOYCAD;

    qDebug() << "Objcect Count : " << this->toycad_objects.size();
}


/*
void DtaoRenderSystem::createNewAxisObject(const std::string & file_path){
    (void)(file_path);
    //Axis model
    std::shared_ptr<LveModel> model
            = std::make_unique<LveModel>(*this->lveDevice, MODEL_TYPE_AXIS);

    //auto new_object = DTAOObject::createObject();
    auto new_object = LveGameObject::createGameObject();
    new_object.model = model;
    new_object.transform.translation = {0.0f, 0.0f, 0.0f};
    new_object.transform.scale = { 1.0f, 1.0f, 1.0f };

    //this->dtao_objects.push_back(std::move(new_object));
    this->gameObjects.push_back(std::move(new_object));
}
*/

/*
void DtaoRenderSystem::loadGameObjects() {
    qDebug() << "\n$$$$$ DtaoRenderSystem::loadGameObjects()";
    return;

    auto cube = LveGameObject::createGameObject();

    //Layout model
    std::string layout_info_file_path = "Rendering/Data/layout_input_data.csv";
    //std::string layout_info_file_path = "Rendering/Data/big_test_espin.csv";
    std::shared_ptr<LayoutModel> layout_model
            = std::make_unique<LayoutModel>(*this->lveDevice, MODEL_TYPE_LAYOUT, layout_info_file_path);
    layout_model->opacity = 0.5f;

    LayoutDataManager* layout_data = layout_model->getLayoutDataManager();
    float trans_x = static_cast<float>(layout_data->getMinX());
    float trans_y = static_cast<float>(layout_data->getMinY());
    float trans_z = static_cast<float>(layout_data->getMinZ());
    float scale = static_cast<float>(layout_data->getScale());

    this->render_scale = scale;

    //Axis model
    std::shared_ptr<LveModel> axis_model
            = std::make_unique<LveModel>(*this->lveDevice, MODEL_TYPE_AXIS);

    //PEX Resistor model
    std::string res_info_file_path = "Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv";
    std::shared_ptr<PEXResistorModel> res_model
            = std::make_unique<PEXResistorModel>(*this->lveDevice, MODEL_TYPE_PEX_RESISTOR, res_info_file_path);

    //PEX Capacitor model
    std::string cap_info_file_path = "Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv";
    std::shared_ptr<PEXCapacitorModel> cap_model
            = std::make_unique<PEXCapacitorModel>(*this->lveDevice, MODEL_TYPE_PEX_CAPACITOR, cap_info_file_path, layout_model->getLayoutDataManager());


    //Resistor Object
    cube = LveGameObject::createGameObject();
    cube.model = res_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Capacitor Object
    cube = LveGameObject::createGameObject();
    cube.model = cap_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Layout Object
    cube = LveGameObject::createGameObject();
    cube.model = layout_model;
    cube.transform.translation = { -trans_x, -trans_y, -trans_z };
    cube.transform.scale = { scale, scale, scale };
    gameObjects.push_back(std::move(cube));

    //Axis Object
    cube = LveGameObject::createGameObject();
    cube.model = axis_model;
    cube.transform.translation = { 0.0f, 0.0f, 0.0f };
    cube.transform.scale = { 1.0f, 1.0f, 1.0f };
    gameObjects.push_back(std::move(cube));

    this->render_object_created = true;
}
*/
!@hash[]!@file[]./Rendering/Src/keyboard_movement_controller.cpp!@hash[]!@code[]#include "keyboard_movement_controller.hpp"
#include "lve_window.hpp"

#define GLM_ENABLE_EXPERIMENTAL

// std
#include <limits>
#include <iostream>

#include <glm/gtx/string_cast.hpp>
#include "lve_model.hpp"

void KeyboardMovementController::visibleSetting(std::vector<LveGameObject>& gameObjects, Qt::Key key) {
    MODEL_TYPE target_model_type = MODEL_TYPE::MODEL_TYPE_DEFAULT;
    bool opacity_mode = false;
    double opacity = 0.0;
    if (key == model_visible_set.resistor_key) {
        target_model_type = MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR;
    }

    else if (key == model_visible_set.capacitor_key) {
        target_model_type = MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR;
    }

    for (auto& obj : gameObjects) {
        if (obj.model->getModelType() == target_model_type) {
            obj.model->toggleVisible();
        }
    }

}

void KeyboardMovementController::setAllMoveFlagOff() {
    camera_moving_flag.rotateLeft = false;
    camera_moving_flag.rotateRight = false;
    camera_moving_flag.moveForward = false;
    camera_moving_flag.moveBackward = false;
    camera_moving_flag.rotateForward = false;
    camera_moving_flag.rotateBackward = false;
}

void KeyboardMovementController::setMouseFlagOff() {
    camera_moving_flag.mouseLeft = false;
    camera_moving_flag.mouseRight = false;
    camera_moving_flag.mouseMiddle = false;
}

void KeyboardMovementController::moveKeyPressed(Qt::Key key) {
    //setAllMoveFlagOff();
    if (key == camera_move_key.moveForward) camera_moving_flag.moveForward = true;
    if (key == camera_move_key.moveBackward) camera_moving_flag.moveBackward = true;
    if (key == camera_move_key.rotateRight) camera_moving_flag.rotateRight = true;
    if (key == camera_move_key.rotateLeft) camera_moving_flag.rotateLeft = true;
    if (key == camera_move_key.rotateForward) camera_moving_flag.rotateForward = true;
    if (key == camera_move_key.rotateBackward) camera_moving_flag.rotateBackward = true;
    if (key == camera_move_key.moveUp) camera_moving_flag.moveUp = true;
    if (key == camera_move_key.moveDown) camera_moving_flag.moveDown = true;
    if (key == camera_move_key.moveLeft) camera_moving_flag.moveLeft = true;
    if (key == camera_move_key.moveRight) camera_moving_flag.moveRight = true;
    if (key == camera_move_key.toggleDemension) {
        camera_moving_flag.toggleDemension = true;
        camera_moving_flag.toggleDemensionXY = true;
    }


}

void KeyboardMovementController::moveKeyReleased(Qt::Key key) {
    //setAllMoveFlagOff();
    if (key == camera_move_key.moveForward) camera_moving_flag.moveForward = false;
    if (key == camera_move_key.moveBackward) camera_moving_flag.moveBackward = false;
    if (key == camera_move_key.rotateRight) camera_moving_flag.rotateRight = false;
    if (key == camera_move_key.rotateLeft) camera_moving_flag.rotateLeft = false;
    if (key == camera_move_key.rotateForward) camera_moving_flag.rotateForward = false;
    if (key == camera_move_key.rotateBackward) camera_moving_flag.rotateBackward = false;
    if (key == camera_move_key.moveUp) camera_moving_flag.moveUp = false;
    if (key == camera_move_key.moveDown) camera_moving_flag.moveDown = false;
    if (key == camera_move_key.moveLeft) camera_moving_flag.moveLeft = false;
    if (key == camera_move_key.moveRight) camera_moving_flag.moveRight = false;

}

void KeyboardMovementController::setMousePosition(QPoint position, int mode) {
    mouse_position.currentPosition = position;
    if (mode == 1) {
        mouse_position.pressPosition = position;
        mouse_position.currentPosition = position;
        xpos_prev = position.x();
        ypos_prev = position.y();
        //translationOnPressed =

    }
    if (mode == 2) {
        mouse_position.releasePosition = position;
        mouse_position.currentPosition = position;
    }

    //qDebug()<< position.y();
}

void KeyboardMovementController::setMouseScroll(QPoint scroll) {
    if (camera_moving_flag.mouseMiddle) {
        mouse_position.scrollClicked = scroll;
    }
    else {
        mouse_position.scroll = scroll;
    }
}

void KeyboardMovementController::moveButtonPressed(Qt::MouseButtons buttons) {
    setMouseFlagOff();
    if (buttons == camera_move_key.mouseLeft) camera_moving_flag.mouseLeft = true;
    if (buttons == camera_move_key.mouseRight) camera_moving_flag.mouseRight = true;
    if (buttons == camera_move_key.mouseMiddle) camera_moving_flag.mouseMiddle = true;


}

void KeyboardMovementController::moveButtonReleased(Qt::MouseButtons buttons) {
    setMouseFlagOff();
    if (buttons == camera_move_key.mouseLeft) camera_moving_flag.mouseLeft = true;
    if (buttons == camera_move_key.mouseRight) camera_moving_flag.mouseRight = true;
    if (buttons == camera_move_key.mouseMiddle) camera_moving_flag.mouseMiddle = true;
}

void KeyboardMovementController::moveCamera(
        float dt, LveCamera& camera, float render_scale,
        std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow,
        std::vector<ToyCADObject>* toycad_objects) {
    float scale = 0.0f;
    float rotate_lr = 0.0f;
    float rotate_ud = 0.0f;
    float rotate_toggle = 0.0f;
    float rotate_toggle_xy = 0.0f;
    float obj_scale = 2*render_scale;

    if (camera_moving_flag.moveForward) scale = 1.0f + 0.01f * obj_scale;
    else if (camera_moving_flag.moveBackward) scale = 1.0f - 0.01f * obj_scale;

    if (camera_moving_flag.rotateRight) rotate_lr = -0.1f * obj_scale;
    else if (camera_moving_flag.rotateLeft) rotate_lr = 0.1f * obj_scale;

    if (camera_moving_flag.rotateForward) rotate_ud = -0.1f * obj_scale;
    else if (camera_moving_flag.rotateBackward) rotate_ud = 0.1f * obj_scale;

    if (camera_moving_flag.toggleDemension && !camera.isperspective) {
        camera.setPerspectiveProjection(glm::radians(50.f), dt, 0.1f, 100.f);
        camera_moving_flag.toggleDemension = false;
    }
    else if (camera_moving_flag.toggleDemension)rotate_toggle = 0.1f;

    if (camera_moving_flag.toggleDemensionXY) rotate_toggle_xy = -0.1f;


    glm::vec3 right= glm::normalize(glm::vec3{camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0]});
    glm::vec3 up= glm::normalize(glm::vec3{camera.viewMatrix[0][1], camera.viewMatrix[1][1], camera.viewMatrix[2][1]});
    glm::vec3 forward= glm::normalize(glm::vec3{camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2]});

    glm::vec3 v{ glm::normalize(glm::cross(right,glm::vec3{0,0,1})) };

    if (glm::dot(rotate_toggle, rotate_toggle) > std::numeric_limits<float>::epsilon()) {

        camera.decomposeView(camera.getView());
        camera.rotation_d = glm::conjugate(camera.rotation_d);

        // yaw / z
        double siny_cosp = 2 * (camera.rotation_d.w * camera.rotation_d.z + camera.rotation_d.x * camera.rotation_d.y);
        double cosy_cosp = 1 - 2 * (camera.rotation_d.y * camera.rotation_d.y + camera.rotation_d.z * camera.rotation_d.z);
        float rotation = (float)atan2(siny_cosp, cosy_cosp);
        float degree = rotation * (180 / 3.141592653589793238463);
        float tilt = asin(forward.z / (sqrt(forward.x * forward.x + forward.y * forward.y + forward.z * forward.z)));
        tilt = tilt * (180 / 3.141592653589793238463);

        if (!camera_moving_flag.toggleDemensionXY && camera_moving_flag.toggleDemension) {
            if (tilt > 89.5) {
                camera.decomposeView(camera.getView());
                camera.setViewTarget(glm::vec3(0.0f, 0.0f, 1.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));
                camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(camera.scale_d.x, camera.scale_d.x, camera.scale_d.x));
                camera_moving_flag.toggleDemension = false;
                float zero_plane_height = tan(glm::radians(25.f));
                camera.setOrthographicProjection(-1 * dt * zero_plane_height, 1 * dt * zero_plane_height, -1 * zero_plane_height, 1 * zero_plane_height, 0.1f, 100.f);
            }
            else {
                rotate_toggle = rotate_toggle * ((90 - tilt) / 2 + 1);
                camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle), right);
            }
        }


        if (camera_moving_flag.toggleDemensionXY) {
            if (up.z < 0) {
                if (180 - abs(degree) < 1) {
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(degree - 90), glm::vec3(0.0f, 0.0f, 1.0f));
                    camera_moving_flag.toggleDemensionXY = false;
                }
                else {
                    rotate_toggle_xy = rotate_toggle_xy * ((180 - abs(degree)) / 2 + 1) * (180 - abs(degree)) / (180 - abs(degree));
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle_xy), glm::vec3(0.0f, 0.0f, 1.0f));
                }
            }
            else {
                if (abs(degree) < 1) {
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(0 - abs(degree)), glm::vec3(0.0f, 0.0f, 1.0f));
                    camera_moving_flag.toggleDemensionXY = false;
                }
                else {
                    rotate_toggle_xy = rotate_toggle_xy * (abs(degree) / 2 + 1) * abs(degree) / abs(degree);
                    camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle_xy), glm::vec3(0.0f, 0.0f, 1.0f));
                }
            }
        }

    }

    if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr), glm::vec3(0.0f, 0.0f, 1.0f));
    }

    if (glm::dot(rotate_ud, rotate_ud) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_ud), right);
    }

    if (glm::dot(scale, scale) > std::numeric_limits<float>::epsilon()) {
        camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(scale, scale, scale));
    }

    glm::vec3 moveDir{ 0.f };
    camera.decomposeView(camera.getView());

    if (camera_moving_flag.moveRight) moveDir += right;
    if (camera_moving_flag.moveLeft)  moveDir -= right;
    if (camera_moving_flag.moveUp)  moveDir -= v;
    if (camera_moving_flag.moveDown)  moveDir += v;



    if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon()) {
        for (auto& gameobject : gameObjects) {
            if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
                gameobject.transform.translation += moveDir/(float)this->monitor.zoom/(float)lvewindow->swapChainImageSize().height()*obj_scale;
            }
        }

        if( toycad_objects != nullptr){
            vector<ToyCADObject>::iterator it = toycad_objects->begin();
            for(;it != toycad_objects->end(); ++it){
                    it->transform.translation +=
                            (moveDir*obj_scale)
                            /((float)this->monitor.zoom*(float)lvewindow->swapChainImageSize().height());
            }
        }
    }

}

void KeyboardMovementController::moveCameraMouse(
        LveCamera& camera, float render_scale,
        std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow,
        std::vector<ToyCADObject>* toycad_objects) {
    if (camera_moving_flag.mouseRight)
    {

        float rotate_lr = 0.0f;
        float rotate_ud = 0.0f;

        rotate_lr = mouse_position.currentPosition.x() - xpos_prev;
        rotate_ud = mouse_position.currentPosition.y() - ypos_prev;

        //glm::vec3 direction{ camera.viewMatrix[0][2], camera.viewMatrix[1][2], 0 };
        glm::vec3 right{ camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0] };
        glm::vec3 up{ camera.viewMatrix[0][1], camera.viewMatrix[1][1], camera.viewMatrix[2][1] };
        glm::vec3 forward{ camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2] };


        if (glm::dot(rotate_ud, rotate_ud) > std::numeric_limits<float>::epsilon()) {
            if (glm::rotate(camera.getView(), glm::radians(rotate_ud * 0.5f), right)[2][1] >= 0) {
                camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_ud * 0.5f), right);
            }
        }

        if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
            camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr * 0.5f), glm::vec3(0.0f, 0.0f, 1.0f));
        }

        xpos_prev = mouse_position.currentPosition.x();
        ypos_prev = mouse_position.currentPosition.y();
    }
    else if (camera_moving_flag.mouseLeft)
    {
        float obj_scale = render_scale;
        glm::vec3 moveDir{ 0.f };
        float movement_lr = mouse_position.currentPosition.x() - xpos_prev;
        float movement_ud = mouse_position.currentPosition.y() - ypos_prev;

        glm::vec3 right = glm::normalize(glm::vec3{camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0]});
        glm::vec3 forward{ glm::normalize(glm::cross(right,glm::vec3{0,0,1})) };

        moveDir += right * (movement_lr);
        moveDir += forward * (movement_ud);

        if (glm::dot(moveDir, moveDir) > std::numeric_limits<float>::epsilon()) {
            for (auto& gameobject : gameObjects) {
                if (gameobject.model->getModelType() != MODEL_TYPE::MODEL_TYPE_AXIS) {
                    gameobject.transform.translation +=  moveDir/(float)this->monitor.zoom/(float)lvewindow->swapChainImageSize().height()*obj_scale ;
                    //camera.viewMatrix = glm::translate(camera.getView(), moveSpeed * dt * moveDir);
                }
            }

            if( toycad_objects != nullptr){
                vector<ToyCADObject>::iterator it = toycad_objects->begin();
                for(;it != toycad_objects->end(); ++it){
                        it->transform.translation +=
                                (moveDir*obj_scale)
                                /((float)this->monitor.zoom*(float)lvewindow->swapChainImageSize().height());

                }
            }//if( toycad_objects != nullptr)

        }

        xpos_prev = mouse_position.currentPosition.x();
        ypos_prev = mouse_position.currentPosition.y();
    }

    if (mouse_position.scroll.y() != 0) {
        float scale_mouse = 1.0f + 0.1f * (mouse_position.scroll.y() / 120);
        camera.viewMatrix = glm::scale(camera.getView(), glm::vec3(scale_mouse, scale_mouse, scale_mouse));
        mouse_position.scroll.setY(0);
    }

}

void KeyboardMovementController::setPerspective(LveCamera& camera, float aspect) {
    if (mouse_position.scrollClicked.y() > 0) {
        if (perspectiveNear + 0.01 > 100.f) {
            perspectiveNear = 100.f;

        }
        else {
            perspectiveNear = perspectiveNear + 0.01;
        }
    }
    else if (mouse_position.scrollClicked.y() < 0) {
        if (perspectiveNear - 0.01 < 0.1f) {
            perspectiveNear = 0.1f;

        }
        else { perspectiveNear = perspectiveNear - 0.01; }
    }
    camera.setPerspectiveProjection(glm::radians(50.f), aspect, perspectiveNear, 100.f);
    mouse_position.scrollClicked.setY(0);
}

void KeyboardMovementController::PEXSetting(std::shared_ptr<PEXResistorModel>& _pexResistorModel, Qt::Key key) {
    if (key == model_visible_set.resistor_up_key) {
        std::cout << "gogogogogogogog" << std::endl;
        _pexResistorModel->increaseNumOfResistorGroup();
        std::cout << "donenenenenenenen" << std::endl;
        _pexResistorModel->destroyBuffers();
        std::cout << "buffer" << std::endl;
        _pexResistorModel->makeCubes();
        std::cout << "cube" << std::endl;
        _pexResistorModel->makeCubeVertices();
        std::cout << "cubeddddddd" << std::endl;
        _pexResistorModel->makeVertices();
        std::cout << "vertice" << std::endl;
        _pexResistorModel->makeIndices();
        _pexResistorModel->makeIndicesForEdge_map();
        _pexResistorModel->createBuffers();
        model_visible_set.resistor_up_key_pressed = false;
    }
    else if (key == model_visible_set.resistor_down_key) {
        std::cout << "gogogogogogogog" << std::endl;
        _pexResistorModel->decreaseNumOfResistorGroup();
        _pexResistorModel->destroyBuffers();
        _pexResistorModel->makeCubes();
        _pexResistorModel->makeCubeVertices();
        _pexResistorModel->makeVertices();
        _pexResistorModel->makeIndices();
        _pexResistorModel->makeIndicesForEdge_map();
        _pexResistorModel->createBuffers();
        model_visible_set.resistor_down_key_pressed = false;
    }
    else if (key == model_visible_set.resistor_horizontal_key) {
        _pexResistorModel->setDirectionOfResistor(RES_DIRECTION_HORIZONTAL);
        _pexResistorModel->destroyBuffers();
        _pexResistorModel->makeCubes();
        _pexResistorModel->makeCubeVertices();
        _pexResistorModel->makeVertices();
        _pexResistorModel->makeIndices();
        _pexResistorModel->makeIndicesForEdge_map();
        _pexResistorModel->createBuffers();
        model_visible_set.resistor_horizontal_key_pressed = false;
    }
    else if (key == model_visible_set.resistor_vertical_key) {
        _pexResistorModel->setDirectionOfResistor(RES_DIRECTION_VERTICAL);
        _pexResistorModel->destroyBuffers();
        _pexResistorModel->makeCubes();
        _pexResistorModel->makeCubeVertices();
        _pexResistorModel->makeVertices();
        _pexResistorModel->makeIndices();
        _pexResistorModel->makeIndicesForEdge_map();
        _pexResistorModel->createBuffers();
        model_visible_set.resistor_vertical_key_pressed = false;
    }
}

//void KeyboardMovementController::translateLayerPosition(std::vector<LveGameObject>& gameObjects){
//
//}

void KeyboardMovementController::triggerDemo() {
    camera_moving_flag.demoTrigger = true;
};

void KeyboardMovementController::onDemo(float dt, LveCamera& camera, float render_scale, std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow) {
    if (camera_moving_flag.demoTrigger) {
        float scale = 0.0f;
        float rotate_lr = 0.0f;
        float rotate_ud = 0.0f;
        float rotate_toggle = 0.0f;
        float rotate_toggle_xy = 0.0f;
        float obj_scale = 2.0f / render_scale;
        demoTime = demoTime + 1;

        //if (camera_moving_flag.moveForward) scale = 1.0f + 0.01f * obj_scale;
        //else if (camera_moving_flag.moveBackward) scale = 1.0f - 0.01f * obj_scale;
        if (!camera_moving_flag.demoInitLayer) {
            gameObjects[0].model->demoVisiblityOff();
            camera_moving_flag.demoInitLayer = true;
        }

        rotate_lr = 1.6f * obj_scale;

        glm::vec3 forward = { camera.viewMatrix[0][2], camera.viewMatrix[1][2], camera.viewMatrix[2][2] };
        float tilt = asin(forward.z / (sqrt(forward.x * forward.x + forward.y * forward.y + forward.z * forward.z))) * (180 / 3.141592653589793238463);
        camera.decomposeView(camera.getView());
        camera.rotation_d = glm::conjugate(camera.rotation_d);
        // yaw / z
        double siny_cosp = 2 * (camera.rotation_d.w * camera.rotation_d.z + camera.rotation_d.x * camera.rotation_d.y);
        double cosy_cosp = 1 - 2 * (camera.rotation_d.y * camera.rotation_d.y + camera.rotation_d.z * camera.rotation_d.z);
        float rotation = (float)atan2(siny_cosp, cosy_cosp) * (180 / 3.141592653589793238463);

        if (rotation < 0) {
            rotation = rotation + 360;
        }

        if (rotation > 350 && !camera_moving_flag.layerOn) {
            camera_moving_flag.tiltOn = true;

        }

        if (camera_moving_flag.tiltOn) {
            rotate_toggle = -0.1f;
            glm::vec3 right{ camera.viewMatrix[0][0], camera.viewMatrix[1][0], camera.viewMatrix[2][0] };
            camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_toggle), right);
            if (tilt < 30) {
                camera_moving_flag.tiltOn = false;
                camera_moving_flag.layerOn = true;
            }
        }

        if (camera_moving_flag.layerOn && !camera_moving_flag.wave1) {
            demoCheckPoint = demoTime;
            std::vector<string> on_layer = { "2","7","15" };
            gameObjects[0].model->demoVisiblityOn(on_layer);
            camera_moving_flag.wave1 = true;
        }

        if (demoCheckPoint < demoTime - 50 && !camera_moving_flag.wave2 && camera_moving_flag.wave1) {
            demoCheckPoint = demoTime;
            std::vector<string> on_layer = { "177","16","17" };
            gameObjects[0].model->demoVisiblityOn(on_layer);
            camera_moving_flag.wave2 = true;
        }

        if (demoCheckPoint < demoTime - 50 && !camera_moving_flag.wave3 && camera_moving_flag.wave2) {
            demoCheckPoint = demoTime;
            std::vector<string> on_layer = { "714","19","18","17","16","15","686","685","245","72914","502","247" };
            gameObjects[0].model->demoVisiblityOn(on_layer);
            camera_moving_flag.wave3 = true;
        }

        if (demoCheckPoint < demoTime - 5000 && camera_moving_flag.wave2) {
            camera_moving_flag.demoTrigger = false;
            camera_moving_flag.demoInitLayer = false;
            camera_moving_flag.tiltOn = false;
            camera_moving_flag.layerOn = false;
            camera_moving_flag.wave1 = false;
            camera_moving_flag.wave2 = false;
            camera_moving_flag.wave3 = false;

        }


        if (camera_moving_flag.rotateForward) rotate_ud = -0.1f * obj_scale;
        else if (camera_moving_flag.rotateBackward) rotate_ud = 0.1f * obj_scale;

        if (camera_moving_flag.toggleDemension && !camera.isperspective) {
            camera.setPerspectiveProjection(glm::radians(50.f), dt, 0.1f, 100.f);
            camera_moving_flag.toggleDemension = false;
        }
        else if (camera_moving_flag.toggleDemension)rotate_toggle = 0.1f;

        if (camera_moving_flag.toggleDemensionXY) rotate_toggle_xy = -0.1f;

        if (glm::dot(rotate_lr, rotate_lr) > std::numeric_limits<float>::epsilon()) {
            camera.viewMatrix = glm::rotate(camera.getView(), glm::radians(rotate_lr), glm::vec3(0.0f, 0.0f, 1.0f));
        }

    }

}



!@hash[]!@file[]./Rendering/Src/lve_camera.cpp!@hash[]!@code[]#include "lve_camera.hpp"

// std
#include <cassert>
#include <limits>
#include <glm/glm.hpp> //vec3, vec4, ivec4, mat4
#include <glm/gtc/matrix_transform.hpp> //translate, rotate, scale, perspective 
#include <glm/gtc/type_ptr.hpp> //value_ptr


void LveCamera::setOrthographicProjection(
    float left, float right, float top, float bottom, float near, float far) {
  projectionMatrix = glm::ortho(left,right,top,bottom,near,far);
  isperspective = false;
}

void LveCamera::setPerspectiveProjection(float fovy, float aspect, float near, float far) {
    projectionMatrix = glm::perspective(fovy, aspect, near, far);
    isperspective = true;
    //  assert(glm::abs(aspect - std::numeric_limits<float>::epsilon()) > 0.0f);
    //  const float tanHalfFovy = tan(fovy / 2.f);
    //  projectionMatrix = glm::mat4{0.0f};
    //  projectionMatrix[0][0] = 1.f / (aspect * tanHalfFovy);
    //  projectionMatrix[1][1] = 1.f / (tanHalfFovy);
    //  projectionMatrix[2][2] = far / (far - near);
    //  projectionMatrix[2][3] = 1.f;
    //  projectionMatrix[3][2] = -(far * near) / (far - near);
}

void LveCamera::setViewYXZ(glm::vec3 position, glm::vec3 rotation) {
    const float c3 = glm::cos(rotation.z);
    const float s3 = glm::sin(rotation.z);
    const float c2 = glm::cos(rotation.x);
    const float s2 = glm::sin(rotation.x);
    const float c1 = glm::cos(rotation.y);
    const float s1 = glm::sin(rotation.y);
    const glm::vec3 u{ (c1 * c3 + s1 * s2 * s3), (c2 * s3), (c1 * s2 * s3 - c3 * s1) };
    const glm::vec3 v{ (c3 * s1 * s2 - c1 * s3), (c2 * c3), (c1 * c3 * s2 + s1 * s3) };
    const glm::vec3 w{ (c2 * s1), (-s2), (c1 * c2) };
    viewMatrix = glm::mat4{ 1.f };
    viewMatrix[0][0] = u.x;
    viewMatrix[1][0] = u.y;
    viewMatrix[2][0] = u.z;
    viewMatrix[0][1] = v.x;
    viewMatrix[1][1] = v.y;
    viewMatrix[2][1] = v.z;
    viewMatrix[0][2] = w.x;
    viewMatrix[1][2] = w.y;
    viewMatrix[2][2] = w.z;
    viewMatrix[3][0] = -glm::dot(u, position);
    viewMatrix[3][1] = -glm::dot(v, position);
    viewMatrix[3][2] = -glm::dot(w, position);
}

void LveCamera::setViewDirection(glm::vec3 position, glm::vec3 direction, glm::vec3 up) {
  const glm::vec3 w{glm::normalize(direction)};
  const glm::vec3 u{glm::normalize(glm::cross(w, up))};
  const glm::vec3 v{glm::cross(w, u)};

  viewMatrix = glm::mat4{1.f};
  viewMatrix[0][0] = u.x;
  viewMatrix[1][0] = u.y;
  viewMatrix[2][0] = u.z;
  viewMatrix[0][1] = v.x;
  viewMatrix[1][1] = v.y;
  viewMatrix[2][1] = v.z;
  viewMatrix[0][2] = w.x;
  viewMatrix[1][2] = w.y;
  viewMatrix[2][2] = w.z;
  viewMatrix[3][0] = -glm::dot(u, position);
  viewMatrix[3][1] = -glm::dot(v, position);
  viewMatrix[3][2] = -glm::dot(w, position);
}

void LveCamera::setViewTarget(glm::vec3 position, glm::vec3 target, glm::vec3 up) {
    viewMatrix = glm::lookAt(position, target, up);
    //setViewDirection(position, target - position, up);
}

void LveCamera::decomposeView(glm::mat4 viewMat) {
    glm::decompose(viewMat, scale_d, rotation_d, translation_d, skew_d, perspective_d);
    rotation_d = glm::conjugate(rotation_d);
}

!@hash[]!@file[]./Rendering/Src/lve_device.cpp!@hash[]!@code[]
#include <vulkan/vulkan.h>
#include "lve_device.hpp"



// std headers
#include <cstring>
#include <iostream>
#include <set>
#include <unordered_set>


// class member functions
LveDevice::LveDevice(LveWindow* window_, QVulkanInstance* qvk_instance_)
    : window(window_), qvk_instance(qvk_instance_) {
    qDebug() << "\n$$$$$ LveDevice()";
    createInstance();
    //setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createCommandPool();
}


LveDevice::~LveDevice() {
    qDebug() << "\n$$$$$ ~LveDevice()";
    vkDestroyCommandPool(device_, commandPool, nullptr);
}

void LveDevice::createInstance() {
    this->instance = this->qvk_instance->vkInstance();
}

void LveDevice::pickPhysicalDevice() {
    uint32_t deviceCount = 0;
    vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr);
    if (deviceCount == 0) {
        throw std::runtime_error("failed to find GPUs with Vulkan support!");
    }

    std::vector<VkPhysicalDevice> devices(deviceCount);
    vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data());

    for (const auto &device : devices) {
        VkPhysicalDeviceProperties prop_temp;
        vkGetPhysicalDeviceProperties(device, &prop_temp);

        if (isDeviceSuitable(device)) {
            physicalDevice = device;
            break;
        }
    }

    if (physicalDevice == VK_NULL_HANDLE) {
        throw std::runtime_error("failed to find a suitable GPU!");
    }

    vkGetPhysicalDeviceProperties(physicalDevice, &properties);
}

void LveDevice::createLogicalDevice() {

    QueueFamilyIndices indices = findQueueFamilies(physicalDevice);
    device_ = this->window->device();
    vkGetDeviceQueue(device_, indices.graphicsFamily, 0, &graphicsQueue_);
    vkGetDeviceQueue(device_, indices.presentFamily, 0, &presentQueue_);
}

void LveDevice::createCommandPool() {
    QueueFamilyIndices queueFamilyIndices = findPhysicalQueueFamilies();

    VkCommandPoolCreateInfo poolInfo = {};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily;
    poolInfo.flags =
            VK_COMMAND_POOL_CREATE_TRANSIENT_BIT | VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;

    if (vkCreateCommandPool(device_, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
        throw std::runtime_error("failed to create command pool!");
    }
}


void LveDevice::createSurface() {
    this->surface_ = this->qvk_instance->surfaceForWindow(this->window);
}


bool LveDevice::isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    bool extensionsSupported = checkDeviceExtensionSupport(device);

    bool swapChainAdequate = false;
    if (extensionsSupported) {
        SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);
        swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty();
    }

    VkPhysicalDeviceFeatures supportedFeatures;
    vkGetPhysicalDeviceFeatures(device, &supportedFeatures);

    return indices.isComplete() && extensionsSupported && swapChainAdequate &&
            supportedFeatures.samplerAnisotropy;
}



bool LveDevice::checkValidationLayerSupport() {
    uint32_t layerCount;
    vkEnumerateInstanceLayerProperties(&layerCount, nullptr);

    std::vector<VkLayerProperties> availableLayers(layerCount);
    vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data());

    for (const char *layerName : validationLayers) {
        bool layerFound = false;

        for (const auto &layerProperties : availableLayers) {
            if (strcmp(layerName, layerProperties.layerName) == 0) {
                layerFound = true;
                break;
            }
        }

        if (!layerFound) {
            return false;
        }
    }

    return true;
}


std::vector<const char *> LveDevice::getRequiredExtensions() {

    std::vector<const char *> extensions{};

    //auto supported_extensions = QVulkanInstance::supportedExtensions();
    //for(auto & cur_ext : supported_extensions){
    //    extensions.push_back(cur_ext.name.data());
    //}

    extensions.push_back("VK_KHR_surface");
    extensions.push_back("VK_KHR_win32_surface");
    //extensions.push_back(VK_KHR_SURFACE_EXTENSION_NAME);
    if (enableValidationLayers) {
        extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
    }

    return extensions;
}


void LveDevice::hasRequiredInstanceExtensions() {
    uint32_t extensionCount = 0;
    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr);
    std::vector<VkExtensionProperties> extensions(extensionCount);
    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data());


    qDebug() << "available extensions:";
    std::unordered_set<std::string> available;
    for (const auto &extension : extensions) {
        qDebug() << "\t" << extension.extensionName;
        available.insert(extension.extensionName);
    }

    qDebug() << "required extensions:";
    auto requiredExtensions = getRequiredExtensions();
    for (const auto &required : requiredExtensions) {
        qDebug() << "\t" << required;
        if (available.find(required) == available.end()) {
            throw std::runtime_error("Missing required glfw extension");
        }
    }
}


bool LveDevice::checkDeviceExtensionSupport(VkPhysicalDevice device) {
    uint32_t extensionCount;
    vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);

    std::vector<VkExtensionProperties> availableExtensions(extensionCount);
    vkEnumerateDeviceExtensionProperties(
                device,
                nullptr,
                &extensionCount,
                availableExtensions.data());

    std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());

    for (const auto &extension : availableExtensions) {
        requiredExtensions.erase(extension.extensionName);
    }

    return requiredExtensions.empty();
}


QueueFamilyIndices LveDevice::findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;

    uint32_t queueFamilyCount = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);

    std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());

    int i = 0;
    for (const auto &queueFamily : queueFamilies) {
        if (queueFamily.queueCount > 0 && queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
            indices.graphicsFamily = i;
            indices.graphicsFamilyHasValue = true;
        }
        VkBool32 presentSupport = false;
        vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface_, &presentSupport);
        if (queueFamily.queueCount > 0 && presentSupport) {
            indices.presentFamily = i;
            indices.presentFamilyHasValue = true;
        }
        if (indices.isComplete()) {
            break;
        }

        i++;
    }

    return indices;
}

SwapChainSupportDetails LveDevice::querySwapChainSupport(VkPhysicalDevice device) {
    SwapChainSupportDetails details;
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface_, &details.capabilities);

    uint32_t formatCount;
    vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface_, &formatCount, nullptr);

    if (formatCount != 0) {
        details.formats.resize(formatCount);
        vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface_, &formatCount, details.formats.data());
    }

    uint32_t presentModeCount;
    vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface_, &presentModeCount, nullptr);

    if (presentModeCount != 0) {
        details.presentModes.resize(presentModeCount);
        vkGetPhysicalDeviceSurfacePresentModesKHR(
                    device,
                    surface_,
                    &presentModeCount,
                    details.presentModes.data());
    }
    return details;
}

VkFormat LveDevice::findSupportedFormat(
        const std::vector<VkFormat> &candidates, VkImageTiling tiling, VkFormatFeatureFlags features) {
    for (VkFormat format : candidates) {
        VkFormatProperties props;
        vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &props);

        if (tiling == VK_IMAGE_TILING_LINEAR && (props.linearTilingFeatures & features) == features) {
            return format;
        } else if (
                   tiling == VK_IMAGE_TILING_OPTIMAL && (props.optimalTilingFeatures & features) == features) {
            return format;
        }
    }
    throw std::runtime_error("failed to find supported format!");
}

uint32_t LveDevice::findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {
    VkPhysicalDeviceMemoryProperties memProperties;
    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);
    for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
        if ((typeFilter & (1 << i)) &&
                (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
            return i;
        }
    }

    throw std::runtime_error("failed to find suitable memory type!");
}

void LveDevice::createBuffer(
        VkDeviceSize size,
        VkBufferUsageFlags usage,
        VkMemoryPropertyFlags properties,
        VkBuffer &buffer,
        VkDeviceMemory &bufferMemory) {
    VkBufferCreateInfo bufferInfo{};
    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    bufferInfo.size = size;
    bufferInfo.usage = usage;
    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    if (vkCreateBuffer(device_, &bufferInfo, nullptr, &buffer) != VK_SUCCESS) {
        throw std::runtime_error("failed to create buffer!");
    }

    VkMemoryRequirements memRequirements;
    vkGetBufferMemoryRequirements(device_, buffer, &memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(device_, &allocInfo, nullptr, &bufferMemory) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate vertex buffer memory!");
    }

    vkBindBufferMemory(device_, buffer, bufferMemory, 0);
}

VkCommandBuffer LveDevice::beginSingleTimeCommands() {
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandPool = commandPool;
    allocInfo.commandBufferCount = 1;

    VkCommandBuffer commandBuffer;
    vkAllocateCommandBuffers(device_, &allocInfo, &commandBuffer);

    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

    vkBeginCommandBuffer(commandBuffer, &beginInfo);
    return commandBuffer;
}

void LveDevice::endSingleTimeCommands(VkCommandBuffer commandBuffer) {
    vkEndCommandBuffer(commandBuffer);

    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &commandBuffer;

    vkQueueSubmit(graphicsQueue_, 1, &submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(graphicsQueue_);

    vkFreeCommandBuffers(device_, commandPool, 1, &commandBuffer);
}

void LveDevice::copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkBufferCopy copyRegion{};
    copyRegion.srcOffset = 0;  // Optional
    copyRegion.dstOffset = 0;  // Optional
    copyRegion.size = size;
    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);

    endSingleTimeCommands(commandBuffer);
}

void LveDevice::copyBufferToImage(
        VkBuffer buffer, VkImage image, uint32_t width, uint32_t height, uint32_t layerCount) {
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkBufferImageCopy region{};
    region.bufferOffset = 0;
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;

    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = layerCount;

    region.imageOffset = {0, 0, 0};
    region.imageExtent = {width, height, 1};

    vkCmdCopyBufferToImage(
                commandBuffer,
                buffer,
                image,
                VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                1,
                &region);
    endSingleTimeCommands(commandBuffer);
}

void LveDevice::createImageWithInfo(
        const VkImageCreateInfo &imageInfo,
        VkMemoryPropertyFlags properties,
        VkImage &image,
        VkDeviceMemory &imageMemory) {
    if (vkCreateImage(device_, &imageInfo, nullptr, &image) != VK_SUCCESS) {
        throw std::runtime_error("failed to create image!");
    }

    VkMemoryRequirements memRequirements;
    vkGetImageMemoryRequirements(device_, image, &memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(device_, &allocInfo, nullptr, &imageMemory) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate image memory!");
    }

    if (vkBindImageMemory(device_, image, imageMemory, 0) != VK_SUCCESS) {
        throw std::runtime_error("failed to bind image memory!");
    }
}

!@hash[]!@file[]./Rendering/Src/lve_model.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>

#include "lve_model.hpp"
#include "rapidcsv.h"

// std
#include <cassert>
#include <cstring>

using namespace std;

inline float coord_normalize(float in_value, float move, float scale) {
    //return 2 * (in_value - min_value) / (max_value - min_value) - 1.0f;
    return (2 * (in_value - move) / (scale)-1.0f);
}



LveModel::LveModel(LveDevice& device, MODEL_TYPE type)
    : lveDevice{ device }, model_type(type) {
    if (type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        makeAxisData();
        createBuffers();
    }

    //createBuffers();
}

LveModel::~LveModel() {
    destroyBuffers();

    this->cube_infos.clear();
    this->cube_vertices.clear();
    this->vertices.clear();
    this->layerby_vertices.clear();
    this->indices_face.clear();
    this->layerby_face.clear();
    this->indices_edge.clear();
    this->layerby_edge.clear();
}

void LveModel::createBuffers() {

    if (this->model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) {
        for (auto const& [key, val] : layerby_vertices) {
            std::map<string, VkBuffer>& buffers = this->layerbyVertexBuffers;
            std::map<string, VkDeviceMemory>& buffersmemory = this->layerbyVertexBuffersMemory;
            createVertexBuffers(val, buffers[key], buffersmemory[key]);

            std::map<string, VkBuffer>& facebuffers = this->layerbyFaceIndexBuffers;
            std::map<string, VkDeviceMemory>& facebuffersmemory = this->layerbyFaceIndexBuffersMemory;
            createIndexBuffers(layerby_face[key], facebuffers[key], facebuffersmemory[key]);

            std::map<string, VkBuffer>& edgebuffers = this->layerbyEdgeIndexBuffers;
            std::map<string, VkDeviceMemory>& edgebuffersmemory = this->layerbyEdgeIndexBuffersMemory;
            createIndexBuffers(layerby_edge[key], edgebuffers[key], edgebuffersmemory[key]);
        }
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        createVertexBuffers(vertices, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) {
        createVertexBuffersResistor(vertices_resistor, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_face, this->indexBufferForFace, this->indexBufferMemoryForFace);
        createIndexBuffers(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) {
        createVertexBuffers(vertices, vertexBuffer, vertexBufferMemory);
        createIndexBuffers(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
    }
}

void LveModel::destroyBuffers() {
    if (this->model_type == MODEL_TYPE::MODEL_TYPE_LAYOUT) {
        for (auto const& [key, val] : layerbyFaceIndexBuffers) {
            vkDestroyBuffer(lveDevice.device(), layerbyVertexBuffers[key], nullptr);
            vkFreeMemory(lveDevice.device(), layerbyVertexBuffersMemory[key], nullptr);
            vkDestroyBuffer(lveDevice.device(), val, nullptr);
            vkFreeMemory(lveDevice.device(), layerbyFaceIndexBuffersMemory[key], nullptr);
            vkDestroyBuffer(lveDevice.device(), layerbyEdgeIndexBuffers[key], nullptr);
            vkFreeMemory(lveDevice.device(), layerbyEdgeIndexBuffersMemory[key], nullptr);
        }

        //vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        //vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_AXIS) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForFace, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForFace, nullptr);
    }
    else if (this->model_type == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR) {
        vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
        vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
        vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
        vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
    }
    this->cube_infos.clear();

    this->cube_vertices.clear();
    this->vertices.clear();
    this->vertices_resistor.clear();
    this->layerby_vertices.clear();
    this->indices_face.clear();
    this->layerby_face.clear();
    this->indices_edge.clear();
    this->layerby_edge.clear();


}
void LveModel::createVertexBuffers(
        const std::vector<Vertex>& vertices,
        VkBuffer& buffer,
        VkDeviceMemory& memory) {
    vertexCount = static_cast<uint32_t>(vertices.size());
    assert(vertexCount >= 3 && "Vertex count must be at least 3");
    VkDeviceSize bufferSize = sizeof(vertices[0]) * vertexCount;

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, vertices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}

void LveModel::createVertexBuffersResistor(
        const std::vector<VertexResistor>& vertices,
        VkBuffer& buffer,
        VkDeviceMemory& memory) {
    vertexCount = static_cast<uint32_t>(vertices.size());
    assert(vertexCount >= 3 && "Vertex count must be at least 3");
    VkDeviceSize bufferSize = sizeof(vertices[0]) * vertexCount;

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, vertices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}


void LveModel::createIndexBuffers(
        const std::vector<uint32_t>& indices,
        VkBuffer& buffer,
        VkDeviceMemory& memory) {
    assert( !indices.empty() && "Index size can't be zero");
    VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, indices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}

void LveModel::drawForFace(VkCommandBuffer commandBuffer) {
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_face.size()), 1, 0, 0, 0);
}

void LveModel::drawForEdge(VkCommandBuffer commandBuffer) {
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_edge.size()), 1, 0, 0, 0);
}

void LveModel::bindVertexBuffer(VkCommandBuffer commandBuffer) {
    VkBuffer buffers[] = {vertexBuffer};
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
}

void LveModel::bindDrawVertexIndexBufferForFace_layer(VkCommandBuffer commandBuffer, const string layer) {
    VkBuffer buffers[] = { layerbyVertexBuffers[layer] };
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
    vkCmdBindIndexBuffer(commandBuffer, layerbyFaceIndexBuffers[layer], 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_face[layer].size()), 1, 0, 0, 0);
}

void LveModel::bindDrawIndexBufferForEdge_layer(VkCommandBuffer commandBuffer, const string layer) {
    vkCmdBindIndexBuffer(commandBuffer, layerbyEdgeIndexBuffers[layer], 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->layerby_edge[layer].size()), 1, 0, 0, 0);
}



void LveModel::bindIndexBufferForFace(VkCommandBuffer commandBuffer) {
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForFace, 0, VK_INDEX_TYPE_UINT32);
}

void LveModel::bindIndexBufferForEdge(VkCommandBuffer commandBuffer) {
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForEdge, 0, VK_INDEX_TYPE_UINT32);
}


std::vector<VkVertexInputBindingDescription> LveModel::Vertex::getBindingDescriptions() {
    std::vector<VkVertexInputBindingDescription> bindingDescriptions(1);
    bindingDescriptions[0].binding = 0;
    bindingDescriptions[0].stride = sizeof(Vertex);
    bindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    return bindingDescriptions;
}

std::vector<VkVertexInputAttributeDescription> LveModel::Vertex::getAttributeDescriptions() {
    std::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);
    attributeDescriptions[0].binding = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset = offsetof(Vertex, position);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(Vertex, color);
    return attributeDescriptions;
}

std::vector<VkVertexInputBindingDescription> LveModel::VertexResistor::getBindingDescriptions() {
    std::vector<VkVertexInputBindingDescription> bindingDescriptions(1);
    bindingDescriptions[0].binding = 0;
    bindingDescriptions[0].stride = sizeof(VertexResistor);
    bindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    return bindingDescriptions;
}

std::vector<VkVertexInputAttributeDescription> LveModel::VertexResistor::getAttributeDescriptions() {
    std::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);
    attributeDescriptions[0].binding = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset = offsetof(VertexResistor, position);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(VertexResistor, color);
    return attributeDescriptions;
}


void LveModel::makeAxisData(const float axis_length) {
    this->vertices.clear();
    this->vertices = {
        { { -axis_length, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f } },
        { {  axis_length, 0.0f, 0.0f }, { 1.0f, 0.0f, 0.0f } },
        { { 0.0f, -axis_length, 0.0f }, { 1.0f, 1.0f, 1.0f } },
        { { 0.0f,  axis_length, 0.0f }, { 0.0f, 1.0f, 0.0f } },
        { { 0.0f, 0.0f, -axis_length }, { 1.0f, 1.0f, 1.0f } },
        { { 0.0f, 0.0f,  axis_length }, { 0.0f, 0.0f, 1.0f } }
    };

    vector<uint32_t>& indices = this->indices_edge;
    indices.clear();
    indices.push_back(0);
    indices.push_back(1);
    indices.push_back(2);
    indices.push_back(3);
    indices.push_back(4);
    indices.push_back(5);
}

void LveModel::updateOpacity(float amount) {
    this->opacity += amount;
    if (this->opacity > 1.0f) this->opacity = 1.0f;
    if (this->opacity < 0.0f) this->opacity = 0.0f;
}

std::map<string, LveModel::LayerProperty> LveModel::getLayer() {
    //if(layerList.empty()){
    //    vector<glm::vec3> it = { glm::vec3{0.1,0.5,0.8},glm::vec3{0.8,0.4,0.2},glm::vec3{0.5,0.9,0.9} };
    //    int a = 0;
    //    for (auto ordered_key : drawing_order_layerby) {
    //
    //        layerList.insert(pair(ordered_key, LayerProperty{true,it.at(a%3), 0.5}) );
    //        a++;
    //    }
    //}
    return layerList;
}

void LveModel::changeLayerColor(string layernumber, glm::vec3 rgb){
    if(layerList.count(layernumber) != 0 ){
        layerList[layernumber].color = rgb;
    }

}

void LveModel::changeLayerOpacity(string layernumber, float opacity){
    if(layerList.count(layernumber) != 0 ){
        layerList[layernumber].opacity = opacity;
    }

}

void LveModel::changeLayerVisiblity(string layernumber, bool visiblity){
    //qDebug() << QString::fromStdString(layernumber) ;

    if(layerList.count(layernumber) != 0 ){
        layerList[layernumber].visiblity = visiblity;
    }

}

void LveModel::demoVisiblityOff(){
    for(auto const& [key, val] : layerList){
        layerList[key].visiblity = false;
    }
    layerList["4"].visiblity = true;

}

void LveModel::demoVisiblityOn(std::vector<string> layernumbers){
    for(auto layer : layernumbers){
        layerList[layer].visiblity = true;
    }
}

!@hash[]!@file[]./Rendering/Src/lve_pipeline.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>

#include "lve_pipeline.hpp"
#include "lve_model.hpp"

// std
#include <cassert>
#include <fstream>
#include <iostream>
#include <stdexcept>



LvePipeline::LvePipeline(
        LveDevice& device,
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo,
    const std::vector<VkVertexInputBindingDescription> bindingDescription_,
    const  std::vector<VkVertexInputAttributeDescription> attributeDescription_
)
    : lveDevice{device} {
    createGraphicsPipeline(vertFilepath, fragFilepath, configInfo, bindingDescription_,attributeDescription_);
}

LvePipeline::~LvePipeline() {
    vkDestroyShaderModule(lveDevice.device(), vertShaderModule, nullptr);
    vkDestroyShaderModule(lveDevice.device(), fragShaderModule, nullptr);
    vkDestroyPipeline(lveDevice.device(), graphicsPipeline, nullptr);
}

std::vector<char> LvePipeline::readFile(const std::string& filepath) {
    std::ifstream file{filepath, std::ios::ate | std::ios::binary};

    if (!file.is_open()) {
        throw std::runtime_error("failed to open file: " + filepath);
    }

    size_t fileSize = static_cast<size_t>(file.tellg());
    std::vector<char> buffer(fileSize);

    file.seekg(0);
    file.read(buffer.data(), fileSize);

    file.close();
    return buffer;
}

void LvePipeline::createGraphicsPipeline(
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo,
    const std::vector<VkVertexInputBindingDescription> bindingDescription_,
    const  std::vector<VkVertexInputAttributeDescription> attributeDescription_
    ) {
    assert(
                configInfo.pipelineLayout != VK_NULL_HANDLE &&
            "Cannot create graphics pipeline: no pipelineLayout provided in configInfo");
    assert(
                configInfo.renderPass != VK_NULL_HANDLE &&
            "Cannot create graphics pipeline: no renderPass provided in configInfo");

    auto vertCode = readFile(vertFilepath);
    auto fragCode = readFile(fragFilepath);

    createShaderModule(vertCode, &vertShaderModule);
    createShaderModule(fragCode, &fragShaderModule);

    VkPipelineShaderStageCreateInfo shaderStages[2];
    shaderStages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    shaderStages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
    shaderStages[0].module = vertShaderModule;
    shaderStages[0].pName = "main";
    shaderStages[0].flags = 0;
    shaderStages[0].pNext = nullptr;
    shaderStages[0].pSpecializationInfo = nullptr;
    shaderStages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    shaderStages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    shaderStages[1].module = fragShaderModule;
    shaderStages[1].pName = "main";
    shaderStages[1].flags = 0;
    shaderStages[1].pNext = nullptr;
    shaderStages[1].pSpecializationInfo = nullptr;

    auto bindingDescriptions = bindingDescription_;
    auto attributeDescriptions = attributeDescription_;
    VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.vertexAttributeDescriptionCount =
            static_cast<uint32_t>(attributeDescriptions.size());
    vertexInputInfo.vertexBindingDescriptionCount = static_cast<uint32_t>(bindingDescriptions.size());
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data();
    vertexInputInfo.pVertexBindingDescriptions = bindingDescriptions.data();

    VkGraphicsPipelineCreateInfo pipelineInfo{};
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &configInfo.inputAssemblyInfo;
    pipelineInfo.pViewportState = &configInfo.viewportInfo;
    pipelineInfo.pRasterizationState = &configInfo.rasterizationInfo;
    pipelineInfo.pMultisampleState = &configInfo.multisampleInfo;
    pipelineInfo.pColorBlendState = &configInfo.colorBlendInfo;
    pipelineInfo.pDepthStencilState = &configInfo.depthStencilInfo;
    pipelineInfo.pDynamicState = &configInfo.dynamicStateInfo;

    pipelineInfo.layout = configInfo.pipelineLayout;
    pipelineInfo.renderPass = configInfo.renderPass;
    pipelineInfo.subpass = configInfo.subpass;

    pipelineInfo.basePipelineIndex = -1;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(
                lveDevice.device(),
                VK_NULL_HANDLE,
                1,
                &pipelineInfo,
                nullptr,
                &graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline");
    }
}

void LvePipeline::createShaderModule(const std::vector<char>& code, VkShaderModule* shaderModule) {
    VkShaderModuleCreateInfo createInfo{};
    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    createInfo.codeSize = code.size();
    createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data());

    if (vkCreateShaderModule(lveDevice.device(), &createInfo, nullptr, shaderModule) != VK_SUCCESS) {
        throw std::runtime_error("failed to create shader module");
    }
}

void LvePipeline::bind(VkCommandBuffer commandBuffer) {
    vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
}

void LvePipeline::defaultPipelineConfigInfo(PipelineConfigInfo& configInfo) {
    configInfo.inputAssemblyInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    configInfo.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    configInfo.inputAssemblyInfo.primitiveRestartEnable = VK_FALSE;

    configInfo.viewportInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    configInfo.viewportInfo.viewportCount = 1;
    configInfo.viewportInfo.pViewports = nullptr;
    configInfo.viewportInfo.scissorCount = 1;
    configInfo.viewportInfo.pScissors = nullptr;

    configInfo.rasterizationInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    configInfo.rasterizationInfo.depthClampEnable = VK_FALSE;
    configInfo.rasterizationInfo.rasterizerDiscardEnable = VK_FALSE;
    configInfo.rasterizationInfo.polygonMode = VK_POLYGON_MODE_FILL;
    configInfo.rasterizationInfo.lineWidth = 1.0f;
    configInfo.rasterizationInfo.cullMode = VK_CULL_MODE_NONE;
    configInfo.rasterizationInfo.frontFace = VK_FRONT_FACE_CLOCKWISE;
    configInfo.rasterizationInfo.depthBiasEnable = VK_FALSE;
    configInfo.rasterizationInfo.depthBiasConstantFactor = 0.0f;  // Optional
    configInfo.rasterizationInfo.depthBiasClamp = 0.0f;           // Optional
    configInfo.rasterizationInfo.depthBiasSlopeFactor = 0.0f;     // Optional

    configInfo.multisampleInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    configInfo.multisampleInfo.sampleShadingEnable = VK_FALSE;
    configInfo.multisampleInfo.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
    configInfo.multisampleInfo.minSampleShading = 1.0f;           // Optional
    configInfo.multisampleInfo.pSampleMask = nullptr;             // Optional
    configInfo.multisampleInfo.alphaToCoverageEnable = VK_FALSE;  // Optional
    configInfo.multisampleInfo.alphaToOneEnable = VK_FALSE;       // Optional

    configInfo.colorBlendAttachment.colorWriteMask =
            VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT |
            VK_COLOR_COMPONENT_A_BIT;
    configInfo.colorBlendAttachment.blendEnable = VK_FALSE;
    configInfo.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;   // Optional
    configInfo.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;  // Optional
    configInfo.colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;              // Optional
    configInfo.colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;   // Optional
    configInfo.colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;  // Optional
    configInfo.colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;              // Optional

    configInfo.colorBlendInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    configInfo.colorBlendInfo.logicOpEnable = VK_FALSE;
    configInfo.colorBlendInfo.logicOp = VK_LOGIC_OP_COPY;  // Optional
    configInfo.colorBlendInfo.attachmentCount = 1;
    configInfo.colorBlendInfo.pAttachments = &configInfo.colorBlendAttachment;
    configInfo.colorBlendInfo.blendConstants[0] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[1] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[2] = 0.0f;  // Optional
    configInfo.colorBlendInfo.blendConstants[3] = 0.0f;  // Optional

    configInfo.depthStencilInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    configInfo.depthStencilInfo.depthTestEnable = VK_TRUE;
    configInfo.depthStencilInfo.depthWriteEnable = VK_TRUE;
    configInfo.depthStencilInfo.depthCompareOp = VK_COMPARE_OP_LESS;
    configInfo.depthStencilInfo.depthBoundsTestEnable = VK_FALSE;
    configInfo.depthStencilInfo.minDepthBounds = 0.0f;  // Optional
    configInfo.depthStencilInfo.maxDepthBounds = 1.0f;  // Optional
    configInfo.depthStencilInfo.stencilTestEnable = VK_FALSE;
    configInfo.depthStencilInfo.front = {};  // Optional
    configInfo.depthStencilInfo.back = {};   // Optional

    configInfo.dynamicStateEnables = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};
    configInfo.dynamicStateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    configInfo.dynamicStateInfo.pDynamicStates = configInfo.dynamicStateEnables.data();
    configInfo.dynamicStateInfo.dynamicStateCount =
            static_cast<uint32_t>(configInfo.dynamicStateEnables.size());
    configInfo.dynamicStateInfo.flags = 0;
}


!@hash[]!@file[]./Rendering/Src/lve_window.cpp!@hash[]!@code[]
#include <QMouseEvent>
#include <QKeyEvent>
#include <QDockWidget>
#include <QGraphicsRectItem>
#include <QGraphicsOpacityEffect>
#include <QFile>
#include <QFileDialog>
#include <QString>

#include "lve_window.hpp"
#include "dtaorendersystem.h"



LveWindow::LveWindow()
{
}

LveWindow::~LveWindow()
{
    //this->destroy();
}

QVulkanWindowRenderer *LveWindow::createRenderer()
{
    qDebug() << "\n$$$$$ LveWindow::createRenderer()";
    this->m_renderer = new DtaoRenderSystem(this);
    return this->m_renderer;
    //return new DtaoRenderSystem(this);

}

void LveWindow::wheelEvent(QWheelEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    //const float amount = e->angleDelta().y() / 8;
    QPoint scroll = e->angleDelta();
    this->m_renderer->cameraController.setMouseScroll(scroll);

    if (keyCtrl == true)
    {
        //      m_rendere->windowZoom(amount);
        QString funcName = "windowZoom";
        //float value = amount;
        //emit signalInfoText(funcName, value);
        //        qDebug()<<funcName << " : " << value;
    }
    else
    {
        //      m_renderer->moveZoom(amount);
        QString funcName = "moveZoom";
        //float value = amount;
        //emit signalInfoText(funcName, value);
        //        qDebug()<<funcName << " : " << value;
    }
}

void LveWindow::mousePressEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    m_mouseButton = e->buttons();
    Qt::MouseButtons cur_button = e->buttons();
    QPoint position = e->pos();
    //m_lastPos = e->pos();
    this->m_renderer->cameraController.moveButtonPressed(cur_button);
    this->m_renderer->cameraController.setMousePosition(position, 1);

}

void LveWindow::emitStatus(float value){
    QString funcName = "rotateRenderX";
    //emit signalInfoText(funcName, value);
}


void LveWindow::mouseReleaseEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    m_mouseButton = 0;
    QString funcName = "mouseRelease";
    Qt::MouseButtons cur_button = e->buttons();
    QPoint position = e->pos();
    //float value = 0;
    //emit signalInfoText(funcName, cur_button);
    this->m_renderer->cameraController.moveButtonReleased(cur_button);
    this->m_renderer->cameraController.setMousePosition(position ,2);
}

void LveWindow::mouseMoveEvent(QMouseEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    QPoint position = e->pos();
    this->m_renderer->cameraController.setMousePosition(position, 0);
    if (m_mouseButton == 0)
        return;
}

void LveWindow::keyPressEvent(QKeyEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    Qt::Key cur_key = (Qt::Key)e->key();
    //QString funcName = "rotateRenderX";
    //float value = 10.0f;
    //emit signalInfoText(funcName, value);

    this->m_renderer->cameraController.moveKeyPressed(cur_key);
    this->m_renderer->cameraController.visibleSetting(this->m_renderer->getGameObjects(), cur_key);
    this->m_renderer->cameraController.PEXSetting(this->m_renderer->getResistorModel(), cur_key);

}
void LveWindow::keyReleaseEvent(QKeyEvent *e)
{
    if( !this->m_renderer->isRenderModelLoaded() ) return;
    Qt::Key cur_key = (Qt::Key)e->key();
    this->m_renderer->cameraController.moveKeyReleased(cur_key);
}

!@hash[]!@file[]./Rendering/Src/simple_render_system.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>
#include "simple_render_system.hpp"

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>
#include <glm/gtc/constants.hpp>

// std
#include <array>
#include <cassert>
#include <stdexcept>



struct SimplePushConstantData {
    glm::mat4 transform{ 1.f };
    alignas(16) glm::vec3 color{};
    glm::float32 alpha;
};

SimpleRenderSystem::SimpleRenderSystem(LveDevice& device, VkRenderPass renderPass)
    : lveDevice{ device } {
    createPipelineLayout(this->pipelineLayoutForLayoutFace);
    createPipelineForFace(renderPass);
    createPipelineLayout(this->pipelineLayoutForLayoutEdge);
    createPipelineForEdge(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXResistor);
    createPipelineForPEXResistor(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXResistorEdge);
    createPipelineForPEXResistorEdge(renderPass);
    createPipelineLayout(this->pipelineLayoutForPEXCapacitor);
    createPipelineForPEXCapacitor(renderPass);

    createPipelineLayout(this->pipelineLayoutForToyCADFace);
    createPipelineForToyCADFace(renderPass);
    createPipelineLayout(this->pipelineLayoutForToyCADEdge);
    createPipelineForToyCADEdge(renderPass);
}

SimpleRenderSystem::~SimpleRenderSystem() {
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForLayoutFace, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForLayoutEdge, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForPEXResistor, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForPEXResistorEdge, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForPEXCapacitor, nullptr);

    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForToyCADFace, nullptr);
    vkDestroyPipelineLayout(lveDevice.device(), pipelineLayoutForToyCADEdge, nullptr);
}


void SimpleRenderSystem::createPipelineLayout(VkPipelineLayout& pipeline_layout) {
    VkPushConstantRange pushConstantRange{};
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange.offset = 0;
    pushConstantRange.size = sizeof(SimplePushConstantData);

    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 0;
    pipelineLayoutInfo.pSetLayouts = nullptr;
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(lveDevice.device(), &pipelineLayoutInfo, nullptr, &pipeline_layout) !=
        VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }
}

void SimpleRenderSystem::createPipelineForFace(VkRenderPass renderPass) {
    assert(pipelineLayoutForLayoutFace != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForLayoutFace;

    pipelineConfig.colorBlendAttachment.blendEnable = VK_TRUE;
    pipelineConfig.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    pipelineConfig.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;

    this->lvePipelineForLayoutFace = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert.spv",
        "Rendering/shaders/simple_shader.frag.spv",
        pipelineConfig, LveModel::Vertex::getBindingDescriptions(), LveModel::Vertex::getAttributeDescriptions());
}

void SimpleRenderSystem::createPipelineForEdge(VkRenderPass renderPass) {
    assert(pipelineLayoutForLayoutEdge != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForLayoutEdge;

    pipelineConfig.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForLayoutEdge = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert_edge.spv",
        "Rendering/shaders/simple_shader.frag_edge.spv",
        pipelineConfig, LveModel::Vertex::getBindingDescriptions(), LveModel::Vertex::getAttributeDescriptions());
}

void SimpleRenderSystem::createPipelineForPEXResistor(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXResistor != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigResistor{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigResistor);
    pipelineConfigResistor.renderPass = renderPass;
    pipelineConfigResistor.pipelineLayout = pipelineLayoutForPEXResistor;
    pipelineConfigResistor.colorBlendAttachment.blendEnable = VK_TRUE;

    pipelineConfigResistor.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    pipelineConfigResistor.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;

    this->lvePipelineForPEXResistor = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert_pex.spv",
        "Rendering/shaders/simple_shader.frag_pex.spv",
        pipelineConfigResistor, LveModel::VertexResistor::getBindingDescriptions(), LveModel::VertexResistor::getAttributeDescriptions());
}


void SimpleRenderSystem::createPipelineForPEXResistorEdge(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXResistorEdge != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigResistorEdge{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigResistorEdge);
    pipelineConfigResistorEdge.renderPass = renderPass;
    pipelineConfigResistorEdge.pipelineLayout = pipelineLayoutForPEXResistorEdge;

    pipelineConfigResistorEdge.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForPEXResistorEdge = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert_pex.spv",
        "Rendering/shaders/simple_shader.frag_pex.spv",
        pipelineConfigResistorEdge, LveModel::VertexResistor::getBindingDescriptions(), LveModel::VertexResistor::getAttributeDescriptions());
}

void SimpleRenderSystem::createPipelineForPEXCapacitorLine(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXResistor != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigCapacitorLine{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigCapacitorLine);
    pipelineConfigCapacitorLine.renderPass = renderPass;
    pipelineConfigCapacitorLine.pipelineLayout = pipelineLayoutForPEXCapacitorLine;
    pipelineConfigCapacitorLine.colorBlendAttachment.blendEnable = VK_TRUE;

    pipelineConfigCapacitorLine.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    pipelineConfigCapacitorLine.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;

    this->lvePipelineForPEXCapacitorLine = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert_pex.spv",
        "Rendering/shaders/simple_shader.frag_pex.spv",
        pipelineConfigCapacitorLine, LveModel::Vertex::getBindingDescriptions(), LveModel::Vertex::getAttributeDescriptions());
}

void SimpleRenderSystem::createPipelineForPEXCapacitor(VkRenderPass renderPass) {
    assert(pipelineLayoutForPEXCapacitor != nullptr && "Cannot create pipeline before pipeline layout");
    PipelineConfigInfo pipelineConfigCapacitor{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfigCapacitor);
    pipelineConfigCapacitor.renderPass = renderPass;
    pipelineConfigCapacitor.pipelineLayout = pipelineLayoutForPEXCapacitor;

    pipelineConfigCapacitor.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForPEXCapacitor = std::make_unique<LvePipeline>(
        lveDevice,
        "Rendering/shaders/simple_shader.vert_pex.spv",
        "Rendering/shaders/simple_shader.frag_pex.spv",
        pipelineConfigCapacitor, LveModel::Vertex::getBindingDescriptions(), LveModel::Vertex::getAttributeDescriptions());
}

void SimpleRenderSystem::renderGameObjects(
    VkCommandBuffer commandBuffer,
    std::vector<LveGameObject>& gameObjects,
    const LveCamera& camera) {

    auto proj = camera.getProjection();
    proj[1][1] *= -1;
    auto projectionView = proj * camera.getView();

    SimplePushConstantData push{};
    for (auto& obj : gameObjects) {
        push.transform = projectionView * obj.transform.mat4();

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_LAYOUT && obj.model->getVisible()) {
            std::map<string, LveModel::LayerProperty> layer_info = obj.model->getLayer();

            for (auto ordered_key : obj.model->drawing_order_layerby) {
                if (layer_info[ordered_key].visiblity) {
                    lvePipelineForLayoutFace->bind(commandBuffer);
                    push.alpha = layer_info[ordered_key].opacity;
                    push.color = layer_info[ordered_key].color;
                    vkCmdPushConstants(
                        commandBuffer, pipelineLayoutForLayoutFace,
                        VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                        sizeof(SimplePushConstantData), &push);
                    obj.model->bindDrawVertexIndexBufferForFace_layer(commandBuffer, ordered_key);
                    lvePipelineForLayoutEdge->bind(commandBuffer);
                    obj.model->bindDrawIndexBufferForEdge_layer(commandBuffer, ordered_key);
                }
            }

        }

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_AXIS && obj.model->getVisible()) {
            lvePipelineForLayoutEdge->bind(commandBuffer);
            push.color = glm::vec3(1.0f, 1.0f, 1.0f);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForLayoutEdge,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            obj.model->drawForEdge(commandBuffer);
        }

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_PEX_RESISTOR && obj.model->getVisible()) {
            //*

            push.alpha = 0.1f;
            push.color = glm::vec3(1.0f, 1.0f, 1.0f);
            lvePipelineForPEXResistor->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForPEXResistor,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForFace(commandBuffer);
            obj.model->drawForFace(commandBuffer);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            lvePipelineForPEXResistorEdge->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForPEXResistorEdge,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);


            obj.model->drawForEdge(commandBuffer);

        }

        if (obj.model->getModelType() == MODEL_TYPE::MODEL_TYPE_PEX_CAPACITOR && obj.model->getVisible()) {
            //*
            lvePipelineForPEXCapacitor->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForPEXCapacitor,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            obj.model->drawForEdge(commandBuffer);
            //*/
        }
    }
}

void SimpleRenderSystem::createPipelineForToyCADFace(VkRenderPass renderPass) {
    assert(pipelineLayoutForToyCADFace != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForToyCADFace;

    pipelineConfig.colorBlendAttachment.blendEnable = VK_TRUE;
    pipelineConfig.colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    pipelineConfig.colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;

    this->lvePipelineForToyCADFace = std::make_unique<LvePipeline>(
                lveDevice,
                "ToyCAD/shaders/toycad.vert.spv",
                "ToyCAD/shaders/toycad.frag.spv",
                pipelineConfig,
                ToyCADModel::ToyCADVertex::getBindingDescriptions(),
                ToyCADModel::ToyCADVertex::getAttributeDescriptions());
}

void SimpleRenderSystem::createPipelineForToyCADEdge(VkRenderPass renderPass) {
    assert(pipelineLayoutForToyCADEdge != nullptr && "Cannot create pipeline before pipeline layout");

    PipelineConfigInfo pipelineConfig{};
    LvePipeline::defaultPipelineConfigInfo(pipelineConfig);
    pipelineConfig.renderPass = renderPass;
    pipelineConfig.pipelineLayout = pipelineLayoutForToyCADEdge;

    pipelineConfig.inputAssemblyInfo.topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;

    this->lvePipelineForToyCADEdge = std::make_unique<LvePipeline>(
                lveDevice,
                "ToyCAD/shaders/toycad.vert.spv",
                "ToyCAD/shaders/toycad.frag.spv",
                pipelineConfig,
                ToyCADModel::ToyCADVertex::getBindingDescriptions(),
                ToyCADModel::ToyCADVertex::getAttributeDescriptions());
}

void SimpleRenderSystem::renderToyCADObjects(
    VkCommandBuffer commandBuffer,
    std::vector<ToyCADObject>& objects,
    const LveCamera& camera) {

    auto proj = camera.getProjection();
    proj[1][1] *= -1;
    auto projectionView = proj * camera.getView();

    SimplePushConstantData push{};
    for (auto& obj : objects) {
        if(obj.getVisibility()){
            push.transform = projectionView * obj.transform.mat4();
            push.alpha = obj.opacity;
            push.color = obj.color;

            lvePipelineForToyCADFace->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForToyCADFace,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindVertexBuffer(commandBuffer);
            obj.model->bindIndexBufferForFace(commandBuffer);
            obj.model->drawForFace(commandBuffer);

            push.color = glm::vec3{obj.color.r*0.8, obj.color.g*0.8, obj.color.b*0.8,};

            lvePipelineForToyCADEdge->bind(commandBuffer);
            vkCmdPushConstants(
                commandBuffer, pipelineLayoutForToyCADEdge,
                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(SimplePushConstantData), &push);
            obj.model->bindIndexBufferForEdge(commandBuffer);
            obj.model->drawForEdge(commandBuffer);
        }//if(obj.getVisibility())
    }//for (auto& obj : objects)
}//void SimpleRenderSystem::renderToyCADObjects
!@hash[]!@file[]./T2D.cpp!@hash[]!@code[]#include "T2D.h"

using namespace std;

bool T2D::text2data(std::string file_name){
    ifstream readfile(file_name);
    string line;
    vector<string> split;

    getline(readfile, line);
    split = T2D::string_split(line, ' ');
    LayoutMinMax.minx = atof(split[0].c_str());
    LayoutMinMax.miny = atof(split[1].c_str());
    LayoutMinMax.maxx = atof(split[2].c_str());
    LayoutMinMax.maxy = atof(split[3].c_str());
    LayoutMinMax.minz = atof(split[4].c_str());
    LayoutMinMax.maxz = atof(split[5].c_str());
    /*cout << LayoutMinMax.minx << "\t";
    cout << LayoutMinMax.miny << "\t";
    cout << LayoutMinMax.maxx << "\t";
    cout << LayoutMinMax.maxy << "\t";
    cout << LayoutMinMax.minz << "\t";
    cout << LayoutMinMax.maxz << endl;*/
    LayoutData10by10.clear();
    while(getline(readfile, line)){
        if(line == "~!@#$%^&*()_++_)(*&^%$#@!~") break;
        split = T2D::string_split(line, ' ');
        this->row = atoi(split[9].c_str());
        this->col = atoi(split[10].c_str());

        buf_ldata10by10.checking = false;
        buf_ldata10by10.layername = split[0];
        buf_ldata10by10.layernum = atoi(split[1].c_str());
        buf_ldata10by10.datatype = atoi(split[2].c_str());
        buf_ldata10by10.color.r = atoi(split[3].c_str());
        buf_ldata10by10.color.g = atoi(split[4].c_str());
        buf_ldata10by10.color.b = atoi(split[5].c_str());
        buf_ldata10by10.color.a = atoi(split[6].c_str());
        buf_ldata10by10.bot = atof(split[7].c_str());
        buf_ldata10by10.top = atof(split[8].c_str());

        buf_xy10by10.resize(row);
        for(int i = 0 ; i < row ; i++){
            buf_xy10by10[i].resize(col);
        }
        for(int i = 0 ; i < row*col ; i++){
            getline(readfile, line);
            split = T2D::string_split(line, ' ');
            int nr = atoi(split[0].c_str());
            int nc = atoi(split[1].c_str());
            int nsize = atoi(split[2].c_str());

            buf_xy.clear();
            for(int i = 0 ; i < nsize ; i++){
                getline(readfile, line);
                split = T2D::string_split(line, ' ');
                B_BOX buf;
                buf.minx = atof(split[0].c_str());
                buf.miny = atof(split[1].c_str());
                buf.maxx = atof(split[2].c_str());
                buf.maxy = atof(split[3].c_str());
                buf_xy.push_back(buf);
            }
            buf_xy10by10[nr][nc] = buf_xy;
        }
        buf_ldata10by10.xy = buf_xy10by10;
        LayoutData10by10.push_back(buf_ldata10by10);

        string m_key = to_string(buf_ldata10by10.layernum)+"."+to_string(buf_ldata10by10.datatype);
        map_LayoutData10by10_.insert({m_key, buf_ldata10by10});
    }
    HierarchyInstance.clear();
    while(getline(readfile, line)){
        split = T2D::string_split(line, ' ');
        Instance buf_instance;
        buf_instance.level = atoi(split[0].c_str());
        buf_instance.name = split[1];
        buf_instance.num = split[2];
        buf_instance.box.minx = atof(split[3].c_str());
        buf_instance.box.miny = atof(split[4].c_str());
        buf_instance.box.maxx = atof(split[5].c_str());
        buf_instance.box.maxy = atof(split[6].c_str());
        HierarchyInstance.push_back(buf_instance);
        //cout << buf_instance.name << endl;
    }

}

vector<string> T2D::string_split(string input, char delimiter) {
    vector<string> answer;
    stringstream ss(input);
    string temp;

    while(getline(ss, temp, delimiter)) {
        if(temp != ""){
            answer.push_back(temp);
        }
    }

    return answer;
}
!@hash[]!@file[]./ToyCAD/Src/toycaddata.cpp!@hash[]!@code[]#include "toycaddata.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>

#include <QDebug>
#include <QFile>

using namespace std;

ToyCADData::ToyCADData()
{
    this->scale = 0.0;
}

ToyCADData::~ToyCADData()
{
    this->cad_data.clear();
}

void ToyCADData::loadToyCADData(const std::string& file_path){
    if (!QFile::exists(file_path.c_str())) {
        cerr << "File is not exist @ ToyCADData - " << file_path << endl;
        return;
    }

    ifstream readfile(file_path);

    string line;
    vector<string> tokens;
    string token;
    TOYCAD_DATA cur_data;

    getline(readfile, line); //bbox line
    stringstream ss(line);
    while( getline(ss, token, ',')){
        tokens.push_back(token);
    }
    this->data_bbox.min_x = stof(tokens[TOYCAD_BBOX_IDX_MINX]);
    this->data_bbox.min_y = stof(tokens[TOYCAD_BBOX_IDX_MINY]);
    this->data_bbox.min_z = stof(tokens[TOYCAD_BBOX_IDX_MINZ]);
    this->data_bbox.max_x = stof(tokens[TOYCAD_BBOX_IDX_MAXX]);
    this->data_bbox.max_y = stof(tokens[TOYCAD_BBOX_IDX_MAXY]);
    this->data_bbox.max_z = stof(tokens[TOYCAD_BBOX_IDX_MAXZ]);
    this->calculateScale();

    getline(readfile, line);//column header line
    while(getline(readfile, line)){
        tokens.clear();
        stringstream ss(line);
        while( getline(ss, token, ',')){
            tokens.push_back(token);
        }

        cur_data.type = tokens[TOYCAD_DATA_IDX_TYPE];
        cur_data.layer = tokens[TOYCAD_DATA_IDX_LAYER];
        cur_data.minx = stof(tokens[TOYCAD_DATA_IDX_MINX]);
        cur_data.miny = stof(tokens[TOYCAD_DATA_IDX_MINY]);
        cur_data.maxx = stof(tokens[TOYCAD_DATA_IDX_MAXX]);
        cur_data.maxy = stof(tokens[TOYCAD_DATA_IDX_MAXY]);
        cur_data.minz = stof(tokens[TOYCAD_DATA_IDX_MINZ]);
        cur_data.maxz = stof(tokens[TOYCAD_DATA_IDX_MAXZ]);
        cur_data.color_r = stoi(tokens[TOYCAD_DATA_IDX_COLOR_R]);
        cur_data.color_g = stoi(tokens[TOYCAD_DATA_IDX_COLOR_G]);
        cur_data.color_b = stoi(tokens[TOYCAD_DATA_IDX_COLOR_B]);
        cur_data.color_a = stoi(tokens[TOYCAD_DATA_IDX_COLOR_A]);
        cur_data.slopex = stof(tokens[TOYCAD_DATA_IDX_SLOPEX]);
        cur_data.slopey = stof(tokens[TOYCAD_DATA_IDX_SLOPEY]);
        cur_data.rotation_degree = stof(tokens[TOYCAD_DATA_IDX_ROTATE]);

        this->cad_data.push_back(cur_data);

    }//while(getline(readfile, line)){
    printAllData();
}

void ToyCADData::calculateScale(){
    double diff_x = this->data_bbox.max_x - this->data_bbox.min_x;
    double diff_y = this->data_bbox.max_y - this->data_bbox.min_y;
    double diff_z = this->data_bbox.max_z - this->data_bbox.min_z;

    double diff_max = diff_x > diff_y ? diff_x : diff_y;
    diff_max = diff_max > diff_z ? diff_max : diff_z;

    this->scale = 1.0f / diff_max;
}

void ToyCADData::printAllData(){
    qDebug() << "ToyCADData :: printAllData()";
    for(auto cur : this->cad_data){
        qDebug() << cur.type.c_str() << ", "
                 << cur.layer.c_str() << ", "
                 << cur.minx << ", "
                 << cur.miny << ", "
                 << cur.maxx << ", "
                 << cur.maxy << ", "
                 << cur.minz << ", "
                 << cur.maxz << ", "
                 << cur.color_r << ", "
                 << cur.color_g << ", "
                 << cur.color_b << ", "
                 << cur.slopex << ", "
                 << cur.slopey << ", "
                 << cur.rotation_degree;
    }
}
!@hash[]!@file[]./ToyCAD/Src/toycadmodel.cpp!@hash[]!@code[]#include <vulkan/vulkan.h>

#include "toycadmodel.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>
#include <cassert>
#include <cmath>

#include <QFile>

using namespace std;

const double PI = 3.141591;
const double RANDIAN_FACTOR = PI / 180.0;

ToyCADModel::ToyCADModel(LveDevice& device, TOYCAD_DATA& toycad_data)
    : lveDevice{device}{
    this->model_type = MODEL_TYPE_TOY_CAD;
    num_points_for_circle = 20;
    this->makeRenderingData(toycad_data);
    this->createBuffers();
}
ToyCADModel::~ToyCADModel(){
    this->destroyBuffers();
    this->vertices.clear();
    this->indices_face.clear();
    this->indices_edge.clear();
}

void ToyCADModel::makeRenderingData(TOYCAD_DATA& toycad_data){
       //this->loadData();
    this->toycad_datatype = getCurDataType(toycad_data.type);
    this->makeVertices(toycad_data);
    this->makeIndices();
}

void ToyCADModel::makeVertices(TOYCAD_DATA& toycad_data){
    if(this->toycad_datatype == TOYCAD_TYPE_RECT) makeRectVertices(toycad_data);
    else if(this->toycad_datatype == TOYCAD_TYPE_CIRCLE) makeCircleVertices(toycad_data);
    else if(this->toycad_datatype == TOYCAD_TYPE_FAN) makeFanVertices(toycad_data);
    else if(this->toycad_datatype == TOYCAD_TYPE_HEXAGON) makeHexagonVertices(toycad_data);
    else if(this->toycad_datatype == TOYCAD_TYPE_OCTAGON) makeOctagonVertices(toycad_data);
    else{}
}

void ToyCADModel::makeRectVertices(TOYCAD_DATA& toycad_data){
    int num_of_vertex = 8;
    ToyCADVertex vertex[num_of_vertex];

    double length_x = (toycad_data.maxx - toycad_data.minx);
    double length_y = (toycad_data.maxy - toycad_data.miny);
    double length_z = (toycad_data.maxz - toycad_data.minz);
    double half_length_x = length_x*0.5;
    double half_length_y = length_y*0.5;
    double height = toycad_data.maxz - toycad_data.minz;
    double delta_x = height*tan(RANDIAN_FACTOR*toycad_data.slopex);
    double delta_y = height*tan(RANDIAN_FACTOR*toycad_data.slopey);
    if( delta_x < -half_length_x) delta_x = -half_length_x;
    if( delta_y < -half_length_y) delta_y = -half_length_y;

    double min_x = 0;
    double max_x = length_x;
    double min_y = 0;
    double max_y = length_y;
    double min_z = 0;
    double max_z = length_z;

    vertex[0].position = {min_x, max_y, max_z};
    vertex[1].position = {max_x, max_y, max_z};
    vertex[2].position = {max_x, min_y, max_z};
    vertex[3].position = {min_x, min_y, max_z};

    vertex[4].position = {min_x - delta_x, max_y + delta_y, min_z};
    vertex[5].position = {max_x + delta_x, max_y + delta_y, min_z};
    vertex[6].position = {max_x + delta_x, min_y - delta_y, min_z};
    vertex[7].position = {min_x - delta_x, min_y - delta_y, min_z};

    for(int i = 0; i < num_of_vertex; ++i)
        this->vertices.push_back(vertex[i]);
}

void ToyCADModel::makeCircleVertices(TOYCAD_DATA& toycad_data){
    int num_of_vertex = this->num_points_for_circle;
    ToyCADVertex vertex;

    double length_x = (toycad_data.maxx - toycad_data.minx);
    double length_y = (toycad_data.maxy - toycad_data.miny);
    double length_z = (toycad_data.maxz - toycad_data.minz);
    if( length_x < length_y ) length_y = length_x;
    else length_x = length_y;

    double radius_top = length_x*0.5;
    double height = toycad_data.maxz - toycad_data.minz;
    double delta = height*tan(RANDIAN_FACTOR*toycad_data.slopex);

    if( delta < -radius_top) delta = -radius_top;
    double radius_bottom = radius_top + delta;

    double cen_x = length_x*0.5;
    double cen_y = length_y*0.5;
    double angle = RANDIAN_FACTOR*360.0/(double)num_of_vertex;

    ToyCADVertex vertex_top_center;
    vertex_top_center.position = {cen_x, cen_y, length_z};
    this->vertices.push_back(vertex_top_center);
    for(int i = 0; i < num_of_vertex; ++i){
        vertex.position = {
            cen_x+radius_top*cos(angle*i),
            cen_y+radius_top*sin(angle*i),
            length_z};
        this->vertices.push_back(vertex);
    }

    ToyCADVertex vertex_bottom_center;
    vertex_bottom_center.position = {cen_x, cen_y, 0};
    this->vertices.push_back(vertex_bottom_center);
    for(int i = 0; i < num_of_vertex; ++i){
        vertex.position = {
            cen_x+radius_bottom*cos(angle*i),
            cen_y+radius_bottom*sin(angle*i),
            0};
        this->vertices.push_back(vertex);
    }
}

void ToyCADModel::makeFanVertices(TOYCAD_DATA& toycad_data){(void)toycad_data;}
void ToyCADModel::makeHexagonVertices(TOYCAD_DATA& toycad_data){(void)toycad_data;}
void ToyCADModel::makeOctagonVertices(TOYCAD_DATA& toycad_data){(void)toycad_data;}


void ToyCADModel::makeIndices(){
    if(this->toycad_datatype == TOYCAD_TYPE_RECT) makeRectIndices();
    else if(this->toycad_datatype == TOYCAD_TYPE_CIRCLE) makeCircleIndices();
    else if(this->toycad_datatype == TOYCAD_TYPE_FAN) makeFanIndices();
    else if(this->toycad_datatype == TOYCAD_TYPE_HEXAGON) makeHexagonIndices();
    else if(this->toycad_datatype == TOYCAD_TYPE_OCTAGON) makeOctagonIndices();
    else{
    }
}


void ToyCADModel::makeRectIndices(){
    //face
    std::vector<uint32_t>& face = this->indices_face;

    face.push_back(0); face.push_back(1); face.push_back(2);
    face.push_back(2); face.push_back(3); face.push_back(0);//top

    face.push_back(3); face.push_back(2); face.push_back(6);
    face.push_back(6); face.push_back(7); face.push_back(3);//front

    face.push_back(0); face.push_back(3); face.push_back(7);
    face.push_back(7); face.push_back(4); face.push_back(0);//left

    face.push_back(1); face.push_back(5); face.push_back(6);
    face.push_back(6); face.push_back(2); face.push_back(1);//right

    face.push_back(0); face.push_back(4); face.push_back(5);
    face.push_back(5); face.push_back(1); face.push_back(0);//back

    face.push_back(4); face.push_back(7); face.push_back(6);
    face.push_back(6); face.push_back(5); face.push_back(4);//bottom

    //edge
    std::vector<uint32_t>& edge = this->indices_edge;
    edge.push_back(0); edge.push_back(1);
    edge.push_back(1); edge.push_back(2);
    edge.push_back(2); edge.push_back(3);
    edge.push_back(3); edge.push_back(0);//top

    edge.push_back(4); edge.push_back(5);
    edge.push_back(5); edge.push_back(6);
    edge.push_back(6); edge.push_back(7);
    edge.push_back(7); edge.push_back(4);//bottom

    edge.push_back(0); edge.push_back(4);
    edge.push_back(1); edge.push_back(5);
    edge.push_back(2); edge.push_back(6);
    edge.push_back(3); edge.push_back(7);//side


}

void ToyCADModel::makeCircleIndices(){
    unsigned int num_of_vertex = this->num_points_for_circle;
    //face
    std::vector<uint32_t>& face = this->indices_face;
    //top circle
    uint32_t cen_idx = 0;
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        face.push_back(cen_idx); face.push_back(i); face.push_back(i+1);
    }
    face.push_back(cen_idx); face.push_back(num_of_vertex); face.push_back(1);

    //bottom circle
    cen_idx = this->num_points_for_circle+1;
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        face.push_back(cen_idx); face.push_back(cen_idx+i); face.push_back(cen_idx+i+1);
    }
    face.push_back(cen_idx); face.push_back(cen_idx+num_of_vertex); face.push_back(cen_idx+1);

    //side
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        face.push_back(i); face.push_back(i+1); face.push_back(i+1+num_of_vertex);
        face.push_back(i+1+num_of_vertex); face.push_back(i+2+num_of_vertex); face.push_back(i+1);
    }
    face.push_back(num_of_vertex); face.push_back(1); face.push_back(num_of_vertex*2+1);
    face.push_back(num_of_vertex*2+1); face.push_back(num_of_vertex+2); face.push_back(1);

    //edge
    std::vector<uint32_t>& edge = this->indices_edge;
    //top
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        edge.push_back(i); edge.push_back(i+1);
    }
    edge.push_back(num_of_vertex); edge.push_back(1);

    //bottom
    for(unsigned int i = 1; i < num_of_vertex; ++i){
        edge.push_back(num_of_vertex+1+i); edge.push_back(num_of_vertex+1+i+1);
    }
    edge.push_back(num_of_vertex*2+1); edge.push_back(num_of_vertex+1+1);
}

void ToyCADModel::makeFanIndices(){}
void ToyCADModel::makeHexagonIndices(){}
void ToyCADModel::makeOctagonIndices(){}


int ToyCADModel::getCurDataType(std::string& str_type){
    TOYCAD_TYPE_LIST type;
    if(str_type == "rect") type = TOYCAD_TYPE_RECT;
    else if(str_type == "circle") type = TOYCAD_TYPE_CIRCLE;
    else if(str_type == "fan") type = TOYCAD_TYPE_FAN;
    else if(str_type == "hexagon") type = TOYCAD_TYPE_HEXAGON;
    else if(str_type == "octagon") type = TOYCAD_TYPE_OCTAGON;
    else type = TOYCAD_TYPE_DEFAULT;

    return type;
}

void ToyCADModel::createBuffers(){
    createVertexBuffer(this->vertices, this->vertexBuffer, this->vertexBufferMemory);
    createIndexBuffer(this->indices_face, this->indexBufferForFace, this->indexBufferMemoryForFace);
    createIndexBuffer(this->indices_edge, this->indexBufferForEdge, this->indexBufferMemoryForEdge);
}

void ToyCADModel::destroyBuffers(){
    vkDestroyBuffer(lveDevice.device(), vertexBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), vertexBufferMemory, nullptr);
    vkDestroyBuffer(lveDevice.device(), indexBufferForFace, nullptr);
    vkFreeMemory(lveDevice.device(), indexBufferMemoryForFace, nullptr);
    vkDestroyBuffer(lveDevice.device(), indexBufferForEdge, nullptr);
    vkFreeMemory(lveDevice.device(), indexBufferMemoryForEdge, nullptr);
}

void ToyCADModel::createVertexBuffer(
        const std::vector<ToyCADVertex>& vertices,
        VkBuffer& buffer,
        VkDeviceMemory& memory){
    uint32_t vertexCount = static_cast<uint32_t>(vertices.size());
    assert(vertexCount >= 3 && "Vertex count must be at least 3");

    VkDeviceSize bufferSize = sizeof(vertices[0]) * vertexCount;
    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, vertices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);

}
void ToyCADModel::createIndexBuffer(
        const std::vector<uint32_t>& indices,
        VkBuffer & buffer,
        VkDeviceMemory & memory){
    assert( !indices.empty() && "Index size can't be zero");

    VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();
    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                stagingBuffer,
                stagingBufferMemory);

    void* data;
    vkMapMemory(lveDevice.device(), stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, indices.data(), (size_t)bufferSize);
    vkUnmapMemory(lveDevice.device(), stagingBufferMemory);

    lveDevice.createBuffer(
                bufferSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                buffer,
                memory);

    lveDevice.copyBuffer(stagingBuffer, buffer, bufferSize);

    vkDestroyBuffer(lveDevice.device(), stagingBuffer, nullptr);
    vkFreeMemory(lveDevice.device(), stagingBufferMemory, nullptr);
}

void ToyCADModel::bindVertexBuffer(VkCommandBuffer commandBuffer){
    VkBuffer buffers[] = {vertexBuffer};
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
}

void ToyCADModel::bindIndexBufferForFace(VkCommandBuffer commandBuffer){
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForFace, 0, VK_INDEX_TYPE_UINT32);
}

void ToyCADModel::bindIndexBufferForEdge(VkCommandBuffer commandBuffer){
    vkCmdBindIndexBuffer(commandBuffer, this->indexBufferForEdge, 0, VK_INDEX_TYPE_UINT32);
}

void ToyCADModel::drawForFace(VkCommandBuffer commandBuffer){
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_face.size()), 1, 0, 0, 0);
}

void ToyCADModel::drawForEdge(VkCommandBuffer commandBuffer){
    vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(this->indices_edge.size()), 1, 0, 0, 0);
}

std::vector<VkVertexInputBindingDescription> ToyCADModel::ToyCADVertex::getBindingDescriptions() {
    std::vector<VkVertexInputBindingDescription> bindingDescriptions(1);
    bindingDescriptions[0].binding = 0;
    bindingDescriptions[0].stride = sizeof(ToyCADVertex);
    bindingDescriptions[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    return bindingDescriptions;
}

std::vector<VkVertexInputAttributeDescription> ToyCADModel::ToyCADVertex::getAttributeDescriptions() {
    std::vector<VkVertexInputAttributeDescription> attributeDescriptions(2);
    attributeDescriptions[0].binding = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset = offsetof(ToyCADVertex, position);

    attributeDescriptions[1].binding = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[1].offset = offsetof(ToyCADVertex, color);
    return attributeDescriptions;
}

void ToyCADModel::test(){
    qDebug() << "test ToyCAD model";
}
!@hash[]!@file[]./all_data.cpp!@hash[]!@code[]#include "all_data.h"
#include <QString>
#include <QTextStream>
#include <QFileDialog>
#include <QVector>

all_data::all_data(QObject *parent) :
    QObject(parent)
{

}

all_data::~all_data()
{

}


void all_data::receiveSelectFileName(QString file_name)
{
    int row = 0;
    int column = 0;
    QFile file(file_name);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;
    QString getLine;
    QStringList list;
    QTextStream fileStream(&file);
    while (!fileStream.atEnd()) {
            getLine.append(fileStream.readLine());
            getLine.append(" ");
            list << (getLine.split(" ", Qt::SkipEmptyParts));
            row++;
            getLine.clear();
    }   // while End

    column = list.count()/row;

    for(int i=0 ; i<row ; i++)
    {
           QVector <QString> tempvector;
           for(int j=0 ; j<column ; j++)
           {
               int num1;
               num1 = j + column*i;
               tempvector.append(list[num1]);
           }
           inputDataVector.append(tempvector);
    }
    emit sendSplitData(row, column, inputDataVector);
    return;
}
!@hash[]!@file[]./dev_dialog.cpp!@hash[]!@code[]#include "dev_dialog.h"
#include "ui_dev_dialog.h"
#include <QDebug>

DevDialog::DevDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::DevDialog)
{
    ui->setupUi(this);
    ui->checkBox_pos->setChecked(true);
}

DevDialog::~DevDialog()
{
    delete ui;
}

void DevDialog::sendParameter(bool *is_pos_checked_, POS_MONITORING *pos_)
{
    is_pos_checked = is_pos_checked_;
    pos = pos_;
    init_check = true;
}


void DevDialog::changePos()
{
//    QString position;
//    position = "(" + QString::number(pos->x) + "," + QString::number(pos->y) + "," + QString::number(pos->z) + ")";
//    ui->label_pos->setText(position);
}

void DevDialog::on_checkBox_pos_stateChanged(int arg1)
{
    if(init_check)
    {
        if(ui->checkBox_pos->isChecked())
        {
            *is_pos_checked = true;
        }
        else
        {
            *is_pos_checked = false;
        }
    }
}
!@hash[]!@file[]./filedb.cpp!@hash[]!@code[]#include "filedb.h"
#include <QFile>
#include <QVector>
#include <QTextStream>
#include <QList>
#include <QDebug>

FileDb::FileDb()
{

}

void FileDb::openFile(QString fileNameInfo,QVector<QList<float>> &vecList,
                      float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize)
{    
    QFile file(fileNameInfo);

    if (file.open(QIODevice::ReadOnly) | (QIODevice::Text))
    {
        QTextStream openFile(&file);
        while(!openFile.atEnd())
        {
            auto dataString = openFile.readLine().split(",");
            QList<float> data;
            for (auto &tempdata : dataString)
            {
                 data.append(tempdata.toFloat());
            }
            vecList.push_back(data);
            qDebug()<< "strVector : " << data;

            if(data.size() == 8)
            {
                if(xMinSize > data[2]){xMinSize = data[2];}
                if(yMinSize > data[3]){yMinSize = data[3];}
                if(xMaxSize < data[4]){xMaxSize = data[4];}
                if(yMaxSize < data[5]){yMaxSize = data[5];}
            }
        }
        file.close();
    }
    else
    {        
        return;
    }

    return;

}
!@hash[]!@file[]./formhier.cpp!@hash[]!@code[]//#include "/Rendering/Src/LayoutPEXData.h"
#include "formhier.h"
#include "ui_formhier.h"
#include "mainwindow.h"

FormHier::FormHier(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormHier)
{
    ui->setupUi(this);

}

FormHier::~FormHier()
{
    delete ui;
}

void FormHier::createHierarchyTree(T2D *t2d){

    this->t2d = t2d;
    vector<QTreeWidgetItem*> m_buf_tree_item;
    QTreeWidgetItem* m_top_tree = new QTreeWidgetItem(ui->hierarchy_tree);
    m_buf_tree_item.resize(99);
    m_buf_tree_item[0] = m_top_tree;
    string m_top_cell_name = this->t2d->HierarchyInstance[0].name + " (" + this->t2d->HierarchyInstance[0].num + ") ";
    m_top_tree->setText(0, QString::fromStdString(m_top_cell_name));
    m_top_tree->setText(1, QString::fromStdString(to_string(0)));
    ui->hierarchy_tree->addTopLevelItem(m_top_tree);

    for(int i = 1 ; i < t2d->HierarchyInstance.size() ; i++){
        int m_level = t2d->HierarchyInstance[i].level;
        string m_cell_name = t2d->HierarchyInstance[i].name + " (" + t2d->HierarchyInstance[i].num + ") ";

        QTreeWidgetItem* m_child_tree = new QTreeWidgetItem();
        m_child_tree->setText(0, QString::fromStdString(m_cell_name));
        m_child_tree->setText(1, QString::fromStdString(to_string(i)));
        m_buf_tree_item[m_level] = m_child_tree;

        m_buf_tree_item[m_level - 1]->addChild(m_child_tree);
    }

//    PEXResistorDataManager::getResistorsOfNode();
//    for (auto& loop : resistors_of_node[0]){
//        qDebug() << "loop test XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
//    }
}

void FormHier::on_hierarchy_tree_itemDoubleClicked(QTreeWidgetItem *item, int column)
{
    cout << "minx : " << this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.minx;
    cout << " miny : " << this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.miny;
    cout << " maxx : " << this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.maxx;
    cout << " maxy : " << this->t2d->HierarchyInstance[atoi(item->text(column+1).toStdString().c_str())].box.maxy << endl;

}

void FormHier::on_hierarchy_searching_textEdited(const QString &arg1)
{
//    QString m_input_text = ui->hierarchy_searching->text();
//    QList<QTreeWidgetItem*> m_all_list = ui->hierarchy_tree->findItems("", Qt::MatchContains | Qt::MatchRecursive, 0);
//    if(m_input_text != ""){
//        for (QTreeWidgetItem *item : m_all_list) {
//            item->setTextColor(0, Qt::black);
//        }
//        QList<QTreeWidgetItem*> clist = ui->hierarchy_tree->findItems(m_input_text, Qt::MatchContains | Qt::MatchRecursive, 0);
//        ui->hierarchy_tree->clear();
//        for (QTreeWidgetItem *item : clist) {
//            item->setTextColor(0, Qt::red);
//        }
//    }else{
//        for (QTreeWidgetItem *item : m_all_list) {
//            item->setTextColor(0, Qt::black);
//        }
//    }

//    QTreeWidgetItemIterator it(ui->hierarchy_tree);
//    while(*it){
//        if((*it)->text(0).contains(arg1, Qt::CaseInsensitive)){
//            (*it)->setHidden(false);
//        }else{
//            (*it)->setHidden(true);
//        }
//        ++it;
//    }

//    QSortFilterProxyModel* m_tree_model = new QSortFilterProxyModel(this);
//    m_tree_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
//    m_tree_model->setSourceModel(ui->hierarchy_tree->model());
//    ui->hierarchy_tree->setModel(m_tree_model);

//    m_tree_model->setFilterRegExp(QRegExp(arg1, Qt::CaseInsensitive, QRegExp::FixedString));
    QString m_hierarchy_searching_text = arg1;

    if(m_hierarchy_searching_text.contains('*')){
        m_hierarchy_searching_text.replace("*", ".*", Qt::CaseInsensitive);
        QRegExp m_regex(m_hierarchy_searching_text, Qt::CaseInsensitive);
        QTreeWidgetItemIterator it(ui->hierarchy_tree);
        while(*it){
            if(m_regex.exactMatch((*it)->text(0))){
                QTreeWidgetItem* item = *it;
                while(item){
                    item->setExpanded(true);
                    item->setHidden(false);
                    item = item->parent();
                }
            }else{
                (*it)->setHidden(true);
            }
            ++it;
        }
    } else{
        QTreeWidgetItemIterator it(ui->hierarchy_tree);
        while(*it){
            if((*it)->text(0).contains(m_hierarchy_searching_text, Qt::CaseInsensitive)){
                QTreeWidgetItem* item = *it;
                while(item){
                    item->setExpanded(true);
                    item->setHidden(false);
                    item = item->parent();
                }
            }else{
                (*it)->setHidden(true);
            }
            ++it;
        }
    }
}












!@hash[]!@file[]./forminfo.cpp!@hash[]!@code[]#include "forminfo.h"
#include "ui_forminfo.h"
#include <QDebug>
#include <QPushButton>
#include "cmath"
#include "defineParam.h"
#include <string>
#include <QDoubleValidator>
#include <QIntValidator>


FormInfo::FormInfo(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormInfo)
{
    ui->setupUi(this);    

    //숫자 제약 설정
    QDoubleValidator *validator_pos = new QDoubleValidator(-9999.0,9999.0,4,this);
    QIntValidator *validator_tilt = new QIntValidator(-90,90,this);
    QIntValidator *validator_rot = new QIntValidator(0,359,this);
    QDoubleValidator *validator_zoom = new QDoubleValidator(0,9999.0,4,this);
    ui->pos_x       ->setValidator(validator_pos);
    ui->pos_y       ->setValidator(validator_pos);
    ui->pos_z       ->setValidator(validator_pos);
    ui->ang_tilt    ->setValidator(validator_tilt);
    ui->ang_rotation->setValidator(validator_rot);
    ui->zoom        ->setValidator(validator_zoom);

    this->setEnabled(false);
    //edit 값 초기화
    setTextPosTotal(&TEMP_POS);
}

FormInfo::~FormInfo()
{
    delete ui;
}

void FormInfo::setTextPosTotal(POS_MONITORING *pos)
{
    if(isFileOpen)
    {
        double rot = pos->rotation;
        if (rot <0) {
            rot = rot+360;
        }
        QString str_rot = QString::number(rot);
        setTextTrim(ui->pos_x, &pos->x, 1, "");
        setTextTrim(ui->pos_y, &pos->y, 1, "");
        setTextTrim(ui->pos_z, &pos->z, 1, "");
        setTextTrim(ui->ang_tilt, &pos->tilt, 1, "");
        setTextTrim(ui->ang_rotation, str_rot);
        setTextTrim(ui->zoom, &pos->zoom, 100, "%");
    }
    else
    {
        setTextTrim(ui->pos_x, "");
        setTextTrim(ui->pos_y, "");
        setTextTrim(ui->pos_z, "");
        setTextTrim(ui->ang_tilt, "");
        setTextTrim(ui->ang_rotation, "");
        setTextTrim(ui->zoom, "");
    }
}

void FormInfo::receiveFile(T2D &t2d)
{
    isFileOpen = true;
    rendering_full = &t2d;
    this->setEnabled(true);
}

void FormInfo::receivePointPos(POS_MONITORING &pos)
{
    this->POS = &pos;
    TEMP_POS = pos;         //TEMP_POS 역할 : enter 를 누르기 전까지 값을 갖고 있는 저장소
}

void FormInfo::changePos()
{
    if (isEndedEdit)
    {
        TEMP_POS = *POS;
        setTextPosTotal(POS);
    }
}

void FormInfo::addItemToPosList(POS_SET *position_item)    //POS_STACK 에 position 넣기
{
    POS_STACK.push_back(*position_item);
    item_data_i = POS_STACK.size() - 1 ;
    addItemToListWidget();
}

void FormInfo::addItemToListWidget()
{
    QListWidgetItem *widgetItem = new QListWidgetItem(QString::fromStdString(POS_STACK[item_data_i].name),ui->listWidget);
    widgetItem->setFlags (widgetItem->flags() | Qt::ItemIsEditable);
    widgetItem->setData(Qt::UserRole,item_data_i);
}

void FormInfo::setTextTrim(QLineEdit *text, double *value, int scale_, QString add_text_)
{
    text->setText(QString::number(round(*value*10000)/10000*scale_)+add_text_);
}

void FormInfo::setTextTrim(QLineEdit *text, QString text_)
{
    text->setText(text_);
}

void FormInfo::makePosListItem()
{
    std::string temp_str = "position";
    pos_number += 1;
    temp_str.append(to_string(pos_number));
    POS_SET TEMP;
    TEMP.name = temp_str;
    TEMP.position = *POS;
    addItemToPosList(&TEMP);
}

QString FormInfo::makePosText()
{
    QString msg;
    if(current_item != -1 && make_status_bar_msg)
    {
        int i = ui->listWidget->currentItem()->data(Qt::UserRole).toInt();
        msg =       QString::fromStdString(POS_STACK[i].name) + " :"
        + " ( " +      QString::number(POS_STACK[i].position.x) + ", "
        +              QString::number(POS_STACK[i].position.y) + ", "
        +              QString::number(POS_STACK[i].position.z) + " )"
        + " tilt : " + QString::number(POS_STACK[i].position.tilt)
        + " rot : "  + QString::number(POS_STACK[i].position.rotation)
        + " zoom : " + QString::number(POS_STACK[i].position.zoom * 100) + "%";
    }
    else{
        msg = "";
    }
    return msg;
}

void FormInfo::sendStatusBarMsg(QString msg)
{
    signalStatusBarMsg(msg);

}

void FormInfo::inputValueToTemp(double *point, double value_)
{
    *point = value_;
}

void FormInfo::convertTextToValue(double *point, const QString &arg1)
{
    double double_arg = arg1.toDouble();
    inputValueToTemp(point, double_arg);
}

void FormInfo::inputPos()       //직접 입력한 값을 POS 구조체에 넣음
{
    if(isFileOpen)
    {
        isEndedEdit = false;
        *POS = TEMP_POS;
        emit signalDirectlyInputPos();
        makePosListItem();
        isEndedEdit = true;
    }
}

//입력이 들어왔을 때
void FormInfo::on_pos_x_textEdited(const QString &arg1)         {convertTextToValue(&TEMP_POS.x,arg1);}
void FormInfo::on_pos_y_textEdited(const QString &arg1)         {convertTextToValue(&TEMP_POS.y,arg1);}
void FormInfo::on_pos_z_textEdited(const QString &arg1)         {convertTextToValue(&TEMP_POS.z,arg1);}
void FormInfo::on_ang_tilt_textEdited(const QString &arg1)      {convertTextToValue(&TEMP_POS.tilt,arg1);}
void FormInfo::on_ang_rotation_textEdited(const QString &arg1)  {convertTextToValue(&TEMP_POS.rotation,arg1);}
void FormInfo::on_zoom_textEdited(const QString &arg1)
{   //zoom 은 100% 일 경우 1 값을 넣어야 하기 때문에 따로 처리
    double double_arg = arg1.toDouble();
    double_arg = double_arg/100;
    inputValueToTemp(&TEMP_POS.zoom,double_arg);
}

//enter 가 눌리거나 focus 를 잃을 때 TEMP_POS 에 있는 값을 출력함
void FormInfo::on_pos_x_editingFinished()       {setTextTrim(ui->pos_x, &TEMP_POS.x, 1, "");}
void FormInfo::on_pos_y_editingFinished()       {setTextTrim(ui->pos_y, &TEMP_POS.y, 1, "");}
void FormInfo::on_pos_z_editingFinished()       {setTextTrim(ui->pos_z, &TEMP_POS.z, 1, "");}
void FormInfo::on_ang_tilt_editingFinished()    {setTextTrim(ui->ang_tilt, &TEMP_POS.tilt, 1, "");}
void FormInfo::on_ang_rotation_editingFinished(){setTextTrim(ui->ang_rotation, &TEMP_POS.rotation, 1, "");}
void FormInfo::on_zoom_editingFinished()        {setTextTrim(ui->zoom, &TEMP_POS.zoom, 100, "%");}

//enter 를 눌렀을 때 TEMP_POS 에 있는 값을 POS 에 넣고 List 를 만듬
void FormInfo::on_pos_x_returnPressed()         {inputPos();}
void FormInfo::on_pos_y_returnPressed()         {inputPos();}
void FormInfo::on_pos_z_returnPressed()         {inputPos();}
void FormInfo::on_ang_tilt_returnPressed()      {inputPos();}
void FormInfo::on_ang_rotation_returnPressed()  {inputPos();}
void FormInfo::on_zoom_returnPressed()          {inputPos();}


void FormInfo::on_listWidget_currentRowChanged(int currentRow)
{
    current_item = currentRow;
    sendStatusBarMsg(makePosText());
}

void FormInfo::on_pushButton_go_clicked()
{
    if(current_item != -1)
    {
        int i = ui->listWidget->currentItem()->data(Qt::UserRole).toInt();
        *POS = POS_STACK[i].position;
        emit signalDirectlyInputPos();
        qDebug() << "GO  : " << ui->listWidget->currentItem()->text() << "data : " << ui->listWidget->currentItem()->data(Qt::UserRole).toInt();
    }
}

void FormInfo::on_pushButton_del_clicked()
{
    if(current_item != -1)
    {
        make_status_bar_msg = false;        //삭제 과정에서 msg 보내지 않도록 방지 : segment fault error 발생
        for (auto item : selected_item)
        {
            ui->listWidget->takeItem(ui->listWidget->row(item));
        }
        make_status_bar_msg = true;         //msg 보내는 것 원복
        current_item = -1;                  //msg 에 "" 넣음
        sendStatusBarMsg(makePosText());                 //msg 출력
    }
}

void FormInfo::on_listWidget_itemChanged(QListWidgetItem *item)
{
    if(current_item != -1)
    {        
        POS_STACK[item->data(Qt::UserRole).toInt()].name = item->text().toStdString();
        sendStatusBarMsg(makePosText());
    }
}


void FormInfo::on_listWidget_itemSelectionChanged()
{
    selected_item = ui->listWidget->selectedItems();
    int sel_item = selected_item.size();
    if(sel_item > 1)
    {
        sendStatusBarMsg("selected " + QString::number(sel_item) + " items");
    }
}
!@hash[]!@file[]./formlayer.cpp!@hash[]!@code[]#include "formlayer.h"
#include "ui_formlayer.h"
#include "Rendering/Src/dtaorendersystem.h"
#include "Rendering/Src/lve_model.hpp"
#include <string>



FormLayer::FormLayer(LveWindow *w, QWidget *parent) :
    QDialog(parent), m_window(w),
    ui(new Ui::FormLayer)
{
    ui->setupUi(this);
    MakeLayerInformationTableHeader();
}

FormLayer::~FormLayer()
{
    delete ui;
}

void FormLayer::ReceiveLayerInformation(T2D &t2d)
{
    ui->tableWidget->clearContents();
    t2d_layer_information = &t2d;
    MakeLayerInformationTableHeader();
    MakeLayerInformationTalbe();
}

void FormLayer::MakeLayerInformationTalbe()
{
    // QTableWidget ??? ????
    ui->tableWidget->setColumnCount(table_default_column);
    ui->tableWidget->setRowCount(t2d_layer_information->LayoutData10by10.size());
    ui->tableWidget->setColumnWidth(5,80);

    // Table a????
    for (int i=1; i < t2d_layer_information->LayoutData10by10.size() ; i++)
    {
        MakeTableWidgetItemForText(i);
        MakeCheckBox(i);
        MakeColorButton(i);
        MakeSliderForOpacity(i);
    }
    MakeHeaderCheckBoxAndSlider();

    // Table Edit ????, ???? ???? ????
    ui->tableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);
    ui->tableWidget->setSelectionMode(QAbstractItemView::SingleSelection);
}

void FormLayer::on_checkboxInTable_stateChanged()
{
    int checkboxrow = -1;
    QCheckBox *checkboxInTable = qobject_cast<QCheckBox*>(sender());
    if (!checkboxInTable)
        return;

    checkboxrow = FindCheckBoxRow(checkboxInTable);

    if (checkboxrow == 0) {
        ChangeAllCheckBoxState(checkboxInTable);
        return;
    }

    // selected checkbox layer name
    QTableWidgetItem *readcheckbox = ui->tableWidget->item(checkboxrow,2);
    QString selectedLayer = readcheckbox->text();
    QString printLayer = "selectedLayer = " + selectedLayer;

    // selected checkbox layer num
    QTableWidgetItem *ReadLayerNumber = ui->tableWidget->item(checkboxrow,3);
    QTableWidgetItem *ReadDataType = ui->tableWidget->item(checkboxrow,4);
    string LayerNumber =ReadLayerNumber->text().toStdString() + "." + ReadDataType->text().toStdString();

    if (checkboxInTable->isChecked()) {
        ChangeCheckBoxStateToOn(checkboxrow, LayerNumber, printLayer);
    } else {
        ChangeCheckBoxStateToOff(checkboxrow, LayerNumber, printLayer);
    }
}

void FormLayer::on_colorbutton_clicked()
{
    QString OldLayerColorRed = "";
    QString OldLayerColorGreen = "";
    QString OldLayerColorBlue = "";
    QString OldLayerColorAlpha = "";
    int OldLayerColorRedNum = 0;
    int OldLayerColorGreenNum = 0;
    int OldLayerColorBlueNum = 0;
    int OldLayerColorAlphaNum = 0;
    QRgb orc = qRgba(0, 0, 0, 0);

    QPushButton *ColorCheckButton = qobject_cast<QPushButton*>(sender());

    int colorbuttonRow = ui->tableWidget->currentRow();
    data_row_for_t2d = colorbuttonRow-1;

    GetPushButtonOldColor(ColorCheckButton, &OldLayerColorRedNum, &OldLayerColorGreenNum, &OldLayerColorBlueNum, &OldLayerColorAlphaNum, &orc);
    EnterPushButtonNewColor(&colorbuttonRow, &orc);
}

void FormLayer::on_opacityslider_valueChanged(int Opacity)
{
    // ui->tableWidget->currentRow() ?? a?????? ???, current row ?? -1 ?? ????
    int sliderrow = -1;
    int sliderrow_for_t2d = -1;
    QString LayerColorname;
    QString LayerColorText;
    QSlider *OpacityInTalbe = qobject_cast<QSlider*>(sender());

    for (int i = 0; i < ui->tableWidget->rowCount(); i++) {
        QWidget *widget = ui->tableWidget->cellWidget(i, 5);
        QSlider *slider = widget->findChild<QSlider*>();

        if (slider == OpacityInTalbe) {
            sliderrow = i;
            sliderrow_for_t2d = sliderrow-1;
            if (sliderrow == 0){
                for (int k=1; k < ui->tableWidget->rowCount(); k++) {
                    QWidget *SliderChangeWidget = ui->tableWidget->cellWidget(k, 5);
                    QSlider *SliderChange = SliderChangeWidget->findChild<QSlider*>();
                    SliderChange->setValue(Opacity);
                    t2d_layer_information->LayoutData10by10[sliderrow_for_t2d].color.a = Opacity;
                    emit outputLayerStatus(empty_for_emit);
                }
            } else {
                QTableWidgetItem *ReadLayer = ui->tableWidget->item(sliderrow,2);
                QString selectedLayer = ReadLayer->text();
                QString printLayer = "selectedLayer = " + selectedLayer;
                printLayer = printLayer + "  Layer  Opacity = " + QString::number(Opacity);
                QString OldColorStyleSheet = ui->tableWidget->cellWidget(sliderrow,1)->styleSheet();
                QStringList splittext = OldColorStyleSheet.split("(");
                QString splitrgbtemp = splittext[1].remove(")");
                QStringList splitrgb = splitrgbtemp.split(",");

                QString OldLayerColorRed = splitrgb[0];
                QString OldLayerColorGreen = splitrgb[1];
                QString OldLayerColorBlue = splitrgb[2];
                QString OldLayerColorAlpha = QString::number(Opacity);

                LayerColorText = "background-color: rgba(" + OldLayerColorRed;
                LayerColorText = LayerColorText + "," + OldLayerColorGreen + "," + OldLayerColorBlue + "," + OldLayerColorAlpha + ")";
                ui->tableWidget->cellWidget(sliderrow,1)->setStyleSheet(LayerColorText);
                t2d_layer_information->LayoutData10by10[sliderrow_for_t2d].color.a = Opacity;
                emit outputLayerStatus(printLayer);

                QTableWidgetItem *ReadLayerNumber = ui->tableWidget->item(sliderrow,3);
                QTableWidgetItem *ReadDataType = ui->tableWidget->item(sliderrow,4);
                string LayerNumber =ReadLayerNumber->text().toStdString() + "." + ReadDataType->text().toStdString();
                DtaoRenderSystem *renderer = this->m_window->getRenderer();
                renderer->getCustomOpacity(LayerNumber,Opacity/(float)255);
            }
            break;
        }
    }
}

void FormLayer::OpacitySliderValueChange(int OpacityValue){

    //qDebug() << "test number ======================================= " << OpacityValue;
    emit outputLayerStatus(empty_for_emit);
}

void FormLayer::MakeLayerInformationTableHeader(){
    QString TalbeHeader[] = {"","Color","Layer\nName","Layer\nNum","Layer\nType","Opacity\n"};
    ui->tableWidget->setColumnCount(6);
    ui->tableWidget->setRowCount(10);
    ui->tableWidget->setColumnWidth(0,20);
    ui->tableWidget->setColumnWidth(1,40);
    ui->tableWidget->setColumnWidth(2,40);
    ui->tableWidget->setColumnWidth(3,40);
    ui->tableWidget->setColumnWidth(4,40);
    ui->tableWidget->setColumnWidth(5,60);

    /// TableWidget Title Format ????
    QBrush brush(QColor(255, 255, 255, 255));
    brush.setStyle(Qt::SolidPattern);
    QFont font;
    font.setPointSize(8);
    font.setBold(true);
    font.setWeight(55);

    /// TableWidget Title ??? ?? ???
    for (int i=1; i<6; i++){
        QTableWidgetItem *TableHeaderItem = new QTableWidgetItem;
        TableHeaderItem->setText(TalbeHeader[i]);
        TableHeaderItem->setTextAlignment(Qt::AlignCenter);
        TableHeaderItem->setFont(font);
        TableHeaderItem->setForeground(brush);
        ui->tableWidget->setItem(0,i,TableHeaderItem);
        ui->tableWidget->setRowHeight(0,50);
        ui->tableWidget->item(0,i)->setBackground(QBrush(QColor(100,100,100)));
    }
}

void FormLayer::MakeTableWidgetItemForText(int table_row){
    data_row_for_t2d = table_row-1;
    QTableWidgetItem *tableitem_name = new QTableWidgetItem;
    QTableWidgetItem *tableitem_num = new QTableWidgetItem;
    QTableWidgetItem *tableitem_type = new QTableWidgetItem;

    tableitem_name->setText(t2d_layer_information->LayoutData10by10[data_row_for_t2d].layername.c_str());
    tableitem_num->setText(QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].layernum));
    tableitem_type->setText(QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].datatype));

    tableitem_name->setTextAlignment(Qt::AlignCenter);
    tableitem_num->setTextAlignment(Qt::AlignCenter);
    tableitem_type->setTextAlignment(Qt::AlignCenter);

    ui->tableWidget->setItem((table_row),2,tableitem_name);
    ui->tableWidget->setItem((table_row),3,tableitem_num);
    ui->tableWidget->setItem((table_row),4,tableitem_type);
}

void FormLayer::MakeSliderForOpacity(int table_row){
    data_row_for_t2d = table_row-1;
    QSlider *OpacitySlider = new QSlider(Qt::Horizontal);
    QWidget *OpacitySliderWidget = new QWidget();
    OpacitySlider->setRange(0,255);
    OpacitySlider->setValue(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a);
    OpacitySlider->setFocusPolicy(Qt::StrongFocus);
    QHBoxLayout *OpacityLayout = new QHBoxLayout(OpacitySliderWidget);
    OpacityLayout->addWidget(OpacitySlider);
    OpacitySliderWidget->setLayout(OpacityLayout);
    ui->tableWidget->setCellWidget(table_row, 5, OpacitySliderWidget);
    QObject::connect(OpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(on_opacityslider_valueChanged(int)));
}

void FormLayer::MakeCheckBox(int table_row){
    data_row_for_t2d = table_row-1;
    QCheckBox *checkBoxItem = new QCheckBox();
    checkBoxItem->setCheckState(Qt::Unchecked);
    QWidget *checkboxWidget = new QWidget();
    QHBoxLayout *checkboxLayout = new QHBoxLayout(checkboxWidget);
    checkboxLayout->addWidget(checkBoxItem);
    checkboxLayout->setAlignment(Qt::AlignCenter);
    checkboxLayout->setContentsMargins(0,0,0,0);
    checkboxWidget->setLayout(checkboxLayout);
    ui->tableWidget->setCellWidget(table_row,0,checkboxWidget);
    QObject::connect(checkBoxItem, SIGNAL(stateChanged(int)), this, SLOT(on_checkboxInTable_stateChanged()));
}

void FormLayer::MakeColorButton(int table_row){
    QString LayerColorRed;
    QString LayerColorGreen;
    QString LayerColorBlue;
    QString LayerColorAlpha;
    QString LayerColorText;
    data_row_for_t2d = table_row-1;
    // Layer color rgb defalut value
    int DefaultRedColor = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.r;
    int DefaultGreenColor = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.g;
    int DefaultBlueColor = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.b;
    int DefaultAlpha = t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a;
    QColor DefaultColor = QColor(DefaultRedColor, DefaultGreenColor, DefaultBlueColor, DefaultAlpha);

    // Layer color rgb defalut value
    LayerColorRed = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.r);
    LayerColorGreen = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.g);
    LayerColorBlue = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.b);
    LayerColorAlpha = QString::number(t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a);

    LayerColorText = "background-color: rgba(" + LayerColorRed;
    LayerColorText = LayerColorText + "," + LayerColorGreen + "," + LayerColorBlue + "," + LayerColorAlpha + ")";

    // color pushbutton a????
    QPushButton *colorbutton = new QPushButton();
    colorbutton->setStyleSheet(LayerColorText);
    ui->tableWidget->setCellWidget(table_row,1,colorbutton);
    QObject::connect(colorbutton, SIGNAL(clicked()), this, SLOT(on_colorbutton_clicked()));
}

void FormLayer::MakeHeaderCheckBoxAndSlider(){
    //tableWidget title ?? checkbox
    QCheckBox *checkBoxItem = new QCheckBox();
    checkBoxItem->setCheckState(Qt::Unchecked);
    QWidget *checkboxWidget = new QWidget();
    QHBoxLayout *checkboxLayout = new QHBoxLayout(checkboxWidget);
    checkboxLayout->addWidget(checkBoxItem);
    checkboxLayout->setAlignment(Qt::AlignCenter);
    checkboxLayout->setContentsMargins(0,0,0,0);
    checkboxWidget->setLayout(checkboxLayout);
    ui->tableWidget->setCellWidget(0,0,checkboxWidget);
    QObject::connect(checkBoxItem, SIGNAL(stateChanged(int)), this, SLOT(on_checkboxInTable_stateChanged()));

    //tableWidget title ?? slider
    QSpacerItem *HeaderVerticalSpacer = new QSpacerItem(0,20,QSizePolicy::Fixed, QSizePolicy::Fixed);
    QSlider *HeaderOpacitySlider = new QSlider();
    HeaderOpacitySlider->setOrientation(Qt::Horizontal);
    HeaderOpacitySlider->setRange(0,255);
    HeaderOpacitySlider->setValue(200);
    QWidget *HeaderSliderWidget = new QWidget();
    QVBoxLayout *HeaderSliderLayout = new QVBoxLayout(HeaderSliderWidget);
    HeaderSliderLayout->addItem(HeaderVerticalSpacer);
    HeaderSliderLayout->addWidget(HeaderOpacitySlider);
    HeaderSliderWidget->setLayout(HeaderSliderLayout);
    ui->tableWidget->setCellWidget(0,5,HeaderSliderWidget);
    QObject::connect(HeaderOpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(on_opacityslider_valueChanged(int)));
}

int FormLayer::FindCheckBoxRow(QCheckBox *checkBoxInCell){
    QCheckBox &temp = *checkBoxInCell;
    for (int i = 0; i < ui->tableWidget->rowCount(); i++) {
        QWidget *widget = ui->tableWidget->cellWidget(i, 0);
        QCheckBox *checkbox = widget->findChild<QCheckBox*>();
        if (checkbox == &temp) {
            checkboxrow = i;
            break;
        }
    }
    return checkboxrow;
}

void FormLayer::ChangeAllCheckBoxState(QCheckBox *checkBoxInCell){
    this->m_layer_all_check = true;
    if (checkBoxInCell->isChecked()) {
        for (int i = 1; i < ui->tableWidget->rowCount(); i++) {
            data_row_for_t2d = i-1;
            QWidget *widget = ui->tableWidget->cellWidget(i, 0);
            QCheckBox *checkbox = widget->findChild<QCheckBox*>();
            checkbox->setCheckState(Qt::Checked);
            t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = true;
        }
        //qDebug() << "All Layer Checkbox Checked.";
        //emit outputLayerStatus(CommentAllCheckedCheckBox);

    } else {
        for (int i = 1; i < ui->tableWidget->rowCount(); i++) {
            data_row_for_t2d = i-1;
            QWidget *widget = ui->tableWidget->cellWidget(i, 0);
            QCheckBox *checkbox = widget->findChild<QCheckBox*>();
            checkbox->setCheckState(Qt::Unchecked);
            t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = false;
        }
        //qDebug() << "All Layer Checkbox Unchecked.";
        //emit outputLayerStatus(CommentAllUncheckedCheckBox);
    }
    this->m_layer_all_check = false;
    emit outputLayerStatus(CommentAllCheckedCheckBox);
}

void FormLayer::ChangeCheckBoxStateToOn(int check_box_row, string layer_num, QString print_comment){
    data_row_for_t2d = check_box_row-1;
    DtaoRenderSystem *renderer = this->m_window->getRenderer();
    renderer->getCustomVisiblity(layer_num, true);
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = true;
    print_comment = print_comment + "  Layer  On";
    emit outputLayerStatus(print_comment);
}

void FormLayer::ChangeCheckBoxStateToOff(int check_box_row, string layer_num, QString print_comment){
    data_row_for_t2d = check_box_row-1;
    DtaoRenderSystem *renderer = this->m_window->getRenderer();
    renderer->getCustomVisiblity(layer_num, false);
    print_comment = print_comment + "  Layer  Off";
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].checking = false;
    emit outputLayerStatus(print_comment);
}

void FormLayer::GetPushButtonOldColor(QPushButton *old_push_button, int *oldred, int *oldgreen, int *oldblue, int *oldalpha, QRgb *oldrgba){
    QPushButton &oldcolor = *old_push_button;
    QString OldColorStyleSheet = oldcolor.styleSheet();
    QStringList splittext = OldColorStyleSheet.split("(");
    QString splitrgbtemp = splittext[1].remove(")");
    QStringList splitrgb = splitrgbtemp.split(",");

    QString OldLayerColorRed = splitrgb[0];
    QString OldLayerColorGreen = splitrgb[1];
    QString OldLayerColorBlue = splitrgb[2];
    QString OldLayerColorAlpha = splitrgb[3];

    *oldred = OldLayerColorRed.toInt();
    *oldgreen = OldLayerColorGreen.toInt();
    *oldblue = OldLayerColorBlue.toInt();
    *oldalpha = OldLayerColorAlpha.toInt();

    *oldrgba = qRgba(*oldred, *oldgreen, *oldblue, *oldalpha);
}

void FormLayer::EnterPushButtonNewColor(int *selected_color_button_row, QRgb *oldrgba){
    QString LayerColorText;
    QRgb chc = QColorDialog::getRgba(*oldrgba);
    int NewColorRed = qRed(chc);
    int NewColorGreen = qGreen(chc);
    int NewColorBlue = qBlue(chc);
    int NewColorAlpha = qAlpha(chc);

    LayerColorText = "background-color: rgba(" + QString::number(NewColorRed);
    LayerColorText = LayerColorText + "," + QString::number(NewColorGreen) + "," + QString::number(NewColorBlue) + "," + QString::number(NewColorAlpha) + ")";
    ui->tableWidget->cellWidget(*selected_color_button_row,1)->setStyleSheet(LayerColorText);

    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.r = NewColorRed;
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.g = NewColorGreen;
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.b = NewColorBlue;
    t2d_layer_information->LayoutData10by10[data_row_for_t2d].color.a = NewColorAlpha;



    string LayerNumber = ui->tableWidget->item(*selected_color_button_row,3)->text().toStdString() + "." + ui->tableWidget->item(*selected_color_button_row,4)->text().toStdString();
    DtaoRenderSystem *renderer = this->m_window->getRenderer();
    renderer->getCustomColor(LayerNumber, glm::vec3 {NewColorRed/(float)255,NewColorGreen/(float)255,NewColorBlue/(float)255});

    emit outputLayerStatus(empty_for_emit);

    QWidget *SliderChangeWidget = ui->tableWidget->cellWidget(*selected_color_button_row, 5);
    QSlider *SliderChange = SliderChangeWidget->findChild<QSlider*>();
    SliderChange->setValue(NewColorAlpha);
}
!@hash[]!@file[]./formmap.cpp!@hash[]!@code[]#include "formmap.h"
#include "ui_formmap.h"
#include <QGraphicsItem>
#include <QGraphicsRectItem>
#include <QVector>
#include <iostream>
#include <QDebug>
#include <QRect>
#include <QKeyEvent>

SuperItem::SuperItem(QGraphicsItem* parent) : QGraphicsItem(parent)
{
    setFlag(QGraphicsItem::ItemIsMovable);
}

void SuperItem::getScaleValue(double *m_scale_, double *m_from_window_to_box_x_, double *m_from_window_to_box_y_, double *m_min_x_, double *m_min_y_, double *m_zoom_init_)
{
    m_scale = m_scale_;
    m_from_window_to_box_x = m_from_window_to_box_x_;
    m_from_window_to_box_y = m_from_window_to_box_y_;
    m_min_x = m_min_x_;
    m_min_y = m_min_y_;
    m_zoom_init = m_zoom_init_;
}

void SuperItem::slotMove(POS_MONITORING *pos)
{    
    //emit signalInitMove(window_width/2,-window_height/2);
    double delta_x = (pos->x - convertPosX()) * (*m_scale);
    double delta_y = (pos->y - convertPosY()) * (*m_scale);
    double rot = 360 - pos->rotation;

    if (abs(delta_x) >__DBL_EPSILON__ || abs(delta_y) > __DBL_EPSILON__) // 0보다 크면
    {        
        moveBy(delta_x, -1 * delta_y);             
    }

    QTransform trans;
    trans.rotate(rot);

    // m_zoom_init = 1um / height;
    // trans.scale = 1 um / height / pos->zoom = 1 um / height / (1 um / now_height) = now_height / height

    trans.scale((*m_zoom_init)/pos->zoom, ((*m_zoom_init)/pos->zoom) * (pos->tilt / 90));
      //zoom 초기가 25%면 ..
    setTransform(trans);
}

void SuperItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    qDebug() << "x : " << this->x() << " y : " << (-1 * this->y());
    qDebug() << "x : " << convertPosX() << " y : " << convertPosY();
}

void SuperItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    painter->setPen(Qt::red);
    painter->drawRoundedRect(-60,-60,120,120,5,5);
    painter->setPen(Qt::blue);
    painter->drawLine(-60,-60,60,-60);
}

QRectF SuperItem::boundingRect() const{ // 나중에 이해를 위한 도움 요청 필요
    return QRectF(-61,-61,122,122);
}

double SuperItem::convertPosX()
{
    return (this->x() - (*m_from_window_to_box_x))/(*m_scale)+(*m_min_x); // 원점이 (0,0) 이 아닐 경우 skew(m_min_x) 추가
}

double SuperItem::convertPosY()
{
    return -1 * (this->y() - (*m_from_window_to_box_y))/(*m_scale)+(*m_min_y);
}

FormMap::FormMap(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormMap)
{
    ui->setupUi(this);

}

FormMap::~FormMap()
{
    delete ui;
}

void FormMap::receiveFile(T2D &t2d)
{
    QGraphicsRectItem *rectItem = new QGraphicsRectItem;
    QGraphicsScene *scene = new QGraphicsScene(this);
    super = new SuperItem();
    super->getScaleValue(&m_scale, &m_from_window_to_box_x, &m_from_window_to_box_y, &m_min_x, &m_min_y, &m_zoom_init);

    m_min_x = t2d.LayoutMinMax.minx;
    m_min_y = t2d.LayoutMinMax.miny;
    double width = t2d.LayoutMinMax.maxx - t2d.LayoutMinMax.minx;
    double height = t2d.LayoutMinMax.maxy - t2d.LayoutMinMax.miny;
    m_zoom_init = 1 / height;
    m_scale = m_gray_box_size/qMax(width,height);    //가장 긴 곳을 120으로 맞춤
    double box_x_zero_point = -1 * m_scale * width /2;
    double box_y_zero_point = -1 * m_scale * height /2;
    m_box_width = m_scale * width;
    m_box_height = m_scale * height;
    m_window_width = ui->graphicsView->size().width();
    m_window_height = ui->graphicsView->size().height();
    m_from_window_to_box_x = m_window_width/2 - m_box_width/2;
    m_from_window_to_box_y = -1 * (m_window_height/2 - m_box_height/2);

    rectItem->setRect(box_x_zero_point,box_y_zero_point,m_box_width,m_box_height);
    rectItem->setBrush(QBrush(QColor(Qt::gray)));
    rectItem->setPos(m_window_width/2,-m_window_height/2); //좌측 위 (0,0) 에서 부터 중앙으로 이동
    scene->setSceneRect(m_from_window_to_box_x,(m_from_window_to_box_y - m_box_height),m_box_width,m_box_height); //Y 좌표는 위에서 얼만큼 내려오는가 라서
    scene->addItem(rectItem);           //사각형
    scene->addItem(super);    

    QObject::connect(this,&FormMap::signalMove,super,&SuperItem::slotMove);

    ui->graphicsView->setScene(scene);

}

void FormMap::receivePointPos(POS_MONITORING &pos)
{
    this->pos = &pos;
}

void FormMap::changePos()
{    
    emit signalMove(pos);
}
!@hash[]!@file[]./formtop.cpp!@hash[]!@code[]#include "formtop.h"
#include "ui_formtop.h"
#include <QGraphicsItem>
#include <QScrollBar>
#include <QVector>
#include <QMap>
#include <iostream>
#include <QDebug>


FormTop::FormTop(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormTop)
{
    ui->setupUi(this);
    this->m_scene = new QGraphicsScene(this);
    trans.scale(1,-1);

    formtop_cut_all = formtop_menu.addAction(tr("All"));
    formtop_cut_all->setCheckable(true);
    formtop_cut_all->setChecked(true);

    formtop_cut_rigtht = formtop_menu.addAction(tr("Right"));
    formtop_cut_rigtht->setCheckable(true);

    formtop_cut_left = formtop_menu.addAction(tr("Left"));
    formtop_cut_left->setCheckable(true);

    formtop_cut_top = formtop_menu.addAction(tr("Top"));
    formtop_cut_top->setCheckable(true);

    formtop_cut_bottom = formtop_menu.addAction(tr("Bottom"));
    formtop_cut_bottom->setCheckable(true);

}


FormTop::~FormTop()
{
    delete ui;
}

void FormTop::receiveFile(T2D &t2d, int pixel, double um)
{
    drawingClear();
    m_scene->clear();
    rendering_full = &t2d;            
    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        for(int row = 0 ; row < (int)rendering_full->LayoutData10by10[layer].xy.size() ; row++)
        {
            rendering_full->LayoutData10by10[layer].xy_filtered.resize(rendering_full->LayoutData10by10[layer].xy.size());
            for(int col = 0 ; col < (int)rendering_full->LayoutData10by10[layer].xy[row].size() ; col++)
            {
                rendering_full->LayoutData10by10[layer].xy_filtered[row].resize(rendering_full->LayoutData10by10[layer].xy[row].size());
            }
        }
    }

    this->m_origin_scale = pixel/um;
    this->m_scale = this->m_origin_scale;

    m_scene->setBackgroundBrush(QBrush(QColor(Qt::white)));

    drawing();
}

void FormTop::drawing()
{
    //areaFilterRect();
    this->getRowCol();
    //cout << "r:" << m_begin_row << " " << m_end_row << endl;
    //cout << "c:" << m_begin_col << " " << m_end_col << endl;
    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        //layer_enviroment ?? ??????? for skip
        if( rendering_full->LayoutData10by10[layer].checking == 0){continue;}
        /*m_begin_row = 0;
        m_begin_col = 0;
        m_end_col = 3;
        m_end_row = 3;*///for test
        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                for(int n = 0 ; n < (int)(rendering_full->LayoutData10by10[layer].xy[row][col]).size(); n++)
                {
                    addRectItem(layer,row,col,n,trans);
                }
            }
        }
    }
    m_scene->setSceneRect(0, 0, this->m_scene_standard, this->m_scene_standard);
    ui->graphicsView->setScene(m_scene);

    m_scene->addRect(0,0,100,100, QPen(QBrush(Qt::red), 0), QBrush(Qt::NoBrush));
    m_scene->addRect(50,50,50,50, QPen(QBrush(Qt::blue), 0), QBrush(Qt::NoBrush));
    m_scene->addRect(0,0,50,50, QPen(QBrush(Qt::black), 0), QBrush(Qt::NoBrush));

}

void FormTop::filterDrawing()
{
    areaFilterRect();
    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        //layer_enviroment ?? ??????? for skip
        if( rendering_full->LayoutData10by10[layer].checking == 0){continue;}
        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                for(int n = 0 ; n < (int)(rendering_full->LayoutData10by10[layer].xy_filtered[row][col]).size(); n++)
                {
                    addFilterRectItem(layer,row,col,n,trans);
                }
            }
        }
    }

    m_scene->setSceneRect(0, 0, this->m_scene_standard, this->m_scene_standard);
    ui->graphicsView->setScene(m_scene);

    m_scene->addRect(0,0,100,100, QPen(QBrush(Qt::red), 0), QBrush(Qt::NoBrush));
    m_scene->addRect(50,50,50,50, QPen(QBrush(Qt::blue), 0), QBrush(Qt::NoBrush));
    m_scene->addRect(0,0,50,50, QPen(QBrush(Qt::black), 0), QBrush(Qt::NoBrush));
}

void FormTop::drawingClear()
{
    // ?????? ??? vector ?? ??????? ?? : delete ?? ????
    for(auto cur_item : rectItemList)
    {
        delete cur_item;
    }
    rectItemList.clear();
    m_scene->clear();
}

void FormTop::receivePointPos(POS_MONITORING &pos)
{
    this->pos = &pos;
    temp_pos.x = pos.x;
    temp_pos.y = pos.y;
}

void FormTop::changePos()
{    
    if(this->changepos_init_check == false) //temp_pos.x != pos->x || temp_pos.y != pos->y)
    {
        m_min_x_size = pos->x - m_area / m_area_scale;
        m_max_x_size = pos->x + m_area / m_area_scale;
        m_min_y_size = pos->y - m_area / m_area_scale;
        m_max_y_size = pos->y + m_area / m_area_scale;

        temp_pos.x = pos->x;
        temp_pos.y = pos->y;

        this->m_scale = this->m_origin_scale * pos->zoom;
        //cout << "jj " << m_scale/0.1 << endl;

        drawingClear();
        if(rendering_full->m_filter_onoff == false){
            drawing();
        }
        if(rendering_full->m_filter_onoff == true){
            filterDrawing();
        }
    } else{
        this->changepos_init_check = false;
    }
}

void FormTop::addRectItem(int layer, int row, int col, int n, QTransform trans)
{

    QGraphicsRectItem *rectItem = new QGraphicsRectItem;
    rectItemList.push_back(rectItem);

    /*float opacity = rendering_full->LayoutData10by10[layer].color.a;
    opacity = opacity/255;*/

    float x = m_scale*(rendering_full->LayoutData10by10[layer].xy[row][col][n].minx - pos->x) + this->m_scene_standard / 2;
    float y = m_scale*(rendering_full->LayoutData10by10[layer].xy[row][col][n].miny - pos->y) - this->m_scene_standard / 2;
    float w = m_scale*(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx - rendering_full->LayoutData10by10[layer].xy[row][col][n].minx);
    float h = m_scale*(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy - rendering_full->LayoutData10by10[layer].xy[row][col][n].miny);

    rectItem->setRect(x,y,w,h);
    rectItem->setBrush(QBrush(QColor(rendering_full->LayoutData10by10[layer].color.r,
                                     rendering_full->LayoutData10by10[layer].color.g,
                                     rendering_full->LayoutData10by10[layer].color.b,
                                     rendering_full->LayoutData10by10[layer].color.a)));
    //rectItem->setOpacity(opacity);
    //qDebug()<< " rect    : " << rectItem->rect() << ":: row/col : " << row << "/" << col << " " << n;
    //qDebug()<< " opacity : " << rendering_full->LayoutData10by10[layer].color.a << " : " << opacity;

    //cout << x << ":" << y << " " << w << ":" << h << endl;
    rectItem->setZValue(rendering_full->LayoutData10by10[layer].bot);

    rectItem->setTransform(trans);
    m_scene->addItem(rectItem);

    /*QColor formtop_rgba = QColor(rendering_full->LayoutData10by10[layer].color.r,
                                 rendering_full->LayoutData10by10[layer].color.g,
                                 rendering_full->LayoutData10by10[layer].color.b,
                                 rendering_full->LayoutData10by10[layer].color.a);

    m_scene->addRect(x, y, w, h, QPen(QBrush(Qt::NoBrush), 0), QBrush(formtop_rgba));*/
}

void FormTop::addFilterRectItem(int layer, int row, int col, int n, QTransform trans)
{

    QGraphicsRectItem *rectItem = new QGraphicsRectItem;
    rectItemList.push_back(rectItem);

    /*float opacity = rendering_full->LayoutData10by10[layer].color.a;
    opacity = opacity/255;*/

    float x = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].minx - pos->x) + this->m_scene_standard / 2;
    float y = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].miny - pos->y) - this->m_scene_standard / 2;
    float w = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].maxx - rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].minx);
    float h = m_scale*(rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].maxy - rendering_full->LayoutData10by10[layer].xy_filtered[row][col][n].miny);

    rectItem->setRect(x,y,w,h);
    rectItem->setBrush(QBrush(QColor(rendering_full->LayoutData10by10[layer].color.r,
                                     rendering_full->LayoutData10by10[layer].color.g,
                                     rendering_full->LayoutData10by10[layer].color.b,
                                     rendering_full->LayoutData10by10[layer].color.a)));

    //rectItem->setOpacity(opacity);
    //qDebug()<< " rect    : " << rectItem->rect() << ":: row/col : " << row << "/" << col << " " << n;
    //qDebug()<< " opacity : " << rendering_full->LayoutData10by10[layer].color.a << " : " << opacity;

    rectItem->setZValue(rendering_full->LayoutData10by10[layer].bot);

    rectItem->setTransform(trans);
    m_scene->addItem(rectItem);
}

int FormTop::extPos(double *pos, double *min, double *max)
{
    double area = m_area / m_area_scale; // 0.05 = 50/1000
    int pos_col_row = (*pos-*min)/m_block_size; // 30.0413/10 = 3
    int max_col_row = (*max-*min)/m_block_size;


    //block ???? ??? ?????? ??o?? ???? ???? external ?? ???
    if ((*pos - *min)<area && pos_col_row > 0) // 30.0413 - 3*10 = 0.0413 < 0.05
    {
        return pos_col_row - 1;
    }
    else if ((*max - *pos)<area && pos_col_row < max_col_row) // 39.9811 col 3 : (3+1)*10 - 39.9811 = 0.0189 < 0.05
    {
        return pos_col_row + 1;
    }

    return pos_col_row;
}

void FormTop::filterRenderingData(int layer, int row, int col, int n)
{
    double minx = 0;
    double maxx = 0;
    double miny = 0;
    double maxy = 0;

    if(m_filter_right == true){
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].minx >= pos->x){return;}
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].minx < pos->x && rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx >= pos->x) //area ???? ????? ???
        {
            maxx = pos->x;
        }
        else
        {
            maxx = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx;
        }
        minx = rendering_full->LayoutData10by10[layer].xy[row][col][n].minx;
        miny = rendering_full->LayoutData10by10[layer].xy[row][col][n].miny;
        maxy = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy;
    }
    if(m_filter_left == true){
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx <= pos->x){return;}
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx > pos->x && rendering_full->LayoutData10by10[layer].xy[row][col][n].minx <= pos->x) //area ???? ????? ???
        {
            minx = pos->x;
        }
        else
        {
            minx = rendering_full->LayoutData10by10[layer].xy[row][col][n].minx;
        }
        maxx = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx;
        miny = rendering_full->LayoutData10by10[layer].xy[row][col][n].miny;
        maxy = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy;
    }
    if(m_filter_top == true){
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].miny >= pos->y){return;}
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].miny < pos->y && rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy >= pos->y) //area ???? ????? ???
        {
            maxy = pos->y;
        }
        else
        {
            maxy = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy;
        }
        minx = rendering_full->LayoutData10by10[layer].xy[row][col][n].minx;
        maxx = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx;
        miny = rendering_full->LayoutData10by10[layer].xy[row][col][n].miny;
    }
    if(m_filter_bottom == true){
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy <= pos->y){return;}
        if(rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy > pos->y && rendering_full->LayoutData10by10[layer].xy[row][col][n].miny <= pos->y) //area ???? ????? ???
        {
            miny = pos->y;
        }
        else
        {
            miny = rendering_full->LayoutData10by10[layer].xy[row][col][n].miny;
        }
        minx = rendering_full->LayoutData10by10[layer].xy[row][col][n].minx;
        maxx = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxx;
        maxy = rendering_full->LayoutData10by10[layer].xy[row][col][n].maxy;
    }


    B_BOX temp;
    temp.minx = minx;
    temp.miny = miny;
    temp.maxx = maxx;
    temp.maxy = maxy;

    rendering_full->LayoutData10by10[layer].xy_filtered[row][col].push_back(temp);
}

void FormTop::areaFilterRect()
{
    //filter BBOX clear
    this->getRowCol();

    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                rendering_full->LayoutData10by10[layer].xy_filtered[row][col].clear();
            }
        }
    }

    /*int pos_col = (pos->x - rendering_full->LayoutMinMax.minx)/m_block_size; //???? ??????   23.3841 / 10 = 2.33841 -> int 2
    int ext_col = extPos(&pos->x, &rendering_full->LayoutMinMax.minx, &rendering_full->LayoutMinMax.maxx);
    m_begin_col = qMin(pos_col,ext_col);
    m_end_col = qMax(pos_col,ext_col)+1;

    int pos_row = (pos->y - rendering_full->LayoutMinMax.miny)/m_block_size;
    int ext_row = extPos(&pos->y, &rendering_full->LayoutMinMax.miny,&rendering_full->LayoutMinMax.maxy);
    m_begin_row = qMin(pos_row,ext_row);
    m_end_row = qMax(pos_col,ext_row)+1;*/

    //layer
    for(int layer = 0 ; layer < (int)rendering_full->LayoutData10by10.size() ; layer++)
    {
        //layer_enviroment ?? ??????? for skip

        if( rendering_full->LayoutData10by10[layer].checking == 0){continue;}

        for(int row = m_begin_row ; row < m_end_row ; row++)
        {
            for(int col = m_begin_col ; col < m_end_col ; col++)
            {
                for(int n = 0 ; n < (int)(rendering_full->LayoutData10by10[layer].xy[row][col]).size(); n++)
                {                
                    filterRenderingData(layer,row,col,n);
                }
            }
        }
    }

}

void FormTop::getRowCol(){
    int pos_col = (pos->x - rendering_full->LayoutMinMax.minx)/m_block_size; //???? ??????   23.3841 / 10 = 2.33841 -> int 2
    if(pos_col - 1 >= 0){
        m_begin_col = pos_col - 1;
    }else{
        m_begin_col = 0;
    }

    if(pos_col + 2 <= rendering_full->col){
        m_end_col = pos_col + 2;
    }else{
        m_end_col = rendering_full->col;
    }

    int pos_row = (pos->y - rendering_full->LayoutMinMax.miny)/m_block_size;
    if(pos_row - 1 >= 0){
        m_begin_row = pos_row - 1;
    }else{
        m_begin_row = 0;
    }

    if(pos_row + 2 <= rendering_full->row){
        m_end_row = pos_row + 2;
    }else{
        m_end_row = rendering_full->row;
    }
}

void FormTop::wheelEvent(QWheelEvent *event){
    int delta = event->delta();

    // ????? ???? ???? ?????? ???? ????
    if (delta > 0) {
        this->pos->zoom *= 1.01; // 10% ???
    } else if (delta < 0) {
        this->pos->zoom /= 1.01; // 10% ????
    }
    //pos->zoom = m_scale;
    //cout << m_scale << endl;
    cout << this->pos->zoom << endl;
    //emit signalChangePos("test", *this->pos);
}

void FormTop::contextMenuEvent(QContextMenuEvent *event){
    QAction* selectedItem = formtop_menu.exec(event->globalPos());
    if (selectedItem == formtop_cut_all) {
        rendering_full->m_filter_onoff = false;
        m_filter_right = false;
        m_filter_left = false;
        m_filter_top = false;
        m_filter_bottom = false;
        this->changePos();
    }
    if (selectedItem == formtop_cut_rigtht) {
        rendering_full->m_filter_onoff = true;
        m_filter_right = true;
        m_filter_left = false;
        m_filter_top = false;
        m_filter_bottom = false;
        this->changePos();
    }
    if (selectedItem == formtop_cut_left) {
        rendering_full->m_filter_onoff = true;
        m_filter_right = false;
        m_filter_left = true;
        m_filter_top = false;
        m_filter_bottom = false;
        this->changePos();
    }
    if (selectedItem == formtop_cut_top) {
        rendering_full->m_filter_onoff = true;
        m_filter_right = false;
        m_filter_left = false;
        m_filter_top = true;
        m_filter_bottom = false;
        this->changePos();
    }
    if (selectedItem == formtop_cut_bottom) {
        rendering_full->m_filter_onoff = true;
        m_filter_right = false;
        m_filter_left = false;
        m_filter_top = false;
        m_filter_bottom = true;
        this->changePos();
    }
    filterMenuCheck();
}

void FormTop::filterMenuCheck(){
    formtop_cut_all->setChecked(!rendering_full->m_filter_onoff);
    formtop_cut_rigtht->setChecked(m_filter_right);
    formtop_cut_left->setChecked(m_filter_left);
    formtop_cut_top->setChecked(m_filter_top);
    formtop_cut_bottom->setChecked(m_filter_bottom);
}









!@hash[]!@file[]./gitmerge.cpp!@hash[]!@code[]#include "gitmerge.h"

#include <QFile>
#include <QTextStream>
#include <QDebug>

//git test

GitMerge::GitMerge()
{
    split1 = hash;
    split2 = hash;
    split1.append(file);
    split2.append(code);

    readCodeFiles();
    readTxtFile();
    if(write_code_files)
    {
        makeCodeFiles();
    }
    else
    {
        makeTxtFile();
    }

}

void GitMerge::readTxtFile()
{
    QString fileName = txt_file;
    QFile file(fileName);
    if(!file.open(QFile::ReadOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for reading ";
        based_on_reading_txt = "";
        if(!file.open(QFile::WriteOnly | QFile::Text))
        {
            return;
        }
        QTextStream out(&file);
        out << "";
        file.close();
        return;
    }
    QTextStream in(&file);
    based_on_reading_txt = in.readAll();
    file.close();

}

void GitMerge::readCodeFiles()
{
    QFile file(pro_file);


    if(!file.open(QFile::ReadOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for reading ";
        return;
    }

    QTextStream in(&file);
    in.setCodec("UTF-8");
    QString merge = in.readAll();
    QStringList mergeList = merge.split("\n");
    for (auto &itemMerge : mergeList)
    {

        itemMerge = itemMerge.remove("\\");
        itemMerge = itemMerge.trimmed();

        if (itemMerge.contains(".cpp", Qt::CaseInsensitive) || itemMerge.contains(".h", Qt::CaseInsensitive) || itemMerge.contains(".ui", Qt::CaseInsensitive))
        {
            QFile codeFile(itemMerge.prepend("./"));
            if(!codeFile.open(QFile::ReadOnly | QFile::Text))
            {
                qDebug() << " Could not open the code file for reading " ;
                return;
            }
            QTextStream codeIn(&codeFile);
            codeIn.setCodec("UTF-8");
            QString codeText = codeIn.readAll();
            //codeText = codeText.toUtf8();

            merged_code_files.append(split1);
            merged_code_files.append(itemMerge);
            merged_code_files.append(split2);
            merged_code_files.append(codeText);
            codeFile.close();

        }

    }
    merged_code_files.append(split1);
    merged_code_files.append("./IInterface.pro");
    merged_code_files.append(split2);
    merged_code_files.append(merge);

    file.close();
}

bool GitMerge::compareCodeFile(QString &A, QString &B)
{
    if (A==B)
    {
        return true;
    }
    else
    {
        return false;
    }

}

void GitMerge::makeTxtFile()
{
    QFile file(txt_file);
    if(!file.open(QFile::WriteOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for writing ";
        return;
    }
    QTextStream out(&file);
    out << merged_code_files;
    out.setCodec("UTF-8");
    file.flush();
    file.close();

}

void GitMerge::makeCodeFiles()
{
    QStringList codeList = merged_code_files.split(split1);
    QStringList fileList = based_on_reading_txt.split(split1);
    QStringList codeListDivide;
    QStringList fileListDivide;
    for (int i = 1; i < fileList.size(); i++)
    {
        fileListDivide = fileList[i].split(split2);
        for (int j = 1; j < codeList.size(); j++)
        {
            codeListDivide = codeList[j].split(split2);
            if (codeListDivide[0] == fileListDivide[0])
            {
                if (codeListDivide[1] != fileListDivide[1])
                {
                    QFile file_gitback(codeListDivide[0].append("_back"));
                    if(!file_gitback.open(QFile::WriteOnly | QFile::Text))
                    {
                        qDebug() << " Could not open the file for writing ";
                        return;
                    }
                    QTextStream out_gitback(&file_gitback);
                    out_gitback << codeListDivide[1];
                    out_gitback.setCodec("UTF-8");
                    file_gitback.flush();
                    file_gitback.close();

                    QFile file(fileListDivide[0]);
                    if(!file.open(QFile::WriteOnly | QFile::Text))
                    {
                        qDebug() << " Could not open the file for writing ";
                        return;
                    }
                    QTextStream out(&file);
                    out << fileListDivide[1];
                    out.setCodec("UTF-8");
                    file.flush();
                    file.close();
                }
                break;
            }
            if (j == codeList.size()-1) // 찾아봤는데 기존 파일이 없다.
            {
                QFile file(fileListDivide[0]);
                if(!file.open(QFile::WriteOnly | QFile::Text))
                {
                    qDebug() << " Could not open the file for writing ";
                    return;
                }
                QTextStream out(&file);
                out << fileListDivide[1];
                out.setCodec("UTF-8");
                file.flush();
                file.close();
            }
        }
    }
}
!@hash[]!@file[]./main.cpp!@hash[]!@code[]#include "mainwindow.h"
#include "gitmerge.h"

#include <QApplication>
#include <QVulkanInstance>
#include <QLoggingCategory>
#include <fstream>
#include <string>
#include <iostream>
#include "formtop.h"

#include "Rendering/Src/lve_window.hpp"
#include "Rendering/Src/simple_render_system.hpp"

Q_LOGGING_CATEGORY(lcVk, "qt.vulkan")

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

///////// git merge
    GitMerge gitMerge;
/// /////

    QLoggingCategory::setFilterRules(QStringLiteral("qt.vulkan=true"));

    QVulkanInstance inst;
    LveWindow *vulkanWindow = new LveWindow;

    //inst.setLayers(QByteArrayList() << "VK_LAYER_LUNARG_standard_validation");


    if (!inst.create())
        qFatal("Failed to create Vulkan instance: %d", inst.errorCode());

    vulkanWindow->setVulkanInstance(&inst);

    MainWindow mainWindow(vulkanWindow);
    QObject::connect(vulkanWindow, &LveWindow::signalInfoText, &mainWindow, &MainWindow::slotInfoText);



    QRect size = mainWindow.geometry();
    mainWindow.shareGeo(size);
    qDebug() << "Main geo : " << mainWindow.geometry();

    mainWindow.show();

    return app.exec();
}





!@hash[]!@file[]./mainwindow.cpp!@hash[]!@code[]#include "mainwindow.h"
#include "ui_mainwindow.h"

#include "Rendering/Src/dtaorendersystem.h"
#include "Rendering/Src/lve_model.hpp"


#include <QMouseEvent>
#include <QKeyEvent>
#include <QDockWidget>
#include <QGraphicsRectItem>
#include <QGraphicsOpacityEffect>
#include <QFile>
#include <QFileDialog>
#include <QString>

#include <fstream>
#include <iostream>
#include <string>
#include <QIODevice>
#include <QTextStream>

MainWindow::MainWindow(LveWindow* w)
    : m_window(w)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QWidget* wrapper = QWidget::createWindowContainer(w);
    ui->graphicsView->setViewport(wrapper);

    dockHier = new QDockWidget(tr("Hierarchy"), this);
    dockHier->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockHier->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockHier->setObjectName("DockWidgetHier");
    addDockWidget(Qt::RightDockWidgetArea, dockHier);
    formHier = new FormHier;
    dockHier->setWidget(formHier);

    dockLayer = new QDockWidget(tr("Layer Information"), this);
    dockLayer->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockLayer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockLayer->setObjectName("DockWidgetLayer");
    addDockWidget(Qt::RightDockWidgetArea, dockLayer);
    formLayer = new FormLayer(this->m_window);
    dockLayer->setWidget(formLayer);

    dockMap = new QDockWidget(tr("Map"), this);
    dockMap->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockMap->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockMap->setObjectName("DockWidgetMap");
    addDockWidget(Qt::LeftDockWidgetArea, dockMap);
    formMap = new FormMap;
    dockMap->setWidget(formMap);

    dockTop = new QDockWidget(tr("Topview"), this);
    dockTop->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockTop->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockTop->setObjectName("DockWidgetTop");
    addDockWidget(Qt::LeftDockWidgetArea, dockTop);
    formTop = new FormTop;
    dockTop->setWidget(formTop);

    dockInfo = new QDockWidget(tr("Info"), this);
    dockInfo->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockInfo->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    dockInfo->setObjectName("DockWidgetInfo");
    addDockWidget(Qt::LeftDockWidgetArea, dockInfo);
    formInfo = new FormInfo;
    dockInfo->setWidget(formInfo);

    resizeDocks({ dockInfo, dockTop, dockMap, dockLayer, dockHier }, { 200,200 }, Qt::Horizontal);
    resizeDocks({ dockTop, dockMap }, { 200,200 }, Qt::Vertical);
    resizeDocks({ dockLayer, dockHier }, { 350,300 }, Qt::Vertical);

    input_dataS = new all_data;

    // test //
    pos.x = 0;
    pos.y = 0;
    pos.z = 0;
    pos.tilt = 90;
    pos.rotation = 0;
    pos.zoom = 1;
    pos.window_zoom = 1;
    formMap->receivePointPos(pos);
    formTop->receivePointPos(pos);
    formInfo->receivePointPos(pos);

    /// connect ////////////////////
    QObject::connect(ui->actionOpen_file, SIGNAL(triggered()), this, SLOT(on_actionOpen_file_triggered));
    QObject::connect(ui->actionOpen_PEX, SIGNAL(triggered()), this, SLOT(on_actionOpen_PEX_triggered));
//    QObject::connect(this, SIGNAL(sendSelectFileName(QString)), input_dataS, SLOT(receiveSelectFileName(QString)));
//    QObject::connect(input_dataS, SIGNAL(sendSplitData(int, int, const QVector <QVector <QString>> &)), formHier, SLOT(ReceiveSplitData(int, int, const QVector <QVector <QString>> &)));
//    QObject::connect(input_dataS, SIGNAL(sendSplitData(int, int, const QVector <QVector <QString>> &)), formLayer, SLOT(ReceiveSplitData(int, int, const QVector <QVector <QString>> &)));
//    QObject::connect(formLayer, SIGNAL(outputLayerStatus(QString)), this, SLOT(inputLayerStatus(QString)));
    //QObject::connect(formTop, SIGNAL(signalChangePos(QString, POS_MONITORING)), this, SLOT(slotInfoText(QString, POS_MONITORING)));
    QObject::connect(formInfo, SIGNAL(signalDirectlyInputPos()), this, SLOT(slotDirectlyInputPos()));
    QObject::connect(formInfo, SIGNAL(signalStatusBarMsg(QString)), this, SLOT(slotStatusBarMsg(QString)));
    QObject::connect(dockMap, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_Map_stateChanged(bool)));
    QObject::connect(dockTop, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_TopView_stateChanged(bool)));
    QObject::connect(dockInfo, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_Info_stateChanged(bool)));
    QObject::connect(dockHier, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_Hier_stateChanged(bool)));
    QObject::connect(dockLayer, SIGNAL(visibilityChanged(bool)), this, SLOT(on_docker_Layer_stateChanged(bool)));
    // 평가용
    dev_dialog = new DevDialog(this);
    devDialog();
}

void MainWindow::shareGeo(QRect size)
{
    QRect windowSize = size;
    qDebug() << "shareGeo : " << windowSize;
}

void MainWindow::devDialog()
{
    dev_dialog->sendParameter(&is_pos_checked, &pos);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::slotInfoText(QString funcName, POS_MONITORING value)
{

    if (value.x != pos_past.x ||
        value.y != pos_past.y ||
        value.z != pos_past.z ||
        (value.tilt - pos_past.tilt) > 0.01 ||
        (value.rotation - pos_past.rotation) > 0.01 ||
        value.zoom != pos_past.zoom)
    {
        pos.x = value.x;
        pos.y = value.y;
        pos.z = value.z;
        pos.tilt = value.tilt;
        pos.rotation = value.rotation;
        pos.zoom = value.zoom;

        sendPositionDataToDocker(); // changePos() refactoring

        pos_past.x = pos.x;
        pos_past.y = pos.y;
        pos_past.z = pos.z;
        pos_past.tilt = pos.tilt;
        pos_past.rotation = pos.rotation;
        pos_past.zoom = pos.zoom;
    }


    //qDebug() << "slotInfoText" << funcName << value.x << " "<< value.y << " "<< value.z << " ";
///// temp //////
//    QString text = funcName + " : " ;
//    for (int i = text.size() ; i < 30 ; i++)
//    {
//        text.append(" ");
//    }

//    statusText.prepend(text);

//    if (statusText.size() > 120)
//        statusText.remove(120,statusText.size()-120);
//    ui->statusbar->showMessage(statusText);

}

void MainWindow::on_actionOpen_file_triggered()
{

    QString file_name = QFileDialog::getOpenFileName(this, "파일 선택", ".", "Files(*.*)");
    //qDebug() << file_name;

    emit sendSelectFileName(file_name);

}

void MainWindow::on_actionOpen_PEX_triggered()
{
    if (this->t2d.LayoutData10by10.empty() == false) {
        QString file_name = QFileDialog::getOpenFileName(this, "파일 선택", ".", "Files(*.*)");

        DtaoRenderSystem* renderer = this->m_window->getRenderer();

        renderer->createNewPEXResObject(file_name);
        renderer->createNewPEXCapObject(file_name,this->t2d);

        //test
    }
    else {
        qDebug() << "Layout Load 후 PEX를 불러올 수 있습니다";
    }
}

void MainWindow::inputLayerStatus(QString text)
{
    if(formLayer->m_layer_all_check == false){
        ui->statusbar->showMessage(text);
        /*formTop->drawingClear();
        formTop->drawing();*/
        sendPositionDataToDocker();
    }
}

void MainWindow::inputPosInformation()
{

    //execute (pos)
}

void MainWindow::on_actionOpen_Layout_triggered()
{
    QString file_name = QFileDialog::getOpenFileName(this, "파일 선택", ".", "Files(*.*)");
    DtaoRenderSystem* renderer = this->m_window->getRenderer();

    //renderer->createNewObject(MODEL_TYPE::MODEL_TYPE_LAYOUT, file_name.toStdString());


}

void MainWindow::on_actionOpen_DB_triggered() {
    std::cout << "callv" << std::endl;
    QString file_name = QFileDialog::getOpenFileName(this, "OpenDB", ".", "Text (*.txt) ;; Files (*.*)");
    if (file_name != "") {
        std::cout << file_name.toStdString() << std::endl;
        this->t2d.text2data(file_name.toStdString());

        //        printf("%-9f %-9f %-9f %-9f %-9f %-9f", t2d.LayoutMinMax.minx, t2d.LayoutMinMax.miny, t2d.LayoutMinMax.maxx, t2d.LayoutMinMax.maxy, t2d.LayoutMinMax.minz, t2d.LayoutMinMax.maxz);
        //        for(int i = 0 ; i < t2d.LayoutData10by10.size() ; i++){
        //            printf("\n%-9s %-9d %-9d %-9d %-9d %-9d %-9d %-9f %-9f ",
        //                   t2d.LayoutData10by10[i].layername.c_str(),
        //                   t2d.LayoutData10by10[i].layernum,
        //                   t2d.LayoutData10by10[i].datatype,
        //                   t2d.LayoutData10by10[i].color.r,
        //                   t2d.LayoutData10by10[i].color.g,
        //                   t2d.LayoutData10by10[i].color.b,
        //                   t2d.LayoutData10by10[i].color.a,
        //                   t2d.LayoutData10by10[i].bot,
        //                   t2d.LayoutData10by10[i].top);
        //            for(int j = 0 ; j < (t2d.LayoutData10by10[i].xy).size() ; j++){
        //                for(int x = 0 ; x < (t2d.LayoutData10by10[i].xy[j]).size() ; x++){
        //                    printf("\n%d %d %d", j, x, (t2d.LayoutData10by10[i].xy[j][x]).size());
        //                    for(int y = 0 ; y < (t2d.LayoutData10by10[i].xy[j][x]).size() ; y++){
        //                        printf("\n%-9f %-9f %-9f %-9f",
        //                               t2d.LayoutData10by10[i].xy[j][x][y].minx,
        //                               t2d.LayoutData10by10[i].xy[j][x][y].miny,
        //                               t2d.LayoutData10by10[i].xy[j][x][y].maxx,
        //                               t2d.LayoutData10by10[i].xy[j][x][y].maxy);
        //                    }
        //                }
        //            }
        //        }
                //to map data
        //        for(int i = 0 ; i < t2d.HierarchyInstance.size() ; i++){
        //            printf("\n%-3d %-19s %-9s %-9f %-9f %-9f %-9f",
        //                                t2d.HierarchyInstance[i].level,
        //                                t2d.HierarchyInstance[i].name.c_str(),
        //                                t2d.HierarchyInstance[i].num.c_str(),
        //                                t2d.HierarchyInstance[i].box.minx,
        //                                t2d.HierarchyInstance[i].box.miny,
        //                                t2d.HierarchyInstance[i].box.maxx,
        //                                t2d.HierarchyInstance[i].box.maxy);
        //        }

        //formHier->createHierarchyTree(&t2d);

        pos.x = t2d.LayoutMinMax.minx;
        pos.y = t2d.LayoutMinMax.miny;
        pos.z = 0;
        pos.tilt = 90;
        pos.rotation = 0;
        pos.zoom = 1;
        formInfo->setTextPosTotal(&pos);

        //to top data


        DtaoRenderSystem* renderer = this->m_window->getRenderer();

        renderer->createT2DObject(MODEL_TYPE::MODEL_TYPE_LAYOUT, t2d);

        //cout << "!!" << renderer->getRenderScale() << endl;
        formInfo->receiveFile(t2d);
        formTop->receiveFile(t2d, 100, 0.1);
        formMap->receiveFile(t2d);
        formLayer->ReceiveLayerInformation(t2d);
        //test



    }
    fflush(stdout);
    cout << "test end" << endl;

}

void MainWindow::slotDirectlyInputPos() //point info 에서 직접 입력한 경우
{
    sendPositionDataToDocker();
    DtaoRenderSystem * renderer = this->m_window->getRenderer();
    renderer->translateLayerPosition(pos);
    //요청사항 230324 vulkan 에서도 수정을 여기서 실행
}

void MainWindow::slotStatusBarMsg(QString msg)
{
    ui->statusbar->showMessage(msg);
}



void MainWindow::on_actionDemo_triggered()
{
    qDebug() << "go?";
    DtaoRenderSystem* renderer = this->m_window->getRenderer();
    renderer->cameraController.triggerDemo();
}




void MainWindow::on_actionTop_triggered()
{
    qDebug() << "go?";
    //cocococo
}

void MainWindow::on_docker_Map_triggered()
{
    if (dockMap->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockMap->show();
    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockMap->hide();
    }
}

void MainWindow::on_docker_Map_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_Map->setCheckable(true);
        ui->docker_Map->setChecked(true);
    } else {
        ui->docker_Map->setCheckable(false);
        ui->docker_Map->setChecked(false);
    }
}

void MainWindow::on_docker_TopView_triggered()
{

    if (dockTop->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockTop->show();

    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockTop->hide();
    }
}

void MainWindow::on_docker_TopView_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_TopView->setCheckable(true);
        ui->docker_TopView->setChecked(true);
    } else {
        ui->docker_TopView->setCheckable(false);
        ui->docker_TopView->setChecked(false);
    }
}

void MainWindow::on_docker_Info_triggered()
{
    if (dockInfo->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockInfo->show();

    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockInfo->hide();
    }
}

void MainWindow::on_docker_Info_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_Info->setCheckable(true);
        ui->docker_Info->setChecked(true);
    } else {
        ui->docker_Info->setCheckable(false);
        ui->docker_Info->setChecked(false);
    }
}

void MainWindow::on_docker_Hier_triggered()
{
    if (dockHier->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockHier->show();

    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockHier->hide();
    }
}

void MainWindow::on_docker_Hier_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_Hier->setCheckable(true);
        ui->docker_Hier->setChecked(true);
    } else {
        ui->docker_Hier->setCheckable(false);
        ui->docker_Hier->setChecked(false);
    }
}

void MainWindow::on_docker_Layer_triggered()
{
    if (dockLayer->isHidden()) {
//        MainWindow::restoreGeometry(dock_widget_geometry);
//        MainWindow::restoreState(dock_widget_state);
        dockLayer->show();

    }
    else {
//        dock_widget_geometry = MainWindow::saveGeometry();
//        dock_widget_state = MainWindow::saveState();
        dockLayer->hide();
    }
}

void MainWindow::on_docker_Layer_stateChanged(bool visibility)
{
    if (visibility) {
        ui->docker_Layer->setCheckable(true);
        ui->docker_Layer->setChecked(true);
    } else {
        ui->docker_Layer->setCheckable(false);
        ui->docker_Layer->setChecked(false);
    }
}

void MainWindow::on_toggle_top_triggered()
{
    DtaoRenderSystem* renderer = this->m_window->getRenderer();
    renderer->cameraController.camera_moving_flag.toggleDemension = true;
    renderer->cameraController.camera_moving_flag.toggleDemensionXY = true;
}

void MainWindow::on_PEX_window_triggered()
{
    pexdialog = new PexDialog(this);
    pexdialog->show();
    pexdialog->raise();
    pexdialog->activateWindow();

}

void MainWindow::sendPositionDataToDocker()
{
//dev_dialog
    if (is_pos_checked)
    {
        formMap->changePos();
        formTop->changePos();
        formInfo->changePos();
        dev_dialog->changePos();
    }
}

void MainWindow::on_actionDialog_on_off_triggered()
{
    dev_dialog->show();
    dev_dialog->raise();
    dev_dialog->activateWindow();
}

void MainWindow::on_actionToyCAD_triggered()
{
    DtaoRenderSystem* renderer = this->m_window->getRenderer();
    renderer->createToyCADObjects("ToyCAD/Data/test.csv");

}
!@hash[]!@file[]./pexdialog.cpp!@hash[]!@code[]#include "pexdialog.h"
#include "ui_pexdialog.h"

PexDialog::PexDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::PexDialog)
{
    ui->setupUi(this);
}

PexDialog::~PexDialog()
{
    delete ui;
}
!@hash[]!@file[]./Rendering/Src/LayoutModel.h!@hash[]!@code[]#pragma once

#include "lve_model.hpp"
#include "T2D.h"

class LayoutModel : public LveModel
{
public:
    LayoutModel(LveDevice& device, MODEL_TYPE model_type, T2D &t2d);
    ~LayoutModel();

    LayoutModel() = delete;
    LayoutModel(const LayoutModel&) = delete;
    LayoutModel& operator=(const LayoutModel&) = delete;

private:
    LayoutDataManager layout_data;

public:
    virtual void makeRenderingData(T2D &t2d);
    virtual void loadData(T2D &t2d);
    virtual void makeVertices();
    virtual void makeIndices();

    void makeCubeVertices();
    void makeIndicesForFace();
    void makeIndicesForEdge();

    void makeCubeVertices_map();
    void makeIndicesForFace_map();
    void makeIndicesForEdge_map();


    LayoutDataManager* getLayoutDataManager() {return &this->layout_data;}

};



!@hash[]!@file[]./Rendering/Src/LayoutPEXData.h!@hash[]!@code[]#pragma once
#include <iostream>
#include <string>
#include <vector>
#include "T2D.h"
#include <QString>
#include <defineParam.h>


void testPEXData();
void testLayoutData();

enum LAYOUTINFO_INDEX {
    //LAYOUTINFO_IDX_STRUCTURE = 0,
    //LAYOUTINFO_IDX_CELLNAME = 1,
    LAYOUTINFO_IDX_LAYER = 0,
    LAYOUTINFO_IDX_DATATYPE = 1,
    LAYOUTINFO_IDX_LEFT = 2,
    LAYOUTINFO_IDX_BOTTOM = 3,
    LAYOUTINFO_IDX_RIGHT = 4,
    LAYOUTINFO_IDX_TOP = 5,
    LAYOUTINFO_IDX_ZSTART = 6,
    LAYOUTINFO_IDX_ZEND = 7,
    LAYOUTINFO_IDX_DEFAULT = -1,

};

enum LAYOUT_LAYER_TYPE {
    LAYOUT_LAYER_TYPE_1 = 0,
    LAYOUT_LAYER_TYPE_DEFAULT = 99
};

enum PEXINFO_INDEX {
    PEXINFO_INDEX_NAME = 0,

    PEXINFO_INDEX_NODE1_NAME = 1,
    PEXINFO_INDEX_NODE1_X = 2,
    PEXINFO_INDEX_NODE1_Y = 3,
    PEXINFO_INDEX_NODE1_ZSTART = 4,
    PEXINFO_INDEX_NODE1_ZEND = 5,
    PEXINFO_INDEX_NODE1_LVL = 6,
    PEXINFO_INDEX_NODE1_LAYER_NUMBER = 7,
    PEXINFO_INDEX_NODE1_LAYER_DATATYPE = 8,
    PEXINFO_INDEX_NODE2_NAME = 9,
    PEXINFO_INDEX_NODE2_X = 10,
    PEXINFO_INDEX_NODE2_Y = 11,
    PEXINFO_INDEX_NODE2_ZSTART = 12,
    PEXINFO_INDEX_NODE2_ZEND = 13,
    PEXINFO_INDEX_NODE2_LVL = 14,
    PEXINFO_INDEX_NODE2_LAYER_NUMBER = 15,
    PEXINFO_INDEX_NODE2_LAYER_DATATYPE = 16,

    PEXINFO_INDEX_VALUE = 17,
    PEXINFO_INDEX_DESCRIPTION = 18,
    PEXINFO_INDEX_DEFULT = 999
};

enum PEXResDirection {
    RES_DIRECTION_VERTICAL = 0,
    RES_DIRECTION_HORIZONTAL = 1,
    RES_DIRECTION_NONE = 99
};

struct cube_info {
    double minx;
    double miny;
    double maxx;
    double maxy;
    double minz;
    double maxz;
};

struct coord3d {
    double x;
    double y;
    double z;
};

struct cube_vertex {
    string layernum;
    coord3d vertex[8];
};

struct node {
    double x;
    double y;
    double z_start;
    double z_end;
    unsigned int layer_number;
    unsigned int layer_datatype;
    std::string name;
};
typedef struct node pex_node;

class LayoutItem {
public:
    LayoutItem();
    ~LayoutItem();
    LayoutItem(const cube_info& pattern_, const int layer_number_, const int layer_datatype_, LAYOUT_LAYER_TYPE layer_type_);

public:
    cube_info pattern;
    unsigned int layer_number;
    unsigned int layer_datatype;
    LAYOUT_LAYER_TYPE layer_type;
};


class LayoutDataManager
{
public:
    LayoutDataManager();
    ~LayoutDataManager();

private:
    std::string file_path;
    std::vector<LayoutItem> patterns;
    T2D *t2d_ptr;


    double scale;

    double layout_min_x;
    double layout_max_x;
    double layout_min_y;
    double layout_max_y;
    double layout_min_z;
    double layout_max_z;
    double x_diff;
    double y_diff;
    double z_diff;



public:
    std::vector<LayoutItem> &getPatterns() { return this->patterns; }
    std::vector<LDATA10BY10> &getPatterns_t2d() { return this->t2d_ptr->LayoutData10by10; }

    void loadLayoutData(T2D &t2d);
    void clear() { this->patterns.clear(); };
    void printLayoutData() {};
    static bool compareByLength( const LDATA10BY10 &a, const LDATA10BY10 &b);

    double getMinX() { return this->layout_min_x; }
    double getMaxX() { return this->layout_max_x; }
    double getMinY() { return this->layout_min_y; }
    double getMaxY() { return this->layout_max_y; }
    double getMinZ() { return this->layout_min_z; }
    double getMaxZ() { return this->layout_max_z; }
    double getDiffX() { return this->x_diff; }
    double getDiffY() { return this->y_diff; }
    double getDiffZ() { return this->z_diff; }
    double getScale() { return this->scale; }

private:
    void calculateScale();

};

class PEXItem
{
public:
    PEXItem();
    ~PEXItem();
    PEXItem(const node& node1_, const node& node2_, const double& value_, const std::string& name_);

public:
    node node1;
    node node2;
    double value;
    std::string name;

public:
    void setNode1(node& node_) { this->node1 = node_; }
    void setNode2(node& node_) { this->node2 = node_; }
    void setValue(double value_) { this->value = value_; }

    node& getNode1() { return this->node1; }
    node& getNode2() { return this->node2; }
    double getValue() { return this->value; }

    virtual void print();
};



class PEXResistor : public PEXItem
{
public:
    PEXResistor();
    ~PEXResistor();
    PEXResistor(const std::string& name_, const node& node1_, const node& node2_, const double& value_, const PEXResDirection& direction_);

private:
    PEXResDirection direction;

public:
    void setDirection(PEXResDirection direction_) { this->direction = direction_; }
    PEXResDirection getDirection() const { return this->direction; }

    static PEXResDirection checkDirectionFromDescription(const std::string& description);

    void print();
};

class PEXCapacitor : public PEXItem
{
public:
    PEXCapacitor();
    ~PEXCapacitor();
    PEXCapacitor(const std::string& name_, const node& node1_, const node& node2_, const double& value_);

public:
    void print();
};


class PEXResistorDataManager
{
public:
    PEXResistorDataManager();
    ~PEXResistorDataManager();

private:
    QString file_path;

    std::vector<PEXResistor> resistors_ref;
    std::vector<PEXResistor> resistors;
    std::vector<std::vector<PEXResistor>> resistors_of_node;

    double max_resistor_vertical;
    double min_resistor_vertical;
    double max_resistor_horizontal;
    double min_resistor_horizontal;

public:
    std::vector<PEXResistor>& getResistors() { return this->resistors; }
    std::vector<std::vector<PEXResistor>>& getResistorsOfNode() { return this->resistors_of_node; }
    void setDriectionOfResistor(PEXResDirection _direction);

    void loadData(const QString file_path);
    void groupResistorOfNode();
    void clear();
    void printData();
    int number_of_resistor_group = -1;

    void increaseNumOfResistorGroup() {
        number_of_resistor_group++;
        this->resistors = this->resistors_of_node[number_of_resistor_group % resistors_of_node.size()];
        std::cout << "ddddddddddddddddddddd" << std::endl;
    }

    void decreaseNumOfResistorGroup() {
        number_of_resistor_group--;
        this->resistors = this->resistors_of_node[number_of_resistor_group % resistors_of_node.size()];
    }

    double getMinResistorVerticalValue() { return this->min_resistor_vertical; }
    double getMaxResistorVerticalValue() { return this->max_resistor_vertical; }
    double getMinResistorHorizontalValue() { return this->min_resistor_horizontal; }
    double getMaxResistorHorizontalValue() { return this->max_resistor_horizontal; }

private:
    void updateMinMaxRes(const double& value, const PEXResDirection direction);
};

class PEXCapacitorDataManager
{
public:
    PEXCapacitorDataManager();
    ~PEXCapacitorDataManager();

private:
    QString file_path;

    std::vector<PEXCapacitor> capasitors;

    double max_capacitor;
    double min_capacitor;

public:
    std::vector<PEXCapacitor>& getCapacitors() { return this->capasitors; }

    void loadData(const QString file_path);
    void clear();
    void printData();

    double getMinCapacitorValue() { return this->min_capacitor; }
    double getMaxCapacitorValue() { return this->max_capacitor; }

private:
    void updateMinMaxCap(const double& value);
};

!@hash[]!@file[]./Rendering/Src/PEXCapacitorModel.h!@hash[]!@code[]#pragma once
#include "lve_model.hpp"
#include "LayoutPEXData.h"

#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <limits>
#include <thread>
#include <queue>
#include <mutex>
#include <cstdio>


typedef unsigned int uint;

class PEXCapacitorModel : public LveModel
{
public:
    struct cap_node {
        double x;
        double y;
        uint layer_number;
        uint layer_datatype;
        std::string name;
        double value;
        uint connected_count;
    };

    struct pattern_cap {
        cube_info pattern;
        uint layer_number;
        uint layer_datatype;
        double cap_value;
        double normalized_cap_value;
        uint cap_count;
    };

public:
    PEXCapacitorModel(
            LveDevice& device, MODEL_TYPE model_type,
            const QString& data_file = "", T2D * layout_data_ =nullptr);
    ~PEXCapacitorModel();

    PEXCapacitorModel() = delete;
    PEXCapacitorModel(const PEXCapacitorModel&) = delete;
    PEXCapacitorModel& operator=(const PEXCapacitorModel&) = delete;

private:
    PEXCapacitorDataManager pex_data;
    std::map<std::string, size_t> cap_node_name_to_index_map;
    T2D* layout_data =nullptr;

    std::vector<cap_node> cap_nodes;
    std::map<std::string, std::vector<cap_node*>> layer_to_cap_node_map;

    std::vector<pattern_cap> pattern_caps;
    std::map<std::string, std::vector<pattern_cap*>> layer_to_pattern_cap_map;

    std::set<std::pair<uint, uint>> layers;

    double max_cap = std::numeric_limits<double>::min();

    size_t num_threads = { 4 };
    std::vector<std::thread> threads;
    std::queue<std::string> layers_queue;
    std::mutex mutex_layers_queue;

public:
    virtual void makeRenderingData(const QString& file_path = "");
    virtual void loadData(const QString& file_path = "");
    virtual void makeVertices();
    virtual void makeIndices();

    void makeCubeVertices();

private:
    void makeCapNodesFromPEXData();
    void makePatternCapsFromLayoutData();

    void attachCapToPattern();
    void makeLayerToCapNodeMap();
    void makeLayerToPatternCapMap();

    void matchCapWithPatternThread(std::queue<std::string>* layers, std::mutex* mutex_);
    void matchCapWithPattern(std::vector<cap_node*>& caps, std::vector<pattern_cap*>& patterns);
    void matchCapWithPattern(
            std::map<std::string, std::vector<cap_node*>>& cap_layer_map_,
            std::map<std::string, std::vector<pattern_cap*>>& pattern_layer_map_,
            uint target_layer_number, uint target_layer_datatype);
    bool isPatternIncludeCap(const pattern_cap& pattern, const cap_node& cap);

    void setLayoutDataManager(T2D* layout_data_) { this->layout_data = layout_data_; }
    void addNewCapNode(pex_node& new_node, double value);

    std::string getLayerString(uint layer_number, uint layer_datatype);

    void normalizePatternCap();

    void makeLayersQueueForThreadJob();
    double percentileOfCapacitor(const pattern_cap& in_cap);



    void printCapNodes();
    void printPatternCaps(FILE* stream = stdout);
    void printLayerToCapNodeMap(FILE* stream = stdout);
    void printLayerToPatternCapMap(const char* msg = "");
    void printLayerList();
};


!@hash[]!@file[]./Rendering/Src/PEXResistorModel.h!@hash[]!@code[]#pragma once

#include "lve_model.hpp"


class PEXResistorModel : public LveModel
{
public:

    PEXResistorModel(LveDevice& device, MODEL_TYPE model_type, const QString& data_file = "");
    ~PEXResistorModel();

    PEXResistorModel() = delete;
    PEXResistorModel(const PEXResistorModel&) = delete;
    PEXResistorModel& operator=(const PEXResistorModel&) = delete;

private:
    PEXResistorDataManager pex_data;
    double res_cube_thickness;


public:
    virtual void makeRenderingData(const QString& file_path = "");
    virtual void loadData(const QString& file_path = "");
    virtual void groupResistorOfNode();
    virtual void increaseNumOfResistorGroup();
    virtual void decreaseNumOfResistorGroup();
    virtual void setDirectionOfResistor(PEXResDirection _direction);
    virtual void makeVertices();
    virtual void makeIndices();
    virtual void makeIndicesForEdge_map();

    double percentileOfResistance(const PEXResistor& in_res);

    void makeCubeVertices();
    void makeCubes();
    void makeCube(const PEXResistor& in_res, cube_info& out_cube, PEXResDirection direction);
    void setResCubeThickness(double value) { this->res_cube_thickness = value; }

private:

};


!@hash[]!@file[]./Rendering/Src/dtaorendersystem.h!@hash[]!@code[]#ifndef DTAORENDERSYSTEM_H
#define DTAORENDERSYSTEM_H

#include <QVulkanWindow>
#include <QVulkanWindowRenderer>
#include <QVulkanDeviceFunctions>
#include <vulkan/vulkan.h>

#include "lve_window.hpp"
#include "lve_device.hpp"
#include "lve_game_object.hpp"
#include "simple_render_system.hpp"
#include "lve_camera.hpp"
#include "keyboard_movement_controller.hpp"
#include "T2D.h"
#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "PEXResistorModel.h"

#include "ToyCAD/Src/toycad_object.h"

#include <iostream>
#include <vector>


enum DTAO_RENDER_MODE{
    DTAO_RENDER_MODE_EMPTY = 0,
    DTAO_RENDER_MODE_LAYOUT,
    DTAO_RENDER_MODE_PEX_ALL,
    DTAO_RENDER_MODE_PEX_RES,
    DTAO_RENDER_MODE_PEX_CAP,
    DTAO_RENDER_MODE_TOYCAD,
    DTAO_RENDER_MODE_DEFAULT
};

class LayoutModel;

class DtaoRenderSystem : public QVulkanWindowRenderer
{
public:
    DtaoRenderSystem(LveWindow *w);
    ~DtaoRenderSystem();

    DtaoRenderSystem(const DtaoRenderSystem &) = delete;
    DtaoRenderSystem &operator=(const DtaoRenderSystem &) = delete;


    void initResources() override;
    void initSwapChainResources() override;
    void releaseSwapChainResources() override;
    void releaseResources() override;
    void translateLayerPosition(POS_MONITORING value);
    void emitMonitor();

    void startNextFrame() override;

    float getRenderScale() {return this->trans_info.scale;}
    LayoutModel* getLayoutModel();
    bool isRenderModelLoaded(){return this->render_object_created;}
    std::vector<LveGameObject> &getGameObjects(){return this->gameObjects;}

public:
    LveCamera camera{};
    KeyboardMovementController cameraController{};


private:
    QVulkanDeviceFunctions *m_devFuncs = nullptr;

    void loadGameObjects();

    LveWindow* lveWindow = nullptr;
    LveDevice* lveDevice = nullptr;
    SimpleRenderSystem* simpleRenderSystem = nullptr;

    std::vector<LveGameObject> gameObjects{};
    bool render_object_created = {false};


    struct TRANS_INFORMATION{
       float trans_x;
       float trans_y;
       float trans_z;
       float scale;
       float minx;
       float miny;
    };
    TRANS_INFORMATION trans_info;
    std::shared_ptr<LayoutModel> layout_model = {nullptr};
    std::shared_ptr<PEXResistorModel> res_model = {nullptr};


public:
    void createNewObject(MODEL_TYPE model_type, const std::string & file_path);

    std::shared_ptr<PEXResistorModel> &getResistorModel() { return this->res_model;};
    void createT2DObject(MODEL_TYPE model_type, T2D t2d);
    void getCustomColor(string layernumber, glm::vec3 rgb);
    void getCustomOpacity(string layernumber, float opacity);
    void getCustomVisiblity(string layernumber, bool visibility);
    void createNewPEXCapObject(const QString & file_path, T2D t2d);
    void createNewPEXResObject(const QString & file_path);


private:
    void createNewLayoutObject(const std::string & file_path);
    void createT2DLayoutObject(T2D & t2d);
    void createNewAxisObject(const QString & file_path);


private:
    void createLveDevice();
    void deleteLveDevice();
    void createSimpleRenderSystem();
    void deleteSimpleRenderSystem();
    void beginRenderPass(VkCommandBuffer command_buffer);
    float aspect;

private:
    std::vector<ToyCADObject> toycad_objects{};

public:
    std::vector<ToyCADObject>& getToyCADObjects(){return this->toycad_objects;}
    void createToyCADObjects(const std::string& file_path);
    int render_mode{DTAO_RENDER_MODE_EMPTY};


};

#endif // DTAORENDERSYSTEM_H
!@hash[]!@file[]./Rendering/Src/keyboard_movement_controller.hpp!@hash[]!@code[]#pragma once

#include <QKeyEvent>
#include <QMouseEvent>
#include "lve_game_object.hpp"
#include "lve_window.hpp"
#include "lve_camera.hpp"
#include "PEXResistorModel.h"
//#include "defineParam.h"

#include "ToyCAD/Src/toycad_object.h"



class KeyboardMovementController {
public:
    struct ModelVisibleSet {
        int resistor_key = Qt::Key_R;
        int capacitor_key = Qt::Key_C;
        int resistor_up_key = Qt::Key_M;
        int resistor_down_key = Qt::Key_N;
        int resistor_horizontal_key = Qt::Key_Comma;
        int resistor_vertical_key = Qt::Key_Period;
        bool resistor_up_key_pressed = false;
        bool resistor_down_key_pressed = false;
        bool resistor_horizontal_key_pressed = false;
        bool resistor_vertical_key_pressed = false;
    };

    struct CameraMoveKeyMappings {
        int rotateLeft = Qt::Key_A;
        int rotateRight = Qt::Key_D;
        int moveForward = Qt::Key_W;
        int moveBackward = Qt::Key_S;
        int rotateForward = Qt::Key_E;
        int rotateBackward = Qt::Key_Q;
        int moveUp = Qt::Key_Up;
        int moveDown= Qt::Key_Down;
        int moveLeft= Qt::Key_Left;
        int moveRight= Qt::Key_Right;
        int toggleDemension= Qt::Key_T;
        Qt::MouseButtons mouseLeft = Qt::LeftButton;
        Qt::MouseButtons mouseRight = Qt::RightButton;
        Qt::MouseButtons mouseMiddle = Qt::MiddleButton;
    };

    struct CameraMovingContinousFlags {
        bool rotateLeft = false;
        bool rotateRight = false;
        bool moveForward = false;
        bool moveBackward = false;
        bool rotateForward = false;
        bool rotateBackward = false;
        bool moveUp = false;
        bool moveDown= false;
        bool moveLeft= false;
        bool moveRight= false;
        bool toggleDemension = false;
        bool toggleDemensionXY = false;
        bool mouseLeft= false;
        bool mouseRight= false;
        bool mouseMiddle= false;
        bool demoTrigger= false;
        bool demoInitLayer= false;
        bool tiltOn=false;
        bool layerOn=false;
        bool wave1 = false;
        bool wave2 = false;
        bool wave3 = false;
    };

    struct MousePosition {
        QPoint pressPosition;
        QPoint releasePosition;
        QPoint currentPosition;
        QPoint scroll;
        QPoint scrollClicked;
    };

    void visibleSetting(std::vector<LveGameObject>& gameObjects, Qt::Key key);
    ModelVisibleSet model_visible_set;
    void moveCamera(Qt::Key key, float dt, LveCamera& camera, float render_scale);
    CameraMoveKeyMappings camera_move_key;
    MousePosition mouse_position;

    void moveCamera(float dt, LveCamera& camera, float render_scale,
                    std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow,
                    std::vector<ToyCADObject>* toycad_objects = nullptr);
    void moveCameraMouse(LveCamera& camera, float render_scale,
                         std::vector<LveGameObject>& gameObjects,LveWindow* lvewindow,
                         std::vector<ToyCADObject>* toycad_objects = nullptr);
    void setPerspective(LveCamera& camera, float aspect);
    void moveKeyPressed(Qt::Key key);
    void moveKeyReleased(Qt::Key key);
    void moveButtonPressed(Qt::MouseButtons buttons);
    void moveButtonReleased(Qt::MouseButtons buttons);
    void setAllMoveFlagOff();
    void setMouseFlagOff();
    void setMousePosition(QPoint position, int mode);
    void setMouseScroll(QPoint position);
    void PEXSetting(std::shared_ptr< PEXResistorModel>& pexResistorModel, Qt::Key key);
    void triggerDemo();
    //void translateLayerPosition(std::vector<LveGameObject>& gameObjects);
    void onDemo(float dt, LveCamera& camera, float render_scale,std::vector<LveGameObject>& gameObjects, LveWindow* lvewindow);
    CameraMovingContinousFlags camera_moving_flag;
    POS_MONITORING monitor;

    glm::vec3 translationOnPressed;


    float moveSpeed{ 0.05f };
    float lookSpeed{ 1.5f };
    int xpos_prev;
    int ypos_prev;
    float perspectiveNear{ 0.1f };
    int demoTime{0};
    int demoCheckPoint{0};


};

!@hash[]!@file[]./Rendering/Src/lve_camera.hpp!@hash[]!@code[]#pragma once

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>
#include <glm/gtx/matrix_decompose.hpp>



class LveCamera {
public:
    void setOrthographicProjection(
            float left, float right, float top, float bottom, float near, float far);
    void setPerspectiveProjection(float fovy, float aspect, float near, float far);

    void setViewDirection(
            glm::vec3 position, glm::vec3 direction, glm::vec3 up = glm::vec3{0.f, -1.f, 0.f});
    void setViewTarget(
            glm::vec3 position, glm::vec3 target, glm::vec3 up = glm::vec3{0.f, -1.f, 0.f});
    void setViewYXZ(glm::vec3 position, glm::vec3 rotation);

    const glm::mat4& getProjection() const { return projectionMatrix; }
    const glm::mat4& getView() const { return viewMatrix; }
    void decomposeView(glm::mat4 viewMat);

public:
    glm::mat4 projectionMatrix{1.f};
    glm::mat4 viewMatrix{1.f};

    glm::vec3 scale_d;
    glm::quat rotation_d;
    glm::vec3 translation_d;
    glm::vec3 skew_d;
    glm::vec4 perspective_d;
    float std_scale = 1.f;
    bool isperspective = true;

};

!@hash[]!@file[]./Rendering/Src/lve_device.hpp!@hash[]!@code[]#pragma once

#include <QVulkanInstance>
#include <vulkan/vulkan.h>

// std lib headers
#include <string>
#include <vector>

#include "lve_window.hpp"


struct SwapChainSupportDetails {
    VkSurfaceCapabilitiesKHR capabilities;
    std::vector<VkSurfaceFormatKHR> formats;
    std::vector<VkPresentModeKHR> presentModes;
};

struct QueueFamilyIndices {
    uint32_t graphicsFamily;
    uint32_t presentFamily;
    bool graphicsFamilyHasValue = false;
    bool presentFamilyHasValue = false;
    bool isComplete() { return graphicsFamilyHasValue && presentFamilyHasValue; }
};

class LveDevice {
public:
#ifdef NDEBUG
    const bool enableValidationLayers = false;
#else
    const bool enableValidationLayers = true;
#endif

    LveDevice(LveWindow* window, QVulkanInstance* qvk_inst);
    ~LveDevice();

    // Not copyable or movable
    LveDevice(const LveDevice &) = delete;
    LveDevice &operator=(const LveDevice &) = delete;
    LveDevice(LveDevice &&) = delete;
    LveDevice &operator=(LveDevice &&) = delete;

    VkCommandPool getVkCommandPool() { return commandPool; }
    VkDevice device() { return device_; }
    VkSurfaceKHR surface() { return surface_; }
    VkQueue graphicsQueue() { return graphicsQueue_; }
    VkQueue presentQueue() { return presentQueue_; }
    VkInstance getInstance() { return this->instance;}

    SwapChainSupportDetails getSwapChainSupport() { return querySwapChainSupport(physicalDevice); }
    uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties);
    QueueFamilyIndices findPhysicalQueueFamilies() { return findQueueFamilies(physicalDevice); }
    VkFormat findSupportedFormat(
            const std::vector<VkFormat> &candidates, VkImageTiling tiling, VkFormatFeatureFlags features);

    // Buffer Helper Functions
    void createBuffer(
            VkDeviceSize size,
            VkBufferUsageFlags usage,
            VkMemoryPropertyFlags properties,
            VkBuffer &buffer,
            VkDeviceMemory &bufferMemory);
    VkCommandBuffer beginSingleTimeCommands();
    void endSingleTimeCommands(VkCommandBuffer commandBuffer);
    void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size);
    void copyBufferToImage(
            VkBuffer buffer, VkImage image, uint32_t width, uint32_t height, uint32_t layerCount);

    void createImageWithInfo(
            const VkImageCreateInfo &imageInfo,
            VkMemoryPropertyFlags properties,
            VkImage &image,
            VkDeviceMemory &imageMemory);

    VkPhysicalDeviceProperties properties;

private:
    void createInstance();
    void setupDebugMessenger();
    void createSurface();
    void pickPhysicalDevice();
    void createLogicalDevice();
    void createCommandPool();

    // helper functions
    bool isDeviceSuitable(VkPhysicalDevice device);
    std::vector<const char *> getRequiredExtensions();
    bool checkValidationLayerSupport();
    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device);
    void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT &createInfo);
    void hasRequiredInstanceExtensions();
    bool checkDeviceExtensionSupport(VkPhysicalDevice device);
    SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device);

    VkInstance instance;
    VkDebugUtilsMessengerEXT debugMessenger;
    VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
    LveWindow * window;
    QVulkanInstance * qvk_instance;
    VkCommandPool commandPool;

    VkDevice device_;
    VkSurfaceKHR surface_;
    VkQueue graphicsQueue_;
    VkQueue presentQueue_;

    const std::vector<const char *> validationLayers = {"VK_LAYER_KHRONOS_validation"};
    const std::vector<const char *> deviceExtensions = {VK_KHR_SWAPCHAIN_EXTENSION_NAME};
};

!@hash[]!@file[]./Rendering/Src/lve_game_object.hpp!@hash[]!@code[]#pragma once

#include "lve_model.hpp"

// libs
#include <glm/gtc/matrix_transform.hpp>
#include <glm/glm.hpp> //vec3, vec4, ivec4, mat4
#include <glm/gtc/type_ptr.hpp> //value_ptr

// std
#include <memory>


struct TransformComponent {
    glm::vec3 translation{};
    glm::vec3 scale{ 1.f, 1.f, 1.f };
    glm::vec3 rotation{};

    // Matrix corrsponds to Translate * Ry * Rx * Rz * Scale
    // Rotations correspond to Tait-bryan angles of Y(1), X(2), Z(3)
    // https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
    glm::mat4 mat4() {
        glm::mat4 glm_mat4 = glm::mat4{ 1 };
        //glm_mat4 = glm::rotate(glm_mat4,  rotation.x, glm::vec3(1.0f, 0.0f, 0.0f));
        //glm_mat4 = glm::rotate(glm_mat4, rotation.y, glm::vec3(0.0f, 1.0f, 0.0f));
        //glm_mat4 = glm::rotate(glm_mat4, rotation.z, glm::vec3(1.0f, 0.0f, 1.0f));
        glm_mat4 = glm::translate(glm_mat4, translation);
        glm_mat4 = glm::scale(glm_mat4, scale);



        return glm_mat4;
    }
};

class LveGameObject {
public:
    using id_t = unsigned int;

    static LveGameObject createGameObject() {
        static id_t currentId = 0;
        std::cout << "\n\n***LveGameObject :: id : " << currentId << "\n\n";
        return LveGameObject{ currentId++ };
    }

    LveGameObject(const LveGameObject&) = delete;
    LveGameObject& operator=(const LveGameObject&) = delete;
    LveGameObject(LveGameObject&&) = default;
    LveGameObject& operator=(LveGameObject&&) = default;

    id_t getId() { return id; }

    void setEdgeLineEnable(bool flag) { this->edge_line_enabled = flag; }
    void setAxisLineEnable(bool flag) { this->axis_line_enabled = flag; }

public:
    std::shared_ptr<LveModel> model{};
    //LveModel* model{};
    glm::vec3 color{};
    TransformComponent transform{};

private:
    LveGameObject(id_t objId) : id{ objId } {}

    id_t id;

private:
    bool edge_line_enabled = { true };
    bool axis_line_enabled = { true };
};

class DTAOObject {
public:
    using id_t = unsigned int;

    static DTAOObject createObject() {
        static id_t currentId = 0;
        std::cout << "\n\n***DTAOObject :: id : " << currentId << "\n\n";
        return DTAOObject{ currentId++ };
    }

    DTAOObject(const DTAOObject&) = delete;
    DTAOObject& operator=(const DTAOObject&) = delete;
    DTAOObject(DTAOObject&&) = default;
    DTAOObject& operator=(DTAOObject&&) = default;

    id_t getId() { return id; }

    void setEdgeLineEnable(bool flag) { this->edge_line_enabled = flag; }
    void setAxisLineEnable(bool flag) { this->axis_line_enabled = flag; }

public:
    std::shared_ptr<LveModel> model{};
    //LveModel* model{};
    glm::vec3 color{};
    TransformComponent transform{};

private:
    DTAOObject(id_t objId) : id{ objId } {}

    id_t id;

private:
    bool edge_line_enabled = { true };
    bool axis_line_enabled = { true };
};
!@hash[]!@file[]./Rendering/Src/lve_model.hpp!@hash[]!@code[]#pragma once

#include "lve_device.hpp"

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>

// std
#include <vector>

#include <string>
#include <iostream>

#include <map>
//#include <ranges>
#include "LayoutPEXData.h"

typedef enum MODEL_TYPE {
    MODEL_TYPE_LAYOUT = 0,
    MODEL_TYPE_AXIS,
    MODEL_TYPE_PEX_RESISTOR,
    MODEL_TYPE_PEX_CAPACITOR,
    MODEL_TYPE_TOY_CAD,
    MODEL_TYPE_DEFAULT
} MODEL_TYPE;


class LveModel {
public:
    struct Vertex {
        glm::vec3 position{};
        glm::vec3 color{};
        glm::vec3 normal{};

        static std::vector<VkVertexInputBindingDescription> getBindingDescriptions();
        static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions();
    };

    struct VertexResistor {
        glm::vec3 position{};
        glm::vec4 color{};
        glm::vec3 normal{};

        static std::vector<VkVertexInputBindingDescription> getBindingDescriptions();
        static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions();
    };


    struct LayerProperty {
        bool visiblity;
        glm::vec3 color{};
        float opacity;
    };

    LveModel(LveDevice& device, MODEL_TYPE model_type);
    ~LveModel();

    LveModel() = delete;
    LveModel(const LveModel&) = delete;
    LveModel& operator=(const LveModel&) = delete;

    //void bind(VkCommandBuffer commandBuffer);
    void bindVertexBuffer(VkCommandBuffer commandBuffer);
    void bindVertexBuffer_map(VkCommandBuffer commandBuffer);
    void bindIndexBufferForFace(VkCommandBuffer commandBuffer);
    void bindIndexBufferForFace_map(VkCommandBuffer commandBuffer);
    void bindDrawVertexIndexBufferForFace_map(VkCommandBuffer commandBuffer);
    void bindDrawVertexIndexBufferForFace_layer(VkCommandBuffer commandBuffer, const string layer);
    void bindDrawIndexBufferForEdge_layer(VkCommandBuffer commandBuffer, const string layer);
    void bindIndexBufferForEdge(VkCommandBuffer commandBuffer);
    void drawForFace(VkCommandBuffer commandBuffer);
    void drawForEdge(VkCommandBuffer commandBuffer);


public:
    void createBuffers();
    void destroyBuffers();
    void createVertexBuffers(const std::vector<Vertex>& vertices, VkBuffer& buffer, VkDeviceMemory& memory);
    void createVertexBuffersResistor(const std::vector<VertexResistor>& vertices, VkBuffer& buffer, VkDeviceMemory& memory);
    void createIndexBuffers(const std::vector<uint32_t>& indices, VkBuffer & buffer, VkDeviceMemory & memory);
    LveDevice& lveDevice;
    VkBuffer vertexBuffer{};
    VkDeviceMemory vertexBufferMemory{};
    std::map<string, VkBuffer> layerbyVertexBuffers;
    std::map<string, VkDeviceMemory> layerbyVertexBuffersMemory;
    uint32_t vertexCount{};

    VkBuffer indexBufferForFace{};
    VkDeviceMemory indexBufferMemoryForFace{};
    VkBuffer indexBufferForEdge{};
    VkDeviceMemory indexBufferMemoryForEdge{};

    std::map<string, VkBuffer> layerbyFaceIndexBuffers;
    std::map<string, VkDeviceMemory> layerbyFaceIndexBuffersMemory;
    std::map<string, VkBuffer> layerbyEdgeIndexBuffers;
    std::map<string, VkDeviceMemory> layerbyEdgeIndexBuffersMemory;

    MODEL_TYPE model_type{};

public:
    //std::string layout_info_file;
    std::vector<cube_info> cube_infos{};
    std::vector<cube_vertex> cube_vertices{};

    std::vector<Vertex> vertices{};
    std::vector<VertexResistor> vertices_resistor{};
    std::vector<uint32_t> indices_face{};
    std::vector<uint32_t> indices_edge{};
    std::vector<string> drawing_order_layerby{};

    std::map<string, std::vector<Vertex>> layerby_vertices;
    std::map<string, std::vector<uint32_t>> layerby_face;
    std::map<string, std::vector<uint32_t>> layerby_edge;
    std::map<string, LayerProperty> layerList;
    std::map<string, glm::vec3> init_layerby_color;
    void changeLayerColor(string layernumber, glm::vec3 rgb);
    void changeLayerOpacity(string layernumber, float opacity);
    void changeLayerVisiblity(string layernumber, bool visiblity);
    void demoVisiblityOff();
    void demoVisiblityOn(std::vector<string> layernumbers);
    bool visible{true};
    float opacity{ 1.0f };

public:
    MODEL_TYPE getModelType() { return this->model_type; }

public:
    //void setLayoutInfoFile(const std::string file_path) { this->layout_info_file = file_path; }
    virtual void makeRenderingData(const QString& file_path = "") {(void)file_path;};
    virtual void loadData(const std::string& file_path = "") {(void)file_path;};
    virtual void makeVertices() {};
    virtual void makeIndices() {};

    void makeAxisData(const float axis_length = (2.0f));
    void setVisible(bool flag) { this->visible = flag; }
    bool getVisible() { return this->visible; }
    void toggleVisible() { this->visible = !this->visible; }
    void updateOpacity(float amount);
    float getOpacity() { return this->opacity; }
    std::map<string, LayerProperty> getLayer();

};

!@hash[]!@file[]./Rendering/Src/lve_pipeline.hpp!@hash[]!@code[]#pragma once

#include "lve_device.hpp"

// std
#include <string>
#include <vector>



struct PipelineConfigInfo {
    PipelineConfigInfo() = default;
    PipelineConfigInfo(const PipelineConfigInfo&) = delete;
    PipelineConfigInfo& operator=(const PipelineConfigInfo&) = delete;

    VkPipelineViewportStateCreateInfo viewportInfo;
    VkPipelineInputAssemblyStateCreateInfo inputAssemblyInfo;
    VkPipelineRasterizationStateCreateInfo rasterizationInfo;
    VkPipelineMultisampleStateCreateInfo multisampleInfo;
    VkPipelineColorBlendAttachmentState colorBlendAttachment;
    VkPipelineColorBlendStateCreateInfo colorBlendInfo;
    VkPipelineDepthStencilStateCreateInfo depthStencilInfo;
    std::vector<VkDynamicState> dynamicStateEnables;
    VkPipelineDynamicStateCreateInfo dynamicStateInfo;
    VkPipelineLayout pipelineLayout = nullptr;
    VkRenderPass renderPass = nullptr;
    uint32_t subpass = 0;
};

class LvePipeline {
public:
    LvePipeline(
        LveDevice& device,
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo,
        const std::vector<VkVertexInputBindingDescription> bindingDescription_,
        const  std::vector<VkVertexInputAttributeDescription> attributeDescription_);
    ~LvePipeline();

    LvePipeline(const LvePipeline&) = delete;
    LvePipeline& operator=(const LvePipeline&) = delete;

    void bind(VkCommandBuffer commandBuffer);

    static void defaultPipelineConfigInfo(PipelineConfigInfo& configInfo);

private:
    static std::vector<char> readFile(const std::string& filepath);

    void createGraphicsPipeline(
        const std::string& vertFilepath,
        const std::string& fragFilepath,
        const PipelineConfigInfo& configInfo,
        const std::vector<VkVertexInputBindingDescription> bindingDescription_,
        const  std::vector<VkVertexInputAttributeDescription> attributeDescription_);

    void createShaderModule(const std::vector<char>& code, VkShaderModule* shaderModule);

    LveDevice& lveDevice;
    VkPipeline graphicsPipeline;
    VkShaderModule vertShaderModule;
    VkShaderModule fragShaderModule;
};

!@hash[]!@file[]./Rendering/Src/lve_window.hpp!@hash[]!@code[]#ifndef LVEWINDOW_H
#define LVEWINDOW_H
#include <vulkan/vulkan.h>
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/string_cast.hpp>

#include <QVulkanWindow>
#include "defineParam.h"
//#include <QVulkanWindowRenderer>

//#include "dtaorendersystem.h"

class QVulkanWidowRenderer;
class DtaoRenderSystem;

class LveWindow : public QVulkanWindow
{
    Q_OBJECT

public:
    LveWindow();
    ~LveWindow();

    LveWindow(const LveWindow &) = delete;
    LveWindow &operator=(const LveWindow &) = delete;

public:
    QVulkanWindowRenderer *createRenderer() override;
    //QVulkanWindowRenderer * getRenderer(){ return this->m_renderer;}
    //LveCamera* camera;
    void emitStatus(float value);

public:
    DtaoRenderSystem * getRenderer(){return this->m_renderer;}

private:
    DtaoRenderSystem *m_renderer;
    //QVulkanWindowRenderer * m_renderer;

    void wheelEvent(QWheelEvent *) override;
    void mousePressEvent(QMouseEvent *) override;
    void mouseReleaseEvent(QMouseEvent *) override;
    void mouseMoveEvent(QMouseEvent *) override;
    void keyPressEvent(QKeyEvent *) override;
    void keyReleaseEvent(QKeyEvent *) override;

    bool keyCtrl = false;
    bool keyShift = false;
    bool keyAlt = false;

    int m_mouseButton = 0;


    QPoint m_lastPos;

signals:
    void signalInfoText(QString funcName, POS_MONITORING value);
};

#endif // LVEWINDOW_H
!@hash[]!@file[]./Rendering/Src/simple_render_system.hpp!@hash[]!@code[]#pragma once
#include <vulkan/vulkan.h>

#include "lve_camera.hpp"
#include "lve_device.hpp"
#include "lve_game_object.hpp"
#include "lve_pipeline.hpp"

#include "ToyCAD/Src/toycad_object.h"

// std
#include <memory>
#include <vector>


class SimpleRenderSystem {


public:

    SimpleRenderSystem(LveDevice& device, VkRenderPass renderPass);
    ~SimpleRenderSystem();

    SimpleRenderSystem(const SimpleRenderSystem&) = delete;
    SimpleRenderSystem& operator=(const SimpleRenderSystem&) = delete;

    void renderGameObjects(
            VkCommandBuffer commandBuffer,
            std::vector<LveGameObject>& gameObjects,
            const LveCamera& camera);

    void renderToyCADObjects(
            VkCommandBuffer commandBuffer,
            std::vector<ToyCADObject>& objects,
            const LveCamera& camera);

private:
    void createPipelineLayout(VkPipelineLayout & pipeline_layout);
    void createPipelineForFace(VkRenderPass renderPass);
    void createPipelineForEdge(VkRenderPass renderPass);
    void createPipelineForPEXResistor(VkRenderPass renderPass);
    void createPipelineForPEXResistorEdge(VkRenderPass renderPass);
    void createPipelineForPEXCapacitorLine(VkRenderPass renderPass);
    void createPipelineForPEXCapacitor(VkRenderPass renderPass);

    void createPipelineForToyCADFace(VkRenderPass renderPass);
    void createPipelineForToyCADEdge(VkRenderPass renderPass);

    LveDevice& lveDevice;

    std::unique_ptr<LvePipeline> lvePipelineForLayoutFace;
    VkPipelineLayout pipelineLayoutForLayoutFace;

    std::unique_ptr<LvePipeline> lvePipelineForLayoutEdge;
    VkPipelineLayout pipelineLayoutForLayoutEdge;

    std::unique_ptr<LvePipeline> lvePipelineForPEXResistor;
    VkPipelineLayout pipelineLayoutForPEXResistor;

    std::unique_ptr<LvePipeline> lvePipelineForPEXResistorEdge;
    VkPipelineLayout pipelineLayoutForPEXResistorEdge;

    std::unique_ptr<LvePipeline> lvePipelineForPEXCapacitorLine;
    VkPipelineLayout pipelineLayoutForPEXCapacitorLine;

    std::unique_ptr<LvePipeline> lvePipelineForPEXCapacitor;
    VkPipelineLayout pipelineLayoutForPEXCapacitor;

    std::unique_ptr<LvePipeline> lvePipelineForToyCADFace;
    VkPipelineLayout pipelineLayoutForToyCADFace;
    std::unique_ptr<LvePipeline> lvePipelineForToyCADEdge;
    VkPipelineLayout pipelineLayoutForToyCADEdge;


};

!@hash[]!@file[]./Rendering/Src/utils.h!@hash[]!@code[]#pragma once
#ifndef UTILS
#define UTILS
#endif

// libs
#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>

#include <string>
#include <iostream>
#include <cstdio>

namespace UTILS {
    inline bool check_file_exsist(const std::string& file_path) {
        FILE* fp = nullptr;
        if (fopen_s(&fp, file_path.c_str(), "r")) {
            fclose(fp);
            return true;
        }
        else {
            return false;
        }
    }

    glm::vec3 getPercentileColour(double v, double vmin, double vmax)
    {
        glm::vec3 c = { 1.0,1.0,0.0 }; // white
        double dv;

        if (v < vmin)
            v = vmin;
        if (v > vmax)
            v = vmax;
        dv = vmax - vmin;

        if (v < (vmin + 0.05 * dv)) {
            c.r = 1;
            c.g = 0;
        }
        else if (v < (vmin + 0.5 * dv)) {
            c.r = 0.5 + 5 * (vmin + 0.5 * dv - v) / dv / 4;
            c.g = 0.5 + 5 * (v - vmin - 0.5 * dv) / dv / 4;
        }
        else if (v < (vmin + 0.95 * dv)) {
            c.r = 0.5 + 5 * (vmin + 0.5 * dv - v) / dv / 4;
            c.g = 0.5 + 5 * (v - vmin - 0.5 * dv) / dv / 4;
        }
        else {
            c.r = 0;
            c.g = 1;
        }


        return(c);
    }
}

!@hash[]!@file[]./T2D.h!@hash[]!@code[]#ifndef T2D_H
#define T2D_H

#include "defineParam.h"

#include <iostream>
#include <vector>
#include <sstream>
#include <fstream>
#include <map>

using namespace std;

struct Instance{
    int level;
    string name;
    string num;
    B_BOX box;
};

class T2D{
    public:
        bool text2data(std::string file_name);

        std::vector<LDATA10BY10> LayoutData10by10;
        map<string, LDATA10BY10> map_LayoutData10by10_;
        MIN_MAX_XYZ LayoutMinMax;

        LDATA10BY10 buf_ldata10by10;
        vector<vector<vector<B_BOX>>> buf_xy10by10;
        vector<B_BOX> buf_xy;
        static std::vector<std::string> string_split(std::string input, char delimiter);

        vector<Instance> HierarchyInstance;

        int row;
        int col;

        bool m_filter_onoff = false;
};

#endif // T2D_H
!@hash[]!@file[]./ToyCAD/Src/toycad_object.h!@hash[]!@code[]#ifndef TOYCAD_OBJECT_H
#define TOYCAD_OBJECT_H

#include "toycadmodel.h"

#include <glm/gtc/matrix_transform.hpp>
#include <glm/glm.hpp>


struct ToyCADTransformComponent {
    glm::vec3 translation{};
    glm::vec3 scale{ 1.f, 1.f, 1.f };
    glm::vec3 rotation{};


    glm::mat4 mat4() {
        glm::mat4 glm_mat4 = glm::mat4{ 1 };
        //glm_mat4 = glm::rotate(glm_mat4,  rotation.x, glm::vec3(1.0f, 0.0f, 0.0f));
        //glm_mat4 = glm::rotate(glm_mat4, rotation.y, glm::vec3(0.0f, 1.0f, 0.0f));

        glm_mat4 = glm::translate(glm_mat4, translation);
        glm_mat4 = glm::rotate(glm_mat4,
                               glm::radians(rotation.z),
                               glm::vec3(0.0f, 0.0f, 1.0f));
        glm_mat4 = glm::scale(glm_mat4, scale);


        return glm_mat4;
    }
};

class ToyCADObject {
public:
    static ToyCADObject createToyCADObject() {
        static unsigned int currentId = 0;
        return ToyCADObject{ currentId++ };
    }

    ToyCADObject(unsigned int objId) : id{ objId } {}

    ToyCADObject(const ToyCADObject&) = delete;
    ToyCADObject& operator=(const ToyCADObject&) = delete;
    ToyCADObject(ToyCADObject&&) = default;
    ToyCADObject& operator=(ToyCADObject&&) = default;

public:
    std::shared_ptr<ToyCADModel> model{};
    glm::vec3 color{};
    float opacity{1.0f};
    bool visibility{true};

    ToyCADTransformComponent transform{};

private:
    unsigned int id;

public:
    unsigned int getId() { return this->id; }
    bool getVisibility(){return this->visibility;}
    void setVisibility(bool visibility){this->visibility = visibility;}
};




#endif // TOYCAD_OBJECT_H
!@hash[]!@file[]./ToyCAD/Src/toycaddata.h!@hash[]!@code[]#ifndef TOYCADDATA_H
#define TOYCADDATA_H

#include <iostream>
#include <vector>


enum TOYCAD_DATA_INDEX {
    TOYCAD_DATA_IDX_TYPE = 0,
    TOYCAD_DATA_IDX_LAYER,
    TOYCAD_DATA_IDX_MINX,
    TOYCAD_DATA_IDX_MINY,
    TOYCAD_DATA_IDX_MAXX,
    TOYCAD_DATA_IDX_MAXY,
    TOYCAD_DATA_IDX_MINZ,
    TOYCAD_DATA_IDX_MAXZ,
    TOYCAD_DATA_IDX_COLOR_R,
    TOYCAD_DATA_IDX_COLOR_G,
    TOYCAD_DATA_IDX_COLOR_B,
    TOYCAD_DATA_IDX_COLOR_A,
    TOYCAD_DATA_IDX_SLOPEX,
    TOYCAD_DATA_IDX_SLOPEY,
    TOYCAD_DATA_IDX_ROTATE,
    TOYCAD_DATA_IDX_DEFAULT
};

enum TOYCAD_BBOX_INDEX {
    TOYCAD_BBOX_IDX_MINX = 0,
    TOYCAD_BBOX_IDX_MAXX,
    TOYCAD_BBOX_IDX_MINY,
    TOYCAD_BBOX_IDX_MAXY,
    TOYCAD_BBOX_IDX_MINZ,
    TOYCAD_BBOX_IDX_MAXZ,
    TOYCAD_BBOX_IDX_DEFAULT
};

enum TOYCAD_TYPE_LIST {
    TOYCAD_TYPE_RECT = 0,
    TOYCAD_TYPE_CIRCLE,
    TOYCAD_TYPE_FAN,
    TOYCAD_TYPE_HEXAGON,
    TOYCAD_TYPE_OCTAGON,
    TOYCAD_TYPE_DEFAULT = 99
};

struct TOYCAD_DATA {
    std::string type;
    std::string layer;
    double minx;
    double miny;
    double maxx;
    double maxy;
    double minz;
    double maxz;
    double color_r;
    double color_g;
    double color_b;
    double color_a;
    double slopex;
    double slopey;
    double rotation_degree;
};

struct TOYCAD_BBOX{
    double min_x;
    double max_x;
    double min_y;
    double max_y;
    double min_z;
    double max_z;
};


class ToyCADData
{
public:
    ToyCADData();
    ~ToyCADData();

public:
    std::vector<TOYCAD_DATA>* getCADData(){ return &this->cad_data;}
    void loadToyCADData(const std::string& file_path);
    TOYCAD_BBOX& getDataBBox(){ return this->data_bbox;}
    double getScale(){return this->scale;}

private:
    std::vector<TOYCAD_DATA> cad_data;
    TOYCAD_BBOX data_bbox;
    double scale;

private:
    void calculateScale();
    void printAllData();
};

#endif // TOYCADDATA_H
!@hash[]!@file[]./ToyCAD/Src/toycadmodel.h!@hash[]!@code[]#ifndef TOYCADMODEL_H
#define TOYCADMODEL_H



#include <iostream>
#include <vector>
#include <string>

#include "Rendering/Src/lve_device.hpp"
#include "Rendering/Src/lve_model.hpp"
#include "toycaddata.h"


class ToyCADModel
{
public:
    struct ToyCADVertex {
        glm::vec3 position{};
        glm::vec3 color{};

        static std::vector<VkVertexInputBindingDescription> getBindingDescriptions();
        static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions();
    };

public:
    ToyCADModel(LveDevice& device, TOYCAD_DATA& toycad_data);
    ~ToyCADModel();

    ToyCADModel() = delete;
    ToyCADModel(const ToyCADModel&) = delete;
    ToyCADModel& operator=(const ToyCADModel&) = delete;


    void bindVertexBuffer(VkCommandBuffer commandBuffer);
    void bindIndexBufferForFace(VkCommandBuffer commandBuffer);
    void bindIndexBufferForEdge(VkCommandBuffer commandBuffer);
    void drawForFace(VkCommandBuffer commandBuffer);
    void drawForEdge(VkCommandBuffer commandBuffer);

    void createBuffers();
    void destroyBuffers();
    void createVertexBuffer(const std::vector<ToyCADVertex>& vertices, VkBuffer& buffer, VkDeviceMemory& memory);
    void createIndexBuffer(const std::vector<uint32_t>& indices, VkBuffer & buffer, VkDeviceMemory & memory);

public:
    void makeRenderingData(TOYCAD_DATA& toycad_data);
    void setNumPointsForCircle(unsigned int num_){this->num_points_for_circle=num_;}
    MODEL_TYPE getModelType() { return this->model_type; }

private:
    void makeVertices(TOYCAD_DATA& toycad_data);
    void makeIndices();

    void makeRectVertices(TOYCAD_DATA& toycad_data);
    void makeCircleVertices(TOYCAD_DATA& toycad_data);
    void makeFanVertices(TOYCAD_DATA& toycad_data);
    void makeHexagonVertices(TOYCAD_DATA& toycad_data);
    void makeOctagonVertices(TOYCAD_DATA& toycad_data);

    void makeRectIndices();
    void makeCircleIndices();
    void makeFanIndices();
    void makeHexagonIndices();
    void makeOctagonIndices();

    //void makeIndicesForEdge();
    int getCurDataType(std::string& str_type);

public:
    LveDevice& lveDevice;
    VkBuffer vertexBuffer{};
    VkDeviceMemory vertexBufferMemory{};
    VkBuffer indexBufferForFace{};
    VkDeviceMemory indexBufferMemoryForFace{};
    VkBuffer indexBufferForEdge{};
    VkDeviceMemory indexBufferMemoryForEdge{};

    std::vector<ToyCADVertex> vertices{};
    std::vector<uint32_t> indices_face{};
    std::vector<uint32_t> indices_edge{};



private:
    unsigned int num_points_for_circle;
    int toycad_datatype;
    MODEL_TYPE model_type{};

public:
    void test();
};

#endif // TOYCADMODEL_H
!@hash[]!@file[]./all_data.h!@hash[]!@code[]#ifndef ALL_DATA_H
#define ALL_DATA_H

#include <QObject>
#include <QDebug>
#include <QVector>


class all_data : public QObject
{
    Q_OBJECT
//    Q_DECLARE_METATYPE(QVector <QVector <QString>>);

public:
    all_data(QObject *parent = nullptr);
    ~all_data();

public:
    QVector <QVector <QString>> inputDataVector;

public slots:
    void receiveSelectFileName(QString file_name);

signals:
    void sendSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector);


};

#endif // ALL_DATA_H
!@hash[]!@file[]./defineParam.h!@hash[]!@code[]#ifndef DEFINETYPE_H
#define DEFINETYPE_H

#include <iostream>
#include <vector>

using namespace std;

struct POS_MONITORING{
    double x;
    double y;
    double z;
    double tilt;
    double rotation;
    double zoom;
    double window_zoom;
};

struct POS_SET
{
    std::string name;
    POS_MONITORING position;
};

struct B_BOX{
    double minx;
    double miny;
    double maxx;
    double maxy;
};

struct COLOR_RGBA{
    int r;
    int g;
    int b;
    int a;
};

struct LDATA10BY10{
    bool checking;
    std::string layername;
    int layernum;
    int datatype;
    COLOR_RGBA color;
    double bot;
    double top;
    std::vector<std::vector<std::vector<B_BOX>>> xy;
    std::vector<std::vector<std::vector<B_BOX>>> xy_filtered;
};

struct MIN_MAX_XYZ{
    double minx;
    double maxx;
    double miny;
    double maxy;
    double minz;
    double maxz;
};


#endif // DEFINETYPE_H


!@hash[]!@file[]./dev_dialog.h!@hash[]!@code[]#ifndef DEV_DIALOG_H
#define DEV_DIALOG_H

#include <QDialog>
#include <defineParam.h>

namespace Ui {
class DevDialog;
}

class DevDialog : public QDialog
{
    Q_OBJECT

public:
    explicit DevDialog(QWidget *parent = nullptr);
    ~DevDialog();

    void sendParameter(bool *is_pos_checked_, POS_MONITORING *pos_);
    void changePos();

private slots:
    void on_checkBox_pos_stateChanged(int arg1);

private:
    Ui::DevDialog *ui;
    bool *is_pos_checked;
    bool init_check = false;
    POS_MONITORING *pos;
};

#endif // DEV_DIALOG_H
!@hash[]!@file[]./filedb.h!@hash[]!@code[]#ifndef FILEDB_H
#define FILEDB_H

#include <QVector>


class FileDb
{
public:
    FileDb();
    void openFile(QString fileNameInfo,QVector<QList<float>> &vecList,
                  float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize);
};

#endif // FILEDB_H
!@hash[]!@file[]./formhier.h!@hash[]!@code[]#ifndef FORMHIER_H
#define FORMHIER_H

#include <QDialog>
//#include "all_data.h"
//#include "mainwindow.h"

#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QSortFilterProxyModel>
#include <vector>
#include <iostream>

#include "T2D.h"

namespace Ui {
class FormHier;
}

class FormHier : public QDialog
{
    Q_OBJECT

public:
    FormHier(QWidget *parent = nullptr);
    ~FormHier();
    Ui::FormHier *ui;

    T2D *t2d;

    void createHierarchyTree(T2D *t2d);
private slots:
    void on_hierarchy_tree_itemDoubleClicked(QTreeWidgetItem *item, int column);
    void on_hierarchy_searching_textEdited(const QString &arg1);
};

#endif // FORMHIER_H

/////
!@hash[]!@file[]./forminfo.h!@hash[]!@code[]#ifndef FORMINFO_H
#define FORMINFO_H

#include <QDialog>
#include <QLineEdit>
#include <QListWidgetItem>
#include <glm/gtx/string_cast.hpp>
#include "T2D.h"
#include "defineParam.h"

namespace Ui {
class FormInfo;
}

class FormInfo : public QDialog
{
    Q_OBJECT

public:
    explicit FormInfo(QWidget *parent = nullptr);
    ~FormInfo();

    void setTextPosTotal(POS_MONITORING *pos);
    void receiveFile(T2D &t2d);
    void receivePointPos(POS_MONITORING &pos);
    void changePos();
    void addItemToPosList(POS_SET *position_item);

private:
    void addItemToListWidget();
    void setTextTrim(QLineEdit *text, double *value, int scale_, QString add_text_);
    void setTextTrim(QLineEdit *text, QString text_);
    void makePosListItem();

    void outputPosList();
    void resetPosList();
    QString makePosText();
    void sendStatusBarMsg(QString msg);
    void inputValueToTemp(double *point, double value_);
    void convertTextToValue(double *point, const QString &str);
    void inputPos();

//    void selectListWidgetItem();

    Ui::FormInfo *ui;
    T2D *rendering_full;
    POS_MONITORING *POS;
    POS_MONITORING TEMP_POS;
    QVector<POS_SET> POS_STACK;
    QList<QListWidgetItem*> selected_item;
    bool isFileOpen = false;
    bool isEndedEdit = true;
    bool make_status_bar_msg = true;
    int current_item = -1;
    int pos_number = 0;
    int item_data_i = 0;

signals:
    void signalDirectlyInputPos();
    void signalStatusBarMsg(QString msg);
private slots:
    void on_pos_x_textEdited(const QString &arg1);
    void on_pos_y_textEdited(const QString &arg1);
    void on_pos_z_textEdited(const QString &arg1);
    void on_ang_tilt_textEdited(const QString &arg1);
    void on_ang_rotation_textEdited(const QString &arg1);
    void on_zoom_textEdited(const QString &arg1);    
    void on_pos_x_editingFinished();
    void on_pos_y_editingFinished();
    void on_pos_z_editingFinished();
    void on_ang_tilt_editingFinished();
    void on_ang_rotation_editingFinished();
    void on_zoom_editingFinished();
    void on_pos_x_returnPressed();
    void on_pos_y_returnPressed();
    void on_pos_z_returnPressed();
    void on_ang_tilt_returnPressed();
    void on_ang_rotation_returnPressed();
    void on_zoom_returnPressed();

    void on_listWidget_currentRowChanged(int currentRow);
    void on_pushButton_go_clicked();
    void on_pushButton_del_clicked();
    void on_listWidget_itemChanged(QListWidgetItem *item);

    void on_listWidget_itemSelectionChanged();
};

#endif // FORMINFO_H
!@hash[]!@file[]./formlayer.h!@hash[]!@code[]#ifndef FORMLAYER_H
#define FORMLAYER_H

#include <QDialog>
#include <QColorDialog>
#include <QtWidgets/QCheckBox>
#include <QTableWidget>
#include <QTableWidgetItem>
#include <QCheckBox>
#include <QPushButton>
#include <QtWidgets/QSlider>
#include <QRgba64>
#include <QDebug>
#include "Rendering/Src/lve_window.hpp"
#include "Rendering/Src/dtaorendersystem.h"
#include "T2D.h"


namespace Ui {
class FormLayer;
}

class FormLayer : public QDialog
{
    Q_OBJECT

public:
    explicit FormLayer(LveWindow *w, QWidget *parent = nullptr);
    ~FormLayer();
    void ReceiveLayerInformation(T2D &t2d);
    void MakeLayerInformationTableHeader();
    void MakeLayerInformationTalbe();
    void MakeTableWidgetItemForText(int);
    void MakeSliderForOpacity(int);
    void MakeCheckBox(int);
    void MakeColorButton(int);
    void MakeHeaderCheckBoxAndSlider();
    void ChangeAllCheckBoxState(QCheckBox *);
    void ChangeCheckBoxStateToOn(int, string, QString);
    void ChangeCheckBoxStateToOff(int, string, QString);
    void GetPushButtonOldColor(QPushButton *, int *, int *, int *, int *, QRgb *);
    void EnterPushButtonNewColor(int *, QRgb *);
    int FindCheckBoxRow(QCheckBox *);

    bool m_layer_all_check = false;

public slots:
    void on_checkboxInTable_stateChanged();
    void on_colorbutton_clicked();
    void on_opacityslider_valueChanged(int);
    void OpacitySliderValueChange(int);

private:
    LveWindow *m_window;
    Ui::FormLayer *ui;
    T2D *t2d_layer_information;
    int data_row_for_t2d = -1;
    int checkboxrow = -1;
    int table_default_column = 6;
    QString empty_for_emit = "";
    QString CommentAllCheckedCheckBox = "All Layer Checked";
    QString CommentAllUncheckedCheckBox = "All Layer Unchecked";


signals:
    void outputLayerStatus(QString printLayer);

};

#endif // FORMLAYER_H
!@hash[]!@file[]./formmap.h!@hash[]!@code[]#ifndef FORMMAP_H
#define FORMMAP_H
#include <glm/gtx/string_cast.hpp>
#include <QDialog>
#include <QGraphicsRectItem>
#include "defineParam.h"
#include "T2D.h"

namespace Ui {
class FormMap;
}

class SuperItem : public QObject, public QGraphicsItem
{
    Q_OBJECT
public:
    SuperItem(QGraphicsItem* parent = NULL);
    void getScaleValue(double *m_scale_, double *m_from_window_to_box_x_, double *m_from_window_to_box_y_, double *m_min_x_, double *m_min_y_, double *m_zoom_init_);
public slots:
    void slotMove(POS_MONITORING *pos);
    virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;

protected:
    void paint(QPainter *painter,
               const QStyleOptionGraphicsItem *option,
               QWidget *widget);    
    QRectF boundingRect() const;


//    virtual void keyPressEvent(QKeyEvent *evnet);

private:
    bool init_check = true;
    double convertPosX();
    double convertPosY();
    double m_pos_past_x = 0;
    double m_pos_past_y = 0;
    double m_view_size = 1;    
    double m_gray_box_size = 120;
    double *m_scale;
    double *m_zoom_init;
    double *m_from_window_to_box_x;
    double *m_from_window_to_box_y;
    double *m_min_x;
    double *m_min_y;
    double m_zero_point_x;
    double m_zero_point_y;
    double temp_x;      // 마우스로 box 움직일 때 좌표 알아보기 위함
    double temp_y;
};

class FormMap : public QDialog
{
    Q_OBJECT

public:
    explicit FormMap(QWidget *parent = nullptr);
    ~FormMap();
    void receiveFile(T2D &t2d);
    void receivePointPos(POS_MONITORING &pos);
    void changePos();

signals:
    void signalMove(POS_MONITORING *pos);
    void signalInitMove(double x, double y);

private:    
    Ui::FormMap *ui;
    QGraphicsRectItem *rectItem;
    QGraphicsRectItem *rectItem2;
    QRect *rect;
    double m_min_x;
    double m_min_y;
    double m_scale = 1;
    double m_zoom_init;
    double m_gray_box_size = 120;
    double m_window_width;
    double m_window_height;
    double m_box_width;
    double m_box_height;
    double m_from_window_to_box_x;
    double m_from_window_to_box_y;

    SuperItem *super;

    POS_MONITORING *pos;

    float pointX = 0;
    float pointY = 0;
    float pointZ = 0;
    float infoTilt = 90;
    float infoRot = 0;
    float infoZoom = 1; //Zoom 초기값에 대한 GDS size 를 갖고와 수정 필요

    float initRot = 0;
    float initTilt = 90;
    float initPointX = 0;
    float initPointY = 0;
    float initPointZ = 0;

    float x = 0;
    float y = 0;
};



#endif // FORMMAP_H
!@hash[]!@file[]./formtop.h!@hash[]!@code[]#ifndef FORMTOP_H
#define FORMTOP_H

#include "T2D.h"
#include "defineParam.h"
#include <QDialog>
#include <QGraphicsItem>
#include <QVector>
#include <QGraphicsRectItem>
#include <QMenu>
#include <QContextMenuEvent>

namespace Ui {
class FormTop;
}

class FormTop : public QDialog
{
    Q_OBJECT

public:
    explicit FormTop(QWidget *parent = nullptr);
    ~FormTop();

    void receiveFile(T2D &t2d, int pixel, double um);
    void drawing();
    void filterDrawing();
    void drawingClear();
    void receivePointPos(POS_MONITORING &pos);
    void changePos();
//    void receiveFile(QVector<QList<float>> **mapFile);

private:
    void addRectItem(int layer, int row, int col, int n, QTransform trans);
    void addFilterRectItem(int layer, int row, int col, int n, QTransform trans);
    int extPos(double *pos, double *min, double *max);
    void filterRenderingData(int layer, int row, int col, int n);
    void areaFilterRect();
    void getRowCol();
    Ui::FormTop *ui;
    T2D *rendering_full;        
    POS_MONITORING *pos;
    POS_MONITORING temp_pos;
    QGraphicsScene *m_scene;
    QVector<QGraphicsRectItem*> rectItemList;
    QTransform trans;
    int m_begin_x = 0, m_begin_y = 0, m_end_x = 1, m_end_y = 1, m_scale = 500;
    float m_min_x = 0, m_min_y =0, m_max_x =0, m_max_y=0;
    bool init_check = true;

    int m_begin_row = 0, m_end_row = 1, m_begin_col = 0, m_end_col = 1;
    int m_block_size = 10; //10um
    double m_area = 50, m_area_scale = 100 ; // 50/1000 = 0.05um(0.001~0.099)
    double m_min_x_size = -0.5, m_max_x_size = 0.5, m_min_y_size = -0.5, m_max_y_size = 0.5;

    double m_origin_scale;
    bool changepos_init_check = true;
    int m_scene_standard = 100;

    QMenu formtop_menu;
    QAction* formtop_cut_all;
    QAction* formtop_cut_rigtht;
    QAction* formtop_cut_left;
    QAction* formtop_cut_top;
    QAction* formtop_cut_bottom;

    //bool m_filter_onoff = false;
    bool m_filter_right = false;
    bool m_filter_left = false;
    bool m_filter_top = false;
    bool m_filter_bottom = false;

    void filterMenuCheck();

signals:
    void signalChangePos(QString func, POS_MONITORING pos);

protected:
    void contextMenuEvent(QContextMenuEvent* event) override;
    void wheelEvent(QWheelEvent *event) override;
};

#endif // FORMTOP_H
!@hash[]!@file[]./gitmerge.h!@hash[]!@code[]#ifndef GITMERGE_H
#define GITMERGE_H

#include <QString>

class GitMerge
{
public:
    GitMerge();
private:
    void readTxtFile();
    void readCodeFiles();
    bool compareCodeFile(QString &A, QString &B);
    void makeTxtFile();
    void makeCodeFiles();

    bool write_code_files = false;
    QString split1;
    QString split2;
    QString merged_code_files;    //각종 cpp, h 등에서 읽어온 내용
    QString based_on_reading_txt; //gitMerge.txt 에서 읽어온 내용
    QString txt_file = "./gitMerge.txt";
    QString pro_file = "./IInterface.pro";
    QString hash = "!@hash[]";
    QString file = "!@file[]";
    QString code = "!@code[]";
};

#endif // GITMERGE_H
!@hash[]!@file[]./mainwindow.h!@hash[]!@code[]#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include "Rendering/Src/lve_window.hpp"

#include <QMainWindow>
#include <QVulkanWindow>
#include <QDockWidget>
#include "formhier.h"
#include "formlayer.h"
#include "formtop.h"
#include "forminfo.h"
#include "formmap.h"
#include "pexdialog.h"
#include "filedb.h"
#include "all_data.h"
#include <QVector>
#include "defineParam.h"

#include "dev_dialog.h"

#include "T2D.h"

class LveWindow;

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; class LayerForm; }
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(LveWindow *w);
    ~MainWindow();

    void shareGeo(QRect size);
    void devDialog();

    T2D t2d;

public slots:

    void slotInfoText(QString funcName, POS_MONITORING value);
    void inputLayerStatus(QString text);
    void on_actionOpen_file_triggered();
    void inputPosInformation();

signals:
    void signalInfoText(QString funcName, float value);
    void sendSelectFileName(QString file_name);



private slots:
    void on_actionOpen_Layout_triggered();
    void on_actionOpen_DB_triggered();
    void on_actionOpen_PEX_triggered();
    void slotDirectlyInputPos();
    void slotStatusBarMsg(QString msg);

    void on_actionTop_triggered();
    void on_actionDemo_triggered();
    void on_docker_TopView_triggered();
    void on_docker_TopView_stateChanged(bool);
    void on_docker_Map_triggered();
    void on_docker_Map_stateChanged(bool);
    void on_docker_Info_triggered();
    void on_docker_Info_stateChanged(bool);
    void on_docker_Hier_triggered();
    void on_docker_Hier_stateChanged(bool);
    void on_docker_Layer_triggered();
    void on_docker_Layer_stateChanged(bool);
    void on_toggle_top_triggered();

    void on_PEX_window_triggered();

    void on_actionDialog_on_off_triggered();

    void on_actionToyCAD_triggered();

private:
    void sendPositionDataToDocker();
    LveWindow *m_window;
    Ui::MainWindow *ui;
    QString statusText;
    FormHier *formHier;
    FormLayer *formLayer;
    FormTop *formTop;
    FormInfo *formInfo;
    FormMap *formMap;
    PexDialog *pexdialog;
    QDockWidget *dockHier;
    QDockWidget *dockLayer;
    QDockWidget *dockMap;
    QDockWidget *dockTop;
    QDockWidget *dockInfo;
    SuperItem *superItem;
    QRect *windowSize;
    FileDb *fileDb;
    all_data *input_dataS;
    QStringList split_data;
    POS_MONITORING pos;
    POS_MONITORING pos_past;
    QByteArray dock_widget_geometry;
    QByteArray dock_widget_state;

//dev_dialog
    DevDialog *dev_dialog;
    bool is_pos_checked = true;

};

#endif // MAINWINDOW_H
!@hash[]!@file[]./pexdialog.h!@hash[]!@code[]#ifndef PEXDIALOG_H
#define PEXDIALOG_H

#include <QDialog>

namespace Ui {
class PexDialog;
}

class PexDialog : public QDialog
{
    Q_OBJECT

public:
    explicit PexDialog(QWidget *parent = nullptr);
    ~PexDialog();

private:
    Ui::PexDialog *ui;
};

#endif // PEXDIALOG_H
!@hash[]!@file[]./dev_dialog.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DevDialog</class>
 <widget class="QDialog" name="DevDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>529</width>
    <height>466</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="14" column="0">
      <widget class="QLabel" name="label_11">
       <property name="text">
        <string>Vulkan PEX</string>
       </property>
      </widget>
     </item>
     <item row="13" column="0">
      <widget class="QCheckBox" name="checkBox_7">
       <property name="text">
        <string>CheckBox</string>
       </property>
      </widget>
     </item>
     <item row="9" column="0">
      <widget class="QCheckBox" name="checkBox_5">
       <property name="text">
        <string>CheckBox</string>
       </property>
      </widget>
     </item>
     <item row="0" column="3">
      <widget class="QLabel" name="label_10">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
     <item row="8" column="0">
      <widget class="QLabel" name="label_5">
       <property name="text">
        <string>Docker Hierarchy</string>
       </property>
      </widget>
     </item>
     <item row="4" column="0">
      <widget class="QLabel" name="label_3">
       <property name="text">
        <string>Docker top view</string>
       </property>
      </widget>
     </item>
     <item row="2" column="0">
      <widget class="QLabel" name="label_2">
       <property name="text">
        <string>Docker mini map</string>
       </property>
      </widget>
     </item>
     <item row="0" column="1">
      <widget class="QLabel" name="label_8">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
     <item row="0" column="2">
      <widget class="QLabel" name="label_9">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
     <item row="1" column="0">
      <widget class="QCheckBox" name="checkBox_pos">
       <property name="text">
        <string>Change Pos</string>
       </property>
      </widget>
     </item>
     <item row="12" column="0">
      <widget class="QLabel" name="label_7">
       <property name="text">
        <string>Vulkan 3D modeling</string>
       </property>
      </widget>
     </item>
     <item row="3" column="0">
      <widget class="QCheckBox" name="checkBox_2">
       <property name="text">
        <string>CheckBox</string>
       </property>
      </widget>
     </item>
     <item row="5" column="0">
      <widget class="QCheckBox" name="checkBox_3">
       <property name="text">
        <string>CheckBox</string>
       </property>
      </widget>
     </item>
     <item row="0" column="0">
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Main Window</string>
       </property>
      </widget>
     </item>
     <item row="6" column="0">
      <widget class="QLabel" name="label_4">
       <property name="text">
        <string>Docker navigator</string>
       </property>
      </widget>
     </item>
     <item row="10" column="0">
      <widget class="QLabel" name="label_6">
       <property name="text">
        <string>Docker Layer</string>
       </property>
      </widget>
     </item>
     <item row="7" column="0">
      <widget class="QCheckBox" name="checkBox_4">
       <property name="text">
        <string>CheckBox</string>
       </property>
      </widget>
     </item>
     <item row="11" column="0">
      <widget class="QCheckBox" name="checkBox_6">
       <property name="text">
        <string>CheckBox</string>
       </property>
      </widget>
     </item>
     <item row="15" column="0">
      <widget class="QCheckBox" name="checkBox_8">
       <property name="text">
        <string>CheckBox</string>
       </property>
      </widget>
     </item>
     <item row="5" column="1">
      <widget class="QPushButton" name="pushButton">
       <property name="text">
        <string>PushButton</string>
       </property>
      </widget>
     </item>
     <item row="1" column="1">
      <widget class="QLabel" name="label_12">
       <property name="text">
        <string>Pos coordinate : </string>
       </property>
       <property name="alignment">
        <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="2" colspan="2">
      <widget class="QLabel" name="label_pos">
       <property name="text">
        <string>pos_label</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./formhier.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormHier</class>
 <widget class="QDialog" name="FormHier">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>780</width>
    <height>646</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>320</width>
    <height>100</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QGridLayout" name="gridLayout_2">
   <item row="0" column="0">
    <layout class="QGridLayout" name="gridLayout">
     <item row="1" column="0">
      <widget class="QTabWidget" name="tabWidget">
       <property name="currentIndex">
        <number>1</number>
       </property>
       <widget class="QWidget" name="tab_3">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
        <attribute name="title">
         <string>Hierarchy</string>
        </attribute>
        <layout class="QGridLayout" name="gridLayout_3">
         <item row="0" column="0">
          <layout class="QVBoxLayout" name="verticalLayout">
           <item>
            <widget class="QLineEdit" name="hierarchy_searching">
             <property name="enabled">
              <bool>true</bool>
             </property>
             <property name="sizePolicy">
              <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
               <horstretch>1</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
             <property name="text">
              <string/>
             </property>
             <property name="alignment">
              <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
             </property>
             <property name="placeholderText">
              <string>Searching...</string>
             </property>
             <property name="clearButtonEnabled">
              <bool>false</bool>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QTreeWidget" name="hierarchy_tree">
             <property name="sizePolicy">
              <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
               <horstretch>1</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
             <property name="verticalScrollBarPolicy">
              <enum>Qt::ScrollBarAsNeeded</enum>
             </property>
             <property name="horizontalScrollBarPolicy">
              <enum>Qt::ScrollBarAlwaysOff</enum>
             </property>
             <property name="expandsOnDoubleClick">
              <bool>false</bool>
             </property>
             <attribute name="headerVisible">
              <bool>false</bool>
             </attribute>
             <column>
              <property name="text">
               <string notr="true">1</string>
              </property>
             </column>
            </widget>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_4">
        <attribute name="title">
         <string>PEX</string>
        </attribute>
        <layout class="QGridLayout" name="gridLayout_4">
         <item row="0" column="0">
          <layout class="QVBoxLayout" name="verticalLayout_2">
           <item>
            <widget class="QTreeWidget" name="pex_tree"/>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./forminfo.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormInfo</class>
 <widget class="QDialog" name="FormInfo">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>400</height>
   </rect>
  </property>
  <property name="maximumSize">
   <size>
    <width>200</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="2">
      <widget class="QLabel" name="label_4">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Z</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="1">
      <widget class="QLabel" name="label_11">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Rotation</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="2">
      <widget class="QLabel" name="label_12">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Zoom</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="1">
      <widget class="QLabel" name="label_2">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Y</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="1">
      <widget class="QLineEdit" name="pos_y">
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="2">
      <widget class="QLineEdit" name="zoom">
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="0">
      <widget class="QLabel" name="label">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>X</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="0">
      <widget class="QLineEdit" name="ang_tilt">
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="0">
      <widget class="QLabel" name="label_10">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Tilt</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="0">
      <widget class="QLineEdit" name="pos_x">
       <property name="inputMask">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="1">
      <widget class="QLineEdit" name="ang_rotation">
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="2">
      <widget class="QLineEdit" name="pos_z">
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QListWidget" name="listWidget">
     <property name="dragDropMode">
      <enum>QAbstractItemView::DragDrop</enum>
     </property>
     <property name="defaultDropAction">
      <enum>Qt::MoveAction</enum>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::ExtendedSelection</enum>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <property name="sizeConstraint">
      <enum>QLayout::SetFixedSize</enum>
     </property>
     <item>
      <widget class="QPushButton" name="pushButton_go">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Go</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_del">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Del</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_save">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Save</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_load">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Load</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>pos_x</tabstop>
  <tabstop>pos_y</tabstop>
  <tabstop>pos_z</tabstop>
  <tabstop>ang_tilt</tabstop>
  <tabstop>ang_rotation</tabstop>
  <tabstop>zoom</tabstop>
 </tabstops>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./formlayer.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormLayer</class>
 <widget class="QDialog" name="FormLayer">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>320</width>
    <height>400</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>320</width>
    <height>0</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>430</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QTableWidget" name="tableWidget">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="focusPolicy">
        <enum>Qt::ClickFocus</enum>
       </property>
       <property name="tabKeyNavigation">
        <bool>true</bool>
       </property>
       <property name="alternatingRowColors">
        <bool>true</bool>
       </property>
       <property name="textElideMode">
        <enum>Qt::ElideMiddle</enum>
       </property>
       <attribute name="horizontalHeaderVisible">
        <bool>false</bool>
       </attribute>
       <attribute name="verticalHeaderVisible">
        <bool>false</bool>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./formmap.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormMap</class>
 <widget class="QDialog" name="FormMap">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>200</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>200</width>
    <height>200</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGraphicsView" name="graphicsView">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="minimumSize">
      <size>
       <width>0</width>
       <height>0</height>
      </size>
     </property>
     <property name="verticalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
     <property name="horizontalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./formtop.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormTop</class>
 <widget class="QDialog" name="FormTop">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>200</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>200</width>
    <height>200</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGraphicsView" name="graphicsView">
     <property name="autoFillBackground">
      <bool>true</bool>
     </property>
     <property name="verticalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
     <property name="horizontalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
     <property name="sizeAdjustPolicy">
      <enum>QAbstractScrollArea::AdjustIgnored</enum>
     </property>
     <property name="backgroundBrush">
      <brush brushstyle="NoBrush">
       <color alpha="255">
        <red>0</red>
        <green>0</green>
        <blue>0</blue>
       </color>
      </brush>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./mainwindow.ui!@hash[]!@code[]<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1024</width>
    <height>768</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
     <widget class="QGraphicsView" name="graphicsView"/>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>1024</width>
     <height>21</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>File</string>
    </property>
    <addaction name="actionOpen_file"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_Layout"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_DB"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_PEX"/>
   </widget>
   <widget class="QMenu" name="menuView">
    <property name="title">
     <string>View</string>
    </property>
    <addaction name="actionLayer_information"/>
   </widget>
   <widget class="QMenu" name="menuCamera">
    <property name="title">
     <string>Camera</string>
    </property>
    <addaction name="actionTop"/>
    <addaction name="actionDemo"/>
   </widget>
   <widget class="QMenu" name="menudevopt">
    <property name="title">
     <string>devopt</string>
    </property>
    <addaction name="actionDialog_on_off"/>
    <addaction name="actionToyCAD"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuView"/>
   <addaction name="menuCamera"/>
   <addaction name="menudevopt"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="toolBar">
   <property name="windowTitle">
    <string>toolBar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="toggle_top"/>
   <addaction name="separator"/>
   <addaction name="docker_Map"/>
   <addaction name="docker_TopView"/>
   <addaction name="docker_Info"/>
   <addaction name="docker_Hier"/>
   <addaction name="docker_Layer"/>
   <addaction name="PEX_window"/>
  </widget>
  <action name="actionOpen_file">
   <property name="text">
    <string>Open file</string>
   </property>
  </action>
  <action name="actionLayer_information">
   <property name="text">
    <string>Layer information</string>
   </property>
  </action>
  <action name="actionOpen_Layout">
   <property name="text">
    <string>Open Layout</string>
   </property>
  </action>
  <action name="actionOpen_DB">
   <property name="text">
    <string>Open DB</string>
   </property>
  </action>
  <action name="actionTop">
   <property name="text">
    <string>Top</string>
   </property>
  </action>
  <action name="actionDemo">
   <property name="text">
    <string>Demo</string>
   </property>
  </action>
  <action name="docker_Map">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normaloff>ImageFile/Map_Icon_50by50.png</normaloff>ImageFile/Map_Icon_50by50.png</iconset>
   </property>
   <property name="text">
    <string>docker_Map</string>
   </property>
   <property name="toolTip">
    <string>docker_Map</string>
   </property>
  </action>
  <action name="docker_TopView">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Top_View_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_TopView</string>
   </property>
   <property name="toolTip">
    <string>docker_TopView</string>
   </property>
  </action>
  <action name="docker_Info">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Info_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_Info</string>
   </property>
   <property name="toolTip">
    <string>docker_Info</string>
   </property>
  </action>
  <action name="docker_Hier">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Hier_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_Hier</string>
   </property>
   <property name="toolTip">
    <string>docker_Hier</string>
   </property>
  </action>
  <action name="docker_Layer">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normalon>ImageFile/Layer_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>docker_Layer</string>
   </property>
   <property name="toolTip">
    <string>docker_Layer</string>
   </property>
  </action>
  <action name="toggle_top">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset>
     <normaloff>ImageFile/Top_toggle_Icon_50by50.png</normaloff>ImageFile/Top_toggle_Icon_50by50.png</iconset>
   </property>
   <property name="text">
    <string>toggle_top</string>
   </property>
   <property name="toolTip">
    <string>toggle_top</string>
   </property>
  </action>
  <action name="PEX_window">
   <property name="checkable">
    <bool>false</bool>
   </property>
   <property name="checked">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset>
     <normalon>ImageFile/PEX_Icon_50by50.png</normalon>
    </iconset>
   </property>
   <property name="text">
    <string>PEX_window</string>
   </property>
  </action>
  <action name="actionOpen_PEX">
   <property name="text">
    <string>Open PEX</string>
   </property>
  </action>
  <action name="actionDialog_on_off">
   <property name="text">
    <string>Dialog on/off</string>
   </property>
  </action>
  <action name="actionToyCAD">
   <property name="text">
    <string>ToyCAD</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./pexdialog.ui!@hash[]!@code[]<ui version="4.0">
 <class>PexDialog</class>
 <widget name="PexDialog" class="QDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
 </widget>
 <resources/>
 <connections/>
</ui>
!@hash[]!@file[]./IInterface.pro!@hash[]!@code[]QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++17
QMAKE_CXXFLAGS += -std=c++17

# You can make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
    Rendering/Src/LayoutData.cpp \
    Rendering/Src/LayoutModel.cpp \
    Rendering/Src/PEXCapacitorModel.cpp \
    Rendering/Src/PEXData.cpp \
    Rendering/Src/PEXResistorModel.cpp \
    Rendering/Src/dtaorendersystem.cpp \
    Rendering/Src/keyboard_movement_controller.cpp \
    Rendering/Src/lve_camera.cpp \
    Rendering/Src/lve_device.cpp \
    Rendering/Src/lve_model.cpp \
    Rendering/Src/lve_pipeline.cpp \
    Rendering/Src/lve_window.cpp \
    Rendering/Src/simple_render_system.cpp \
    T2D.cpp \
    ToyCAD/Src/toycaddata.cpp \
    ToyCAD/Src/toycadmodel.cpp \
    all_data.cpp \
    dev_dialog.cpp \
    filedb.cpp \
    formhier.cpp \
    forminfo.cpp \
    formlayer.cpp \
    formmap.cpp \
    formtop.cpp \
    gitmerge.cpp \
    main.cpp \
    mainwindow.cpp \
    pexdialog.cpp

HEADERS += \
    Rendering/Src/LayoutModel.h \
    Rendering/Src/LayoutPEXData.h \
    Rendering/Src/PEXCapacitorModel.h \
    Rendering/Src/PEXResistorModel.h \
    Rendering/Src/dtaorendersystem.h \
    Rendering/Src/keyboard_movement_controller.hpp \
    Rendering/Src/lve_camera.hpp \
    Rendering/Src/lve_device.hpp \
    Rendering/Src/lve_game_object.hpp \
    Rendering/Src/lve_model.hpp \
    Rendering/Src/lve_pipeline.hpp \
    Rendering/Src/lve_window.hpp \
    Rendering/Src/simple_render_system.hpp \
    Rendering/Src/utils.h \
    T2D.h \
    ToyCAD/Src/toycad_object.h \
    ToyCAD/Src/toycaddata.h \
    ToyCAD/Src/toycadmodel.h \
    all_data.h \
    defineParam.h \
    dev_dialog.h \
    filedb.h \
    formhier.h \
    forminfo.h \
    formlayer.h \
    formmap.h \
    formtop.h \
    gitmerge.h \
    mainwindow.h \
    pexdialog.h

FORMS += \
    dev_dialog.ui \
    formhier.ui \
    forminfo.ui \
    formlayer.ui \
    formmap.ui \
    formtop.ui \
    mainwindow.ui \
    pexdialog.ui

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target


RESOURCES += \
    Resources.qrc

DISTFILES += \
    Rendering/Data/MVP_PEX_RC_r1_0130.csv \
    Rendering/Data/MVP_PEX_RC_r1_0130_0208version.csv \
    Rendering/Data/big_test_espin.csv \
    Rendering/Data/layout_input_data.csv \
    Rendering/Data/layout_input_data_old_format.csv \
    Rendering/Data/pex_cap_test.csv \
    Rendering/Data/pex_res_test.csv \
    Rendering/Data/pex_res_test_beol_only.csv \
    Rendering/Data/pex_res_test_simple.csv \
    Rendering/Data/test_espin.csv \
    Rendering/shaders/compile.bat \
    Rendering/shaders/simple_shader.frag \
    Rendering/shaders/simple_shader.frag.spv \
    Rendering/shaders/simple_shader.frag_edge.spv \
    Rendering/shaders/simple_shader.frag_pex.spv \
    Rendering/shaders/simple_shader.vert \
    Rendering/shaders/simple_shader.vert.spv \
    Rendering/shaders/simple_shader.vert_edge.spv \
    Rendering/shaders/simple_shader.vert_pex.spv \
    Rendering/shaders/simple_shader_edge.frag \
    Rendering/shaders/simple_shader_edge.vert \
    Rendering/shaders/simple_shader_pex.frag \
    Rendering/shaders/simple_shader_pex.vert \
    ToyCAD/Data/test.csv \
    ToyCAD/Data/toy_cad_test_data.csv \
    ToyCAD/shaders/compile.bat \
    ToyCAD/shaders/toycad.frag \
    ToyCAD/shaders/toycad.frag.spv \
    ToyCAD/shaders/toycad.vert \
    ToyCAD/shaders/toycad.vert.spv



INCLUDEPATH += $$PWD/../../Library/glm-0.9.9.8

unix:!macx|win32: LIBS += -L$$PWD/../../Library/VulkanSDK/1.3.239.0/Lib/ -lvulkan-1

INCLUDEPATH += $$PWD/../../Library/VulkanSDK/1.3.239.0/Lib
DEPENDPATH += $$PWD/../../Library/VulkanSDK/1.3.239.0/Lib

INCLUDEPATH += $$PWD/../../Library/glm-0.9.9.8/glm

#한글 실험

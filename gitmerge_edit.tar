all_data.cpp����������������������������������������������������������������������������������������0000644�4673156�4001001�00000005241�14402242514�011677� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "all_data.h"
#include <QString>
#include <QTextStream>
#include <QFileDialog>
#include <QVector>

all_data::all_data(QObject *parent) :
    QObject(parent)
{

}

all_data::~all_data()
{

}


void all_data::receiveSelectFileName(QString file_name)
{

//    qDebug() << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
//    qDebug() << file_name;

    int row = 0;
    int column = 0;
    QFile file(file_name);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;
    QString getLine;
    QStringList list;
    QTextStream fileStream(&file);
    QRegExp rx("[,]");


    while (!fileStream.atEnd()) {
            getLine.append(fileStream.readLine());
            getLine.append(",");
            list << (getLine.split(rx));
//            for (int column=0;column<17;column++)
//            {
//                split_data[row][column] << list[row][column];
//                //emit sendSplitData(split_data[row][column]);
//                //qDebug() << "row = " << row << split_data[row][column];
//            }
            row++;
//            column = list.count();
            getLine.clear();
    }   // while End

    column = list.count()/row;

//    qDebug() << list;


    for(int i=0 ; i<row ; i++)
    {
           QVector <QString> tempvector;
           for(int j=0 ; j<column ; j++)
           {
               int num1;
               num1 = j + column*i;
               tempvector.append(list[num1]);

//               qDebug() << "list " << num1 << list[num1];


           }
           inputDataVector.append(tempvector);
//           qDebug() << "inputDataVector " << inputDataVector;

    }
//    qDebug() << "1st" << inputDataVector.value(0);
//    qDebug() << "All" << inputDataVector;
//    qDebug() << "2nd" << inputDataVector.value(1);
//    qDebug() << "3rd" << inputDataVector.value(2);
//    qDebug() << "inputDataVector" << ": " << inputDataVector;

//    QVector <QVector <QVector <int> > > myVector;

//    int massive[4][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16} };

//    QVector <QVector <int> > matrix;

//    for(int i = 0; i < 4; i++)
//    {
//        QVector<int> tempVector;

//        for(int j = 0; j < 4; j++)
//        {
//            tempVector.push_back(massive[i][j]);
//            qDebug() << "Value " << j << ": " << tempVector.value(j);
//        }
//        matrix.push_back(tempVector);
//        qDebug() << "matrix row " << i << ": " << matrix.value(i);
//    }

//    myVector.push_back(matrix);

//    qDebug() << "myVector: " << myVector.value(0);




    emit sendSplitData(row, column, inputDataVector);


}
���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������filedb.cpp������������������������������������������������������������������������������������������0000644�4673156�4001001�00000002322�14402242514�011360� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "filedb.h"
#include <QFile>
#include <QVector>
#include <QTextStream>
#include <QList>
#include <QDebug>

FileDb::FileDb()
{

}

void FileDb::openFile(QString fileNameInfo,QVector<QList<float>> &vecList,
                      float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize)
{    
    QFile file(fileNameInfo);

    if (file.open(QIODevice::ReadOnly) | (QIODevice::Text))
    {
        QTextStream openFile(&file);
        while(!openFile.atEnd())
        {
            auto dataString = openFile.readLine().split(",");
            QList<float> data;
            for (auto &tempdata : dataString)
            {
                 data.append(tempdata.toFloat());
            }
            vecList.push_back(data);
            qDebug()<< "strVector : " << data;

            if(data.size() == 8)
            {
                if(xMinSize > data[2]){xMinSize = data[2];}
                if(yMinSize > data[3]){yMinSize = data[3];}
                if(xMaxSize < data[4]){xMaxSize = data[4];}
                if(yMaxSize < data[5]){yMaxSize = data[5];}
            }
        }
        file.close();
    }
    else
    {        
        return;
    }

    return;

}
��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formhier.cpp����������������������������������������������������������������������������������������0000644�4673156�4001001�00000006051�14402242514�011751� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "formhier.h"
#include "ui_formhier.h"
#include "mainwindow.h"
#include <QTableWidget>
#include <QDebug>


FormHier::FormHier(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormHier)
{
    ui->setupUi(this);
    // QTableWidget defalut 크기 설정
    QStringList defalutTableHeader;
    defalutTableHeader << "LayerName" << "LayerNum" << "LayerType" << "Red" << "Green" << "Blue";

    ui->tableWidget->setColumnCount(6);
    ui->tableWidget->setRowCount(10);
    ui->tableWidget->setColumnWidth(0,80);
    ui->tableWidget->setColumnWidth(1,80);
    ui->tableWidget->setColumnWidth(2,80);
    ui->tableWidget->setColumnWidth(3,50);
    ui->tableWidget->setColumnWidth(4,50);
    ui->tableWidget->setColumnWidth(5,50);
    ui->tableWidget->setHorizontalHeaderLabels(defalutTableHeader);

    ui->tableWidget->horizontalHeader()->setStyleSheet("QHeaderView::section {background-color:#404040;color:#FFFFFF;}");

//    tempcolor = ui->tableWidget->setBackgroundRole();
//    ui->tableWidget->setHorizontalHeaderItem(0,QColor(128,128,128));

}

FormHier::~FormHier()
{
    delete ui;
}

//void FormHier::testMyData(){
//    this->dataset->split_datas[0][0] = QString("No, I'm not fool!!!");
//}

//void FormHier::ReceiveSplitData(QStringList list, int row, int column,  QVector <QVector <QString>> &inputDataVector)
void FormHier::ReceiveSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector)
{
//    qDebug() << "xxxxxxxxxxxxxxxxxxxxxxxxx";
//    qDebug() << "row" << row;
//    qDebug() << "column" << column;
//    qDebug() << "1st" << inputDataVector.value(0);
//    qDebug() << "2nd" << inputDataVector.value(1);
//    qDebug() << "3rd" << inputDataVector.value(2);
//    qDebug() << "1st_1st" << inputDataVector.value(0).value(0);

// QTableWidget 에서 QStringList 로만 받기때문에 자료형변환
    QStringList vectorTOqstringlist;
    QStringList vectorTOqstringlistHoriLabels;

// QTableWidget 크기 설정
    ui->tableWidget->setColumnCount(column);
    ui->tableWidget->setRowCount(row);

// Table Header Font size/bold change
    QFont font = ui->tableWidget->horizontalHeader()->font();
    font.setBold(true);
    font.setPointSize(10);
    ui->tableWidget->horizontalHeader()->setFont(font);

// Table 채우기
    for (int i=0; i<row ; i++)
    {
        for (int j=0; j<column ; j++)
        {
            vectorTOqstringlist << inputDataVector.value(i+1).value(j);
            vectorTOqstringlistHoriLabels << inputDataVector.value(0).value(j);
            ui->tableWidget->setItem(i,j,new QTableWidgetItem(vectorTOqstringlist[i*column+j]));
            ui->tableWidget->setHorizontalHeaderLabels(vectorTOqstringlistHoriLabels);
        }

    }
//    ui->tableWidget->set;
//    ui->tableWidget->setColumnWidth(0,80);
//    ui->tableWidget->setColumnWidth(1,80);
//    ui->tableWidget->setColumnWidth(2,80);
//    ui->tableWidget->setColumnWidth(3,50);
//    ui->tableWidget->setColumnWidth(4,50);
//    ui->tableWidget->setColumnWidth(5,50);



}
���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������forminfo.cpp����������������������������������������������������������������������������������������0000644�4673156�4001001�00000010356�14402242514�011760� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "forminfo.h"
#include "ui_forminfo.h"
#include <QDebug>
#include "cmath"

FormInfo::FormInfo(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormInfo)
{
    ui->setupUi(this);
    ui->pointX->setText(QString::number(round(pointX*10000)/10000));
    ui->pointY->setText(QString::number(round(pointY*10000)/10000));
    ui->pointZ->setText(QString::number(round(pointZ*10000)/10000));
    ui->infoRot->setText(QString::number(round(infoRot*10000)/10000));
    ui->infoTilt->setText(QString::number(round(infoTilt*10000)/10000));
    ui->infoZoom->setText(QString::number(round(1/infoZoom*1000)/10)+"%");
}

void FormInfo::slotInfoText(QString funcName, float value)
{


    if (funcName == "moveGdsX")
    {
        pointX = pointX + value;
        ui->pointX->setText(QString::number(round(pointX*10000)/10000));
        initPointX = pointX;
    }
    if (funcName == "moveGdsY")
    {
        pointY = pointY + value;
        ui->pointY->setText(QString::number(round(pointY*10000)/10000));
        initPointY = pointY;
    }
    if (funcName == "moveGdsZ")
    {
        pointZ = pointZ + value;
        ui->pointZ->setText(QString::number(round(pointZ*10000)/10000));
        initPointZ = pointZ;
    }
    if (funcName == "rotateRenderX")
    {
        infoRot = initRot + value;
        if (infoRot>360)
            infoRot = infoRot - 360;
        if (infoRot<0)
            infoRot = infoRot + 360;
        ui->infoRot->setText(QString::number(round(infoRot*10000)/10000));
    }
    if (funcName == "rotateRenderY")
    {
        qDebug()<<"rotateRenderY";
        infoTilt = initTilt + value;
        if (infoTilt>90)
            infoTilt = 90;
        if (infoTilt<-90)
            infoTilt = -90;
        ui->infoTilt->setText(QString::number(round(infoTilt*10000)/10000));
    }
    if (funcName == "moveZoom")
    {
        qDebug()<<"moveZoom";
        infoZoom = infoZoom + infoZoom*value/1500;        //일정 높이를 100% 로 설정할 필요 있음, 결국 초기값은 GDS Size 에 따라 바뀔 수 있음.
        if (infoZoom < 0.01)
            infoZoom = 0.01;
        if (infoZoom > 100)
            infoZoom = 100;
        ui->infoZoom->setText(QString::number(round(1/infoZoom*1000)/10)+"%");
    }
    if (funcName == "moveRenderX")
    {
        qDebug()<< "moveRenderX";
        x = value;
        moveRender(x,y);
//        pointX = initPointX+value*cos(infoRot*pi/180)*infoZoom;
//        pointY = initPointY+value*sin(infoRot*pi/180)*infoZoom;
//        qDebug() << pointX << " : " << pointY;
//        ui->pointX->setText(QString::number(round(pointX*10000)/10000));
//        ui->pointY->setText(QString::number(round(pointY*10000)/10000));
    }
    if (funcName == "moveRenderY")
    {
        qDebug()<< "moveRenderY";
        y = value;
        moveRender(x,y);
//        pointX = initPointX+value*sin(infoRot*pi/180)*sin(infoTilt*pi/180)*infoZoom;
//        pointY = initPointY+value*cos(infoRot*pi/180)*sin(infoTilt*pi/180)*infoZoom;
//        pointZ = initPointZ+value*cos(infoTilt*pi/180)*infoZoom;
//        qDebug() << pointX << " : " << pointY;
//        ui->pointX->setText(QString::number(round(pointX*10000)/10000));
//        ui->pointY->setText(QString::number(round(pointY*10000)/10000));
//        ui->pointZ->setText(QString::number(round(pointZ*10000)/10000));
    }
    if (funcName == "mouseRelease")
    {
        qDebug()<< "mouseRelease";
        initTilt = infoTilt;
        initRot = infoRot;
        initPointX = pointX;
        initPointY = pointY;
        initPointZ = pointZ;

    }

}

void FormInfo::moveRender(float x, float y)
{
    const double pi = 3.1415926;

    qDebug()<< "moveRender";
    pointX = initPointX+x*cos(infoRot*pi/180)*infoZoom + y*sin(infoRot*pi/180)*sin(infoTilt*pi/180)*infoZoom;
    pointY = initPointY+x*sin(infoRot*pi/180)*infoZoom + y*cos(infoRot*pi/180)*sin(infoTilt*pi/180)*infoZoom;
    pointZ = initPointZ+y*cos(infoTilt*pi/180)*infoZoom;

    ui->pointX->setText(QString::number(round(pointX*10000)/10000));
    ui->pointY->setText(QString::number(round(pointY*10000)/10000));
    ui->pointZ->setText(QString::number(round(pointZ*10000)/10000));

}

FormInfo::~FormInfo()
{
    delete ui;
}
����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formlayer.cpp���������������������������������������������������������������������������������������0000644�4673156�4001001�00000027105�14402513177�012147� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "formlayer.h"
#include "ui_formlayer.h"



FormLayer::FormLayer(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormLayer)
{
    ui->setupUi(this);
    QStringList defalutTableHeader;
    QString TalbeHeader[] = {"","COLOR","Layer\nName","Layer\nNum","Layer\nType","Opacity\n"};

    ui->tableWidget->setColumnCount(6);
    ui->tableWidget->setRowCount(10);
    ui->tableWidget->setColumnWidth(0,15);
    ui->tableWidget->setColumnWidth(1,50);
    ui->tableWidget->setColumnWidth(2,60);
    ui->tableWidget->setColumnWidth(3,60);
    ui->tableWidget->setColumnWidth(4,60);
    ui->tableWidget->setColumnWidth(5,100);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// TableWidget Title Format 설정
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    QBrush brush(QColor(255, 255, 255, 255));
    brush.setStyle(Qt::SolidPattern);
    QFont font;
    font.setBold(true);
    font.setWeight(75);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// TableWidget Title 입력 및 반영
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    for (int i=1; i<6; i++){
        QTableWidgetItem *TableHeaderItem = new QTableWidgetItem;
        TableHeaderItem->setText(TalbeHeader[i]);
        TableHeaderItem->setTextAlignment(Qt::AlignCenter);
        TableHeaderItem->setFont(font);
        TableHeaderItem->setForeground(brush);
        ui->tableWidget->setItem(0,i,TableHeaderItem);
        ui->tableWidget->setRowHeight(0,50);
        ui->tableWidget->item(0,i)->setBackground(QBrush(QColor(80,80,80)));
    }
}

FormLayer::~FormLayer()
{
    delete ui;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \brief FormLayer::ReceiveSplitData
/// \param row
/// \param column
/// \param inputDataVector
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void FormLayer::ReceiveSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector)
{
// QTableWidget 에서 QStringList 로만 받기때문에 자료형변환
    QStringList vectorTOqstringlist;
    QStringList vectorTOqstringlistHoriLabels;
    QStringList vectorTOqstringcolorlist;
    QString LayerColorRed;
    QString LayerColorGreen;
    QString LayerColorBlue;
    QString LayerColorText;
    vectorTOqstringlistHoriLabels << " ";

// QTableWidget 크기 설정
    ui->tableWidget->setColumnCount(6);
    ui->tableWidget->setRowCount(row);
//    ui->tableWidget->setItemDelegateForColumn(5,new SliderDelegate);
    ui->tableWidget->setColumnWidth(5,150);

// Table 채우기
    for (int i=0; i<row ; i++)
    {
       // table value 채우기
        for (int j=0; j<(column-4) ; j++)
        {
            vectorTOqstringlist << inputDataVector.value(i+1).value(j);
//            vectorTOqstringlistHoriLabels << inputDataVector.value(0).value(j+1);
            QTableWidgetItem *tableitem = new QTableWidgetItem;
            tableitem->setText(vectorTOqstringlist[i*(column-4)+j]);
            tableitem->setTextAlignment(Qt::AlignCenter);
            ui->tableWidget->setItem((i+1),j+2,tableitem);
        }

        //Opacity 채우기
        QSlider *OpacitySlider = new QSlider(Qt::Horizontal);
        QWidget *OpacitySliderWidget = new QWidget();
        OpacitySlider->setRange(0,100);
        OpacitySlider->setValue(100);
        OpacitySlider->setFocusPolicy(Qt::StrongFocus);
        QHBoxLayout *OpacityLayout = new QHBoxLayout(OpacitySliderWidget);
        OpacityLayout->addWidget(OpacitySlider);
        OpacitySliderWidget->setLayout(OpacityLayout);

//        OpacitySlider->setTickPosition(QSlider::TicksBothSides);
//        OpacitySlider->setTickInterval(10);
        ui->tableWidget->setCellWidget(i+1, 5, OpacitySliderWidget);
        QObject::connect(OpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(handleOpacitySlider(int)));

        // checkbox 채우기
        QCheckBox *checkBoxItem = new QCheckBox();
        checkBoxItem->setCheckState(Qt::Checked);
        QWidget *checkboxWidget = new QWidget();
        QHBoxLayout *checkboxLayout = new QHBoxLayout(checkboxWidget);
        checkboxLayout->addWidget(checkBoxItem);
        checkboxLayout->setAlignment(Qt::AlignCenter);
        checkboxLayout->setContentsMargins(0,0,0,0);
        checkboxWidget->setLayout(checkboxLayout);
        ui->tableWidget->setCellWidget(i+1,0,checkboxWidget);

        QWidget *widget = ui->tableWidget->cellWidget(i+1, 0);
        QCheckBox *checkboxInTable = widget->findChild<QCheckBox *>();
        QObject::connect(checkboxInTable, SIGNAL(stateChanged(int)), this, SLOT(tableWidget_checkBoxChanged()));

        // Layer color rgb value
        LayerColorRed = inputDataVector.value(i+1).value(3);
        LayerColorGreen = inputDataVector.value(i+1).value(4);
        LayerColorBlue = inputDataVector.value(i+1).value(5);

        LayerColorText = "background-color: rgb(" + LayerColorRed;
        LayerColorText = LayerColorText + "," + LayerColorGreen + "," + LayerColorBlue + ")";

        // color pushbutton 채우기
        QPushButton *colorbutton = new QPushButton();
        colorbutton->setStyleSheet(LayerColorText);
        ui->tableWidget->setCellWidget(i+1,1,colorbutton);
        QObject::connect(colorbutton, SIGNAL(clicked()), this, SLOT(on_colorbutton_clicked()));
    }
    ui->tableWidget->setHorizontalHeaderLabels(vectorTOqstringlistHoriLabels);

///////////////////////////////tableWidget title 에 checkbox ///////////////////////////////
        QCheckBox *checkBoxItem = new QCheckBox();
        checkBoxItem->setCheckState(Qt::Checked);
        QWidget *checkboxWidget = new QWidget();
        QHBoxLayout *checkboxLayout = new QHBoxLayout(checkboxWidget);
        checkboxLayout->addWidget(checkBoxItem);
        checkboxLayout->setAlignment(Qt::AlignCenter);
        checkboxLayout->setContentsMargins(0,0,0,0);
        checkboxWidget->setLayout(checkboxLayout);
        ui->tableWidget->setCellWidget(0,0,checkboxWidget);

        QWidget *findwidget = ui->tableWidget->cellWidget(0, 0);
        QCheckBox *checkboxInTable = findwidget->findChild<QCheckBox *>();
        QObject::connect(checkboxInTable, SIGNAL(stateChanged(int)), this, SLOT(tableWidget_checkBoxChanged()));

///////////////////////////////tableWidget title 에 slider ///////////////////////////////

        QSpacerItem *HeaderVerticalSpacer = new QSpacerItem(0,20,QSizePolicy::Fixed, QSizePolicy::Fixed);
        QSlider *HeaderOpacitySlider = new QSlider();
        HeaderOpacitySlider->setOrientation(Qt::Horizontal);
        HeaderOpacitySlider->setValue(100);
        HeaderOpacitySlider->setRange(0,100);
        QWidget *HeaderSliderWidget = new QWidget();
        QVBoxLayout *HeaderSliderLayout = new QVBoxLayout(HeaderSliderWidget);
        HeaderSliderLayout->addItem(HeaderVerticalSpacer);
        HeaderSliderLayout->addWidget(HeaderOpacitySlider);
        HeaderSliderWidget->setLayout(HeaderSliderLayout);
        ui->tableWidget->setCellWidget(0,5,HeaderSliderWidget);

        QObject::connect(HeaderOpacitySlider, SIGNAL(valueChanged(int)), this, SLOT(handleOpacitySlider(int)));

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \brief FormLayer::on_tableWidget_itemChanged
/// \param checkBoxItem
/// description : checkbox 선택에 따라 Layer On/Off mainwindow status 창에 출력
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void FormLayer::tableWidget_checkBoxChanged()
{
    QCheckBox *checkboxInTable = qobject_cast<QCheckBox*>(sender());
    if (!checkboxInTable)
        return;

    int checkboxrow = -1;
    for (int i = 0; i < ui->tableWidget->rowCount(); i++) {
        QWidget *widget = ui->tableWidget->cellWidget(i, 0);
        QCheckBox *checkbox = widget->findChild<QCheckBox*>();
        if (checkbox == checkboxInTable) {
            checkboxrow = i;
            break;
        }
    }

    if (checkboxrow == 0) {
        QString CommentAllCheckedCheckBox = "All Layer Checked";
        QString CommentAllUncheckedCheckBox = "All Layer Unchecked";

        if (checkboxInTable->isChecked()) {
            for (int i = 1; i < ui->tableWidget->rowCount(); i++) {
                QWidget *widget = ui->tableWidget->cellWidget(i, 0);
                QCheckBox *checkbox = widget->findChild<QCheckBox*>();
                checkbox->setCheckState(Qt::Checked);
            }
            qDebug() << "All Layer Checkbox Checked.";
            emit outputLayerStatus(CommentAllCheckedCheckBox);

        } else {
                for (int i = 1; i < ui->tableWidget->rowCount(); i++) {
                    QWidget *widget = ui->tableWidget->cellWidget(i, 0);
                    QCheckBox *checkbox = widget->findChild<QCheckBox*>();
                    checkbox->setCheckState(Qt::Unchecked);
                }
                qDebug() << "All Layer Checkbox Unchecked.";
                emit outputLayerStatus(CommentAllUncheckedCheckBox);
            }
        return;
    }

    QTableWidgetItem *readcheckbox = ui->tableWidget->item(checkboxrow,2);
    QString selectedLayer = readcheckbox->text();
    QString printLayer = "selectedLayer = " + selectedLayer;

    if (checkboxInTable->isChecked()) {
        printLayer = printLayer + "  Layer  On";
        emit outputLayerStatus(printLayer);
        qDebug() << "Checkbox at row" << checkboxrow << "is checked.";
    } else {
        printLayer = printLayer + "  Layer  Off";
        emit outputLayerStatus(printLayer);
        qDebug() << "Checkbox at row" << checkboxrow << "is unchecked.";
    }
}

void FormLayer::on_colorbutton_clicked()
{
    QString LayerColorname;
    QString LayerColorText;
    int colorbuttonRow = ui->tableWidget->currentRow();

    QColor color = QColorDialog::getColor(Qt::yellow, this);

    LayerColorname = color.name();
    LayerColorText = "background-color: " + LayerColorname;

    ui->tableWidget->cellWidget(colorbuttonRow,1)->setStyleSheet(LayerColorText);
}

void FormLayer::handleOpacitySlider(int Opacity)
{
    int sliderrow=-1;
    QSlider *OpacityInTalbe = qobject_cast<QSlider*>(sender());
    for (int i = 0; i < ui->tableWidget->rowCount(); i++) {
        QWidget *widget = ui->tableWidget->cellWidget(i, 5);
        QSlider *slider = widget->findChild<QSlider*>();

        if (slider == OpacityInTalbe) {
            sliderrow = i;

            if (sliderrow == 0){

                for (int k=1; k < ui->tableWidget->rowCount(); k++) {
                    QWidget *SliderChangeWidget = ui->tableWidget->cellWidget(k, 5);
                    QSlider *SliderChange = SliderChangeWidget->findChild<QSlider*>();
                    SliderChange->setValue(Opacity);
                }
            } else {
                QTableWidgetItem *ReadLayer = ui->tableWidget->item(sliderrow,2);
                QString selectedLayer = ReadLayer->text();
                QString printLayer = "selectedLayer = " + selectedLayer;
                printLayer = printLayer + "  Layer  Opacity = " + QString::number(Opacity);
                emit outputLayerStatus(printLayer);
                qDebug() << printLayer;
            }
            break;
        }
    }
}
�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formmap.cpp�����������������������������������������������������������������������������������������0000644�4673156�4001001�00000010356�14402242514�011602� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "formmap.h"
#include "ui_formmap.h"
#include <QGraphicsItem>
#include <QGraphicsRectItem>
#include <QVector>
#include <iostream>
#include <QDebug>
#include <QRect>
#include <QKeyEvent>

FormMap::FormMap(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormMap)
{
    ui->setupUi(this);

}

void FormMap::receiveSize(float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize, float &zoomScale)
{
    float scale=1;

    width = xMaxSize-xMinSize;
    height = yMaxSize-yMinSize;
    qDebug() << "scale : " << scale << "| width : " << width << "| height : " << height;
    scale = 178/std::max(width,height);
    width = scale * width;
    height = scale * height;
//    float rectScale = 176*zoomScale; 추후 변경

    qDebug() << "scale : " << scale << "| width : " << width << "| height : " << height;

    QGraphicsRectItem *rectItem = new QGraphicsRectItem;
    QGraphicsScene *scene = new QGraphicsScene(this);
    rectItem->setRect(-(width/2),-(height/2),width,height);
    rectItem->setBrush(QBrush(QColor(Qt::gray)));
    scene->addItem(rectItem);

    SuperItem *super = new SuperItem;
    scene->addItem(super);
    QObject::connect(this,&FormMap::signalMove,super,&SuperItem::slotMove);

    ui->graphicsView->setScene(scene);

}

void FormMap::slotInfoText(QString funcName, float value)
{

    if (funcName == "moveGdsX")
    {
        pointX = pointX + value;
        initPointX = pointX;
        emit signalMove(value,0,0,999,999);
    }
    if (funcName == "moveGdsY")
    {
        pointY = pointY + value;
        initPointY = pointY;
        emit signalMove(0, value,0,999,999);
    }
    if (funcName == "rotateRenderX")
    {
        infoRot = initRot + value;
        if (infoRot>360)
            infoRot = infoRot - 360;
        if (infoRot<0)
            infoRot = infoRot + 360;
        emit signalMove(0, 0 ,0,infoRot,999);
    }
    if (funcName == "rotateRenderY")
    {
        infoTilt = initTilt + value;
        if (infoTilt>90)
            infoTilt = 90;
        if (infoTilt<-90)
            infoTilt = -90;
        emit signalMove(0, 0 ,0,999,infoTilt);
    }
    if (funcName == "moveZoom")
    {
        infoZoom = infoZoom + infoZoom*value/1500;        //일정 높이를 100% 로 설정할 필요 있음, 결국 초기값은 GDS Size 에 따라 바뀔 수 있음.
        if (infoZoom < 0.01)
            infoZoom = 0.01;
        if (infoZoom > 100)
            infoZoom = 100;
        emit signalMove(0, 0, infoZoom, 999, 999);
    }
    if (funcName == "moveRenderX")
    {
        x = value;
    }
    if (funcName == "moveRenderY")
    {
        y = value;
    }
    if (funcName == "mouseRelease")
    {
        initTilt = infoTilt;
        initRot = infoRot;
        initPointX = pointX;
        initPointY = pointY;
        initPointZ = pointZ;
    }
}

FormMap::~FormMap()
{
    delete ui;
}

SuperItem::SuperItem(QGraphicsItem* parent) : QGraphicsItem(parent)
{
    setFlag(QGraphicsItem::ItemIsMovable);
}



QRectF SuperItem::boundingRect() const{
    return QRectF(-88,-88,175,175);
}

void SuperItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    painter->setPen(Qt::red);
    painter->drawRoundedRect(-88,-88,175,175,5,5);


}

void SuperItem::slotMove(float x, float y, float zoom, float rot, float tilt)
{
    QTransform trans;

    if (zoom != 0)
    {
        _zoom = zoom;
    }
    if (rot != 999)
    {
        _rot = rot;
    }
    if (tilt != 999)
    {
        _tilt = tilt;
    }
    trans.rotate(_rot);
    trans.scale(_zoom, _zoom*_tilt/90);
    setTransform(trans);

    if (x + y !=0)
    {
        moveBy(x, -y);
        qDebug() << "pos : " << pos();
    }






}

//void SuperItem::keyPressEvent(QKeyEvent *event){
//    switch(event->key()){
//    case Qt::Key_D:{
//        moveBy(30,0);
//        qDebug() << "press D";
//        break;
//        }
//    case Qt::Key_A:{
//        moveBy(-30,0);
//        break;
//        }
//    case Qt::Key_W:{
//        moveBy(0,-30);
//        break;
//        }
//    case Qt::Key_S:{
//        moveBy(0,30);
//        break;
//        }
//    }
//    update();

//}
����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formtop.cpp�����������������������������������������������������������������������������������������0000644�4673156�4001001�00000007445�14402242514�011634� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "formtop.h"
#include "ui_formtop.h"
#include <QGraphicsItem>
#include <QScrollBar>
#include <QVector>
#include <QMap>
#include <iostream>
#include <QDebug>

FormTop::FormTop(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::FormTop)
{
    ui->setupUi(this);
}

//void FormTop::receiveFile(QVector<QList<float>> **mapFile)
void FormTop::receiveFile(QVector<QVector<QVector<QList<float>>>>& mapFile)
{
//    QString temp;
//    temp = strVector[1][3];
//    float fTemp = temp.toFloat()*1000000;
//    int iTemp = int(fTemp);
    float minX=0, maxX=0, minY=0, maxY=0;
    float posX = 0, posY =0;
    int areaX = 10, areaY = 10;
    int beginX = 0, beginY = 0, endX = mapFile.size(), endY = mapFile[0].size();
    if (posX - areaX > 0){beginX=posX - areaX;}
    if (posY - areaY > 0){beginY=posY - areaY;}
    if (posX + areaX < mapFile.size()){endX = posX + areaX;}
    if (posY + areaY < mapFile[0].size()){endY = posY + areaY;}



    QMap<int, QColor> mapColor;
    mapColor.insert(0,Qt::white);
    mapColor.insert(15,Qt::red);
    mapColor.insert(16,Qt::yellow);
    mapColor.insert(17,Qt::green);
    mapColor.insert(18,Qt::blue);
    mapColor.insert(19,Qt::magenta);
    mapColor.insert(714,Qt::red);
    mapColor.insert(177,Qt::red);

    qDebug() << "mapColor" <<mapColor;

    QGraphicsScene *scene = new QGraphicsScene(this);
    scene->setBackgroundBrush(QBrush(QColor(Qt::white)));
    //scene->setSceneRect(0,0,200,200);
    QPen mPen;
    mPen.setWidth(5);
    mPen.setColor(Qt::red);
// 기존에 있는 vector 를 남겨놔야 함 : delete 를 위해
    //            for(auto cur_item : rectItemList){
    //                delete cur_item;
    //            }
    //            rectItemList.clear();


    QVector<QGraphicsRectItem*> rectItemList;

    QGraphicsLineItem *zeroX = new QGraphicsLineItem;
    QGraphicsLineItem *zeroY = new QGraphicsLineItem;
    QTransform trans;
    trans.scale(1,-1);

    QVector<QList<float>> vecList;
    for (int i = beginX ; i < endX ; i++)
    {
        for (int j = beginY ; j < endY ; j++)
        {
            vecList.append(mapFile[i][j]);
        }
    }

    for (auto &data : vecList)
    {

        if (data.size() == 8)
        {
            QGraphicsRectItem *rectItem = new QGraphicsRectItem;
            rectItemList.push_back(rectItem);


            float x = 500*(data[2]);
            float y = 500*(data[3]);
            float w = 500*(data[4] - data[2]);
            float h = 500*(data[5] - data[3]);

            if (x<minX){minX = x;}
            if (x>maxX){maxX = x;}
            if (y<minY){minY = y;}
            if (y>maxY){maxY = y;}
            rectItem->setRect(x,y,w,h);
            rectItem->setBrush(QBrush(QColor(mapColor[int(data[0])])));
            rectItem->setOpacity(0.5);
            rectItem->setZValue(data[6]);

            rectItem->setTransform(trans);
            scene->addItem(rectItem);
        }
    }
    zeroX->setLine(0,0,maxX,0);
    zeroY->setLine(0,0,0,maxY);
    zeroX->setPen(QPen(QColor(Qt::red)));
    zeroY->setPen(QPen(QColor(Qt::red)));
    zeroX->setZValue(400);
    zeroY->setZValue(400);
    zeroY->setTransform(trans);
    scene->addItem(zeroX);
    scene->addItem(zeroY);
    ui->graphicsView->setScene(scene);
//    float dx = 100-(maxX-minX)/2;
//    float dy = 100-(maxY-minY)/2;



//    ui->graphicsView->horizontalScrollBar()->setValue(ui->graphicsView->horizontalScrollBar()->value()+dx);
//    ui->graphicsView->verticalScrollBar()->setValue(ui->graphicsView->verticalScrollBar()->value()+dy);
//    ui->graphicsView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//    ui->graphicsView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);


}




FormTop::~FormTop()
{
    delete ui;
}
���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������gitmerge.cpp����������������������������������������������������������������������������������������0000644�4673156�4001001�00000001404�14402520061�011732� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "gitmerge.h"

#include <QFile>
#include <QTextStream>
#include <QDebug>

GitMerge::GitMerge()
{
    this->mergeFiles();
}

void GitMerge::mergeFiles()
{
    QFile file("./IInterface.pro");

    if(!file.open(QFile::ReadOnly | QFile::Text))
    {
        qDebug() << " Could not open the file for reading ";
        return;
    }

    QTextStream in(&file);
    QString merge = in.readAll();
    QStringList mergeList = merge.split("\n");
    for (auto &itemMerge : mergeList)
    {
        if (itemMerge.contains(".cpp", Qt::CaseInsensitive) | itemMerge.contains(".h", Qt::CaseInsensitive) | itemMerge.contains(".ui", Qt::CaseInsensitive) )
        {
            qDebug() << itemMerge;
        }

    }

    file.close();
}


������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������main.cpp��������������������������������������������������������������������������������������������0000644�4673156�4001001�00000002304�14402517330�011060� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "mainwindow.h"
#include "gitmerge.h"

#include <QApplication>
#include <QVulkanInstance>
#include <QLoggingCategory>
#include <fstream>
#include <string>
#include <iostream>
#include "formtop.h"

#include "Rendering/Src/lve_window.hpp"
#include "Rendering/Src/simple_render_system.hpp"

Q_LOGGING_CATEGORY(lcVk, "qt.vulkan")

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

///////// git merge
    GitMerge gitMerge;
/// /////

    QLoggingCategory::setFilterRules(QStringLiteral("qt.vulkan=true"));

    QVulkanInstance inst;
    LveWindow *vulkanWindow = new LveWindow;

    //inst.setLayers(QByteArrayList() << "VK_LAYER_LUNARG_standard_validation");


    if (!inst.create())
        qFatal("Failed to create Vulkan instance: %d", inst.errorCode());

    vulkanWindow->setVulkanInstance(&inst);

    MainWindow mainWindow(vulkanWindow);
    QObject::connect(vulkanWindow, &LveWindow::signalInfoText, &mainWindow, &MainWindow::slotInfoText);

    QRect size = mainWindow.geometry();
    mainWindow.shareGeo(size);
    qDebug() << "Main geo : " << mainWindow.geometry();

    mainWindow.show();





    return app.exec();
}





����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������mainwindow.cpp��������������������������������������������������������������������������������������0000644�4673156�4001001�00000016042�14402514633�012317� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include "mainwindow.h"
#include "ui_mainwindow.h"

#include "Rendering/Src/dtaorendersystem.h"
#include "Rendering/Src/lve_model.hpp"

#include <QMouseEvent>
#include <QKeyEvent>
#include <QDockWidget>
#include <QGraphicsRectItem>
#include <QGraphicsOpacityEffect>
#include <QFile>
#include <QFileDialog>
#include <QString>

#include <fstream>
#include <iostream>
#include <string>
#include <QIODevice>
#include <QTextStream>

MainWindow::MainWindow(LveWindow *w)
    : m_window(w)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QWidget *wrapper = QWidget::createWindowContainer(w);
    ui->graphicsView->setViewport(wrapper);

    QDockWidget *dockHier = new QDockWidget(tr("Hierarchy"), this);
    dockHier->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockHier->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addDockWidget(Qt::RightDockWidgetArea, dockHier);
    formHier = new FormHier;
    dockHier->setWidget(formHier);

    QDockWidget *dockLayer = new QDockWidget(tr("Layer Information"), this);
    dockLayer->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockLayer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addDockWidget(Qt::RightDockWidgetArea, dockLayer);
    formLayer = new FormLayer;
    dockLayer->setWidget(formLayer);

    QDockWidget *dockMap = new QDockWidget(tr("Map"), this);
    dockMap->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockMap->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addDockWidget(Qt::LeftDockWidgetArea, dockMap);
    formMap = new FormMap;    
    dockMap->setWidget(formMap);

    QDockWidget *dockTop = new QDockWidget(tr("Topview"), this);
    dockTop->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockTop->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addDockWidget(Qt::LeftDockWidgetArea, dockTop);
    formTop = new FormTop;    
    dockTop->setWidget(formTop);

    QDockWidget *dockInfo = new QDockWidget(tr("Info"), this);
    dockInfo->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    dockInfo->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addDockWidget(Qt::LeftDockWidgetArea, dockInfo);
    formInfo = new FormInfo;
    dockInfo->setWidget(formInfo);

    resizeDocks({dockInfo, dockTop, dockMap, dockLayer, dockHier}, {200,200}, Qt::Horizontal);
    resizeDocks({dockTop, dockMap}, {200,200}, Qt::Vertical);

    input_dataS = new all_data;


    /// connect ////////////////////
    QObject::connect(ui->actionOpen_file, SIGNAL(triggered()), this, SLOT(on_actionOpen_file_triggered));
    QObject::connect(this, SIGNAL(sendSelectFileName(QString)), input_dataS, SLOT(receiveSelectFileName(QString)));
    QObject::connect(input_dataS, SIGNAL(sendSplitData(int, int, const QVector <QVector <QString>> &)), formHier, SLOT(ReceiveSplitData(int, int, const QVector <QVector <QString>> &)));
    QObject::connect(input_dataS, SIGNAL(sendSplitData(int, int, const QVector <QVector <QString>> &)), formLayer, SLOT(ReceiveSplitData(int, int, const QVector <QVector <QString>> &)));
    QObject::connect(formLayer, SIGNAL(outputLayerStatus(QString)), this, SLOT(inputLayerStatus(QString)));

}

void MainWindow::shareGeo(QRect size)
{
    QRect windowSize = size;
    qDebug() << "shareGeo : " << windowSize;
}


MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::slotInfoText(QString funcName, float value)
{
    formInfo->slotInfoText(funcName,value);
    formMap->slotInfoText(funcName,value);
    qDebug() << "slotInfoText" << value;
///// temp //////
    QString text = funcName + " : " + QString::number(value);
    for (int i = text.size() ; i < 30 ; i++)
    {
        text.append(" ");
    }

    statusText.prepend(text);

    if (statusText.size() > 120)
        statusText.remove(120,statusText.size()-120);
    ui->statusbar->showMessage(statusText);

}

void MainWindow::on_actionOpen_Map_File_triggered()
{
    QString fileNameInfo = QFileDialog::getOpenFileName(this,
                                                        tr("Open map file"),
                                                        ".",
                                                        tr("text (*.txt)")
                                                        );
    FileDb *fileDb = new FileDb;
    QVector<QList<float>> vecList;
    float xMinSize = 0, yMinSize = 0, xMaxSize = 0, yMaxSize = 0;
    fileDb->openFile(fileNameInfo, vecList , xMinSize, yMinSize, xMaxSize, yMaxSize);

    int posScale = 1000, splitSize = 10; //posScale 이 1이면 um 단위, posScale 이 1000이면 nm 단위
    int n = (int(xMaxSize *posScale)-int(xMinSize *posScale))/splitSize +1;
    int m = (int(yMaxSize *posScale)-int(yMinSize *posScale))/splitSize +1;
    qDebug() << "int n / int m : " << n << " , " <<m;

    ////////////////////////////////////////////////
    QVector<QVector<QVector<QList<float>>>> mapFile(n, QVector<QVector<QList<float>>>(m, {{}}));
//    QVector<QList<float>> mapFile[n][m];
    // 구조 변경에 대해 생각할 필요 있음
    // 주형 구조 : struct(layer, r, g, b, z, thk, opacity, vector())

    mapFile[0][0][0].append({0, 0, xMinSize, yMinSize, xMaxSize, yMaxSize, 0, 0});

    for (auto & data : vecList)
    {
        if(data.size() == 8)
        {
            qDebug() << " " << data[2] << " "<< int(data[2]*100) << " "<< data[3] << " "<< int(data[3]*100);
            int in_n = 0, in_m = 0;
            if(data[2]<0)
            {in_n = n + int(data[2]*100)-1;}
            else
            {in_n = int(data[2]*100);}
            if(data[3]<0)
            {in_m = m + int(data[3]*100)-1;}
            else
            {in_m = int(data[3]*100);}
            mapFile[in_n][in_m].append(data);
        }
    }



    for(int i = 0 ; i < (int(mapFile[0][0][0][2]*1000)-int(mapFile[0][0][0][0]*1000))/10+1 ; i++)
    {
        QDebug oneLine = qDebug();
        for(int j = 0 ; j < (int(mapFile[0][0][0][3]*1000)-int(mapFile[0][0][0][1]*1000))/10+1 ; j++)
        {
            oneLine << "["<<i<<"]["<<j<<"] "<<mapFile[i][j];
        }
        qDebug() << "";
    }

    float zoomScale = std::max(xMaxSize-xMinSize,yMaxSize-yMinSize)/10;
    formMap->receiveSize(xMinSize,yMinSize,xMaxSize,yMaxSize,zoomScale);
    formTop->receiveFile(mapFile);

}

void MainWindow::on_actionOpen_file_triggered()
{

    QString file_name = QFileDialog::getOpenFileName(this, "파일 선택",".","Files(*.*)");
    //qDebug() << file_name;

    emit sendSelectFileName(file_name);

}


void MainWindow::inputLayerStatus(QString text)
{
    ui->statusbar->showMessage(text);
}



void MainWindow::on_actionOpen_Layout_triggered()
{
    QString file_name = QFileDialog::getOpenFileName(this, "파일 선택",".","Files(*.*)");
    DtaoRenderSystem * renderer = this->m_window->getRenderer();

    renderer->createNewObject(MODEL_TYPE::MODEL_TYPE_LAYOUT, file_name.toStdString());


}
����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������trianglerenderer.cpp��������������������������������������������������������������������������������0000644�4673156�4001001�00000050257�14402242514�013501� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/****************************************************************************
**
** Copyright (C) 2017 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** "Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include "trianglerenderer.h"
#include <QVulkanFunctions>
#include <QFile>

// Note that the vertex data and the projection matrix assume OpenGL. With
// Vulkan Y is negated in clip space and the near/far plane is at 0/1 instead
// of -1/1. These will be corrected for by an extra transformation when
// calculating the modelview-projection matrix.
static float vertexData[] = { // Y up, front = CCW
     0.0f,   0.5f,   1.0f, 0.0f, 0.0f,
    -0.5f,  -0.5f,   0.0f, 1.0f, 0.0f,
     0.5f,  -0.5f,   0.0f, 0.0f, 1.0f
};

static const int UNIFORM_DATA_SIZE = 16 * sizeof(float);

static inline VkDeviceSize aligned(VkDeviceSize v, VkDeviceSize byteAlign)
{
    return (v + byteAlign - 1) & ~(byteAlign - 1);
}

TriangleRenderer::TriangleRenderer(QVulkanWindow *w, bool msaa)
    : m_window(w)
{
    if (msaa) {
        const QVector<int> counts = w->supportedSampleCounts();
        qDebug() << "Supported sample counts:" << counts;
        for (int s = 16; s >= 4; s /= 2) {
            if (counts.contains(s)) {
                qDebug("Requesting sample count %d", s);
                m_window->setSampleCount(s);
                break;
            }
        }
    }
}

VkShaderModule TriangleRenderer::createShader(const QString &name)
{
    QFile file(name);
    if (!file.open(QIODevice::ReadOnly)) {
        qWarning("Failed to read shader %s", qPrintable(name));
        return VK_NULL_HANDLE;
    }
    QByteArray blob = file.readAll();
    file.close();

    VkShaderModuleCreateInfo shaderInfo;
    memset(&shaderInfo, 0, sizeof(shaderInfo));
    shaderInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    shaderInfo.codeSize = blob.size();
    shaderInfo.pCode = reinterpret_cast<const uint32_t *>(blob.constData());
    VkShaderModule shaderModule;
    VkResult err = m_devFuncs->vkCreateShaderModule(m_window->device(), &shaderInfo, nullptr, &shaderModule);
    if (err != VK_SUCCESS) {
        qWarning("Failed to create shader module: %d", err);
        return VK_NULL_HANDLE;
    }

    return shaderModule;
}

void TriangleRenderer::initResources()
{
    qDebug("initResources");

    VkDevice dev = m_window->device();
    m_devFuncs = m_window->vulkanInstance()->deviceFunctions(dev);

    // Prepare the vertex and uniform data. The vertex data will never
    // change so one buffer is sufficient regardless of the value of
    // QVulkanWindow::CONCURRENT_FRAME_COUNT. Uniform data is changing per
    // frame however so active frames have to have a dedicated copy.

    // Use just one memory allocation and one buffer. We will then specify the
    // appropriate offsets for uniform buffers in the VkDescriptorBufferInfo.
    // Have to watch out for
    // VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment, though.

    // The uniform buffer is not strictly required in this example, we could
    // have used push constants as well since our single matrix (64 bytes) fits
    // into the spec mandated minimum limit of 128 bytes. However, once that
    // limit is not sufficient, the per-frame buffers, as shown below, will
    // become necessary.

    const int concurrentFrameCount = m_window->concurrentFrameCount();
    const VkPhysicalDeviceLimits *pdevLimits = &m_window->physicalDeviceProperties()->limits;
    const VkDeviceSize uniAlign = pdevLimits->minUniformBufferOffsetAlignment;
    qDebug("uniform buffer offset alignment is %u", (uint) uniAlign);
    VkBufferCreateInfo bufInfo;
    memset(&bufInfo, 0, sizeof(bufInfo));
    bufInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    // Our internal layout is vertex, uniform, uniform, ... with each uniform buffer start offset aligned to uniAlign.
    const VkDeviceSize vertexAllocSize = aligned(sizeof(vertexData), uniAlign);
    const VkDeviceSize uniformAllocSize = aligned(UNIFORM_DATA_SIZE, uniAlign);
    bufInfo.size = vertexAllocSize + concurrentFrameCount * uniformAllocSize;
    bufInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;

    VkResult err = m_devFuncs->vkCreateBuffer(dev, &bufInfo, nullptr, &m_buf);
    if (err != VK_SUCCESS)
        qFatal("Failed to create buffer: %d", err);

    VkMemoryRequirements memReq;
    m_devFuncs->vkGetBufferMemoryRequirements(dev, m_buf, &memReq);

    VkMemoryAllocateInfo memAllocInfo = {
        VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        nullptr,
        memReq.size,
        m_window->hostVisibleMemoryIndex()
    };

    err = m_devFuncs->vkAllocateMemory(dev, &memAllocInfo, nullptr, &m_bufMem);
    if (err != VK_SUCCESS)
        qFatal("Failed to allocate memory: %d", err);

    err = m_devFuncs->vkBindBufferMemory(dev, m_buf, m_bufMem, 0);
    if (err != VK_SUCCESS)
        qFatal("Failed to bind buffer memory: %d", err);

    quint8 *p;
    err = m_devFuncs->vkMapMemory(dev, m_bufMem, 0, memReq.size, 0, reinterpret_cast<void **>(&p));
    if (err != VK_SUCCESS)
        qFatal("Failed to map memory: %d", err);
    memcpy(p, vertexData, sizeof(vertexData));
    QMatrix4x4 ident;
    memset(m_uniformBufInfo, 0, sizeof(m_uniformBufInfo));
    for (int i = 0; i < concurrentFrameCount; ++i) {
        const VkDeviceSize offset = vertexAllocSize + i * uniformAllocSize;
        memcpy(p + offset, ident.constData(), 16 * sizeof(float));
        m_uniformBufInfo[i].buffer = m_buf;
        m_uniformBufInfo[i].offset = offset;
        m_uniformBufInfo[i].range = uniformAllocSize;
    }
    m_devFuncs->vkUnmapMemory(dev, m_bufMem);

    VkVertexInputBindingDescription vertexBindingDesc = {
        0, // binding
        5 * sizeof(float),
        VK_VERTEX_INPUT_RATE_VERTEX
    };
    VkVertexInputAttributeDescription vertexAttrDesc[] = {
        { // position
            0, // location
            0, // binding
            VK_FORMAT_R32G32_SFLOAT,
            0
        },
        { // color
            1,
            0,
            VK_FORMAT_R32G32B32_SFLOAT,
            2 * sizeof(float)
        }
    };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo;
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.pNext = nullptr;
    vertexInputInfo.flags = 0;
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.pVertexBindingDescriptions = &vertexBindingDesc;
    vertexInputInfo.vertexAttributeDescriptionCount = 2;
    vertexInputInfo.pVertexAttributeDescriptions = vertexAttrDesc;

    // Set up descriptor set and its layout.
    VkDescriptorPoolSize descPoolSizes = { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, uint32_t(concurrentFrameCount) };
    VkDescriptorPoolCreateInfo descPoolInfo;
    memset(&descPoolInfo, 0, sizeof(descPoolInfo));
    descPoolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    descPoolInfo.maxSets = concurrentFrameCount;
    descPoolInfo.poolSizeCount = 1;
    descPoolInfo.pPoolSizes = &descPoolSizes;
    err = m_devFuncs->vkCreateDescriptorPool(dev, &descPoolInfo, nullptr, &m_descPool);
    if (err != VK_SUCCESS)
        qFatal("Failed to create descriptor pool: %d", err);

    VkDescriptorSetLayoutBinding layoutBinding = {
        0, // binding
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        1,
        VK_SHADER_STAGE_VERTEX_BIT,
        nullptr
    };
    VkDescriptorSetLayoutCreateInfo descLayoutInfo = {
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        nullptr,
        0,
        1,
        &layoutBinding
    };
    err = m_devFuncs->vkCreateDescriptorSetLayout(dev, &descLayoutInfo, nullptr, &m_descSetLayout);
    if (err != VK_SUCCESS)
        qFatal("Failed to create descriptor set layout: %d", err);

    for (int i = 0; i < concurrentFrameCount; ++i) {
        VkDescriptorSetAllocateInfo descSetAllocInfo = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
            nullptr,
            m_descPool,
            1,
            &m_descSetLayout
        };
        err = m_devFuncs->vkAllocateDescriptorSets(dev, &descSetAllocInfo, &m_descSet[i]);
        if (err != VK_SUCCESS)
            qFatal("Failed to allocate descriptor set: %d", err);

        VkWriteDescriptorSet descWrite;
        memset(&descWrite, 0, sizeof(descWrite));
        descWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        descWrite.dstSet = m_descSet[i];
        descWrite.descriptorCount = 1;
        descWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        descWrite.pBufferInfo = &m_uniformBufInfo[i];
        m_devFuncs->vkUpdateDescriptorSets(dev, 1, &descWrite, 0, nullptr);
    }

    // Pipeline cache
    VkPipelineCacheCreateInfo pipelineCacheInfo;
    memset(&pipelineCacheInfo, 0, sizeof(pipelineCacheInfo));
    pipelineCacheInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
    err = m_devFuncs->vkCreatePipelineCache(dev, &pipelineCacheInfo, nullptr, &m_pipelineCache);
    if (err != VK_SUCCESS)
        qFatal("Failed to create pipeline cache: %d", err);

    // Pipeline layout
    VkPipelineLayoutCreateInfo pipelineLayoutInfo;
    memset(&pipelineLayoutInfo, 0, sizeof(pipelineLayoutInfo));
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &m_descSetLayout;
    err = m_devFuncs->vkCreatePipelineLayout(dev, &pipelineLayoutInfo, nullptr, &m_pipelineLayout);
    if (err != VK_SUCCESS)
        qFatal("Failed to create pipeline layout: %d", err);

    // Shaders
    VkShaderModule vertShaderModule = createShader(QStringLiteral(":/color_vert.spv"));
    VkShaderModule fragShaderModule = createShader(QStringLiteral(":/color_frag.spv"));

    // Graphics pipeline
    VkGraphicsPipelineCreateInfo pipelineInfo;
    memset(&pipelineInfo, 0, sizeof(pipelineInfo));
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;

    VkPipelineShaderStageCreateInfo shaderStages[2] = {
        {
            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            nullptr,
            0,
            VK_SHADER_STAGE_VERTEX_BIT,
            vertShaderModule,
            "main",
            nullptr
        },
        {
            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            nullptr,
            0,
            VK_SHADER_STAGE_FRAGMENT_BIT,
            fragShaderModule,
            "main",
            nullptr
        }
    };
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;

    pipelineInfo.pVertexInputState = &vertexInputInfo;

    VkPipelineInputAssemblyStateCreateInfo ia;
    memset(&ia, 0, sizeof(ia));
    ia.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    ia.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    pipelineInfo.pInputAssemblyState = &ia;

    // The viewport and scissor will be set dynamically via vkCmdSetViewport/Scissor.
    // This way the pipeline does not need to be touched when resizing the window.
    VkPipelineViewportStateCreateInfo vp;
    memset(&vp, 0, sizeof(vp));
    vp.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    vp.viewportCount = 1;
    vp.scissorCount = 1;
    pipelineInfo.pViewportState = &vp;

    VkPipelineRasterizationStateCreateInfo rs;
    memset(&rs, 0, sizeof(rs));
    rs.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rs.polygonMode = VK_POLYGON_MODE_FILL;
    rs.cullMode = VK_CULL_MODE_NONE; // we want the back face as well
    rs.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rs.lineWidth = 1.0f;
    pipelineInfo.pRasterizationState = &rs;

    VkPipelineMultisampleStateCreateInfo ms;
    memset(&ms, 0, sizeof(ms));
    ms.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    // Enable multisampling.
    ms.rasterizationSamples = m_window->sampleCountFlagBits();
    pipelineInfo.pMultisampleState = &ms;

    VkPipelineDepthStencilStateCreateInfo ds;
    memset(&ds, 0, sizeof(ds));
    ds.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    ds.depthTestEnable = VK_TRUE;
    ds.depthWriteEnable = VK_TRUE;
    ds.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &ds;

    VkPipelineColorBlendStateCreateInfo cb;
    memset(&cb, 0, sizeof(cb));
    cb.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    // no blend, write out all of rgba
    VkPipelineColorBlendAttachmentState att;
    memset(&att, 0, sizeof(att));
    att.colorWriteMask = 0xF;
    cb.attachmentCount = 1;
    cb.pAttachments = &att;
    pipelineInfo.pColorBlendState = &cb;

    VkDynamicState dynEnable[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR };
    VkPipelineDynamicStateCreateInfo dyn;
    memset(&dyn, 0, sizeof(dyn));
    dyn.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dyn.dynamicStateCount = sizeof(dynEnable) / sizeof(VkDynamicState);
    dyn.pDynamicStates = dynEnable;
    pipelineInfo.pDynamicState = &dyn;

    pipelineInfo.layout = m_pipelineLayout;
    pipelineInfo.renderPass = m_window->defaultRenderPass();

    err = m_devFuncs->vkCreateGraphicsPipelines(dev, m_pipelineCache, 1, &pipelineInfo, nullptr, &m_pipeline);
    if (err != VK_SUCCESS)
        qFatal("Failed to create graphics pipeline: %d", err);

    if (vertShaderModule)
        m_devFuncs->vkDestroyShaderModule(dev, vertShaderModule, nullptr);
    if (fragShaderModule)
        m_devFuncs->vkDestroyShaderModule(dev, fragShaderModule, nullptr);
}

void TriangleRenderer::initSwapChainResources()
{
    qDebug("initSwapChainResources");

    // Projection matrix
    m_proj = m_window->clipCorrectionMatrix(); // adjust for Vulkan-OpenGL clip space differences
    const QSize sz = m_window->swapChainImageSize();
    m_proj.perspective(45.0f, sz.width() / (float) sz.height(), 0.01f, 100.0f);
    m_proj.translate(0, 0, -4);
}

void TriangleRenderer::releaseSwapChainResources()
{
    qDebug("releaseSwapChainResources");
}

void TriangleRenderer::releaseResources()
{
    qDebug("releaseResources");

    VkDevice dev = m_window->device();

    if (m_pipeline) {
        m_devFuncs->vkDestroyPipeline(dev, m_pipeline, nullptr);
        m_pipeline = VK_NULL_HANDLE;
    }

    if (m_pipelineLayout) {
        m_devFuncs->vkDestroyPipelineLayout(dev, m_pipelineLayout, nullptr);
        m_pipelineLayout = VK_NULL_HANDLE;
    }

    if (m_pipelineCache) {
        m_devFuncs->vkDestroyPipelineCache(dev, m_pipelineCache, nullptr);
        m_pipelineCache = VK_NULL_HANDLE;
    }

    if (m_descSetLayout) {
        m_devFuncs->vkDestroyDescriptorSetLayout(dev, m_descSetLayout, nullptr);
        m_descSetLayout = VK_NULL_HANDLE;
    }

    if (m_descPool) {
        m_devFuncs->vkDestroyDescriptorPool(dev, m_descPool, nullptr);
        m_descPool = VK_NULL_HANDLE;
    }

    if (m_buf) {
        m_devFuncs->vkDestroyBuffer(dev, m_buf, nullptr);
        m_buf = VK_NULL_HANDLE;
    }

    if (m_bufMem) {
        m_devFuncs->vkFreeMemory(dev, m_bufMem, nullptr);
        m_bufMem = VK_NULL_HANDLE;
    }
}

void TriangleRenderer::startNextFrame()
{
    VkDevice dev = m_window->device();
    VkCommandBuffer cb = m_window->currentCommandBuffer();
    const QSize sz = m_window->swapChainImageSize();

    VkClearColorValue clearColor = {{ 0, 0, 0, 1 }};
    VkClearDepthStencilValue clearDS = { 1, 0 };
    VkClearValue clearValues[3];
    memset(clearValues, 0, sizeof(clearValues));
    clearValues[0].color = clearValues[2].color = clearColor;
    clearValues[1].depthStencil = clearDS;

    VkRenderPassBeginInfo rpBeginInfo;
    memset(&rpBeginInfo, 0, sizeof(rpBeginInfo));
    rpBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    rpBeginInfo.renderPass = m_window->defaultRenderPass();
    rpBeginInfo.framebuffer = m_window->currentFramebuffer();
    rpBeginInfo.renderArea.extent.width = sz.width();
    rpBeginInfo.renderArea.extent.height = sz.height();
    rpBeginInfo.clearValueCount = m_window->sampleCountFlagBits() > VK_SAMPLE_COUNT_1_BIT ? 3 : 2;
    rpBeginInfo.pClearValues = clearValues;
    VkCommandBuffer cmdBuf = m_window->currentCommandBuffer();
    m_devFuncs->vkCmdBeginRenderPass(cmdBuf, &rpBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

    quint8 *p;
    VkResult err = m_devFuncs->vkMapMemory(dev, m_bufMem, m_uniformBufInfo[m_window->currentFrame()].offset,
            UNIFORM_DATA_SIZE, 0, reinterpret_cast<void **>(&p));
    if (err != VK_SUCCESS)
        qFatal("Failed to map memory: %d", err);
    QMatrix4x4 m = m_proj;
    m.rotate(m_rotation, m_rotation_ver , 1, 0);
    memcpy(p, m.constData(), 16 * sizeof(float));
    m_devFuncs->vkUnmapMemory(dev, m_bufMem);

    // Not exactly a real animation system, just advance on every frame for now.
    m_rotation += 1.0f;

    m_devFuncs->vkCmdBindPipeline(cb, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline);
    m_devFuncs->vkCmdBindDescriptorSets(cb, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipelineLayout, 0, 1,
                               &m_descSet[m_window->currentFrame()], 0, nullptr);
    VkDeviceSize vbOffset = 0;
    m_devFuncs->vkCmdBindVertexBuffers(cb, 0, 1, &m_buf, &vbOffset);

    VkViewport viewport;
    viewport.x = viewport.y = 0;
    viewport.width = sz.width();
    viewport.height = sz.height();
    viewport.minDepth = 0;
    viewport.maxDepth = 1;
    m_devFuncs->vkCmdSetViewport(cb, 0, 1, &viewport);

    VkRect2D scissor;
    scissor.offset.x = scissor.offset.y = 0;
    scissor.extent.width = viewport.width;
    scissor.extent.height = viewport.height;
    m_devFuncs->vkCmdSetScissor(cb, 0, 1, &scissor);

    m_devFuncs->vkCmdDraw(cb, 3, 1, 0, 0);

    m_devFuncs->vkCmdEndRenderPass(cmdBuf);

    m_window->frameReady();
    m_window->requestUpdate(); // render continuously, throttled by the presentation rate
}

�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������all_data.h������������������������������������������������������������������������������������������0000644�4673156�4001001�00000001052�14402242514�011340� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#ifndef ALL_DATA_H
#define ALL_DATA_H

#include <QObject>
#include <QDebug>
#include <QVector>


class all_data : public QObject
{
    Q_OBJECT
//    Q_DECLARE_METATYPE(QVector <QVector <QString>>);

public:
    all_data(QObject *parent = nullptr);
    ~all_data();

public:
    QVector <QVector <QString>> inputDataVector;

public slots:
    void receiveSelectFileName(QString file_name);

signals:
    void sendSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector);


};

#endif // ALL_DATA_H
��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������filedb.h��������������������������������������������������������������������������������������������0000644�4673156�4001001�00000000436�14402242514�011031� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#ifndef FILEDB_H
#define FILEDB_H

#include <QVector>


class FileDb
{
public:
    FileDb();
    void openFile(QString fileNameInfo,QVector<QList<float>> &vecList,
                  float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize);
};

#endif // FILEDB_H
����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formhier.h������������������������������������������������������������������������������������������0000644�4673156�4001001�00000001254�14402242514�011416� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#ifndef FORMHIER_H
#define FORMHIER_H

#include <QDialog>
//#include "all_data.h"
//#include "mainwindow.h"

namespace Ui {
class FormHier;
}

class FormHier : public QDialog
{
    Q_OBJECT

public slots:
    void ReceiveSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector);
//    void ReceiveSplitData(QStringList list, int row, int column);

public:
    FormHier(QWidget *parent = nullptr);
    ~FormHier();
    Ui::FormHier *ui;

public:
    //MyDataSet *dataset = nullptr;

public:
    //void setMyDataSet(MyDataSet * dataset_){ this->dataset = dataset_;}
    //void testMyData();

};

#endif // FORMHIER_H

/////
����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������forminfo.h������������������������������������������������������������������������������������������0000644�4673156�4001001�00000001422�14402242514�011417� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#ifndef FORMINFO_H
#define FORMINFO_H

#include <QDialog>

namespace Ui {
class FormInfo;
}

class FormInfo : public QDialog
{
    Q_OBJECT

public:
    explicit FormInfo(QWidget *parent = nullptr);
    ~FormInfo();

public slots:
    void slotInfoText(QString funcName, float value);
    void moveRender(float x, float y);

private:
    Ui::FormInfo *ui;
    float pointX = 0;
    float pointY = 0;
    float pointZ = 0;
    float infoTilt = 90;
    float infoRot = 0;
    float infoZoom = 1; //Zoom 초기값에 대한 GDS size 를 갖고와 수정 필요

    float initRot = 0;
    float initTilt = 90;
    float initPointX = 0;
    float initPointY = 0;
    float initPointZ = 0;

    float x = 0;
    float y = 0;
};

#endif // FORMINFO_H
����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formlayer.h�����������������������������������������������������������������������������������������0000644�4673156�4001001�00000004302�14402242514�011600� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#ifndef FORMLAYER_H
#define FORMLAYER_H

#include <QDialog>
#include <QColorDialog>
#include <QtWidgets/QCheckBox>
#include <QtWidgets>
#include <QTableWidget>
#include <QTableWidgetItem>
#include <QCheckBox>
#include <QPushButton>
#include <QtWidgets/QSlider>
#include <QDebug>


namespace Ui {
class FormLayer;
}

class FormLayer : public QDialog
{
    Q_OBJECT

public slots:
    void ReceiveSplitData(int row, int column, const QVector <QVector <QString>> &inputDataVector);

public:
    explicit FormLayer(QWidget *parent = nullptr);
    ~FormLayer();
    int i;
    int row;
    int column;

//    QTableWidgetItem *checkBoxItem[3];


private slots:
    void tableWidget_checkBoxChanged();
    void on_colorbutton_clicked();
    void handleOpacitySlider(int);

private:
    Ui::FormLayer *ui;

signals:
    void outputLayerStatus(QString printLayer);

};

//class SliderDelegate : public QItemDelegate
//{
//public:
//    SliderDelegate(QWidget *parent = nullptr) : QItemDelegate(parent){
////        SliderDelegate delegate(this);
//    }
//    QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &option,const QModelIndex &index) const override
//    {
//        QSlider *slider = new QSlider(Qt::Horizontal, parent);
//        slider->setRange(0, 100);
//        slider->setGeometry(option.rect);
//        slider->setFocusPolicy(Qt::StrongFocus);
//        slider->setTickPosition(QSlider::TicksBothSides);
//        slider->setTickInterval(10);
//        slider->show();
//        return slider;
//    }

//    void setEditorData(QWidget *editor, const QModelIndex &index) const override
//    {
//        int value = index.model()->data(index, Qt::EditRole).toInt();
//        QSlider *slider = static_cast<QSlider*>(editor);
//        slider->setValue(value);
//        qDebug() << slider;
//    }

//    void setModelData(QWidget *editor, QAbstractItemModel *model,
//                      const QModelIndex &index) const override
//    {
//        QSlider *slider = static_cast<QSlider*>(editor);
//        int value = slider->value();
//        model->setData(index, value, Qt::EditRole);
//    }
//};


#endif // FORMLAYER_H
������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formmap.h�������������������������������������������������������������������������������������������0000644�4673156�4001001�00000003140�14402242514�011240� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#ifndef FORMMAP_H
#define FORMMAP_H

#include <QDialog>
#include <QGraphicsRectItem>

namespace Ui {
class FormMap;
}

class SuperItem : public QObject, public QGraphicsItem
{
    Q_OBJECT
public:
    SuperItem(QGraphicsItem* parent = NULL);
public slots:
    void slotMove(float x, float y, float zoom, float rot, float tilt);

protected:
    void paint(QPainter *painter,
               const QStyleOptionGraphicsItem *option,
               QWidget *widget);
    QRectF boundingRect() const;

//    virtual void keyPressEvent(QKeyEvent *evnet);
    float _zoom = 1;
    float _rot = 0;
    float _tilt = 90;

};

class FormMap : public QDialog
{
    Q_OBJECT

public:
    explicit FormMap(QWidget *parent = nullptr);
    ~FormMap();
    void receiveSize(float &xMinSize,float &yMinSize,float &xMaxSize,float &yMaxSize, float &zoomScale);

public slots:
    void slotInfoText(QString funcName, float value);

signals:
    void signalMove(float x, float y, float zoom, float rot, float tilt);

private:
    Ui::FormMap *ui;
    QGraphicsRectItem *rectItem;
    QGraphicsRectItem *rectItem2;
    QRect *rect;
    float width;
    float height;
    SuperItem *super;

    float pointX = 0;
    float pointY = 0;
    float pointZ = 0;
    float infoTilt = 90;
    float infoRot = 0;
    float infoZoom = 1; //Zoom 초기값에 대한 GDS size 를 갖고와 수정 필요

    float initRot = 0;
    float initTilt = 90;
    float initPointX = 0;
    float initPointY = 0;
    float initPointZ = 0;

    float x = 0;
    float y = 0;
};



#endif // FORMMAP_H
��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formtop.h�������������������������������������������������������������������������������������������0000644�4673156�4001001�00000000642�14402242514�011271� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#ifndef FORMTOP_H
#define FORMTOP_H

#include <QDialog>

namespace Ui {
class FormTop;
}

class FormTop : public QDialog
{
    Q_OBJECT

public:
    explicit FormTop(QWidget *parent = nullptr);
    ~FormTop();
    void receiveFile(QVector<QVector<QVector<QList<float>>>>& mapFile);
//    void receiveFile(QVector<QList<float>> **mapFile);

private:
    Ui::FormTop *ui;
};

#endif // FORMTOP_H
����������������������������������������������������������������������������������������������gitmerge.h������������������������������������������������������������������������������������������0000644�4673156�4001001�00000000344�14402517330�011406� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#ifndef GITMERGE_H
#define GITMERGE_H

#include <QString>

class GitMerge
{
public:
    GitMerge();
private:
    void mergeFiles();
//    void compareFiles();
//    void makeMergeFile();
};

#endif // GITMERGE_H
��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������mainwindow.h����������������������������������������������������������������������������������������0000644�4673156�4001001�00000002526�14402513177�011770� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include "Rendering/Src/lve_window.hpp"

#include <QMainWindow>
#include <QVulkanWindow>
#include <QDockWidget>
#include "formhier.h"
#include "formlayer.h"
#include "formtop.h"
#include "forminfo.h"
#include "formmap.h"
#include "filedb.h"
#include "all_data.h"
#include <QVector>

class LveWindow;

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; class LayerForm; }
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(LveWindow *w);
    ~MainWindow();

    void shareGeo(QRect size);

public slots:

    void slotInfoText(QString funcName, float value);
    void inputLayerStatus(QString text);
    void on_actionOpen_file_triggered();

signals:
    void signalInfoText(QString funcName, float value);
    void sendSelectFileName(QString file_name);


private slots:
    void on_actionOpen_Map_File_triggered();

    void on_actionOpen_Layout_triggered();

private:
    LveWindow *m_window;
    Ui::MainWindow *ui;
    QString statusText;
    FormHier *formHier;
    FormLayer *formLayer;
    FormTop *formTop;
    FormInfo *formInfo;
    FormMap *formMap;
    SuperItem *superItem;
    QRect *windowSize;
    FileDb *fileDb;
    all_data *input_dataS;
    QStringList split_data;
};

#endif // MAINWINDOW_H
��������������������������������������������������������������������������������������������������������������������������������������������������������������������������trianglerenderer.h����������������������������������������������������������������������������������0000644�4673156�4001001�00000007061�14402242514�013141� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/****************************************************************************
**
** Copyright (C) 2017 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** "Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include <QVulkanWindow>

class TriangleRenderer : public QVulkanWindowRenderer
{
public:
    TriangleRenderer(QVulkanWindow *w, bool msaa = false);

    void initResources() override;
    void initSwapChainResources() override;
    void releaseSwapChainResources() override;
    void releaseResources() override;

    void startNextFrame() override;



protected:
    VkShaderModule createShader(const QString &name);

    QVulkanWindow *m_window;
    QVulkanDeviceFunctions *m_devFuncs;

    VkDeviceMemory m_bufMem = VK_NULL_HANDLE;
    VkBuffer m_buf = VK_NULL_HANDLE;
    VkDescriptorBufferInfo m_uniformBufInfo[QVulkanWindow::MAX_CONCURRENT_FRAME_COUNT];

    VkDescriptorPool m_descPool = VK_NULL_HANDLE;
    VkDescriptorSetLayout m_descSetLayout = VK_NULL_HANDLE;
    VkDescriptorSet m_descSet[QVulkanWindow::MAX_CONCURRENT_FRAME_COUNT];

    VkPipelineCache m_pipelineCache = VK_NULL_HANDLE;
    VkPipelineLayout m_pipelineLayout = VK_NULL_HANDLE;
    VkPipeline m_pipeline = VK_NULL_HANDLE;

    QMatrix4x4 m_proj;
    float m_rotation = 0.0f;
    float m_rotation_ver = 0.0f;
};
�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ui_formhier.h���������������������������������������������������������������������������������������0000644�4673156�4001001�00000005602�14402513261�012114� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/********************************************************************************
** Form generated from reading UI file 'formhier.ui'
**
** Created by: Qt User Interface Compiler version 5.14.2
**
** WARNING! All changes made in this file will be lost when recompiling UI file!
********************************************************************************/

#ifndef UI_FORMHIER_H
#define UI_FORMHIER_H

#include <QtCore/QVariant>
#include <QtWidgets/QApplication>
#include <QtWidgets/QDialog>
#include <QtWidgets/QGridLayout>
#include <QtWidgets/QHeaderView>
#include <QtWidgets/QTableWidget>
#include <QtWidgets/QVBoxLayout>

QT_BEGIN_NAMESPACE

class Ui_FormHier
{
public:
    QVBoxLayout *verticalLayout;
    QGridLayout *gridLayout;
    QTableWidget *tableWidget;

    void setupUi(QDialog *FormHier)
    {
        if (FormHier->objectName().isEmpty())
            FormHier->setObjectName(QString::fromUtf8("FormHier"));
        FormHier->resize(510, 300);
        QSizePolicy sizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
        sizePolicy.setHorizontalStretch(0);
        sizePolicy.setVerticalStretch(0);
        sizePolicy.setHeightForWidth(FormHier->sizePolicy().hasHeightForWidth());
        FormHier->setSizePolicy(sizePolicy);
        FormHier->setMinimumSize(QSize(450, 100));
        verticalLayout = new QVBoxLayout(FormHier);
        verticalLayout->setObjectName(QString::fromUtf8("verticalLayout"));
        gridLayout = new QGridLayout();
        gridLayout->setObjectName(QString::fromUtf8("gridLayout"));
        tableWidget = new QTableWidget(FormHier);
        tableWidget->setObjectName(QString::fromUtf8("tableWidget"));
        sizePolicy.setHeightForWidth(tableWidget->sizePolicy().hasHeightForWidth());
        tableWidget->setSizePolicy(sizePolicy);
        tableWidget->setMinimumSize(QSize(260, 100));
        tableWidget->setBaseSize(QSize(260, 100));
        tableWidget->setSizeAdjustPolicy(QAbstractScrollArea::AdjustToContents);
        tableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);
        tableWidget->setAlternatingRowColors(true);
        tableWidget->setGridStyle(Qt::SolidLine);
        tableWidget->horizontalHeader()->setCascadingSectionResizes(false);
        tableWidget->horizontalHeader()->setStretchLastSection(false);
        tableWidget->verticalHeader()->setVisible(false);

        gridLayout->addWidget(tableWidget, 0, 0, 1, 1);


        verticalLayout->addLayout(gridLayout);


        retranslateUi(FormHier);

        QMetaObject::connectSlotsByName(FormHier);
    } // setupUi

    void retranslateUi(QDialog *FormHier)
    {
        FormHier->setWindowTitle(QCoreApplication::translate("FormHier", "Dialog", nullptr));
    } // retranslateUi

};

namespace Ui {
    class FormHier: public Ui_FormHier {};
} // namespace Ui

QT_END_NAMESPACE

#endif // UI_FORMHIER_H
������������������������������������������������������������������������������������������������������������������������������ui_forminfo.h���������������������������������������������������������������������������������������0000644�4673156�4001001�00000017361�14402513261�012125� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/********************************************************************************
** Form generated from reading UI file 'forminfo.ui'
**
** Created by: Qt User Interface Compiler version 5.14.2
**
** WARNING! All changes made in this file will be lost when recompiling UI file!
********************************************************************************/

#ifndef UI_FORMINFO_H
#define UI_FORMINFO_H

#include <QtCore/QVariant>
#include <QtWidgets/QApplication>
#include <QtWidgets/QDialog>
#include <QtWidgets/QGridLayout>
#include <QtWidgets/QLabel>
#include <QtWidgets/QListWidget>
#include <QtWidgets/QVBoxLayout>

QT_BEGIN_NAMESPACE

class Ui_FormInfo
{
public:
    QVBoxLayout *verticalLayout;
    QGridLayout *gridLayout;
    QLabel *label;
    QLabel *infoZoom;
    QLabel *pointZ;
    QLabel *infoTilt;
    QLabel *infoRot;
    QLabel *pointY;
    QLabel *label_2;
    QLabel *label_4;
    QLabel *pointX;
    QLabel *label_10;
    QLabel *label_11;
    QLabel *label_12;
    QListWidget *listWidget;

    void setupUi(QDialog *FormInfo)
    {
        if (FormInfo->objectName().isEmpty())
            FormInfo->setObjectName(QString::fromUtf8("FormInfo"));
        FormInfo->resize(200, 400);
        FormInfo->setMaximumSize(QSize(200, 16777215));
        verticalLayout = new QVBoxLayout(FormInfo);
        verticalLayout->setObjectName(QString::fromUtf8("verticalLayout"));
        gridLayout = new QGridLayout();
        gridLayout->setObjectName(QString::fromUtf8("gridLayout"));
        label = new QLabel(FormInfo);
        label->setObjectName(QString::fromUtf8("label"));
        QSizePolicy sizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
        sizePolicy.setHorizontalStretch(0);
        sizePolicy.setVerticalStretch(0);
        sizePolicy.setHeightForWidth(label->sizePolicy().hasHeightForWidth());
        label->setSizePolicy(sizePolicy);
        label->setMinimumSize(QSize(0, 20));
        label->setMaximumSize(QSize(16777215, 20));
        label->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(label, 0, 0, 1, 1);

        infoZoom = new QLabel(FormInfo);
        infoZoom->setObjectName(QString::fromUtf8("infoZoom"));
        sizePolicy.setHeightForWidth(infoZoom->sizePolicy().hasHeightForWidth());
        infoZoom->setSizePolicy(sizePolicy);
        infoZoom->setMinimumSize(QSize(0, 20));
        infoZoom->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(infoZoom, 3, 2, 1, 1);

        pointZ = new QLabel(FormInfo);
        pointZ->setObjectName(QString::fromUtf8("pointZ"));
        sizePolicy.setHeightForWidth(pointZ->sizePolicy().hasHeightForWidth());
        pointZ->setSizePolicy(sizePolicy);
        pointZ->setMinimumSize(QSize(0, 20));
        pointZ->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(pointZ, 1, 2, 1, 1);

        infoTilt = new QLabel(FormInfo);
        infoTilt->setObjectName(QString::fromUtf8("infoTilt"));
        sizePolicy.setHeightForWidth(infoTilt->sizePolicy().hasHeightForWidth());
        infoTilt->setSizePolicy(sizePolicy);
        infoTilt->setMinimumSize(QSize(0, 20));
        infoTilt->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(infoTilt, 3, 0, 1, 1);

        infoRot = new QLabel(FormInfo);
        infoRot->setObjectName(QString::fromUtf8("infoRot"));
        sizePolicy.setHeightForWidth(infoRot->sizePolicy().hasHeightForWidth());
        infoRot->setSizePolicy(sizePolicy);
        infoRot->setMinimumSize(QSize(0, 20));
        infoRot->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(infoRot, 3, 1, 1, 1);

        pointY = new QLabel(FormInfo);
        pointY->setObjectName(QString::fromUtf8("pointY"));
        sizePolicy.setHeightForWidth(pointY->sizePolicy().hasHeightForWidth());
        pointY->setSizePolicy(sizePolicy);
        pointY->setMinimumSize(QSize(0, 20));
        pointY->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(pointY, 1, 1, 1, 1);

        label_2 = new QLabel(FormInfo);
        label_2->setObjectName(QString::fromUtf8("label_2"));
        sizePolicy.setHeightForWidth(label_2->sizePolicy().hasHeightForWidth());
        label_2->setSizePolicy(sizePolicy);
        label_2->setMinimumSize(QSize(0, 20));
        label_2->setMaximumSize(QSize(16777215, 20));
        label_2->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(label_2, 0, 1, 1, 1);

        label_4 = new QLabel(FormInfo);
        label_4->setObjectName(QString::fromUtf8("label_4"));
        sizePolicy.setHeightForWidth(label_4->sizePolicy().hasHeightForWidth());
        label_4->setSizePolicy(sizePolicy);
        label_4->setMinimumSize(QSize(0, 20));
        label_4->setMaximumSize(QSize(16777215, 20));
        label_4->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(label_4, 0, 2, 1, 1);

        pointX = new QLabel(FormInfo);
        pointX->setObjectName(QString::fromUtf8("pointX"));
        sizePolicy.setHeightForWidth(pointX->sizePolicy().hasHeightForWidth());
        pointX->setSizePolicy(sizePolicy);
        pointX->setMinimumSize(QSize(0, 20));
        pointX->setMaximumSize(QSize(16777215, 20));
        pointX->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(pointX, 1, 0, 1, 1);

        label_10 = new QLabel(FormInfo);
        label_10->setObjectName(QString::fromUtf8("label_10"));
        sizePolicy.setHeightForWidth(label_10->sizePolicy().hasHeightForWidth());
        label_10->setSizePolicy(sizePolicy);
        label_10->setMinimumSize(QSize(0, 20));
        label_10->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(label_10, 2, 0, 1, 1);

        label_11 = new QLabel(FormInfo);
        label_11->setObjectName(QString::fromUtf8("label_11"));
        sizePolicy.setHeightForWidth(label_11->sizePolicy().hasHeightForWidth());
        label_11->setSizePolicy(sizePolicy);
        label_11->setMinimumSize(QSize(0, 20));
        label_11->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(label_11, 2, 1, 1, 1);

        label_12 = new QLabel(FormInfo);
        label_12->setObjectName(QString::fromUtf8("label_12"));
        sizePolicy.setHeightForWidth(label_12->sizePolicy().hasHeightForWidth());
        label_12->setSizePolicy(sizePolicy);
        label_12->setMinimumSize(QSize(0, 20));
        label_12->setAlignment(Qt::AlignCenter);

        gridLayout->addWidget(label_12, 2, 2, 1, 1);


        verticalLayout->addLayout(gridLayout);

        listWidget = new QListWidget(FormInfo);
        listWidget->setObjectName(QString::fromUtf8("listWidget"));

        verticalLayout->addWidget(listWidget);


        retranslateUi(FormInfo);

        QMetaObject::connectSlotsByName(FormInfo);
    } // setupUi

    void retranslateUi(QDialog *FormInfo)
    {
        FormInfo->setWindowTitle(QCoreApplication::translate("FormInfo", "Dialog", nullptr));
        label->setText(QCoreApplication::translate("FormInfo", "X", nullptr));
        infoZoom->setText(QString());
        pointZ->setText(QString());
        infoTilt->setText(QString());
        infoRot->setText(QString());
        pointY->setText(QString());
        label_2->setText(QCoreApplication::translate("FormInfo", "Y", nullptr));
        label_4->setText(QCoreApplication::translate("FormInfo", "Z", nullptr));
        pointX->setText(QString());
        label_10->setText(QCoreApplication::translate("FormInfo", "Tilt", nullptr));
        label_11->setText(QCoreApplication::translate("FormInfo", "Rotation", nullptr));
        label_12->setText(QCoreApplication::translate("FormInfo", "Zoom", nullptr));
    } // retranslateUi

};

namespace Ui {
    class FormInfo: public Ui_FormInfo {};
} // namespace Ui

QT_END_NAMESPACE

#endif // UI_FORMINFO_H
�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ui_formlayer.h��������������������������������������������������������������������������������������0000644�4673156�4001001�00000005050�14402513261�012276� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/********************************************************************************
** Form generated from reading UI file 'formlayer.ui'
**
** Created by: Qt User Interface Compiler version 5.14.2
**
** WARNING! All changes made in this file will be lost when recompiling UI file!
********************************************************************************/

#ifndef UI_FORMLAYER_H
#define UI_FORMLAYER_H

#include <QtCore/QVariant>
#include <QtWidgets/QApplication>
#include <QtWidgets/QDialog>
#include <QtWidgets/QGridLayout>
#include <QtWidgets/QHeaderView>
#include <QtWidgets/QTableWidget>
#include <QtWidgets/QVBoxLayout>

QT_BEGIN_NAMESPACE

class Ui_FormLayer
{
public:
    QVBoxLayout *verticalLayout;
    QGridLayout *gridLayout;
    QTableWidget *tableWidget;

    void setupUi(QDialog *FormLayer)
    {
        if (FormLayer->objectName().isEmpty())
            FormLayer->setObjectName(QString::fromUtf8("FormLayer"));
        FormLayer->resize(450, 600);
        QSizePolicy sizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
        sizePolicy.setHorizontalStretch(0);
        sizePolicy.setVerticalStretch(0);
        sizePolicy.setHeightForWidth(FormLayer->sizePolicy().hasHeightForWidth());
        FormLayer->setSizePolicy(sizePolicy);
        FormLayer->setMinimumSize(QSize(450, 300));
        FormLayer->setMaximumSize(QSize(430, 16777215));
        verticalLayout = new QVBoxLayout(FormLayer);
        verticalLayout->setObjectName(QString::fromUtf8("verticalLayout"));
        gridLayout = new QGridLayout();
        gridLayout->setObjectName(QString::fromUtf8("gridLayout"));
        tableWidget = new QTableWidget(FormLayer);
        tableWidget->setObjectName(QString::fromUtf8("tableWidget"));
        tableWidget->setFocusPolicy(Qt::ClickFocus);
        tableWidget->setAlternatingRowColors(true);
        tableWidget->setTextElideMode(Qt::ElideMiddle);
        tableWidget->horizontalHeader()->setVisible(false);
        tableWidget->verticalHeader()->setVisible(false);

        gridLayout->addWidget(tableWidget, 0, 0, 1, 1);


        verticalLayout->addLayout(gridLayout);


        retranslateUi(FormLayer);

        QMetaObject::connectSlotsByName(FormLayer);
    } // setupUi

    void retranslateUi(QDialog *FormLayer)
    {
        FormLayer->setWindowTitle(QCoreApplication::translate("FormLayer", "Dialog", nullptr));
    } // retranslateUi

};

namespace Ui {
    class FormLayer: public Ui_FormLayer {};
} // namespace Ui

QT_END_NAMESPACE

#endif // UI_FORMLAYER_H
����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ui_formmap.h����������������������������������������������������������������������������������������0000644�4673156�4001001�00000004170�14402513261�011741� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/********************************************************************************
** Form generated from reading UI file 'formmap.ui'
**
** Created by: Qt User Interface Compiler version 5.14.2
**
** WARNING! All changes made in this file will be lost when recompiling UI file!
********************************************************************************/

#ifndef UI_FORMMAP_H
#define UI_FORMMAP_H

#include <QtCore/QVariant>
#include <QtWidgets/QApplication>
#include <QtWidgets/QDialog>
#include <QtWidgets/QGraphicsView>
#include <QtWidgets/QVBoxLayout>

QT_BEGIN_NAMESPACE

class Ui_FormMap
{
public:
    QVBoxLayout *verticalLayout;
    QGraphicsView *graphicsView;

    void setupUi(QDialog *FormMap)
    {
        if (FormMap->objectName().isEmpty())
            FormMap->setObjectName(QString::fromUtf8("FormMap"));
        FormMap->resize(200, 200);
        FormMap->setMinimumSize(QSize(200, 200));
        verticalLayout = new QVBoxLayout(FormMap);
        verticalLayout->setObjectName(QString::fromUtf8("verticalLayout"));
        graphicsView = new QGraphicsView(FormMap);
        graphicsView->setObjectName(QString::fromUtf8("graphicsView"));
        QSizePolicy sizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
        sizePolicy.setHorizontalStretch(0);
        sizePolicy.setVerticalStretch(0);
        sizePolicy.setHeightForWidth(graphicsView->sizePolicy().hasHeightForWidth());
        graphicsView->setSizePolicy(sizePolicy);
        graphicsView->setMinimumSize(QSize(0, 0));
        graphicsView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        graphicsView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

        verticalLayout->addWidget(graphicsView);


        retranslateUi(FormMap);

        QMetaObject::connectSlotsByName(FormMap);
    } // setupUi

    void retranslateUi(QDialog *FormMap)
    {
        FormMap->setWindowTitle(QCoreApplication::translate("FormMap", "Dialog", nullptr));
    } // retranslateUi

};

namespace Ui {
    class FormMap: public Ui_FormMap {};
} // namespace Ui

QT_END_NAMESPACE

#endif // UI_FORMMAP_H
��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ui_formtop.h����������������������������������������������������������������������������������������0000644�4673156�4001001�00000003172�14402513261�011767� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/********************************************************************************
** Form generated from reading UI file 'formtop.ui'
**
** Created by: Qt User Interface Compiler version 5.14.2
**
** WARNING! All changes made in this file will be lost when recompiling UI file!
********************************************************************************/

#ifndef UI_FORMTOP_H
#define UI_FORMTOP_H

#include <QtCore/QVariant>
#include <QtWidgets/QApplication>
#include <QtWidgets/QDialog>
#include <QtWidgets/QGraphicsView>
#include <QtWidgets/QVBoxLayout>

QT_BEGIN_NAMESPACE

class Ui_FormTop
{
public:
    QVBoxLayout *verticalLayout;
    QGraphicsView *graphicsView;

    void setupUi(QDialog *FormTop)
    {
        if (FormTop->objectName().isEmpty())
            FormTop->setObjectName(QString::fromUtf8("FormTop"));
        FormTop->resize(200, 200);
        FormTop->setMinimumSize(QSize(200, 200));
        verticalLayout = new QVBoxLayout(FormTop);
        verticalLayout->setObjectName(QString::fromUtf8("verticalLayout"));
        graphicsView = new QGraphicsView(FormTop);
        graphicsView->setObjectName(QString::fromUtf8("graphicsView"));

        verticalLayout->addWidget(graphicsView);


        retranslateUi(FormTop);

        QMetaObject::connectSlotsByName(FormTop);
    } // setupUi

    void retranslateUi(QDialog *FormTop)
    {
        FormTop->setWindowTitle(QCoreApplication::translate("FormTop", "Dialog", nullptr));
    } // retranslateUi

};

namespace Ui {
    class FormTop: public Ui_FormTop {};
} // namespace Ui

QT_END_NAMESPACE

#endif // UI_FORMTOP_H
������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ui_mainwindow.h�������������������������������������������������������������������������������������0000644�4673156�4001001�00000011142�14402513261�012451� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/********************************************************************************
** Form generated from reading UI file 'mainwindow.ui'
**
** Created by: Qt User Interface Compiler version 5.14.2
**
** WARNING! All changes made in this file will be lost when recompiling UI file!
********************************************************************************/

#ifndef UI_MAINWINDOW_H
#define UI_MAINWINDOW_H

#include <QtCore/QVariant>
#include <QtWidgets/QAction>
#include <QtWidgets/QApplication>
#include <QtWidgets/QGraphicsView>
#include <QtWidgets/QMainWindow>
#include <QtWidgets/QMenu>
#include <QtWidgets/QMenuBar>
#include <QtWidgets/QStatusBar>
#include <QtWidgets/QToolBar>
#include <QtWidgets/QVBoxLayout>
#include <QtWidgets/QWidget>

QT_BEGIN_NAMESPACE

class Ui_MainWindow
{
public:
    QAction *actionOpen_file;
    QAction *actionLayer_information;
    QAction *actionOpen_Map_File;
    QAction *actionOpen_Layout;
    QWidget *centralwidget;
    QVBoxLayout *verticalLayout_2;
    QGraphicsView *graphicsView;
    QMenuBar *menubar;
    QMenu *menuFile;
    QMenu *menuView;
    QStatusBar *statusbar;
    QToolBar *toolBar;

    void setupUi(QMainWindow *MainWindow)
    {
        if (MainWindow->objectName().isEmpty())
            MainWindow->setObjectName(QString::fromUtf8("MainWindow"));
        MainWindow->resize(1024, 768);
        actionOpen_file = new QAction(MainWindow);
        actionOpen_file->setObjectName(QString::fromUtf8("actionOpen_file"));
        actionLayer_information = new QAction(MainWindow);
        actionLayer_information->setObjectName(QString::fromUtf8("actionLayer_information"));
        actionOpen_Map_File = new QAction(MainWindow);
        actionOpen_Map_File->setObjectName(QString::fromUtf8("actionOpen_Map_File"));
        actionOpen_Layout = new QAction(MainWindow);
        actionOpen_Layout->setObjectName(QString::fromUtf8("actionOpen_Layout"));
        centralwidget = new QWidget(MainWindow);
        centralwidget->setObjectName(QString::fromUtf8("centralwidget"));
        verticalLayout_2 = new QVBoxLayout(centralwidget);
        verticalLayout_2->setObjectName(QString::fromUtf8("verticalLayout_2"));
        graphicsView = new QGraphicsView(centralwidget);
        graphicsView->setObjectName(QString::fromUtf8("graphicsView"));

        verticalLayout_2->addWidget(graphicsView);

        MainWindow->setCentralWidget(centralwidget);
        menubar = new QMenuBar(MainWindow);
        menubar->setObjectName(QString::fromUtf8("menubar"));
        menubar->setGeometry(QRect(0, 0, 1024, 20));
        menuFile = new QMenu(menubar);
        menuFile->setObjectName(QString::fromUtf8("menuFile"));
        menuView = new QMenu(menubar);
        menuView->setObjectName(QString::fromUtf8("menuView"));
        MainWindow->setMenuBar(menubar);
        statusbar = new QStatusBar(MainWindow);
        statusbar->setObjectName(QString::fromUtf8("statusbar"));
        MainWindow->setStatusBar(statusbar);
        toolBar = new QToolBar(MainWindow);
        toolBar->setObjectName(QString::fromUtf8("toolBar"));
        MainWindow->addToolBar(Qt::TopToolBarArea, toolBar);

        menubar->addAction(menuFile->menuAction());
        menubar->addAction(menuView->menuAction());
        menuFile->addAction(actionOpen_file);
        menuFile->addSeparator();
        menuFile->addAction(actionOpen_Map_File);
        menuFile->addAction(actionOpen_Layout);
        menuView->addAction(actionLayer_information);

        retranslateUi(MainWindow);

        QMetaObject::connectSlotsByName(MainWindow);
    } // setupUi

    void retranslateUi(QMainWindow *MainWindow)
    {
        MainWindow->setWindowTitle(QCoreApplication::translate("MainWindow", "MainWindow", nullptr));
        actionOpen_file->setText(QCoreApplication::translate("MainWindow", "Open file", nullptr));
        actionLayer_information->setText(QCoreApplication::translate("MainWindow", "Layer information", nullptr));
        actionOpen_Map_File->setText(QCoreApplication::translate("MainWindow", "Open Map File", nullptr));
        actionOpen_Layout->setText(QCoreApplication::translate("MainWindow", "Open Layout", nullptr));
        menuFile->setTitle(QCoreApplication::translate("MainWindow", "File", nullptr));
        menuView->setTitle(QCoreApplication::translate("MainWindow", "View", nullptr));
        toolBar->setWindowTitle(QCoreApplication::translate("MainWindow", "toolBar", nullptr));
    } // retranslateUi

};

namespace Ui {
    class MainWindow: public Ui_MainWindow {};
} // namespace Ui

QT_END_NAMESPACE

#endif // UI_MAINWINDOW_H
������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formhier.ui�����������������������������������������������������������������������������������������0000644�4673156�4001001�00000004317�14402513177�011615� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormHier</class>
 <widget class="QDialog" name="FormHier">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>510</width>
    <height>300</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>450</width>
    <height>100</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QTableWidget" name="tableWidget">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>260</width>
         <height>100</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>260</width>
         <height>100</height>
        </size>
       </property>
       <property name="sizeAdjustPolicy">
        <enum>QAbstractScrollArea::AdjustToContents</enum>
       </property>
       <property name="editTriggers">
        <set>QAbstractItemView::NoEditTriggers</set>
       </property>
       <property name="alternatingRowColors">
        <bool>true</bool>
       </property>
       <property name="gridStyle">
        <enum>Qt::SolidLine</enum>
       </property>
       <attribute name="horizontalHeaderCascadingSectionResizes">
        <bool>false</bool>
       </attribute>
       <attribute name="horizontalHeaderStretchLastSection">
        <bool>false</bool>
       </attribute>
       <attribute name="verticalHeaderVisible">
        <bool>false</bool>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������forminfo.ui�����������������������������������������������������������������������������������������0000644�4673156�4001001�00000021554�14402242514�011615� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormInfo</class>
 <widget class="QDialog" name="FormInfo">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>400</height>
   </rect>
  </property>
  <property name="maximumSize">
   <size>
    <width>200</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QLabel" name="label">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>X</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="2">
      <widget class="QLabel" name="infoZoom">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="2">
      <widget class="QLabel" name="pointZ">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="0">
      <widget class="QLabel" name="infoTilt">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="3" column="1">
      <widget class="QLabel" name="infoRot">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="1">
      <widget class="QLabel" name="pointY">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="1">
      <widget class="QLabel" name="label_2">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Y</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="0" column="2">
      <widget class="QLabel" name="label_4">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Z</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="1" column="0">
      <widget class="QLabel" name="pointX">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="0">
      <widget class="QLabel" name="label_10">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Tilt</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="1">
      <widget class="QLabel" name="label_11">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Rotation</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
     <item row="2" column="2">
      <widget class="QLabel" name="label_12">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>0</width>
         <height>20</height>
        </size>
       </property>
       <property name="text">
        <string>Zoom</string>
       </property>
       <property name="alignment">
        <set>Qt::AlignCenter</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QListWidget" name="listWidget"/>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
����������������������������������������������������������������������������������������������������������������������������������������������������formlayer.ui����������������������������������������������������������������������������������������0000644�4673156�4001001�00000003102�14402513177�011771� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormLayer</class>
 <widget class="QDialog" name="FormLayer">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>450</width>
    <height>600</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>450</width>
    <height>300</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>430</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QTableWidget" name="tableWidget">
       <property name="focusPolicy">
        <enum>Qt::ClickFocus</enum>
       </property>
       <property name="alternatingRowColors">
        <bool>true</bool>
       </property>
       <property name="textElideMode">
        <enum>Qt::ElideMiddle</enum>
       </property>
       <attribute name="horizontalHeaderVisible">
        <bool>false</bool>
       </attribute>
       <attribute name="verticalHeaderVisible">
        <bool>false</bool>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formmap.ui������������������������������������������������������������������������������������������0000644�4673156�4001001�00000002335�14402242514�011433� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormMap</class>
 <widget class="QDialog" name="FormMap">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>200</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>200</width>
    <height>200</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGraphicsView" name="graphicsView">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="minimumSize">
      <size>
       <width>0</width>
       <height>0</height>
      </size>
     </property>
     <property name="verticalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
     <property name="horizontalScrollBarPolicy">
      <enum>Qt::ScrollBarAlwaysOff</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������formtop.ui������������������������������������������������������������������������������������������0000644�4673156�4001001�00000001234�14402242514�011455� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FormTop</class>
 <widget class="QDialog" name="FormTop">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>200</width>
    <height>200</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>200</width>
    <height>200</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGraphicsView" name="graphicsView"/>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������mainwindow.ui���������������������������������������������������������������������������������������0000644�4673156�4001001�00000004313�14402513177�012152� 0����������������������������������������������������������������������������������������������������ustar  �donk.lee�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1024</width>
    <height>768</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
     <widget class="QGraphicsView" name="graphicsView"/>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>1024</width>
     <height>20</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>File</string>
    </property>
    <addaction name="actionOpen_file"/>
    <addaction name="separator"/>
    <addaction name="actionOpen_Map_File"/>
    <addaction name="actionOpen_Layout"/>
   </widget>
   <widget class="QMenu" name="menuView">
    <property name="title">
     <string>View</string>
    </property>
    <addaction name="actionLayer_information"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuView"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="toolBar">
   <property name="windowTitle">
    <string>toolBar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
  </widget>
  <action name="actionOpen_file">
   <property name="text">
    <string>Open file</string>
   </property>
  </action>
  <action name="actionLayer_information">
   <property name="text">
    <string>Layer information</string>
   </property>
  </action>
  <action name="actionOpen_Map_File">
   <property name="text">
    <string>Open Map File</string>
   </property>
  </action>
  <action name="actionOpen_Layout">
   <property name="text">
    <string>Open Layout</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>
�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
